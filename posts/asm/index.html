<!DOCTYPE html>
<html lang="en"><head>
    <title>OPdbg</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no" />
    <meta name="theme-color" content="#000084" />
    <link rel="icon" href="https://www.codetea.top/favicon.ico">
    <link rel="canonical" href="https://www.codetea.top/">
    
    
    
<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\[\[", "\]\]"],
    ],
    svg: {
      fontCache: "global",
    },
  };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>

    
        <script>renderMathInElement(document.body);</script>
    
    <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/atom-one-dark.min.css" rel="stylesheet">
    <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/languages/armasm.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/languages/mipsasm.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/languages/wasm.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/languages/x86asm.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"></button>
            <a class="brand" href="https://www.codetea.top/">OPdbg</a>
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                    
                        
                            <li>
                                <a href="/about/">
                                    
                                    <span>About</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/posts">
                                    
                                    <span>Blog</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/tags">
                                    
                                    <span>Tags</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/link">
                                    
                                    <span>Link</span>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
        </div>
    </div>
</nav><div id="content" class="container">

<div class="row-fluid navmargin">
    <div class="page-header">
        <h1>汇编语言 笔记 - Thu, Feb 3, 2022</h1>
    </div>
    <p class="lead"></p>
    <h1 id="汇编语言">汇编语言</h1>
<h2 id="概述">概述</h2>
<p>编程形式</p>
<blockquote>
<p>开关&ndash;&gt;打孔&ndash;&gt;输入设备</p>
</blockquote>
<p>汇编语言的出现</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">mov eax, 5
mov ebx, 6
add eax, ebx
</code></pre><p>汇编程序的执行</p>
<blockquote>
<p>汇编代码 -&gt; 汇编程序 -&gt; 处理器可识别 01010101 -&gt; 处理器执行</p>
</blockquote>
<h3 id="学习汇编的意义">学习汇编的意义</h3>
<ol>
<li>开发时调试</li>
<li>逆向时候的代码阅读</li>
<li>某些特殊技术的使用（如shellcode、壳）</li>
</ol>
<blockquote>
<p>shellcode：可以运行在任意位置的代码（汇编语言）</p>
<p>壳：加壳或脱壳都需要用的汇编语言</p>
</blockquote>
<p>环境配置</p>
<ul>
<li>
<p>Ollydbg</p>
</li>
<li>
<p>Visual Studio 2015</p>
</li>
</ul>
<h2 id="x16-汇编">x16 汇编</h2>
<h3 id="通用寄存器">通用寄存器</h3>
<table>
<thead>
<tr>
<th>16位寄存器</th>
<th>高8位</th>
<th>低8位</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX</td>
<td>AH</td>
<td>AL</td>
</tr>
<tr>
<td>BX</td>
<td>BH</td>
<td>BL</td>
</tr>
<tr>
<td>CX</td>
<td>CH</td>
<td>CL</td>
</tr>
<tr>
<td>DX</td>
<td>DH</td>
<td>DL</td>
</tr>
<tr>
<td>SI</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>DI</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>SP</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>BP</td>
<td>\</td>
<td>\</td>
</tr>
</tbody>
</table>
<p><img src="/images/ASM/image-20211123194526478.png" alt="image-20211123194526478"></p>
<h3 id="内存字节序">内存字节序</h3>
<p>:chestnut: 0x12345678</p>
<p>每个地址只有存储1字节</p>
<table>
<thead>
<tr>
<th>大端序</th>
<th>小端序</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>78</td>
</tr>
<tr>
<td>34</td>
<td>56</td>
</tr>
<tr>
<td>56</td>
<td>34</td>
</tr>
<tr>
<td>78</td>
<td>12</td>
</tr>
<tr>
<td>CC</td>
<td>CC</td>
</tr>
<tr>
<td>CC</td>
<td>CC</td>
</tr>
<tr>
<td>CC</td>
<td>CC</td>
</tr>
</tbody>
</table>
<h3 id="段的概念">段的概念</h3>
<p><img src="/images/ASM/image-20211123201417209.png" alt="image-20211123201417209"></p>
<blockquote>
<p>CS段只有16位，8086有20根地址线，那么地址如何存储？</p>
<p>简单粗暴 除以0x10，因为只有以零结尾的地址才能作为段地址</p>
</blockquote>
<p>CS：代码段</p>
<p>DS：数据段</p>
<p>ES：扩展段</p>
<p>SS：堆栈段</p>
<h3 id="16位汇编基本框架">16位汇编基本框架</h3>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">assume cs:code ;设置代码段

code segment ;代码段开始
rkmain proc
	mov ax,0
	mov cx, 10H
rk:     
	inc ax
	loop rk
	mov ax, 4c00H
	int 21H
rkmain endp

start:  call rkmain ;指定开始位置
code ends ;代码段结束
end start
</code></pre><blockquote>
<p><code>add</code> 加</p>
<p><code>int</code> 自增</p>
<p><code>sub</code> 减</p>
<p><code>dec</code> 自减</p>
<p><code>loop</code> 循环</p>
</blockquote>
<h3 id="函数传参">函数传参</h3>
<ul>
<li>寄存器传参</li>
<li>堆栈传参</li>
<li>内存传参</li>
</ul>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">assume cs:code

code segment

addx proc
	push bp
	mov bp,sp
	mov si,[bp+4]
	mov di,[bp+6]
	add si,di
	mov ax,si
	pop bp
	ret
addx endp

rkmain proc
	mov ax,5
	mov bx,6
	push ax
	push bx
	call addx
	add sp,4
	mov bx,ax
	mov ax, 4c00H
	int 21H
rkmain endp

start:  call rkmain

code ends
end start
</code></pre><h3 id="flag寄存器">FLAG寄存器</h3>
<h4 id="状态标志">状态标志</h4>
<p>CF：进位位</p>
<p>PF：奇偶位</p>
<p>AF：辅助进位位</p>
<p>ZF：零值位</p>
<p>SF：符号位</p>
<p>OF：溢出位</p>
<h3 id="cmp指令">CMP指令</h3>
<blockquote>
<p>CMP OPRD1, OPRD2</p>
<p>SUB</p>
<p>影响标志位</p>
</blockquote>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">mov ax,2
mov bx,1
cmp ax.bx
</code></pre><p>相等</p>
<p>AX-BX = 0 ZF=1</p>
<p>不等</p>
<p>AX-BX !=0 ZF=0</p>
<p>AX &lt; BX:</p>
<p>AX-BX = ? CF=1</p>
<p>AX &gt; BX:</p>
<p>AX-BX=? CF=0 ZF=0</p>
<p>AX &lt;= BX:</p>
<p>AX-BX=? CF=1 || ZF=1</p>
<p>AX &gt;= BX:</p>
<p>AX-BX=? CF=0 || ZF=1</p>
<h3 id="jcc指令">JCC指令</h3>
<p>一类指令 跳转</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">jmp address 
je address ;等于则跳转 ZF=1
jne address ;不等于则跳转 ZF=0
jb address ;低于则跳转 CF=1
ja address ;高于则跳转 CF=0 &amp;&amp; ZF=0
</code></pre><h3 id="运算指令">运算指令</h3>
<p>四则运算</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">mov ax,16
mov bx,5
add ax,5
sub ax,3
mul bx ; &gt;16bit DX:AX 32bit 默认与ax操作
div bx ; DX-&gt;余数 AX-&gt;商 默认与ax操作
</code></pre><p>位运算</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">xor ax,bx
and ax,bx
or ax,bx
not ax
</code></pre><h2 id="x86汇编">x86汇编</h2>
<p>通用寄存器</p>
<table>
<thead>
<tr>
<th>寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td>EAX</td>
</tr>
<tr>
<td>EBX</td>
</tr>
<tr>
<td>ECX</td>
</tr>
<tr>
<td>EDX</td>
</tr>
<tr>
<td>ESI</td>
</tr>
<tr>
<td>EDI</td>
</tr>
<tr>
<td>ESP</td>
</tr>
<tr>
<td>EBP</td>
</tr>
</tbody>
</table>
<h3 id="段">段</h3>
<table>
<thead>
<tr>
<th>段</th>
</tr>
</thead>
<tbody>
<tr>
<td>CS</td>
</tr>
<tr>
<td>DS</td>
</tr>
<tr>
<td>ES</td>
</tr>
<tr>
<td>SS</td>
</tr>
<tr>
<td>FS</td>
</tr>
<tr>
<td>GS</td>
</tr>
</tbody>
</table>
<h4 id="段选择子">段选择子</h4>
<p>CS 代码段 1B</p>
<p>DS ES SS 数据段 23</p>
<p>FS 3B</p>
<ul>
<li>
<p>Index：3</p>
</li>
<li>
<p>Ti：0</p>
</li>
<li>
<p>RPL：3</p>
</li>
</ul>
<h4 id="段描述符">段描述符</h4>
<p>代码段：</p>
<blockquote>
<p><code>00cffb00 0000ffff</code></p>
<p>1100 1111 1111 1011 0000 0000</p>
<p>Base：<code>0000 0000</code></p>
<p>Limit：<code>ffffff</code></p>
<p><code>ffffff * 0x1000</code></p>
<p><code>FFFFFF000+0X1000</code></p>
<p><code>10 0000 0000 - 1</code></p>
<p><code>FFFF FFFF</code></p>
<p>G = 1 Limit单位是页</p>
<p>G = 0 Limit单位是字节</p>
<p>页</p>
<ul>
<li>大页 4M</li>
<li>小页 4K</li>
</ul>
<p>寻址空间：<code>0000 0000 ~ FFFF FFFF</code></p>
</blockquote>
<p>数据段</p>
<blockquote>
<p><code>00cff300 0000ffff</code></p>
<p>BASE：<code>0000 0000</code></p>
<p>Limit：<code>FFFF FFFF</code></p>
</blockquote>
<p>FS段</p>
<blockquote>
<p><code>0040f300 00000fff</code></p>
<p>G=0 字节</p>
<p><code>0000 0000 0100 0000 1111 0011 0000 0000</code></p>
<p><code>fff * 1</code> <code>fff</code>字节</p>
<p><code>0 ~ fff</code></p>
</blockquote>
<p>4GB空间 虚拟的4GB空间</p>
<ul>
<li>低2GB是每个进程独享的</li>
<li>高2GB是内核空间，是共享的</li>
</ul>
<p>base+offset = 虚拟地址</p>
<h3 id="页">页</h3>
<blockquote>
<p>内存的一种管理模式</p>
</blockquote>
<p>29912</p>
<p>CR3</p>
<p>PDPTE -&gt; PTE - PDE -&gt; 物理页 (4k)</p>
<p>76B26000 E9 A1 B0 76</p>
<p>01 (PDPTE) （1 * 8)</p>
<p>110110101(PTE) (1B5 * 8 )</p>
<p>100100110(PDE) (126 * 8)</p>
<p>00000000000(页内偏移) (000)</p>
<hr>
<blockquote>
<p>R3 用户层 TEB（线程环境块）</p>
<p>R0 系统内核 驱动 KPCR（CPU状态块）</p>
</blockquote>
<h3 id="调用约定">调用约定</h3>
<ol>
<li><code>cdecl</code></li>
<li><code>stdcall</code></li>
<li><code>fastcall</code></li>
<li><code>thiscall</code></li>
</ol>
<blockquote>
<p><code>lib</code> 静态链接库</p>
<p><code>dll</code> 动态链接库</p>
</blockquote>
<h4 id="cdecl">cdecl</h4>
<p>C语言调用约定</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">push eax
push eax
call printf
add esp,8
</code></pre><h4 id="stdcall">stdcall</h4>
<p>Win32调用约定</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">push 1
push 2
push 3
push 4
call messagebox
</code></pre><h4 id="fastcall">fastcall</h4>
<p>x64 调用约定</p>
<p>前四个参数使用寄存器传参，后面使用堆栈</p>
<blockquote>
<p>rcx rdx r8 r9</p>
</blockquote>
<h3 id="x86基本框架">x86基本框架</h3>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">.586
.model flat,stdcall
option casemap:none

includelib ucrt.lib
includelib legacy_stdio_definitions.lib
includelib User32.lib
includelib Kernel32.lib

MessageBoxA PROTO hWnd:DWORD,lpText:BYTE,lpCaption:BYTE,uType:DWORD
ExitProcess PROTO uType:DWORD
extern printf:proc
extern scanf:proc
extern putchar:proc

.data
szStr db 'Hello World!',0
.code
main proc
	lea eax,szStr
	push eax
	call printf
	add esp,4
	push 0
	call ExitProcess
	add esp,4
main endp
end
</code></pre><h3 id="内联汇编">内联汇编</h3>
<p>单行内联汇编</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">_ASM<span style="color:#f92672">/</span> mov nNum, <span style="color:#ae81ff">100</span>;
</code></pre></div><p>多行内联汇编</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">_ASM<span style="color:#f92672">/</span> {
		mov nNum,<span style="color:#ae81ff">100</span>
		mov eax,nNum
		push eax
		mov eax,fNum
		push eax
		call printf
		add esp,<span style="color:#ae81ff">8</span>
	}
</code></pre></div><p>遍历数组</p>
<p>按结尾数据遍历</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> nNum;
	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> fNum <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
	<span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>,<span style="color:#ae81ff">0</span> };
	_ASM<span style="color:#f92672">/</span> {
		xor esi,esi
		jmp loopX
	loopM:
		inc esi
	loopX:
		mov edi,[arr<span style="color:#f92672">+</span>esi<span style="color:#f92672">*</span><span style="color:#ae81ff">4</span>]
		push edi
		mov eax,fNum
		push eax
		call printf
		add esp,<span style="color:#ae81ff">8</span>
		cmp edi,<span style="color:#ae81ff">0</span>
		jne loopM
	}
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>按长度进行遍历</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> nNum;
	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> fNum <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
	<span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>];
	<span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
	{
		arr[i] <span style="color:#f92672">=</span> i;
	}
	_ASM<span style="color:#f92672">/</span> {
		xor edi,edi
		xor esi,esi
		xor edx,edx
		mov edi,<span style="color:#ae81ff">9</span>h
		jmp Mloop
		Xloop:
		inc esi
		Mloop:
		mov edx, [arr <span style="color:#f92672">+</span> esi <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>]
		push edx
		mov eax,fNum
		push eax
		call printf
		add esp,<span style="color:#ae81ff">8</span>
		cmp edi,esi
		jne Xloop
	}
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="结构体和api">结构体和API</h3>
<p>汇编语言结构体</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">.586
.model flat,stdcall

.data
info struct ;声明结构体
x dword ?
y dword ?
info ends

m_info info &lt;&gt; ;初始化结构体
.code

main proc
	mov eax,5
	mov m_info.x,eax
	mov ebx,m_info.x
	mov eax,eax
main endp

end main
</code></pre><h2 id="x64汇编">x64汇编</h2>
<p>x64和x86汇编寄存器区别</p>
<blockquote>
<p>x86 : <code>eax ebx ecx edx esi edi ebp esp eip eflags</code></p>
<p>x64 : <code>rax rbx rcx rdx rsi rdi rbp rsp rip rflags </code></p>
<p>x64扩展 ： <code>r8 r9 r10 r11 r12 r13 r14 r15</code></p>
</blockquote>
<h2 id="汇编代码剽窃小技巧">汇编代码剽窃小技巧</h2>
<ol>
<li>所有的jcc死地址，都要改成标号</li>
<li>所有的call，都要确定，是系统函数，还是自己的函数，想办法call过去</li>
<li>一切检查或者初始化类的无用代码，全部去掉</li>
<li>一些必要逻辑里的不合理东西，去掉这些，然后自己写代码，让他合理化</li>
</ol>
<h2 id="16位32位64位汇编的区别">16位/32位/64位汇编的区别</h2>
<p>区别</p>
<blockquote>
<p>16位：实模式，16位处理器内的内部，最多可以处理存储的长度为16位。</p>
<p>32位：保护模式，32位处理器内的内部，最多可以处理存储的长度为32位。</p>
<p>64位：保护模式，64位处理器内的内部，最多可以处理存储的长度为64位。</p>
</blockquote>
<p>通用寄存器简介</p>
<table>
<thead>
<tr>
<th>位数</th>
<th>通用寄存器</th>
<th>扩展</th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>AX BX CX DX SI DI BP SP</td>
<td>R8W R9W R10W R11W R12W R13W R14W R15W</td>
</tr>
<tr>
<td>32</td>
<td>EAX EBX ECX EDX ESI EDI EBP ESP</td>
<td>R8D R9D R10D R11D R12D R13D R14D R15D</td>
</tr>
<tr>
<td>64</td>
<td>RAX RBX RCX RDX RSI RDI RBP RSP</td>
<td>R8 R9 R10 R11 R12 R13 R14 R15</td>
</tr>
</tbody>
</table>
<p>基本执行环境</p>
<table>
<thead>
<tr>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody>
<tr>
<td>8个32位通用寄存器</td>
<td>16个64位通用寄存器</td>
</tr>
<tr>
<td>标志寄存器EFLAGS</td>
<td>标志寄存器RFLAGS</td>
</tr>
<tr>
<td>指令寄存器EIP</td>
<td>指令寄存器RIP</td>
</tr>
</tbody>
</table>
<h3 id="eflags寄存器">EFLAGS寄存器</h3>
<p>Eflags寄存器，Eflags寄存器包含了独立的二进制位，用于控制CPU操作。或是反应一些CPU操作的结果。有些指令可以测试和控制这些单独的处理器标志位。</p>
<h3 id="mmx寄存器">MMX寄存器</h3>
<p>在实现高级多媒体和通信应用时，MMX技术提高了Intel处理器的性能。8个64位MMX寄存器支持成为SIMD的特殊指令。顾名思义，MMX指令对MMX寄存器中的数据值直接进行并行操作。虽然它们看上去是独立的寄存器，但是MMX寄存器实际上是浮点单元中使用的同样寄存器的别名。</p>
<h2 id="通用寄存器-1">通用寄存器</h2>
<p>eax：累加器，操作数和结果数据累加器，返回值运算结果一般都存储在这里</p>
<p><img src="/images/ASM/image-20210811183106370.png" alt="image-20210811183106370"></p>
<p>ebx：基地址，DS段的数据指针，在内存寻址的时候存放基地址</p>
<p><img src="/images/ASM/image-20210811183206737.png" alt="image-20210811183206737"></p>
<p>ecx：计数器，字符串和循环操作的计数器</p>
<p><img src="/images/ASM/image-20210811183244169.png" alt="image-20210811183244169"></p>
<p>edx：用于存储部分乘法结果和部分除法被除数</p>
<p><img src="/images/ASM/image-20210811183411998.png" alt="image-20210811183411998"></p>
<p>ebp：基址指针，SS段的数据指针</p>
<p><img src="/images/ASM/image-20210811183548209.png" alt="image-20210811183548209"></p>
<p>esp：栈帧指针，一般指向栈顶，所以也被称为栈顶指针</p>
<p><img src="/images/ASM/image-20210811183809151.png" alt="image-20210811183809151"></p>
<p>edi：字符串操作的目标指针，ES段的数据指针</p>
<p><img src="/images/ASM/image-20210811183910749.png" alt="image-20210811183910749"></p>
<p>esi：字符串操作的源指针，SS段的数据指针</p>
<p><img src="/images/ASM/image-20210811184031993.png" alt="image-20210811184031993"></p>
<h2 id="冯诺依曼">冯诺依曼</h2>
<p>计算机科学的奠基者</p>
<ul>
<li>艾伦·麦锡森·图灵  - - - 图灵机</li>
<li>约翰·冯·诺依曼  - - - 数据存储的体系结构</li>
</ul>
<p>约翰·冯·诺依曼</p>
<blockquote>
<p>1903年 出生犹太家庭</p>
<p>1926年 布达佩斯大学数学博士学位</p>
<p>1930年 接受了普林斯顿大学客座教授的职位</p>
<p>1931年 普林斯顿大学终身教授</p>
<p>1933年 普林斯顿高等研究院</p>
<p>1937年 美国公民</p>
<p>1938年 获博修奖</p>
<p>1954年 美国原子能委员会委员</p>
<p>1957 在华盛顿德里医院去世</p>
</blockquote>
<h3 id="冯诺依曼体系">冯诺依曼体系</h3>
<p>计算机由控制器、运算器、存储器、输入设备、输出设备五部分组成。</p>
<p>冯诺依曼提出的计算机体系结构，奠定了现代计算机的结构理念</p>
<p><img src="/images/ASM/image-20210811190118360.png" alt="image-20210811190118360"></p>
<h2 id="内存基础">内存基础</h2>
<h3 id="什么是内存">什么是内存</h3>
<p>在冯诺依曼结构中用来存储程序和数据的部件叫做存储器，我们的计算机可以正常的运行，主要依靠的就是存储器的记忆能力。存储器分为主存储器和辅助存储器，主存储器也叫内存储器，也就是我们常说的内存</p>
<h3 id="内存寻址范围">内存寻址范围</h3>
<blockquote>
<p>现在主流的系统是32位系统和64位系统</p>
<p>32位系统内存的寻址范围是0x00000000-0xFFFFFFFF</p>
<p>32位系统内存最大寻址范围是0xFFFFFFFF+1(4294967296) - - - 4GB</p>
<p>64位内存的寻址范围是0x0000000000000000-0xFFFFFFFFFFFFFFFF</p>
</blockquote>
<p><img src="/images/ASM/image-20210811191257593.png" alt="image-20210811191257593"></p>
<h3 id="内存和寄存器的区别">内存和寄存器的区别</h3>
<p>寄存器：数量少，在CPU内部，速度极快，但是价格昂贵</p>
<p>内存：数量庞大，相对寄存器而言，速度较慢，但是价格便宜</p>
<h3 id="内存的五种表现形式">内存的五种表现形式</h3>
<p>立即数：</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">MOV EAX, DWORD PTR DS:[0x???????]
</code></pre><p>寄存器：</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">MOV EBX, 0x????????
MOV EAX, DWORD PTR DS:[EBX]
</code></pre><p>寄存器+立即数</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">MOV EBX, 0x???????
MOV EAX, DWORD PTR DS:[EBX+4]
</code></pre><p>比例因子：[REG+REG*{1,2,4,8}]</p>
<p>数组元素地址=数组首地址+元素索引*数组元素占用空间</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">MOV EAX, 0x????????
MOV EBX, 0x2
MOV ECX, DWORD PTR DS:[EAX+EBX*4]
</code></pre><p>比例因子+立刻数：</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">MOV EAX, 0x????????
MOV EBX, 0x2
MOV ECX, DWORD PTR DS:[EAX+EBX*4+1]
</code></pre><h3 id="数据存储模式">数据存储模式</h3>
<p>大端序：数据高位在内存低位，数据低位在内存高位</p>
<p>小端序：数据高位在内存高位，数据低位在内存低位</p>
<p>地址0x77 66 55 44</p>
<p>大端序：念的时候是77 66 55 44</p>
<p>小端序：念的时候是44 55 66 77</p>
<p>大端序常用于ARM架构</p>
<p>小端序常用于x86、AMD64架构</p>
<h2 id="eflags寄存器-1">EFLAGS寄存器</h2>
<p>CF：进位借位标志位</p>
<p>PF：奇偶标志位</p>
<p>AF：辅助进位标志位</p>
<p>ZF：0标志位</p>
<p>SF：符号标志位</p>
<p>TF：单目标志位</p>
<p>IF：中断标志位</p>
<p>DF：方向标志位</p>
<p>OF：溢出标志位</p>
<h2 id="数学运算">数学运算</h2>
<h3 id="加法">加法</h3>
<p>加法指令 ADD（Addition）</p>
<p>格式：ADD OPRD1, OPRD2</p>
<p>功能：两数相加</p>
<p>加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响</p>
<p>不允许OPRD1与OPRD2同时为存储器</p>
<hr>
<p>带进位加法指令 ADC（Addition Carry)</p>
<p>格式：ADC OPRD1, OPRD2</p>
<p>功能：OPRD1 = OPRD1 + OPRD2 + CF</p>
<h3 id="减法">减法</h3>
<p>减法指令 SUB（Subtract）</p>
<p>格式：SUB OPRD1, OPRD2</p>
<p>功能：两个操作数的相减，即从OPRD1中减去OPRD2，其结果放在OPRD1中。指令的类型及对标志位的影响与ADD指令相同，注意立即数不能用于目的操作数，两个存储器操作数之间不能直接相减，操作数可为8位或16位的无符号数或带符号数。</p>
<hr>
<p>带借位减法指令 SBB（Subtraction with Borrow）</p>
<p>格式：SBB OPRD1, OPRD2</p>
<p>功能：进行两个操作数的相减再减去CF进位标志位，即从OPRD1 = OPRD1 - OPRD2 -CF，其结果放在OPDR1中。</p>
<h3 id="乘法">乘法</h3>
<p>无符号数乘法指令 MUL（Multiply）</p>
<p>格式：MUL OPRD</p>
<hr>
<p>带符号数乘法指令 IMUL（Integer Multiply）</p>
<p>格式：IMUL OPRD、</p>
<p>功能：乘法操作</p>
<p>OPRD为通用寄存器或寄存器操作数</p>
<p>本指令影响标志位CF及OF</p>
<h3 id="除法">除法</h3>
<p>无符号数除法指令 DIV（Division）</p>
<p>格式：DIV OPRD</p>
<p>功能：实现两个无符号二进制数除法运算</p>
<hr>
<p>带符号数除法指定 IDIV（Integer Division）</p>
<p>格式：IDIV OPRD</p>
<p>功能：这实现两个带符号数的二进制除法运算</p>
<blockquote>
<p>16bit，分存2个8bit AH:AL 商AL 余AH</p>
<p>32bit，分存2个16bit DX:AX 商AX 余DX</p>
<p>64bit，分存2个32bit EDX:EAX 商EAX 余EDX</p>
<p>128bit，分存2个64bit RDX:RAX 商RAX 余RDX</p>
</blockquote>
<h3 id="自增">自增</h3>
<p>加1指令 INC（Increment by 1）</p>
<p>格式：INC OPRD</p>
<p>功能：OPRD = OPRD + 1</p>
<h3 id="自减">自减</h3>
<p>减1指令 DEC（Decrement by 1）</p>
<p>格式：DEC OPRD</p>
<p>功能：OPRD = OPRD - 1</p>
<h2 id="逻辑运算">逻辑运算</h2>
<h3 id="与">与</h3>
<p>逻辑与运算指令 AND</p>
<p>格式：AND OPRD1, OPRD2</p>
<p>功能：对两个操作数实现按位逻辑与运算，结果送至目的操作数。本指令可以进行字节或字的 ‘与‘ 运算，OPRD1 &lt; - - OPRD1 and OPRD2.</p>
<p>本指令影响标志位PF、SF、ZF，使CF=0、OF=0.例如，在同一个通用寄存器自身相与时，  操作数虽不变，但使CF置零。本指令主要用于修改操作数或置某些位为零。</p>
<h3 id="或">或</h3>
<p>逻辑或指令 OR</p>
<p>格式：OR OPRD1, OPRD2</p>
<p>功能：OR指令完成对两个操作数按位的 ‘或’ 运算，结果送至目的操作数中，本指令可以进 - - - - 行字节或字的 ‘或’ 运算。OPRD1 &lt; - - OPRD1 OR  OPRD2。</p>
<h3 id="异或操作">异或操作</h3>
<p>逻辑异或运算指令 XOR</p>
<p>格式：XOR OPRD1, OPRD2</p>
<p>功能：实现两个操作数按位 ‘异或’ 运算，结果送至目的操作数中。OPRD1 &lt; - - OPRD1 XOR OPRD2</p>
<h3 id="非运算">非运算</h3>
<p>逻辑操作符 NOT</p>
<p>格式：NOT exp</p>
<p>功能：按位求反</p>
<h2 id="堆栈操作">堆栈操作</h2>
<h3 id="什么是堆栈">什么是堆栈</h3>
<ol>
<li>栈是一个后进先出的存储区域，位于堆栈段中，SS段寄存器描述的就是堆栈段的地址</li>
<li>栈的数据出口位于栈顶，也就是esp寄存器所指向的位置</li>
<li>栈顶是低位，也就是地址较小的一侧，由ebp寄存器指向的栈底，并不会改变</li>
</ol>
<h3 id="栈操作指令">栈操作指令</h3>
<p>PUSH：压栈操作，32位汇编首先ESP-4，留出一个空间，然后把要压入栈中的内容压入</p>
<p>POP：出栈指令，32位汇编首先将栈顶的数据弹出给指定的目标，然后ESP+4，清掉空间</p>
<h3 id="栈的作用">栈的作用</h3>
<ol>
<li>存储少量数据</li>
<li>保存寄存器环境</li>
<li>传递参数</li>
</ol>
<h2 id="数据移动指令">数据移动指令</h2>
<h3 id="mov指令">MOV指令</h3>
<p>数据传送指令MOV</p>
<p>格式：MOV OPRD1, OPRD2</p>
<p>功能：本指令将一个源操作数送到目的操作数中，即OPRD1 &lt; - - OPRD2</p>
<p>说明：</p>
<ul>
<li>OPRD1为目的操作数，可以是寄存器、存储器、累加器</li>
<li>OPRD2为源操作数，可以是寄存器、存储器、累加器和立即数</li>
</ul>
<h3 id="lea指令">LEA指令</h3>
<p>有效地址传送指令 LEA</p>
<p>格式：LEA OPRD1，OPRD2</p>
<p>功能：将源操作数给出的有效地址传送到指定的寄存器中</p>
<p>OPRD1必须是寄存器</p>
<h3 id="xchg指令">XCHG指令</h3>
<p>数据交换指令 XCHG</p>
<p>格式：XCHG OPRD1, OPRD2 其中的OPRD1为目的操作数，OPRD2为源操作数</p>
<p>功能：将两个操作数相互交换位置，该指令把源操作数OPRD2与目的操作数OPRD1交换</p>
<h2 id="比较指令">比较指令</h2>
<h3 id="cmp指令-1">CMP指令</h3>
<p>比较指令 CMP（Compare）</p>
<p>格式：CMP OPRD1, OPRD2</p>
<p>功能：对两数进行相减，进行比较</p>
<h3 id="test指令">TEST指令</h3>
<p>测试指令 TEST</p>
<p>格式：TEST OPRD1,OPRD2</p>
<p>功能：其中OPRD1、OPRD2的含义同AND指令一样，也是对两个操作数进行按位的 ‘与’ 运算，- - - - 唯一不同之处是不将 ‘与’ 的结果送目的操作数，即本指令对两个操作数的内容均不进行修改，仅是在逻辑与操作后，对标志位重新置位</p>
<h2 id="jcc条件转移指令">JCC条件转移指令</h2>
<h3 id="常用的jcc指令">常用的JCC指令</h3>
<p>JMP：无条件跳转</p>
<p>JZ/JE：ZF = 1 等于0或相等跳转</p>
<p>JNZ/JNE：ZF = 0 不等于0或者不相等跳转</p>
<p>JBE/JNA：CF = 1/ZF = 1 低于等于/不高于跳转</p>
<p>JNBE/JA：CF = 0/ ZF = 0 不低于等于/高于跳转</p>
<p>JL/JNGE：SF！=OF 小于/不大于等于跳转</p>
<p>JNL/JGE：SF = OF 不小于/大于等于跳转</p>
<h3 id="jcc表">JCC表</h3>
<table>
<thead>
<tr>
<th>JCC指令</th>
<th>中文含义</th>
<th>英文原意</th>
<th>检查符号位</th>
<th>典型C应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>JZ/JE</td>
<td>若为0则跳转；若相等则跳转</td>
<td>jump if zero;jump if equal</td>
<td>ZF=1</td>
<td>if (i == j);if (i == 0);</td>
</tr>
<tr>
<td>JNZ/JNE</td>
<td>若不为0则跳转；若不相等则跳转</td>
<td>jump if not zero;jump if not equal</td>
<td>ZF=0</td>
<td>if (i != j);if (i != 0);</td>
</tr>
<tr>
<td>JS</td>
<td>若为负则跳转</td>
<td>jump if sign</td>
<td>SF=1</td>
<td>if (i &lt; 0);</td>
</tr>
<tr>
<td>JNS</td>
<td>若为正则跳转</td>
<td>jump if not sign</td>
<td>SF=0</td>
<td>if (i &gt; 0);</td>
</tr>
<tr>
<td>JP/JPE</td>
<td>若1出现次数为偶数则跳转</td>
<td>jump if Parity (Even)</td>
<td>PF=1</td>
<td>(null)</td>
</tr>
<tr>
<td>JNP/JPO</td>
<td>若1出现次数为奇数则跳转</td>
<td>jump if not parity (odd)</td>
<td>PF=0</td>
<td>(null)</td>
</tr>
<tr>
<td>JO</td>
<td>若溢出则跳转</td>
<td>jump if overflow</td>
<td>OF=1</td>
<td>(null)</td>
</tr>
<tr>
<td>JNO</td>
<td>若无溢出则跳转</td>
<td>jump if not overflow</td>
<td>OF=0</td>
<td>(null)</td>
</tr>
<tr>
<td>JC/JB/JNAE</td>
<td>若进位则跳转；若低于则跳转；若不高于等于则跳转</td>
<td>jump if carry;jump if below;jump if not above equal</td>
<td>CF=1</td>
<td>if (i &lt; j);</td>
</tr>
<tr>
<td>JNC/JNB/JAE</td>
<td>若无进位则跳转；若不低于则跳转；若高于等于则跳转；</td>
<td>jump if not carry;jump if not below;jump if above equal</td>
<td>CF=0</td>
<td>if (i &gt;= j);</td>
</tr>
<tr>
<td>JBE/JNA</td>
<td>若低于等于则跳转；若不高于则跳转</td>
<td>jump if below equal;jump if not above</td>
<td>ZF=1或CF=1</td>
<td>if (i &lt;= j);</td>
</tr>
<tr>
<td>JNBE/JA</td>
<td>若不低于等于则跳转；若高于则跳转</td>
<td>jump if not below equal;jump if above</td>
<td>ZF=0或CF=0</td>
<td>if (i &gt; j);</td>
</tr>
<tr>
<td>JL/JNGE</td>
<td>若小于则跳转；若不大于等于则跳转</td>
<td>jump if less;jump if not greater equal</td>
<td>SF != OF</td>
<td>if (si &lt; sj);</td>
</tr>
<tr>
<td>JNL/JGE</td>
<td>若不小于则跳转；若大于等于则跳转；</td>
<td>jump if not less;jump if greater equal</td>
<td>SF = OF</td>
<td>if (si &gt;= sj);</td>
</tr>
<tr>
<td>JLE/JNG</td>
<td>若小于等于则跳转；若不大于则跳转</td>
<td>jump if less equal;jump if not greater</td>
<td>ZF != OF 或 ZF=1</td>
<td>if (si &lt;= sj);</td>
</tr>
<tr>
<td>JNLE/JG</td>
<td>若不小于等于则跳转；若大于则跳转</td>
<td>jump if not less equal;jump if greater</td>
<td>SF=0F 且 ZF=0</td>
<td>if(si&gt;sj)</td>
</tr>
</tbody>
</table>
<h2 id="串操作指令">串操作指令</h2>
<h3 id="movs指令">MOVS指令</h3>
<p>字符串传送指令 MOVS</p>
<p>格式：MOVS OPRD1, OPRD2 MOVSB MOVSW</p>
<p>功能：OPRD1 &lt; - - OPRD2</p>
<p>说明：</p>
<ol>
<li>其中OPRD2为源串符号地址，OPRD1为目的串符号地址</li>
</ol>
<h3 id="stos指令">STOS指令</h3>
<p>字符串存储指令 STOS</p>
<p>格式：STOS OPRD</p>
<p>功能：把AL(字节)或AX(字)中的数据存储到DI为目的串地址指针所寻址的存储器单元中去指针DI将根据DF的值进行自动调整</p>
<h3 id="rep指令">REP指令</h3>
<p>重复前缀说明</p>
<p>格式：</p>
<ul>
<li>REP  ;CX&lt;&gt;0 重复执行字符串指令</li>
<li>REPZ/REPE ;CX&lt;&gt;0 且ZF=1重复执行字符串指令</li>
<li>REPNZ/REPNE ;CX&lt;&gt;0 且ZF=0重复执行字符串指令</li>
</ul>
<p>功能：在串操作指令前加上重复前缀，可以对字符串进行重复处理。由于加上重复前缀后，对应的指令代码是不同的，所以指令的功能便具有重复处理的功能，重复的次数存放在CX寄存器中</p>
<h2 id="call与retn">CALL与RETN</h2>
<h3 id="call指令">CALL指令</h3>
<p>过程调用指令 CALL</p>
<p>格式：CALL OPRD</p>
<p>功能：过程调用指令</p>
<p>相当于：</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">push eip
jmp OPRD
</code></pre><h3 id="retn指令">RETN指令</h3>
<pre><code>返回指令，相当于：
</code></pre>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">pop eip
jmp eip
</code></pre><h2 id="函数">函数</h2>
<p>过程调用-函数</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">function proc
	code
function end
</code></pre><p>参数传递方式：</p>
<ol>
<li>寄存器传参</li>
<li>堆栈传参</li>
</ol>
<h2 id="win32汇编入门">WIN32汇编入门</h2>
<p>什么是API？</p>
<p>API（Application Programming Interface, 应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节</p>
<p>Windows系统除了协调应用程序的执行、内存的分配、系统资源的管理外，同时他也是一个很大的服务中心。调用这个服务中心的各种服务（每一种服务就是一个函数）可以帮助应用程序达到开启视窗、描绘图形和使用周边设备等目的，由于这些函数服务的对象是应用程序，所以称之为Application Programming Interface, 简称API函数。WIN32 API也就是Microsoft Windows 32位平台的应用程序编程接口</p>
<p>凡是在 Windows 工作环境底下执行的应用程序，都可以调用Windows API</p>

    <h4><a href="https://www.codetea.top/">Back to Home</a></h4>
</div>


        </div><footer class="container">
    <hr class="soften">
    <p>
    OrcasCode Blog | 

&copy; 

    OolongCode

<span id="thisyear">2022</span>

    | OolongBytes Space


</p>
    <p class="text-center">
        
        
        <a href="https://linkedin.com">Linkedin</a> 
        <a href="https://github.com/OolongCode">GitHub</a> 
        <a href="https://gitlab.com">GitLab</a>
    </p>
</footer>

</body><link rel="stylesheet" href="/css/bootstrap.css">
<link rel="stylesheet" href="/css/bootstrap-responsive.css">
<link rel="stylesheet" href="/css/style.css">

<script src="/js/jquery.js"></script>
<script src="/js/bootstrap-386.js"></script>
<script src="/js/bootstrap-transition.js"></script>
<script src="/js/bootstrap-alert.js"></script>
<script src="/js/bootstrap-modal.js"></script>
<script src="/js/bootstrap-dropdown.js"></script>
<script src="/js/bootstrap-scrollspy.js"></script>
<script src="/js/bootstrap-tab.js"></script>
<script src="/js/bootstrap-tooltip.js"></script>
<script src="/js/bootstrap-popover.js"></script>
<script src="/js/bootstrap-button.js"></script>
<script src="/js/bootstrap-collapse.js"></script>
<script src="/js/bootstrap-carousel.js"></script>
<script src="/js/bootstrap-typeahead.js"></script>
<script src="/js/bootstrap-affix.js"></script>
<script>
    _386 = { 
        fastLoad: false ,
        onePass: false , 
        speedFactor: 1 
    };

    
    function ThisYear() {
        document.getElementById('thisyear').innerHTML = new Date().getFullYear();
    };
</script></html>
