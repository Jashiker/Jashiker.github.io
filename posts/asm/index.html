<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>汇编语言 笔记 | Jasmine❀Hiker</title><meta name=keywords content="Reverse,assembly,note"><meta name=description content="汇编语言 概述 编程形式
开关&ndash;>打孔&ndash;>输入设备
汇编语言的出现
mov eax, 5 mov ebx, 6 add eax, ebx 汇编程序的执行
汇编代码 -> 汇编程序 -> 处理器可识别 01010101 -> 处理器执行
学习汇编的意义 开发时调试 逆向时候的代码阅读 某些特殊技术的使用（如shellcode、壳） shellcode：可以运行在任意位置的代码（汇编语言）
壳：加壳或脱壳都需要用的汇编语言
环境配置
Ollydbg
Visual Studio 2015
x16 汇编 通用寄存器 16位寄存器 高8位 低8位 AX AH AL BX BH BL CX CH CL DX DH DL SI \ \ DI \ \ SP \ \ BP \ \ 内存字节序 :chestnut: 0x12345678
每个地址只有存储1字节
大端序 小端序 12 78 34 56 56 34 78 12 CC CC CC CC CC CC 段的概念 CS段只有16位，8086有20根地址线，那么地址如何存储？"><meta name=author content="Me"><link rel=canonical href=/posts/asm/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css integrity="sha256-v1+fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=apple-touch-icon href=apple-touch-icon.png><link rel=mask-icon href=safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="汇编语言 笔记"><meta property="og:description" content="汇编语言 概述 编程形式
开关&ndash;>打孔&ndash;>输入设备
汇编语言的出现
mov eax, 5 mov ebx, 6 add eax, ebx 汇编程序的执行
汇编代码 -> 汇编程序 -> 处理器可识别 01010101 -> 处理器执行
学习汇编的意义 开发时调试 逆向时候的代码阅读 某些特殊技术的使用（如shellcode、壳） shellcode：可以运行在任意位置的代码（汇编语言）
壳：加壳或脱壳都需要用的汇编语言
环境配置
Ollydbg
Visual Studio 2015
x16 汇编 通用寄存器 16位寄存器 高8位 低8位 AX AH AL BX BH BL CX CH CL DX DH DL SI \ \ DI \ \ SP \ \ BP \ \ 内存字节序 :chestnut: 0x12345678
每个地址只有存储1字节
大端序 小端序 12 78 34 56 56 34 78 12 CC CC CC CC CC CC 段的概念 CS段只有16位，8086有20根地址线，那么地址如何存储？"><meta property="og:type" content="article"><meta property="og:url" content="/posts/asm/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-03T09:56:53+08:00"><meta property="article:modified_time" content="2022-02-03T09:56:53+08:00"><meta property="og:site_name" content="Jasmine❀Hiker"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="汇编语言 笔记"><meta name=twitter:description content="汇编语言 概述 编程形式
开关&ndash;>打孔&ndash;>输入设备
汇编语言的出现
mov eax, 5 mov ebx, 6 add eax, ebx 汇编程序的执行
汇编代码 -> 汇编程序 -> 处理器可识别 01010101 -> 处理器执行
学习汇编的意义 开发时调试 逆向时候的代码阅读 某些特殊技术的使用（如shellcode、壳） shellcode：可以运行在任意位置的代码（汇编语言）
壳：加壳或脱壳都需要用的汇编语言
环境配置
Ollydbg
Visual Studio 2015
x16 汇编 通用寄存器 16位寄存器 高8位 低8位 AX AH AL BX BH BL CX CH CL DX DH DL SI \ \ DI \ \ SP \ \ BP \ \ 内存字节序 :chestnut: 0x12345678
每个地址只有存储1字节
大端序 小端序 12 78 34 56 56 34 78 12 CC CC CC CC CC CC 段的概念 CS段只有16位，8086有20根地址线，那么地址如何存储？"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"汇编语言 笔记","item":"/posts/asm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"汇编语言 笔记","name":"汇编语言 笔记","description":"汇编语言 概述 编程形式\n开关\u0026ndash;\u0026gt;打孔\u0026ndash;\u0026gt;输入设备\n汇编语言的出现\nmov eax, 5 mov ebx, 6 add eax, ebx 汇编程序的执行\n汇编代码 -\u0026gt; 汇编程序 -\u0026gt; 处理器可识别 01010101 -\u0026gt; 处理器执行\n学习汇编的意义 开发时调试 逆向时候的代码阅读 某些特殊技术的使用（如shellcode、壳） shellcode：可以运行在任意位置的代码（汇编语言）\n壳：加壳或脱壳都需要用的汇编语言\n环境配置\nOllydbg\nVisual Studio 2015\nx16 汇编 通用寄存器 16位寄存器 高8位 低8位 AX AH AL BX BH BL CX CH CL DX DH DL SI \\ \\ DI \\ \\ SP \\ \\ BP \\ \\ 内存字节序 :chestnut: 0x12345678\n每个地址只有存储1字节\n大端序 小端序 12 78 34 56 56 34 78 12 CC CC CC CC CC CC 段的概念 CS段只有16位，8086有20根地址线，那么地址如何存储？","keywords":["Reverse","assembly","note"],"articleBody":"汇编语言 概述 编程形式\n开关–\u003e打孔–\u003e输入设备\n汇编语言的出现\nmov eax, 5 mov ebx, 6 add eax, ebx 汇编程序的执行\n汇编代码 -\u003e 汇编程序 -\u003e 处理器可识别 01010101 -\u003e 处理器执行\n学习汇编的意义 开发时调试 逆向时候的代码阅读 某些特殊技术的使用（如shellcode、壳） shellcode：可以运行在任意位置的代码（汇编语言）\n壳：加壳或脱壳都需要用的汇编语言\n环境配置\nOllydbg\nVisual Studio 2015\nx16 汇编 通用寄存器 16位寄存器 高8位 低8位 AX AH AL BX BH BL CX CH CL DX DH DL SI \\ \\ DI \\ \\ SP \\ \\ BP \\ \\ 内存字节序 :chestnut: 0x12345678\n每个地址只有存储1字节\n大端序 小端序 12 78 34 56 56 34 78 12 CC CC CC CC CC CC 段的概念 CS段只有16位，8086有20根地址线，那么地址如何存储？\n简单粗暴 除以0x10，因为只有以零结尾的地址才能作为段地址\nCS：代码段\nDS：数据段\nES：扩展段\nSS：堆栈段\n16位汇编基本框架 assume cs:code ;设置代码段 code segment ;代码段开始 rkmain proc mov ax,0 mov cx, 10H rk: inc ax loop rk mov ax, 4c00H int 21H rkmain endp start: call rkmain ;指定开始位置 code ends ;代码段结束 end start add 加\nint 自增\nsub 减\ndec 自减\nloop 循环\n函数传参 寄存器传参 堆栈传参 内存传参 assume cs:code code segment addx proc push bp mov bp,sp mov si,[bp+4] mov di,[bp+6] add si,di mov ax,si pop bp ret addx endp rkmain proc mov ax,5 mov bx,6 push ax push bx call addx add sp,4 mov bx,ax mov ax, 4c00H int 21H rkmain endp start: call rkmain code ends end start FLAG寄存器 状态标志 CF：进位位\nPF：奇偶位\nAF：辅助进位位\nZF：零值位\nSF：符号位\nOF：溢出位\nCMP指令 CMP OPRD1, OPRD2\nSUB\n影响标志位\nmov ax,2 mov bx,1 cmp ax.bx 相等\nAX-BX = 0 ZF=1\n不等\nAX-BX !=0 ZF=0\nAX \u003c BX:\nAX-BX = ? CF=1\nAX \u003e BX:\nAX-BX=? CF=0 ZF=0\nAX \u003c= BX:\nAX-BX=? CF=1 || ZF=1\nAX \u003e= BX:\nAX-BX=? CF=0 || ZF=1\nJCC指令 一类指令 跳转\njmp address je address ;等于则跳转 ZF=1 jne address ;不等于则跳转 ZF=0 jb address ;低于则跳转 CF=1 ja address ;高于则跳转 CF=0 \u0026\u0026 ZF=0 运算指令 四则运算\nmov ax,16 mov bx,5 add ax,5 sub ax,3 mul bx ; \u003e16bit DX:AX 32bit 默认与ax操作 div bx ; DX-\u003e余数 AX-\u003e商 默认与ax操作 位运算\nxor ax,bx and ax,bx or ax,bx not ax x86汇编 通用寄存器\n寄存器 EAX EBX ECX EDX ESI EDI ESP EBP 段 段 CS DS ES SS FS GS 段选择子 CS 代码段 1B\nDS ES SS 数据段 23\nFS 3B\nIndex：3\nTi：0\nRPL：3\n段描述符 代码段：\n00cffb00 0000ffff\n1100 1111 1111 1011 0000 0000\nBase：0000 0000\nLimit：ffffff\nffffff * 0x1000\nFFFFFF000+0X1000\n10 0000 0000 - 1\nFFFF FFFF\nG = 1 Limit单位是页\nG = 0 Limit单位是字节\n页\n大页 4M 小页 4K 寻址空间：0000 0000 ~ FFFF FFFF\n数据段\n00cff300 0000ffff\nBASE：0000 0000\nLimit：FFFF FFFF\nFS段\n0040f300 00000fff\nG=0 字节\n0000 0000 0100 0000 1111 0011 0000 0000\nfff * 1 fff字节\n0 ~ fff\n4GB空间 虚拟的4GB空间\n低2GB是每个进程独享的 高2GB是内核空间，是共享的 base+offset = 虚拟地址\n页 内存的一种管理模式\n29912\nCR3\nPDPTE -\u003e PTE - PDE -\u003e 物理页 (4k)\n76B26000 E9 A1 B0 76\n01 (PDPTE) （1 * 8)\n110110101(PTE) (1B5 * 8 )\n100100110(PDE) (126 * 8)\n00000000000(页内偏移) (000)\nR3 用户层 TEB（线程环境块）\nR0 系统内核 驱动 KPCR（CPU状态块）\n调用约定 cdecl stdcall fastcall thiscall lib 静态链接库\ndll 动态链接库\ncdecl C语言调用约定\npush eax push eax call printf add esp,8 stdcall Win32调用约定\npush 1 push 2 push 3 push 4 call messagebox fastcall x64 调用约定\n前四个参数使用寄存器传参，后面使用堆栈\nrcx rdx r8 r9\nx86基本框架 .586 .model flat,stdcall option casemap:none includelib ucrt.lib includelib legacy_stdio_definitions.lib includelib User32.lib includelib Kernel32.lib MessageBoxA PROTO hWnd:DWORD,lpText:BYTE,lpCaption:BYTE,uType:DWORD ExitProcess PROTO uType:DWORD extern printf:proc extern scanf:proc extern putchar:proc .data szStr db 'Hello World!',0 .code main proc lea eax,szStr push eax call printf add esp,4 push 0 call ExitProcess add esp,4 main endp end 内联汇编 单行内联汇编\n_ASM/ mov nNum, 100; 多行内联汇编\n_ASM/ { mov nNum,100 mov eax,nNum push eax mov eax,fNum push eax call printf add esp,8 } 遍历数组\n按结尾数据遍历\n#include #include int main() { int nNum; char* fNum = \"%d\\n\"; int arr[] = { 1,2,3,4,5,6,7,8,9,0 }; _ASM/ { xor esi,esi jmp loopX loopM: inc esi loopX: mov edi,[arr+esi*4] push edi mov eax,fNum push eax call printf add esp,8 cmp edi,0 jne loopM } system(\"pause\"); return 0; } 按长度进行遍历\n#include #include int main() { int nNum; char* fNum = \"%d\\n\"; int arr[10]; for (size_t i = 0; i \u003c 10; i++) { arr[i] = i; } _ASM/ { xor edi,edi xor esi,esi xor edx,edx mov edi,9h jmp Mloop Xloop: inc esi Mloop: mov edx, [arr + esi * 4] push edx mov eax,fNum push eax call printf add esp,8 cmp edi,esi jne Xloop } system(\"pause\"); return 0; } 结构体和API 汇编语言结构体\n.586 .model flat,stdcall .data info struct ;声明结构体 x dword ? y dword ? info ends m_info info \u003c\u003e ;初始化结构体 .code main proc mov eax,5 mov m_info.x,eax mov ebx,m_info.x mov eax,eax main endp end main x64汇编 x64和x86汇编寄存器区别\nx86 : eax ebx ecx edx esi edi ebp esp eip eflags\nx64 : rax rbx rcx rdx rsi rdi rbp rsp rip rflags x64扩展 ： r8 r9 r10 r11 r12 r13 r14 r15\n汇编代码剽窃小技巧 所有的jcc死地址，都要改成标号 所有的call，都要确定，是系统函数，还是自己的函数，想办法call过去 一切检查或者初始化类的无用代码，全部去掉 一些必要逻辑里的不合理东西，去掉这些，然后自己写代码，让他合理化 16位/32位/64位汇编的区别 区别\n16位：实模式，16位处理器内的内部，最多可以处理存储的长度为16位。\n32位：保护模式，32位处理器内的内部，最多可以处理存储的长度为32位。\n64位：保护模式，64位处理器内的内部，最多可以处理存储的长度为64位。\n通用寄存器简介\n位数 通用寄存器 扩展 16 AX BX CX DX SI DI BP SP R8W R9W R10W R11W R12W R13W R14W R15W 32 EAX EBX ECX EDX ESI EDI EBP ESP R8D R9D R10D R11D R12D R13D R14D R15D 64 RAX RBX RCX RDX RSI RDI RBP RSP R8 R9 R10 R11 R12 R13 R14 R15 基本执行环境\n32位 64位 8个32位通用寄存器 16个64位通用寄存器 标志寄存器EFLAGS 标志寄存器RFLAGS 指令寄存器EIP 指令寄存器RIP EFLAGS寄存器 Eflags寄存器，Eflags寄存器包含了独立的二进制位，用于控制CPU操作。或是反应一些CPU操作的结果。有些指令可以测试和控制这些单独的处理器标志位。\nMMX寄存器 在实现高级多媒体和通信应用时，MMX技术提高了Intel处理器的性能。8个64位MMX寄存器支持成为SIMD的特殊指令。顾名思义，MMX指令对MMX寄存器中的数据值直接进行并行操作。虽然它们看上去是独立的寄存器，但是MMX寄存器实际上是浮点单元中使用的同样寄存器的别名。\n通用寄存器 eax：累加器，操作数和结果数据累加器，返回值运算结果一般都存储在这里\nebx：基地址，DS段的数据指针，在内存寻址的时候存放基地址\necx：计数器，字符串和循环操作的计数器\nedx：用于存储部分乘法结果和部分除法被除数\nebp：基址指针，SS段的数据指针\nesp：栈帧指针，一般指向栈顶，所以也被称为栈顶指针\nedi：字符串操作的目标指针，ES段的数据指针\nesi：字符串操作的源指针，SS段的数据指针\n冯诺依曼 计算机科学的奠基者\n艾伦·麦锡森·图灵 - - - 图灵机 约翰·冯·诺依曼 - - - 数据存储的体系结构 约翰·冯·诺依曼\n1903年 出生犹太家庭\n1926年 布达佩斯大学数学博士学位\n1930年 接受了普林斯顿大学客座教授的职位\n1931年 普林斯顿大学终身教授\n1933年 普林斯顿高等研究院\n1937年 美国公民\n1938年 获博修奖\n1954年 美国原子能委员会委员\n1957 在华盛顿德里医院去世\n冯诺依曼体系 计算机由控制器、运算器、存储器、输入设备、输出设备五部分组成。\n冯诺依曼提出的计算机体系结构，奠定了现代计算机的结构理念\n内存基础 什么是内存 在冯诺依曼结构中用来存储程序和数据的部件叫做存储器，我们的计算机可以正常的运行，主要依靠的就是存储器的记忆能力。存储器分为主存储器和辅助存储器，主存储器也叫内存储器，也就是我们常说的内存\n内存寻址范围 现在主流的系统是32位系统和64位系统\n32位系统内存的寻址范围是0x00000000-0xFFFFFFFF\n32位系统内存最大寻址范围是0xFFFFFFFF+1(4294967296) - - - 4GB\n64位内存的寻址范围是0x0000000000000000-0xFFFFFFFFFFFFFFFF\n内存和寄存器的区别 寄存器：数量少，在CPU内部，速度极快，但是价格昂贵\n内存：数量庞大，相对寄存器而言，速度较慢，但是价格便宜\n内存的五种表现形式 立即数：\nMOV EAX, DWORD PTR DS:[0x???????] 寄存器：\nMOV EBX, 0x???????? MOV EAX, DWORD PTR DS:[EBX] 寄存器+立即数\nMOV EBX, 0x??????? MOV EAX, DWORD PTR DS:[EBX+4] 比例因子：[REG+REG*{1,2,4,8}]\n数组元素地址=数组首地址+元素索引*数组元素占用空间\nMOV EAX, 0x???????? MOV EBX, 0x2 MOV ECX, DWORD PTR DS:[EAX+EBX*4] 比例因子+立刻数：\nMOV EAX, 0x???????? MOV EBX, 0x2 MOV ECX, DWORD PTR DS:[EAX+EBX*4+1] 数据存储模式 大端序：数据高位在内存低位，数据低位在内存高位\n小端序：数据高位在内存高位，数据低位在内存低位\n地址0x77 66 55 44\n大端序：念的时候是77 66 55 44\n小端序：念的时候是44 55 66 77\n大端序常用于ARM架构\n小端序常用于x86、AMD64架构\nEFLAGS寄存器 CF：进位借位标志位\nPF：奇偶标志位\nAF：辅助进位标志位\nZF：0标志位\nSF：符号标志位\nTF：单目标志位\nIF：中断标志位\nDF：方向标志位\nOF：溢出标志位\n数学运算 加法 加法指令 ADD（Addition）\n格式：ADD OPRD1, OPRD2\n功能：两数相加\n加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响\n不允许OPRD1与OPRD2同时为存储器\n带进位加法指令 ADC（Addition Carry)\n格式：ADC OPRD1, OPRD2\n功能：OPRD1 = OPRD1 + OPRD2 + CF\n减法 减法指令 SUB（Subtract）\n格式：SUB OPRD1, OPRD2\n功能：两个操作数的相减，即从OPRD1中减去OPRD2，其结果放在OPRD1中。指令的类型及对标志位的影响与ADD指令相同，注意立即数不能用于目的操作数，两个存储器操作数之间不能直接相减，操作数可为8位或16位的无符号数或带符号数。\n带借位减法指令 SBB（Subtraction with Borrow）\n格式：SBB OPRD1, OPRD2\n功能：进行两个操作数的相减再减去CF进位标志位，即从OPRD1 = OPRD1 - OPRD2 -CF，其结果放在OPDR1中。\n乘法 无符号数乘法指令 MUL（Multiply）\n格式：MUL OPRD\n带符号数乘法指令 IMUL（Integer Multiply）\n格式：IMUL OPRD、\n功能：乘法操作\nOPRD为通用寄存器或寄存器操作数\n本指令影响标志位CF及OF\n除法 无符号数除法指令 DIV（Division）\n格式：DIV OPRD\n功能：实现两个无符号二进制数除法运算\n带符号数除法指定 IDIV（Integer Division）\n格式：IDIV OPRD\n功能：这实现两个带符号数的二进制除法运算\n16bit，分存2个8bit AH:AL 商AL 余AH\n32bit，分存2个16bit DX:AX 商AX 余DX\n64bit，分存2个32bit EDX:EAX 商EAX 余EDX\n128bit，分存2个64bit RDX:RAX 商RAX 余RDX\n自增 加1指令 INC（Increment by 1）\n格式：INC OPRD\n功能：OPRD = OPRD + 1\n自减 减1指令 DEC（Decrement by 1）\n格式：DEC OPRD\n功能：OPRD = OPRD - 1\n逻辑运算 与 逻辑与运算指令 AND\n格式：AND OPRD1, OPRD2\n功能：对两个操作数实现按位逻辑与运算，结果送至目的操作数。本指令可以进行字节或字的 ‘与‘ 运算，OPRD1 \u003c - - OPRD1 and OPRD2.\n本指令影响标志位PF、SF、ZF，使CF=0、OF=0.例如，在同一个通用寄存器自身相与时， 操作数虽不变，但使CF置零。本指令主要用于修改操作数或置某些位为零。\n或 逻辑或指令 OR\n格式：OR OPRD1, OPRD2\n功能：OR指令完成对两个操作数按位的 ‘或’ 运算，结果送至目的操作数中，本指令可以进 - - - - 行字节或字的 ‘或’ 运算。OPRD1 \u003c - - OPRD1 OR OPRD2。\n异或操作 逻辑异或运算指令 XOR\n格式：XOR OPRD1, OPRD2\n功能：实现两个操作数按位 ‘异或’ 运算，结果送至目的操作数中。OPRD1 \u003c - - OPRD1 XOR OPRD2\n非运算 逻辑操作符 NOT\n格式：NOT exp\n功能：按位求反\n堆栈操作 什么是堆栈 栈是一个后进先出的存储区域，位于堆栈段中，SS段寄存器描述的就是堆栈段的地址 栈的数据出口位于栈顶，也就是esp寄存器所指向的位置 栈顶是低位，也就是地址较小的一侧，由ebp寄存器指向的栈底，并不会改变 栈操作指令 PUSH：压栈操作，32位汇编首先ESP-4，留出一个空间，然后把要压入栈中的内容压入\nPOP：出栈指令，32位汇编首先将栈顶的数据弹出给指定的目标，然后ESP+4，清掉空间\n栈的作用 存储少量数据 保存寄存器环境 传递参数 数据移动指令 MOV指令 数据传送指令MOV\n格式：MOV OPRD1, OPRD2\n功能：本指令将一个源操作数送到目的操作数中，即OPRD1 \u003c - - OPRD2\n说明：\nOPRD1为目的操作数，可以是寄存器、存储器、累加器 OPRD2为源操作数，可以是寄存器、存储器、累加器和立即数 LEA指令 有效地址传送指令 LEA\n格式：LEA OPRD1，OPRD2\n功能：将源操作数给出的有效地址传送到指定的寄存器中\nOPRD1必须是寄存器\nXCHG指令 数据交换指令 XCHG\n格式：XCHG OPRD1, OPRD2 其中的OPRD1为目的操作数，OPRD2为源操作数\n功能：将两个操作数相互交换位置，该指令把源操作数OPRD2与目的操作数OPRD1交换\n比较指令 CMP指令 比较指令 CMP（Compare）\n格式：CMP OPRD1, OPRD2\n功能：对两数进行相减，进行比较\nTEST指令 测试指令 TEST\n格式：TEST OPRD1,OPRD2\n功能：其中OPRD1、OPRD2的含义同AND指令一样，也是对两个操作数进行按位的 ‘与’ 运算，- - - - 唯一不同之处是不将 ‘与’ 的结果送目的操作数，即本指令对两个操作数的内容均不进行修改，仅是在逻辑与操作后，对标志位重新置位\nJCC条件转移指令 常用的JCC指令 JMP：无条件跳转\nJZ/JE：ZF = 1 等于0或相等跳转\nJNZ/JNE：ZF = 0 不等于0或者不相等跳转\nJBE/JNA：CF = 1/ZF = 1 低于等于/不高于跳转\nJNBE/JA：CF = 0/ ZF = 0 不低于等于/高于跳转\nJL/JNGE：SF！=OF 小于/不大于等于跳转\nJNL/JGE：SF = OF 不小于/大于等于跳转\nJCC表 JCC指令 中文含义 英文原意 检查符号位 典型C应用 JZ/JE 若为0则跳转；若相等则跳转 jump if zero;jump if equal ZF=1 if (i == j);if (i == 0); JNZ/JNE 若不为0则跳转；若不相等则跳转 jump if not zero;jump if not equal ZF=0 if (i != j);if (i != 0); JS 若为负则跳转 jump if sign SF=1 if (i \u003c 0); JNS 若为正则跳转 jump if not sign SF=0 if (i \u003e 0); JP/JPE 若1出现次数为偶数则跳转 jump if Parity (Even) PF=1 (null) JNP/JPO 若1出现次数为奇数则跳转 jump if not parity (odd) PF=0 (null) JO 若溢出则跳转 jump if overflow OF=1 (null) JNO 若无溢出则跳转 jump if not overflow OF=0 (null) JC/JB/JNAE 若进位则跳转；若低于则跳转；若不高于等于则跳转 jump if carry;jump if below;jump if not above equal CF=1 if (i \u003c j); JNC/JNB/JAE 若无进位则跳转；若不低于则跳转；若高于等于则跳转； jump if not carry;jump if not below;jump if above equal CF=0 if (i \u003e= j); JBE/JNA 若低于等于则跳转；若不高于则跳转 jump if below equal;jump if not above ZF=1或CF=1 if (i \u003c= j); JNBE/JA 若不低于等于则跳转；若高于则跳转 jump if not below equal;jump if above ZF=0或CF=0 if (i \u003e j); JL/JNGE 若小于则跳转；若不大于等于则跳转 jump if less;jump if not greater equal SF != OF if (si \u003c sj); JNL/JGE 若不小于则跳转；若大于等于则跳转； jump if not less;jump if greater equal SF = OF if (si \u003e= sj); JLE/JNG 若小于等于则跳转；若不大于则跳转 jump if less equal;jump if not greater ZF != OF 或 ZF=1 if (si \u003c= sj); JNLE/JG 若不小于等于则跳转；若大于则跳转 jump if not less equal;jump if greater SF=0F 且 ZF=0 if(si\u003esj) 串操作指令 MOVS指令 字符串传送指令 MOVS\n格式：MOVS OPRD1, OPRD2 MOVSB MOVSW\n功能：OPRD1 \u003c - - OPRD2\n说明：\n其中OPRD2为源串符号地址，OPRD1为目的串符号地址 STOS指令 字符串存储指令 STOS\n格式：STOS OPRD\n功能：把AL(字节)或AX(字)中的数据存储到DI为目的串地址指针所寻址的存储器单元中去指针DI将根据DF的值进行自动调整\nREP指令 重复前缀说明\n格式：\nREP ;CX\u003c\u003e0 重复执行字符串指令 REPZ/REPE ;CX\u003c\u003e0 且ZF=1重复执行字符串指令 REPNZ/REPNE ;CX\u003c\u003e0 且ZF=0重复执行字符串指令 功能：在串操作指令前加上重复前缀，可以对字符串进行重复处理。由于加上重复前缀后，对应的指令代码是不同的，所以指令的功能便具有重复处理的功能，重复的次数存放在CX寄存器中\nCALL与RETN CALL指令 过程调用指令 CALL\n格式：CALL OPRD\n功能：过程调用指令\n相当于：\npush eip jmp OPRD RETN指令 返回指令，相当于： pop eip jmp eip 函数 过程调用-函数\nfunction proc code function end 参数传递方式：\n寄存器传参 堆栈传参 WIN32汇编入门 什么是API？\nAPI（Application Programming Interface, 应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节\nWindows系统除了协调应用程序的执行、内存的分配、系统资源的管理外，同时他也是一个很大的服务中心。调用这个服务中心的各种服务（每一种服务就是一个函数）可以帮助应用程序达到开启视窗、描绘图形和使用周边设备等目的，由于这些函数服务的对象是应用程序，所以称之为Application Programming Interface, 简称API函数。WIN32 API也就是Microsoft Windows 32位平台的应用程序编程接口\n凡是在 Windows 工作环境底下执行的应用程序，都可以调用Windows API\n","wordCount":"1534","inLanguage":"en","datePublished":"2022-02-03T09:56:53+08:00","dateModified":"2022-02-03T09:56:53+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/asm/"},"publisher":{"@type":"Organization","name":"Jasmine❀Hiker","logo":{"@type":"ImageObject","url":"favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li><li><a href=/posts/ title=Posts><span>Posts</span></a></li><li><a href=/about/ title=About><span>About</span></a></li><li><a href=/link/ title=Link><span>Link</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>汇编语言 笔记</h1><div class=post-meta><span title='2022-02-03 09:56:53 +0800 CST'>February 3, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1534 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80 aria-label=汇编语言>汇编语言</a><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a><ul><li><a href=#%e5%ad%a6%e4%b9%a0%e6%b1%87%e7%bc%96%e7%9a%84%e6%84%8f%e4%b9%89 aria-label=学习汇编的意义>学习汇编的意义</a></li></ul></li><li><a href=#x16-%e6%b1%87%e7%bc%96 aria-label="x16 汇编">x16 汇编</a><ul><li><a href=#%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8 aria-label=通用寄存器>通用寄存器</a></li><li><a href=#%e5%86%85%e5%ad%98%e5%ad%97%e8%8a%82%e5%ba%8f aria-label=内存字节序>内存字节序</a></li><li><a href=#%e6%ae%b5%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=段的概念>段的概念</a></li><li><a href=#16%e4%bd%8d%e6%b1%87%e7%bc%96%e5%9f%ba%e6%9c%ac%e6%a1%86%e6%9e%b6 aria-label=16位汇编基本框架>16位汇编基本框架</a></li><li><a href=#%e5%87%bd%e6%95%b0%e4%bc%a0%e5%8f%82 aria-label=函数传参>函数传参</a></li><li><a href=#flag%e5%af%84%e5%ad%98%e5%99%a8 aria-label=FLAG寄存器>FLAG寄存器</a><ul><li><a href=#%e7%8a%b6%e6%80%81%e6%a0%87%e5%bf%97 aria-label=状态标志>状态标志</a></li></ul></li><li><a href=#cmp%e6%8c%87%e4%bb%a4 aria-label=CMP指令>CMP指令</a></li><li><a href=#jcc%e6%8c%87%e4%bb%a4 aria-label=JCC指令>JCC指令</a></li><li><a href=#%e8%bf%90%e7%ae%97%e6%8c%87%e4%bb%a4 aria-label=运算指令>运算指令</a></li></ul></li><li><a href=#x86%e6%b1%87%e7%bc%96 aria-label=x86汇编>x86汇编</a><ul><li><a href=#%e6%ae%b5 aria-label=段>段</a><ul><li><a href=#%e6%ae%b5%e9%80%89%e6%8b%a9%e5%ad%90 aria-label=段选择子>段选择子</a></li><li><a href=#%e6%ae%b5%e6%8f%8f%e8%bf%b0%e7%ac%a6 aria-label=段描述符>段描述符</a></li></ul></li><li><a href=#%e9%a1%b5 aria-label=页>页</a></li><li><a href=#%e8%b0%83%e7%94%a8%e7%ba%a6%e5%ae%9a aria-label=调用约定>调用约定</a><ul><li><a href=#cdecl aria-label=cdecl>cdecl</a></li><li><a href=#stdcall aria-label=stdcall>stdcall</a></li><li><a href=#fastcall aria-label=fastcall>fastcall</a></li></ul></li><li><a href=#x86%e5%9f%ba%e6%9c%ac%e6%a1%86%e6%9e%b6 aria-label=x86基本框架>x86基本框架</a></li><li><a href=#%e5%86%85%e8%81%94%e6%b1%87%e7%bc%96 aria-label=内联汇编>内联汇编</a></li><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8capi aria-label=结构体和API>结构体和API</a></li></ul></li><li><a href=#x64%e6%b1%87%e7%bc%96 aria-label=x64汇编>x64汇编</a></li><li><a href=#%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%e5%89%bd%e7%aa%83%e5%b0%8f%e6%8a%80%e5%b7%a7 aria-label=汇编代码剽窃小技巧>汇编代码剽窃小技巧</a></li><li><a href=#16%e4%bd%8d32%e4%bd%8d64%e4%bd%8d%e6%b1%87%e7%bc%96%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=16位/32位/64位汇编的区别>16位/32位/64位汇编的区别</a><ul><li><a href=#eflags%e5%af%84%e5%ad%98%e5%99%a8 aria-label=EFLAGS寄存器>EFLAGS寄存器</a></li><li><a href=#mmx%e5%af%84%e5%ad%98%e5%99%a8 aria-label=MMX寄存器>MMX寄存器</a></li></ul></li><li><a href=#%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8-1 aria-label=通用寄存器>通用寄存器</a></li><li><a href=#%e5%86%af%e8%af%ba%e4%be%9d%e6%9b%bc aria-label=冯诺依曼>冯诺依曼</a><ul><li><a href=#%e5%86%af%e8%af%ba%e4%be%9d%e6%9b%bc%e4%bd%93%e7%b3%bb aria-label=冯诺依曼体系>冯诺依曼体系</a></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e5%9f%ba%e7%a1%80 aria-label=内存基础>内存基础</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98 aria-label=什么是内存>什么是内存</a></li><li><a href=#%e5%86%85%e5%ad%98%e5%af%bb%e5%9d%80%e8%8c%83%e5%9b%b4 aria-label=内存寻址范围>内存寻址范围</a></li><li><a href=#%e5%86%85%e5%ad%98%e5%92%8c%e5%af%84%e5%ad%98%e5%99%a8%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=内存和寄存器的区别>内存和寄存器的区别</a></li><li><a href=#%e5%86%85%e5%ad%98%e7%9a%84%e4%ba%94%e7%a7%8d%e8%a1%a8%e7%8e%b0%e5%bd%a2%e5%bc%8f aria-label=内存的五种表现形式>内存的五种表现形式</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e6%a8%a1%e5%bc%8f aria-label=数据存储模式>数据存储模式</a></li></ul></li><li><a href=#eflags%e5%af%84%e5%ad%98%e5%99%a8-1 aria-label=EFLAGS寄存器>EFLAGS寄存器</a></li><li><a href=#%e6%95%b0%e5%ad%a6%e8%bf%90%e7%ae%97 aria-label=数学运算>数学运算</a><ul><li><a href=#%e5%8a%a0%e6%b3%95 aria-label=加法>加法</a></li><li><a href=#%e5%87%8f%e6%b3%95 aria-label=减法>减法</a></li><li><a href=#%e4%b9%98%e6%b3%95 aria-label=乘法>乘法</a></li><li><a href=#%e9%99%a4%e6%b3%95 aria-label=除法>除法</a></li><li><a href=#%e8%87%aa%e5%a2%9e aria-label=自增>自增</a></li><li><a href=#%e8%87%aa%e5%87%8f aria-label=自减>自减</a></li></ul></li><li><a href=#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97 aria-label=逻辑运算>逻辑运算</a><ul><li><a href=#%e4%b8%8e aria-label=与>与</a></li><li><a href=#%e6%88%96 aria-label=或>或</a></li><li><a href=#%e5%bc%82%e6%88%96%e6%93%8d%e4%bd%9c aria-label=异或操作>异或操作</a></li><li><a href=#%e9%9d%9e%e8%bf%90%e7%ae%97 aria-label=非运算>非运算</a></li></ul></li><li><a href=#%e5%a0%86%e6%a0%88%e6%93%8d%e4%bd%9c aria-label=堆栈操作>堆栈操作</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%a0%86%e6%a0%88 aria-label=什么是堆栈>什么是堆栈</a></li><li><a href=#%e6%a0%88%e6%93%8d%e4%bd%9c%e6%8c%87%e4%bb%a4 aria-label=栈操作指令>栈操作指令</a></li><li><a href=#%e6%a0%88%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=栈的作用>栈的作用</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%a7%bb%e5%8a%a8%e6%8c%87%e4%bb%a4 aria-label=数据移动指令>数据移动指令</a><ul><li><a href=#mov%e6%8c%87%e4%bb%a4 aria-label=MOV指令>MOV指令</a></li><li><a href=#lea%e6%8c%87%e4%bb%a4 aria-label=LEA指令>LEA指令</a></li><li><a href=#xchg%e6%8c%87%e4%bb%a4 aria-label=XCHG指令>XCHG指令</a></li></ul></li><li><a href=#%e6%af%94%e8%be%83%e6%8c%87%e4%bb%a4 aria-label=比较指令>比较指令</a><ul><li><a href=#cmp%e6%8c%87%e4%bb%a4-1 aria-label=CMP指令>CMP指令</a></li><li><a href=#test%e6%8c%87%e4%bb%a4 aria-label=TEST指令>TEST指令</a></li></ul></li><li><a href=#jcc%e6%9d%a1%e4%bb%b6%e8%bd%ac%e7%a7%bb%e6%8c%87%e4%bb%a4 aria-label=JCC条件转移指令>JCC条件转移指令</a><ul><li><a href=#%e5%b8%b8%e7%94%a8%e7%9a%84jcc%e6%8c%87%e4%bb%a4 aria-label=常用的JCC指令>常用的JCC指令</a></li><li><a href=#jcc%e8%a1%a8 aria-label=JCC表>JCC表</a></li></ul></li><li><a href=#%e4%b8%b2%e6%93%8d%e4%bd%9c%e6%8c%87%e4%bb%a4 aria-label=串操作指令>串操作指令</a><ul><li><a href=#movs%e6%8c%87%e4%bb%a4 aria-label=MOVS指令>MOVS指令</a></li><li><a href=#stos%e6%8c%87%e4%bb%a4 aria-label=STOS指令>STOS指令</a></li><li><a href=#rep%e6%8c%87%e4%bb%a4 aria-label=REP指令>REP指令</a></li></ul></li><li><a href=#call%e4%b8%8eretn aria-label=CALL与RETN>CALL与RETN</a><ul><li><a href=#call%e6%8c%87%e4%bb%a4 aria-label=CALL指令>CALL指令</a></li><li><a href=#retn%e6%8c%87%e4%bb%a4 aria-label=RETN指令>RETN指令</a></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a></li><li><a href=#win32%e6%b1%87%e7%bc%96%e5%85%a5%e9%97%a8 aria-label=WIN32汇编入门>WIN32汇编入门</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=汇编语言>汇编语言<a hidden class=anchor aria-hidden=true href=#汇编语言>#</a></h1><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><p>编程形式</p><blockquote><p>开关&ndash;>打孔&ndash;>输入设备</p></blockquote><p>汇编语言的出现</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>mov eax, 5
mov ebx, 6
add eax, ebx
</code></pre><p>汇编程序的执行</p><blockquote><p>汇编代码 -> 汇编程序 -> 处理器可识别 01010101 -> 处理器执行</p></blockquote><h3 id=学习汇编的意义>学习汇编的意义<a hidden class=anchor aria-hidden=true href=#学习汇编的意义>#</a></h3><ol><li>开发时调试</li><li>逆向时候的代码阅读</li><li>某些特殊技术的使用（如shellcode、壳）</li></ol><blockquote><p>shellcode：可以运行在任意位置的代码（汇编语言）</p><p>壳：加壳或脱壳都需要用的汇编语言</p></blockquote><p>环境配置</p><ul><li><p>Ollydbg</p></li><li><p>Visual Studio 2015</p></li></ul><h2 id=x16-汇编>x16 汇编<a hidden class=anchor aria-hidden=true href=#x16-汇编>#</a></h2><h3 id=通用寄存器>通用寄存器<a hidden class=anchor aria-hidden=true href=#通用寄存器>#</a></h3><table><thead><tr><th>16位寄存器</th><th>高8位</th><th>低8位</th></tr></thead><tbody><tr><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>DX</td><td>DH</td><td>DL</td></tr><tr><td>SI</td><td>\</td><td>\</td></tr><tr><td>DI</td><td>\</td><td>\</td></tr><tr><td>SP</td><td>\</td><td>\</td></tr><tr><td>BP</td><td>\</td><td>\</td></tr></tbody></table><p><img loading=lazy src=/images/ASM/image-20211123194526478.png alt=image-20211123194526478></p><h3 id=内存字节序>内存字节序<a hidden class=anchor aria-hidden=true href=#内存字节序>#</a></h3><p>:chestnut: 0x12345678</p><p>每个地址只有存储1字节</p><table><thead><tr><th>大端序</th><th>小端序</th></tr></thead><tbody><tr><td>12</td><td>78</td></tr><tr><td>34</td><td>56</td></tr><tr><td>56</td><td>34</td></tr><tr><td>78</td><td>12</td></tr><tr><td>CC</td><td>CC</td></tr><tr><td>CC</td><td>CC</td></tr><tr><td>CC</td><td>CC</td></tr></tbody></table><h3 id=段的概念>段的概念<a hidden class=anchor aria-hidden=true href=#段的概念>#</a></h3><p><img loading=lazy src=/images/ASM/image-20211123201417209.png alt=image-20211123201417209></p><blockquote><p>CS段只有16位，8086有20根地址线，那么地址如何存储？</p><p>简单粗暴 除以0x10，因为只有以零结尾的地址才能作为段地址</p></blockquote><p>CS：代码段</p><p>DS：数据段</p><p>ES：扩展段</p><p>SS：堆栈段</p><h3 id=16位汇编基本框架>16位汇编基本框架<a hidden class=anchor aria-hidden=true href=#16位汇编基本框架>#</a></h3><pre tabindex=0><code class=language-x86asm data-lang=x86asm>assume cs:code ;设置代码段

code segment ;代码段开始
rkmain proc
	mov ax,0
	mov cx, 10H
rk:     
	inc ax
	loop rk
	mov ax, 4c00H
	int 21H
rkmain endp

start:  call rkmain ;指定开始位置
code ends ;代码段结束
end start
</code></pre><blockquote><p><code>add</code> 加</p><p><code>int</code> 自增</p><p><code>sub</code> 减</p><p><code>dec</code> 自减</p><p><code>loop</code> 循环</p></blockquote><h3 id=函数传参>函数传参<a hidden class=anchor aria-hidden=true href=#函数传参>#</a></h3><ul><li>寄存器传参</li><li>堆栈传参</li><li>内存传参</li></ul><pre tabindex=0><code class=language-x86asm data-lang=x86asm>assume cs:code

code segment

addx proc
	push bp
	mov bp,sp
	mov si,[bp+4]
	mov di,[bp+6]
	add si,di
	mov ax,si
	pop bp
	ret
addx endp

rkmain proc
	mov ax,5
	mov bx,6
	push ax
	push bx
	call addx
	add sp,4
	mov bx,ax
	mov ax, 4c00H
	int 21H
rkmain endp

start:  call rkmain

code ends
end start
</code></pre><h3 id=flag寄存器>FLAG寄存器<a hidden class=anchor aria-hidden=true href=#flag寄存器>#</a></h3><h4 id=状态标志>状态标志<a hidden class=anchor aria-hidden=true href=#状态标志>#</a></h4><p>CF：进位位</p><p>PF：奇偶位</p><p>AF：辅助进位位</p><p>ZF：零值位</p><p>SF：符号位</p><p>OF：溢出位</p><h3 id=cmp指令>CMP指令<a hidden class=anchor aria-hidden=true href=#cmp指令>#</a></h3><blockquote><p>CMP OPRD1, OPRD2</p><p>SUB</p><p>影响标志位</p></blockquote><pre tabindex=0><code class=language-x86asm data-lang=x86asm>mov ax,2
mov bx,1
cmp ax.bx
</code></pre><p>相等</p><p>AX-BX = 0 ZF=1</p><p>不等</p><p>AX-BX !=0 ZF=0</p><p>AX &lt; BX:</p><p>AX-BX = ? CF=1</p><p>AX > BX:</p><p>AX-BX=? CF=0 ZF=0</p><p>AX &lt;= BX:</p><p>AX-BX=? CF=1 || ZF=1</p><p>AX >= BX:</p><p>AX-BX=? CF=0 || ZF=1</p><h3 id=jcc指令>JCC指令<a hidden class=anchor aria-hidden=true href=#jcc指令>#</a></h3><p>一类指令 跳转</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>jmp address 
je address ;等于则跳转 ZF=1
jne address ;不等于则跳转 ZF=0
jb address ;低于则跳转 CF=1
ja address ;高于则跳转 CF=0 &amp;&amp; ZF=0
</code></pre><h3 id=运算指令>运算指令<a hidden class=anchor aria-hidden=true href=#运算指令>#</a></h3><p>四则运算</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>mov ax,16
mov bx,5
add ax,5
sub ax,3
mul bx ; &gt;16bit DX:AX 32bit 默认与ax操作
div bx ; DX-&gt;余数 AX-&gt;商 默认与ax操作
</code></pre><p>位运算</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>xor ax,bx
and ax,bx
or ax,bx
not ax
</code></pre><h2 id=x86汇编>x86汇编<a hidden class=anchor aria-hidden=true href=#x86汇编>#</a></h2><p>通用寄存器</p><table><thead><tr><th>寄存器</th></tr></thead><tbody><tr><td>EAX</td></tr><tr><td>EBX</td></tr><tr><td>ECX</td></tr><tr><td>EDX</td></tr><tr><td>ESI</td></tr><tr><td>EDI</td></tr><tr><td>ESP</td></tr><tr><td>EBP</td></tr></tbody></table><h3 id=段>段<a hidden class=anchor aria-hidden=true href=#段>#</a></h3><table><thead><tr><th>段</th></tr></thead><tbody><tr><td>CS</td></tr><tr><td>DS</td></tr><tr><td>ES</td></tr><tr><td>SS</td></tr><tr><td>FS</td></tr><tr><td>GS</td></tr></tbody></table><h4 id=段选择子>段选择子<a hidden class=anchor aria-hidden=true href=#段选择子>#</a></h4><p>CS 代码段 1B</p><p>DS ES SS 数据段 23</p><p>FS 3B</p><ul><li><p>Index：3</p></li><li><p>Ti：0</p></li><li><p>RPL：3</p></li></ul><h4 id=段描述符>段描述符<a hidden class=anchor aria-hidden=true href=#段描述符>#</a></h4><p>代码段：</p><blockquote><p><code>00cffb00 0000ffff</code></p><p>1100 1111 1111 1011 0000 0000</p><p>Base：<code>0000 0000</code></p><p>Limit：<code>ffffff</code></p><p><code>ffffff * 0x1000</code></p><p><code>FFFFFF000+0X1000</code></p><p><code>10 0000 0000 - 1</code></p><p><code>FFFF FFFF</code></p><p>G = 1 Limit单位是页</p><p>G = 0 Limit单位是字节</p><p>页</p><ul><li>大页 4M</li><li>小页 4K</li></ul><p>寻址空间：<code>0000 0000 ~ FFFF FFFF</code></p></blockquote><p>数据段</p><blockquote><p><code>00cff300 0000ffff</code></p><p>BASE：<code>0000 0000</code></p><p>Limit：<code>FFFF FFFF</code></p></blockquote><p>FS段</p><blockquote><p><code>0040f300 00000fff</code></p><p>G=0 字节</p><p><code>0000 0000 0100 0000 1111 0011 0000 0000</code></p><p><code>fff * 1</code> <code>fff</code>字节</p><p><code>0 ~ fff</code></p></blockquote><p>4GB空间 虚拟的4GB空间</p><ul><li>低2GB是每个进程独享的</li><li>高2GB是内核空间，是共享的</li></ul><p>base+offset = 虚拟地址</p><h3 id=页>页<a hidden class=anchor aria-hidden=true href=#页>#</a></h3><blockquote><p>内存的一种管理模式</p></blockquote><p>29912</p><p>CR3</p><p>PDPTE -> PTE - PDE -> 物理页 (4k)</p><p>76B26000 E9 A1 B0 76</p><p>01 (PDPTE) （1 * 8)</p><p>110110101(PTE) (1B5 * 8 )</p><p>100100110(PDE) (126 * 8)</p><p>00000000000(页内偏移) (000)</p><hr><blockquote><p>R3 用户层 TEB（线程环境块）</p><p>R0 系统内核 驱动 KPCR（CPU状态块）</p></blockquote><h3 id=调用约定>调用约定<a hidden class=anchor aria-hidden=true href=#调用约定>#</a></h3><ol><li><code>cdecl</code></li><li><code>stdcall</code></li><li><code>fastcall</code></li><li><code>thiscall</code></li></ol><blockquote><p><code>lib</code> 静态链接库</p><p><code>dll</code> 动态链接库</p></blockquote><h4 id=cdecl>cdecl<a hidden class=anchor aria-hidden=true href=#cdecl>#</a></h4><p>C语言调用约定</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>push eax
push eax
call printf
add esp,8
</code></pre><h4 id=stdcall>stdcall<a hidden class=anchor aria-hidden=true href=#stdcall>#</a></h4><p>Win32调用约定</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>push 1
push 2
push 3
push 4
call messagebox
</code></pre><h4 id=fastcall>fastcall<a hidden class=anchor aria-hidden=true href=#fastcall>#</a></h4><p>x64 调用约定</p><p>前四个参数使用寄存器传参，后面使用堆栈</p><blockquote><p>rcx rdx r8 r9</p></blockquote><h3 id=x86基本框架>x86基本框架<a hidden class=anchor aria-hidden=true href=#x86基本框架>#</a></h3><pre tabindex=0><code class=language-x86asm data-lang=x86asm>.586
.model flat,stdcall
option casemap:none

includelib ucrt.lib
includelib legacy_stdio_definitions.lib
includelib User32.lib
includelib Kernel32.lib

MessageBoxA PROTO hWnd:DWORD,lpText:BYTE,lpCaption:BYTE,uType:DWORD
ExitProcess PROTO uType:DWORD
extern printf:proc
extern scanf:proc
extern putchar:proc

.data
szStr db &#39;Hello World!&#39;,0
.code
main proc
	lea eax,szStr
	push eax
	call printf
	add esp,4
	push 0
	call ExitProcess
	add esp,4
main endp
end
</code></pre><h3 id=内联汇编>内联汇编<a hidden class=anchor aria-hidden=true href=#内联汇编>#</a></h3><p>单行内联汇编</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>_ASM</span><span class=o>/</span> <span class=n>mov</span> <span class=n>nNum</span><span class=p>,</span> <span class=mi>100</span><span class=p>;</span>
</span></span></code></pre></div><p>多行内联汇编</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>_ASM</span><span class=o>/</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>mov</span> <span class=n>nNum</span><span class=p>,</span><span class=mi>100</span>
</span></span><span class=line><span class=cl>		<span class=n>mov</span> <span class=n>eax</span><span class=p>,</span><span class=n>nNum</span>
</span></span><span class=line><span class=cl>		<span class=n>push</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl>		<span class=n>mov</span> <span class=n>eax</span><span class=p>,</span><span class=n>fNum</span>
</span></span><span class=line><span class=cl>		<span class=n>push</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl>		<span class=n>call</span> <span class=n>printf</span>
</span></span><span class=line><span class=cl>		<span class=n>add</span> <span class=n>esp</span><span class=p>,</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>遍历数组</p><p>按结尾数据遍历</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>nNum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>fNum</span> <span class=o>=</span> <span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>arr</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>9</span><span class=p>,</span><span class=mi>0</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>_ASM</span><span class=o>/</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>xor</span> <span class=n>esi</span><span class=p>,</span><span class=n>esi</span>
</span></span><span class=line><span class=cl>		<span class=n>jmp</span> <span class=n>loopX</span>
</span></span><span class=line><span class=cl>	<span class=nl>loopM</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>inc</span> <span class=n>esi</span>
</span></span><span class=line><span class=cl>	<span class=nl>loopX</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>mov</span> <span class=n>edi</span><span class=p>,[</span><span class=n>arr</span><span class=o>+</span><span class=n>esi</span><span class=o>*</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=n>push</span> <span class=n>edi</span>
</span></span><span class=line><span class=cl>		<span class=n>mov</span> <span class=n>eax</span><span class=p>,</span><span class=n>fNum</span>
</span></span><span class=line><span class=cl>		<span class=n>push</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl>		<span class=n>call</span> <span class=n>printf</span>
</span></span><span class=line><span class=cl>		<span class=n>add</span> <span class=n>esp</span><span class=p>,</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>		<span class=n>cmp</span> <span class=n>edi</span><span class=p>,</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=n>jne</span> <span class=n>loopM</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>按长度进行遍历</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>nNum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>fNum</span> <span class=o>=</span> <span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>_ASM</span><span class=o>/</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>xor</span> <span class=n>edi</span><span class=p>,</span><span class=n>edi</span>
</span></span><span class=line><span class=cl>		<span class=n>xor</span> <span class=n>esi</span><span class=p>,</span><span class=n>esi</span>
</span></span><span class=line><span class=cl>		<span class=n>xor</span> <span class=n>edx</span><span class=p>,</span><span class=n>edx</span>
</span></span><span class=line><span class=cl>		<span class=n>mov</span> <span class=n>edi</span><span class=p>,</span><span class=mi>9</span><span class=n>h</span>
</span></span><span class=line><span class=cl>		<span class=n>jmp</span> <span class=n>Mloop</span>
</span></span><span class=line><span class=cl>		<span class=nl>Xloop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>inc</span> <span class=n>esi</span>
</span></span><span class=line><span class=cl>		<span class=nl>Mloop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>mov</span> <span class=n>edx</span><span class=p>,</span> <span class=p>[</span><span class=n>arr</span> <span class=o>+</span> <span class=n>esi</span> <span class=o>*</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=n>push</span> <span class=n>edx</span>
</span></span><span class=line><span class=cl>		<span class=n>mov</span> <span class=n>eax</span><span class=p>,</span><span class=n>fNum</span>
</span></span><span class=line><span class=cl>		<span class=n>push</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl>		<span class=n>call</span> <span class=n>printf</span>
</span></span><span class=line><span class=cl>		<span class=n>add</span> <span class=n>esp</span><span class=p>,</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>		<span class=n>cmp</span> <span class=n>edi</span><span class=p>,</span><span class=n>esi</span>
</span></span><span class=line><span class=cl>		<span class=n>jne</span> <span class=n>Xloop</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=结构体和api>结构体和API<a hidden class=anchor aria-hidden=true href=#结构体和api>#</a></h3><p>汇编语言结构体</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>.586
.model flat,stdcall

.data
info struct ;声明结构体
x dword ?
y dword ?
info ends

m_info info &lt;&gt; ;初始化结构体
.code

main proc
	mov eax,5
	mov m_info.x,eax
	mov ebx,m_info.x
	mov eax,eax
main endp

end main
</code></pre><h2 id=x64汇编>x64汇编<a hidden class=anchor aria-hidden=true href=#x64汇编>#</a></h2><p>x64和x86汇编寄存器区别</p><blockquote><p>x86 : <code>eax ebx ecx edx esi edi ebp esp eip eflags</code></p><p>x64 : <code>rax rbx rcx rdx rsi rdi rbp rsp rip rflags</code></p><p>x64扩展 ： <code>r8 r9 r10 r11 r12 r13 r14 r15</code></p></blockquote><h2 id=汇编代码剽窃小技巧>汇编代码剽窃小技巧<a hidden class=anchor aria-hidden=true href=#汇编代码剽窃小技巧>#</a></h2><ol><li>所有的jcc死地址，都要改成标号</li><li>所有的call，都要确定，是系统函数，还是自己的函数，想办法call过去</li><li>一切检查或者初始化类的无用代码，全部去掉</li><li>一些必要逻辑里的不合理东西，去掉这些，然后自己写代码，让他合理化</li></ol><h2 id=16位32位64位汇编的区别>16位/32位/64位汇编的区别<a hidden class=anchor aria-hidden=true href=#16位32位64位汇编的区别>#</a></h2><p>区别</p><blockquote><p>16位：实模式，16位处理器内的内部，最多可以处理存储的长度为16位。</p><p>32位：保护模式，32位处理器内的内部，最多可以处理存储的长度为32位。</p><p>64位：保护模式，64位处理器内的内部，最多可以处理存储的长度为64位。</p></blockquote><p>通用寄存器简介</p><table><thead><tr><th>位数</th><th>通用寄存器</th><th>扩展</th></tr></thead><tbody><tr><td>16</td><td>AX BX CX DX SI DI BP SP</td><td>R8W R9W R10W R11W R12W R13W R14W R15W</td></tr><tr><td>32</td><td>EAX EBX ECX EDX ESI EDI EBP ESP</td><td>R8D R9D R10D R11D R12D R13D R14D R15D</td></tr><tr><td>64</td><td>RAX RBX RCX RDX RSI RDI RBP RSP</td><td>R8 R9 R10 R11 R12 R13 R14 R15</td></tr></tbody></table><p>基本执行环境</p><table><thead><tr><th>32位</th><th>64位</th></tr></thead><tbody><tr><td>8个32位通用寄存器</td><td>16个64位通用寄存器</td></tr><tr><td>标志寄存器EFLAGS</td><td>标志寄存器RFLAGS</td></tr><tr><td>指令寄存器EIP</td><td>指令寄存器RIP</td></tr></tbody></table><h3 id=eflags寄存器>EFLAGS寄存器<a hidden class=anchor aria-hidden=true href=#eflags寄存器>#</a></h3><p>Eflags寄存器，Eflags寄存器包含了独立的二进制位，用于控制CPU操作。或是反应一些CPU操作的结果。有些指令可以测试和控制这些单独的处理器标志位。</p><h3 id=mmx寄存器>MMX寄存器<a hidden class=anchor aria-hidden=true href=#mmx寄存器>#</a></h3><p>在实现高级多媒体和通信应用时，MMX技术提高了Intel处理器的性能。8个64位MMX寄存器支持成为SIMD的特殊指令。顾名思义，MMX指令对MMX寄存器中的数据值直接进行并行操作。虽然它们看上去是独立的寄存器，但是MMX寄存器实际上是浮点单元中使用的同样寄存器的别名。</p><h2 id=通用寄存器-1>通用寄存器<a hidden class=anchor aria-hidden=true href=#通用寄存器-1>#</a></h2><p>eax：累加器，操作数和结果数据累加器，返回值运算结果一般都存储在这里</p><p><img loading=lazy src=/images/ASM/image-20210811183106370.png alt=image-20210811183106370></p><p>ebx：基地址，DS段的数据指针，在内存寻址的时候存放基地址</p><p><img loading=lazy src=/images/ASM/image-20210811183206737.png alt=image-20210811183206737></p><p>ecx：计数器，字符串和循环操作的计数器</p><p><img loading=lazy src=/images/ASM/image-20210811183244169.png alt=image-20210811183244169></p><p>edx：用于存储部分乘法结果和部分除法被除数</p><p><img loading=lazy src=/images/ASM/image-20210811183411998.png alt=image-20210811183411998></p><p>ebp：基址指针，SS段的数据指针</p><p><img loading=lazy src=/images/ASM/image-20210811183548209.png alt=image-20210811183548209></p><p>esp：栈帧指针，一般指向栈顶，所以也被称为栈顶指针</p><p><img loading=lazy src=/images/ASM/image-20210811183809151.png alt=image-20210811183809151></p><p>edi：字符串操作的目标指针，ES段的数据指针</p><p><img loading=lazy src=/images/ASM/image-20210811183910749.png alt=image-20210811183910749></p><p>esi：字符串操作的源指针，SS段的数据指针</p><p><img loading=lazy src=/images/ASM/image-20210811184031993.png alt=image-20210811184031993></p><h2 id=冯诺依曼>冯诺依曼<a hidden class=anchor aria-hidden=true href=#冯诺依曼>#</a></h2><p>计算机科学的奠基者</p><ul><li>艾伦·麦锡森·图灵 - - - 图灵机</li><li>约翰·冯·诺依曼 - - - 数据存储的体系结构</li></ul><p>约翰·冯·诺依曼</p><blockquote><p>1903年 出生犹太家庭</p><p>1926年 布达佩斯大学数学博士学位</p><p>1930年 接受了普林斯顿大学客座教授的职位</p><p>1931年 普林斯顿大学终身教授</p><p>1933年 普林斯顿高等研究院</p><p>1937年 美国公民</p><p>1938年 获博修奖</p><p>1954年 美国原子能委员会委员</p><p>1957 在华盛顿德里医院去世</p></blockquote><h3 id=冯诺依曼体系>冯诺依曼体系<a hidden class=anchor aria-hidden=true href=#冯诺依曼体系>#</a></h3><p>计算机由控制器、运算器、存储器、输入设备、输出设备五部分组成。</p><p>冯诺依曼提出的计算机体系结构，奠定了现代计算机的结构理念</p><p><img loading=lazy src=/images/ASM/image-20210811190118360.png alt=image-20210811190118360></p><h2 id=内存基础>内存基础<a hidden class=anchor aria-hidden=true href=#内存基础>#</a></h2><h3 id=什么是内存>什么是内存<a hidden class=anchor aria-hidden=true href=#什么是内存>#</a></h3><p>在冯诺依曼结构中用来存储程序和数据的部件叫做存储器，我们的计算机可以正常的运行，主要依靠的就是存储器的记忆能力。存储器分为主存储器和辅助存储器，主存储器也叫内存储器，也就是我们常说的内存</p><h3 id=内存寻址范围>内存寻址范围<a hidden class=anchor aria-hidden=true href=#内存寻址范围>#</a></h3><blockquote><p>现在主流的系统是32位系统和64位系统</p><p>32位系统内存的寻址范围是0x00000000-0xFFFFFFFF</p><p>32位系统内存最大寻址范围是0xFFFFFFFF+1(4294967296) - - - 4GB</p><p>64位内存的寻址范围是0x0000000000000000-0xFFFFFFFFFFFFFFFF</p></blockquote><p><img loading=lazy src=/images/ASM/image-20210811191257593.png alt=image-20210811191257593></p><h3 id=内存和寄存器的区别>内存和寄存器的区别<a hidden class=anchor aria-hidden=true href=#内存和寄存器的区别>#</a></h3><p>寄存器：数量少，在CPU内部，速度极快，但是价格昂贵</p><p>内存：数量庞大，相对寄存器而言，速度较慢，但是价格便宜</p><h3 id=内存的五种表现形式>内存的五种表现形式<a hidden class=anchor aria-hidden=true href=#内存的五种表现形式>#</a></h3><p>立即数：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV EAX, DWORD PTR DS:[0x???????]
</code></pre><p>寄存器：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV EBX, 0x????????
MOV EAX, DWORD PTR DS:[EBX]
</code></pre><p>寄存器+立即数</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV EBX, 0x???????
MOV EAX, DWORD PTR DS:[EBX+4]
</code></pre><p>比例因子：[REG+REG*{1,2,4,8}]</p><p>数组元素地址=数组首地址+元素索引*数组元素占用空间</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV EAX, 0x????????
MOV EBX, 0x2
MOV ECX, DWORD PTR DS:[EAX+EBX*4]
</code></pre><p>比例因子+立刻数：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV EAX, 0x????????
MOV EBX, 0x2
MOV ECX, DWORD PTR DS:[EAX+EBX*4+1]
</code></pre><h3 id=数据存储模式>数据存储模式<a hidden class=anchor aria-hidden=true href=#数据存储模式>#</a></h3><p>大端序：数据高位在内存低位，数据低位在内存高位</p><p>小端序：数据高位在内存高位，数据低位在内存低位</p><p>地址0x77 66 55 44</p><p>大端序：念的时候是77 66 55 44</p><p>小端序：念的时候是44 55 66 77</p><p>大端序常用于ARM架构</p><p>小端序常用于x86、AMD64架构</p><h2 id=eflags寄存器-1>EFLAGS寄存器<a hidden class=anchor aria-hidden=true href=#eflags寄存器-1>#</a></h2><p>CF：进位借位标志位</p><p>PF：奇偶标志位</p><p>AF：辅助进位标志位</p><p>ZF：0标志位</p><p>SF：符号标志位</p><p>TF：单目标志位</p><p>IF：中断标志位</p><p>DF：方向标志位</p><p>OF：溢出标志位</p><h2 id=数学运算>数学运算<a hidden class=anchor aria-hidden=true href=#数学运算>#</a></h2><h3 id=加法>加法<a hidden class=anchor aria-hidden=true href=#加法>#</a></h3><p>加法指令 ADD（Addition）</p><p>格式：ADD OPRD1, OPRD2</p><p>功能：两数相加</p><p>加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响</p><p>不允许OPRD1与OPRD2同时为存储器</p><hr><p>带进位加法指令 ADC（Addition Carry)</p><p>格式：ADC OPRD1, OPRD2</p><p>功能：OPRD1 = OPRD1 + OPRD2 + CF</p><h3 id=减法>减法<a hidden class=anchor aria-hidden=true href=#减法>#</a></h3><p>减法指令 SUB（Subtract）</p><p>格式：SUB OPRD1, OPRD2</p><p>功能：两个操作数的相减，即从OPRD1中减去OPRD2，其结果放在OPRD1中。指令的类型及对标志位的影响与ADD指令相同，注意立即数不能用于目的操作数，两个存储器操作数之间不能直接相减，操作数可为8位或16位的无符号数或带符号数。</p><hr><p>带借位减法指令 SBB（Subtraction with Borrow）</p><p>格式：SBB OPRD1, OPRD2</p><p>功能：进行两个操作数的相减再减去CF进位标志位，即从OPRD1 = OPRD1 - OPRD2 -CF，其结果放在OPDR1中。</p><h3 id=乘法>乘法<a hidden class=anchor aria-hidden=true href=#乘法>#</a></h3><p>无符号数乘法指令 MUL（Multiply）</p><p>格式：MUL OPRD</p><hr><p>带符号数乘法指令 IMUL（Integer Multiply）</p><p>格式：IMUL OPRD、</p><p>功能：乘法操作</p><p>OPRD为通用寄存器或寄存器操作数</p><p>本指令影响标志位CF及OF</p><h3 id=除法>除法<a hidden class=anchor aria-hidden=true href=#除法>#</a></h3><p>无符号数除法指令 DIV（Division）</p><p>格式：DIV OPRD</p><p>功能：实现两个无符号二进制数除法运算</p><hr><p>带符号数除法指定 IDIV（Integer Division）</p><p>格式：IDIV OPRD</p><p>功能：这实现两个带符号数的二进制除法运算</p><blockquote><p>16bit，分存2个8bit AH:AL 商AL 余AH</p><p>32bit，分存2个16bit DX:AX 商AX 余DX</p><p>64bit，分存2个32bit EDX:EAX 商EAX 余EDX</p><p>128bit，分存2个64bit RDX:RAX 商RAX 余RDX</p></blockquote><h3 id=自增>自增<a hidden class=anchor aria-hidden=true href=#自增>#</a></h3><p>加1指令 INC（Increment by 1）</p><p>格式：INC OPRD</p><p>功能：OPRD = OPRD + 1</p><h3 id=自减>自减<a hidden class=anchor aria-hidden=true href=#自减>#</a></h3><p>减1指令 DEC（Decrement by 1）</p><p>格式：DEC OPRD</p><p>功能：OPRD = OPRD - 1</p><h2 id=逻辑运算>逻辑运算<a hidden class=anchor aria-hidden=true href=#逻辑运算>#</a></h2><h3 id=与>与<a hidden class=anchor aria-hidden=true href=#与>#</a></h3><p>逻辑与运算指令 AND</p><p>格式：AND OPRD1, OPRD2</p><p>功能：对两个操作数实现按位逻辑与运算，结果送至目的操作数。本指令可以进行字节或字的 ‘与‘ 运算，OPRD1 &lt; - - OPRD1 and OPRD2.</p><p>本指令影响标志位PF、SF、ZF，使CF=0、OF=0.例如，在同一个通用寄存器自身相与时， 操作数虽不变，但使CF置零。本指令主要用于修改操作数或置某些位为零。</p><h3 id=或>或<a hidden class=anchor aria-hidden=true href=#或>#</a></h3><p>逻辑或指令 OR</p><p>格式：OR OPRD1, OPRD2</p><p>功能：OR指令完成对两个操作数按位的 ‘或’ 运算，结果送至目的操作数中，本指令可以进 - - - - 行字节或字的 ‘或’ 运算。OPRD1 &lt; - - OPRD1 OR OPRD2。</p><h3 id=异或操作>异或操作<a hidden class=anchor aria-hidden=true href=#异或操作>#</a></h3><p>逻辑异或运算指令 XOR</p><p>格式：XOR OPRD1, OPRD2</p><p>功能：实现两个操作数按位 ‘异或’ 运算，结果送至目的操作数中。OPRD1 &lt; - - OPRD1 XOR OPRD2</p><h3 id=非运算>非运算<a hidden class=anchor aria-hidden=true href=#非运算>#</a></h3><p>逻辑操作符 NOT</p><p>格式：NOT exp</p><p>功能：按位求反</p><h2 id=堆栈操作>堆栈操作<a hidden class=anchor aria-hidden=true href=#堆栈操作>#</a></h2><h3 id=什么是堆栈>什么是堆栈<a hidden class=anchor aria-hidden=true href=#什么是堆栈>#</a></h3><ol><li>栈是一个后进先出的存储区域，位于堆栈段中，SS段寄存器描述的就是堆栈段的地址</li><li>栈的数据出口位于栈顶，也就是esp寄存器所指向的位置</li><li>栈顶是低位，也就是地址较小的一侧，由ebp寄存器指向的栈底，并不会改变</li></ol><h3 id=栈操作指令>栈操作指令<a hidden class=anchor aria-hidden=true href=#栈操作指令>#</a></h3><p>PUSH：压栈操作，32位汇编首先ESP-4，留出一个空间，然后把要压入栈中的内容压入</p><p>POP：出栈指令，32位汇编首先将栈顶的数据弹出给指定的目标，然后ESP+4，清掉空间</p><h3 id=栈的作用>栈的作用<a hidden class=anchor aria-hidden=true href=#栈的作用>#</a></h3><ol><li>存储少量数据</li><li>保存寄存器环境</li><li>传递参数</li></ol><h2 id=数据移动指令>数据移动指令<a hidden class=anchor aria-hidden=true href=#数据移动指令>#</a></h2><h3 id=mov指令>MOV指令<a hidden class=anchor aria-hidden=true href=#mov指令>#</a></h3><p>数据传送指令MOV</p><p>格式：MOV OPRD1, OPRD2</p><p>功能：本指令将一个源操作数送到目的操作数中，即OPRD1 &lt; - - OPRD2</p><p>说明：</p><ul><li>OPRD1为目的操作数，可以是寄存器、存储器、累加器</li><li>OPRD2为源操作数，可以是寄存器、存储器、累加器和立即数</li></ul><h3 id=lea指令>LEA指令<a hidden class=anchor aria-hidden=true href=#lea指令>#</a></h3><p>有效地址传送指令 LEA</p><p>格式：LEA OPRD1，OPRD2</p><p>功能：将源操作数给出的有效地址传送到指定的寄存器中</p><p>OPRD1必须是寄存器</p><h3 id=xchg指令>XCHG指令<a hidden class=anchor aria-hidden=true href=#xchg指令>#</a></h3><p>数据交换指令 XCHG</p><p>格式：XCHG OPRD1, OPRD2 其中的OPRD1为目的操作数，OPRD2为源操作数</p><p>功能：将两个操作数相互交换位置，该指令把源操作数OPRD2与目的操作数OPRD1交换</p><h2 id=比较指令>比较指令<a hidden class=anchor aria-hidden=true href=#比较指令>#</a></h2><h3 id=cmp指令-1>CMP指令<a hidden class=anchor aria-hidden=true href=#cmp指令-1>#</a></h3><p>比较指令 CMP（Compare）</p><p>格式：CMP OPRD1, OPRD2</p><p>功能：对两数进行相减，进行比较</p><h3 id=test指令>TEST指令<a hidden class=anchor aria-hidden=true href=#test指令>#</a></h3><p>测试指令 TEST</p><p>格式：TEST OPRD1,OPRD2</p><p>功能：其中OPRD1、OPRD2的含义同AND指令一样，也是对两个操作数进行按位的 ‘与’ 运算，- - - - 唯一不同之处是不将 ‘与’ 的结果送目的操作数，即本指令对两个操作数的内容均不进行修改，仅是在逻辑与操作后，对标志位重新置位</p><h2 id=jcc条件转移指令>JCC条件转移指令<a hidden class=anchor aria-hidden=true href=#jcc条件转移指令>#</a></h2><h3 id=常用的jcc指令>常用的JCC指令<a hidden class=anchor aria-hidden=true href=#常用的jcc指令>#</a></h3><p>JMP：无条件跳转</p><p>JZ/JE：ZF = 1 等于0或相等跳转</p><p>JNZ/JNE：ZF = 0 不等于0或者不相等跳转</p><p>JBE/JNA：CF = 1/ZF = 1 低于等于/不高于跳转</p><p>JNBE/JA：CF = 0/ ZF = 0 不低于等于/高于跳转</p><p>JL/JNGE：SF！=OF 小于/不大于等于跳转</p><p>JNL/JGE：SF = OF 不小于/大于等于跳转</p><h3 id=jcc表>JCC表<a hidden class=anchor aria-hidden=true href=#jcc表>#</a></h3><table><thead><tr><th>JCC指令</th><th>中文含义</th><th>英文原意</th><th>检查符号位</th><th>典型C应用</th></tr></thead><tbody><tr><td>JZ/JE</td><td>若为0则跳转；若相等则跳转</td><td>jump if zero;jump if equal</td><td>ZF=1</td><td>if (i == j);if (i == 0);</td></tr><tr><td>JNZ/JNE</td><td>若不为0则跳转；若不相等则跳转</td><td>jump if not zero;jump if not equal</td><td>ZF=0</td><td>if (i != j);if (i != 0);</td></tr><tr><td>JS</td><td>若为负则跳转</td><td>jump if sign</td><td>SF=1</td><td>if (i &lt; 0);</td></tr><tr><td>JNS</td><td>若为正则跳转</td><td>jump if not sign</td><td>SF=0</td><td>if (i > 0);</td></tr><tr><td>JP/JPE</td><td>若1出现次数为偶数则跳转</td><td>jump if Parity (Even)</td><td>PF=1</td><td>(null)</td></tr><tr><td>JNP/JPO</td><td>若1出现次数为奇数则跳转</td><td>jump if not parity (odd)</td><td>PF=0</td><td>(null)</td></tr><tr><td>JO</td><td>若溢出则跳转</td><td>jump if overflow</td><td>OF=1</td><td>(null)</td></tr><tr><td>JNO</td><td>若无溢出则跳转</td><td>jump if not overflow</td><td>OF=0</td><td>(null)</td></tr><tr><td>JC/JB/JNAE</td><td>若进位则跳转；若低于则跳转；若不高于等于则跳转</td><td>jump if carry;jump if below;jump if not above equal</td><td>CF=1</td><td>if (i &lt; j);</td></tr><tr><td>JNC/JNB/JAE</td><td>若无进位则跳转；若不低于则跳转；若高于等于则跳转；</td><td>jump if not carry;jump if not below;jump if above equal</td><td>CF=0</td><td>if (i >= j);</td></tr><tr><td>JBE/JNA</td><td>若低于等于则跳转；若不高于则跳转</td><td>jump if below equal;jump if not above</td><td>ZF=1或CF=1</td><td>if (i &lt;= j);</td></tr><tr><td>JNBE/JA</td><td>若不低于等于则跳转；若高于则跳转</td><td>jump if not below equal;jump if above</td><td>ZF=0或CF=0</td><td>if (i > j);</td></tr><tr><td>JL/JNGE</td><td>若小于则跳转；若不大于等于则跳转</td><td>jump if less;jump if not greater equal</td><td>SF != OF</td><td>if (si &lt; sj);</td></tr><tr><td>JNL/JGE</td><td>若不小于则跳转；若大于等于则跳转；</td><td>jump if not less;jump if greater equal</td><td>SF = OF</td><td>if (si >= sj);</td></tr><tr><td>JLE/JNG</td><td>若小于等于则跳转；若不大于则跳转</td><td>jump if less equal;jump if not greater</td><td>ZF != OF 或 ZF=1</td><td>if (si &lt;= sj);</td></tr><tr><td>JNLE/JG</td><td>若不小于等于则跳转；若大于则跳转</td><td>jump if not less equal;jump if greater</td><td>SF=0F 且 ZF=0</td><td>if(si>sj)</td></tr></tbody></table><h2 id=串操作指令>串操作指令<a hidden class=anchor aria-hidden=true href=#串操作指令>#</a></h2><h3 id=movs指令>MOVS指令<a hidden class=anchor aria-hidden=true href=#movs指令>#</a></h3><p>字符串传送指令 MOVS</p><p>格式：MOVS OPRD1, OPRD2 MOVSB MOVSW</p><p>功能：OPRD1 &lt; - - OPRD2</p><p>说明：</p><ol><li>其中OPRD2为源串符号地址，OPRD1为目的串符号地址</li></ol><h3 id=stos指令>STOS指令<a hidden class=anchor aria-hidden=true href=#stos指令>#</a></h3><p>字符串存储指令 STOS</p><p>格式：STOS OPRD</p><p>功能：把AL(字节)或AX(字)中的数据存储到DI为目的串地址指针所寻址的存储器单元中去指针DI将根据DF的值进行自动调整</p><h3 id=rep指令>REP指令<a hidden class=anchor aria-hidden=true href=#rep指令>#</a></h3><p>重复前缀说明</p><p>格式：</p><ul><li>REP ;CX&lt;>0 重复执行字符串指令</li><li>REPZ/REPE ;CX&lt;>0 且ZF=1重复执行字符串指令</li><li>REPNZ/REPNE ;CX&lt;>0 且ZF=0重复执行字符串指令</li></ul><p>功能：在串操作指令前加上重复前缀，可以对字符串进行重复处理。由于加上重复前缀后，对应的指令代码是不同的，所以指令的功能便具有重复处理的功能，重复的次数存放在CX寄存器中</p><h2 id=call与retn>CALL与RETN<a hidden class=anchor aria-hidden=true href=#call与retn>#</a></h2><h3 id=call指令>CALL指令<a hidden class=anchor aria-hidden=true href=#call指令>#</a></h3><p>过程调用指令 CALL</p><p>格式：CALL OPRD</p><p>功能：过程调用指令</p><p>相当于：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>push eip
jmp OPRD
</code></pre><h3 id=retn指令>RETN指令<a hidden class=anchor aria-hidden=true href=#retn指令>#</a></h3><pre><code>返回指令，相当于：
</code></pre><pre tabindex=0><code class=language-x86asm data-lang=x86asm>pop eip
jmp eip
</code></pre><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><p>过程调用-函数</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>function proc
	code
function end
</code></pre><p>参数传递方式：</p><ol><li>寄存器传参</li><li>堆栈传参</li></ol><h2 id=win32汇编入门>WIN32汇编入门<a hidden class=anchor aria-hidden=true href=#win32汇编入门>#</a></h2><p>什么是API？</p><p>API（Application Programming Interface, 应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节</p><p>Windows系统除了协调应用程序的执行、内存的分配、系统资源的管理外，同时他也是一个很大的服务中心。调用这个服务中心的各种服务（每一种服务就是一个函数）可以帮助应用程序达到开启视窗、描绘图形和使用周边设备等目的，由于这些函数服务的对象是应用程序，所以称之为Application Programming Interface, 简称API函数。WIN32 API也就是Microsoft Windows 32位平台的应用程序编程接口</p><p>凡是在 Windows 工作环境底下执行的应用程序，都可以调用Windows API</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/reverse/>Reverse</a></li><li><a href=/tags/assembly/>assembly</a></li><li><a href=/tags/note/>note</a></li></ul><nav class=paginav><a class=prev href=/posts/html-basic/><span class=title>« Prev</span><br><span>HTML基础语法 笔记</span></a>
<a class=next href=/posts/c-core/><span class=title>Next »</span><br><span>C语言核心内容 笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Jasmine❀Hiker</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
</script><script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script></body></html>