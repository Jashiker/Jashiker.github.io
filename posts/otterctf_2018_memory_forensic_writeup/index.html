<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OtterCTF 2018 内存取证复现 | Jasmine❀Hiker</title><meta name=keywords content="ctf,Forensics,writeup"><meta name=description content="OtterCTF 2018 Memory Forensic Reappearance 想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3
环境配置：Kali Linux 2022 工具配置：volatility + mimikatz
Info 题目附件就一个镜像，先查看下镜像的指纹数据：
5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：
vol.py -f OtterCTF.vmem imageinfo 说明
vol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：
可以看到大致的镜像系统是Win7系统
What the password? 查看题目描述：
you got a sample of rick's PC's memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：
对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取
使用如下指令使用mimikatz插件进行获取：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息："><meta name=author content="Me"><link rel=canonical href=/posts/otterctf_2018_memory_forensic_writeup/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css integrity="sha256-v1+fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=apple-touch-icon href=apple-touch-icon.png><link rel=mask-icon href=safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="OtterCTF 2018 内存取证复现"><meta property="og:description" content="OtterCTF 2018 Memory Forensic Reappearance 想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3
环境配置：Kali Linux 2022 工具配置：volatility + mimikatz
Info 题目附件就一个镜像，先查看下镜像的指纹数据：
5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：
vol.py -f OtterCTF.vmem imageinfo 说明
vol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：
可以看到大致的镜像系统是Win7系统
What the password? 查看题目描述：
you got a sample of rick's PC's memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：
对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取
使用如下指令使用mimikatz插件进行获取：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息："><meta property="og:type" content="article"><meta property="og:url" content="/posts/otterctf_2018_memory_forensic_writeup/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-04T23:18:37+08:00"><meta property="article:modified_time" content="2022-10-04T23:18:37+08:00"><meta property="og:site_name" content="Jasmine❀Hiker"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="OtterCTF 2018 内存取证复现"><meta name=twitter:description content="OtterCTF 2018 Memory Forensic Reappearance 想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3
环境配置：Kali Linux 2022 工具配置：volatility + mimikatz
Info 题目附件就一个镜像，先查看下镜像的指纹数据：
5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：
vol.py -f OtterCTF.vmem imageinfo 说明
vol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：
可以看到大致的镜像系统是Win7系统
What the password? 查看题目描述：
you got a sample of rick's PC's memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：
对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取
使用如下指令使用mimikatz插件进行获取：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"OtterCTF 2018 内存取证复现","item":"/posts/otterctf_2018_memory_forensic_writeup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OtterCTF 2018 内存取证复现","name":"OtterCTF 2018 内存取证复现","description":"OtterCTF 2018 Memory Forensic Reappearance 想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3\n环境配置：Kali Linux 2022 工具配置：volatility + mimikatz\nInfo 题目附件就一个镜像，先查看下镜像的指纹数据：\n5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：\nvol.py -f OtterCTF.vmem imageinfo 说明\nvol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：\n可以看到大致的镜像系统是Win7系统\nWhat the password? 查看题目描述：\nyou got a sample of rick\u0026#39;s PC\u0026#39;s memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：\n对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取\n使用如下指令使用mimikatz插件进行获取：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息：","keywords":["ctf","Forensics","writeup"],"articleBody":"OtterCTF 2018 Memory Forensic Reappearance 想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3\n环境配置：Kali Linux 2022 工具配置：volatility + mimikatz\nInfo 题目附件就一个镜像，先查看下镜像的指纹数据：\n5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：\nvol.py -f OtterCTF.vmem imageinfo 说明\nvol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：\n可以看到大致的镜像系统是Win7系统\nWhat the password? 查看题目描述：\nyou got a sample of rick's PC's memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：\n对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取\n使用如下指令使用mimikatz插件进行获取：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息：\n已经获取到了密码信息，提交flag，攻破此题：\nCTF{MortyIsReallyAnOtter} General Info 查看题目描述：\nLet's start easy - whats the PC's name and IP address? 需要获取PC’s name和IP， PC的名字已经很明确了，应该就是刚刚获取密码信息得到的WIN-LO6FAF3DTFE\n下面需要获取的应该就是IP地址，使用网络扫描指令应该可以获取到相应的信息：\n可以看出IP地址应该是：192.168.202.131\n根据题目要求，flag应该是：\nCTF{WIN-LO6FAF3DTFE} CTF{192.168.202.131} Play Time 查看题目描述：\nRick just loves to play some good old videogames. can you tell which game is he playing? whats the IP address of the server? 玩游戏肯定会有进程的存储在内存中，扫描下进程情况，使用如下指令进行查看：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 psscan 得到如下信息：\n可以发现到了一个不熟悉的进程，猜测这个进程是游戏进程，也就是游戏名称是LunarMS.exe\n再使用netscan查看下网络通信信息：\n可以发现一个ip地址，应该是游戏下载的ip地址，可以得到flag：\nCTF{LunarMS.exe} CTF{77.102.199.102} Name Game 查看题目描述：\nWe know that the account was logged in to a channel called Lunar-3. what is the account name? 应该需要找到游戏的用户名，应该存储在游戏的内存中，尝试将游戏进程进行dump来获取到游戏进程的内存信息\nvol程序进行内存dump的指令如下：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 708 -D ./ 说明\nmemdump 内存dump的命令 -p 708 指定PID号708的进程 -D ./ 指定内存dump进程文件存储位置 运行指令得到：\n尝试检索dump出来的文件的字符串，使用如下命令：\nstrings 708.dmp | grep Lunar-3 说明\nstrings 708.dmp 打印出708.dmp二进制文件中的可打印字符 | 管道符，可以将左边命令输出的数据传递右边的命令处理 grep Lunar-3 检索有Lunar字符串所在的行并打印 运行命令得到：\n发现是存在相关字符串内容，增加点参数来获得字符串的上下文内容，执行如下命令：\nstrings 708.dmp | grep Lunar-3 -A 3 -B 3 说明\n-A 3 检索字符串所在行的前3行 -B 3 检索字符串所在行的后3行 执行命令得到：\n发现存在可疑字符串：0tt3r8r33z3\n感觉这个字符串应该就是用户名，尝试提交成功\n故flag是：\nCTF{0tt3r8r33z3} Name Game 2 查看题目描述：\nFrom a little research we found that the username of the logged on character is always after this signature: 0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2} What's rick's character's name? 这道题目应该寻找相关的字符，需要进行模糊搜索\n这道题目有两种解题方法：\n使用Linux的hexdump和grep命令来进行联合检索 使用Hexedit类工具进行逐一寻找来确定相应位置 Method 1 使用如下Linux命令：\nhexdump -C 708.dmp | grep \"64\" -A 5 -B 5 | grep \"40 06\" -A 5 -B 5 | grep \"5a 0c 00 00\" -A 5 -B 5 执行命令获得：\n由于dump文件比较大，因此，这个命令可能需要执行4-5min才能执行出来结果，运行命令比较简单，但是运行时间相对比较长。\n运行得到的字符串就是M0rtyL0L\n故此题的flag就是CTF{M0rtyL0L}\nMethod 2 使用WinHex之类的工具进行查看搜索5a0c0000\n进行Hex value的搜索，依次对搜索列表进行比对和寻找：\n最后找到目标位置：\n这种方式要进行查找比对，查找速度快的话是比Linux命令要快些，但是就是需要不断的人工比对和查看\n得到字符串M0rtyL0L\n故此题的flag就是CTF{M0rtyL0L}\n这两种解题方法各有利弊，可以根据个人的喜好选择求解，个人更倾向于Linux那种解法，输入完命令就可以喝杯茶慢慢等，一会儿结果就出来了\nSilly Rick 查看题目描述\nSilly rick always forgets his email's password, so he uses a Stored Password Services online to store his password. He always copy and paste the password so he will not get it wrong. whats rick's email password? 根据题目描述，可以确定的关键语句copy and paste，说明邮箱地址应该是存储在粘贴板上面，可以查看下内存的粘贴板。\n使用vol的如下指令查看粘贴板信息：\n可以发现的粘贴板信息：M@il_Pr0vid0rs\n故此题的flag就是：\nCTF{M@il_Pr0vid0rs} Hide And Seek 查看题目描述\nThe reason that we took rick's PC memory dump is because there was a malware infection. Please find the malware process name (including the extension) 根据题目描述，应该是需要寻找下恶意软件进程名称，vol这个软件功能非常强大，可以直接使用malfind的参数进行扫描，使用如下指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 malfind | grep Process 得到恶意进程信息：\n可以简单的归纳下恶意进程的信息：\nName Pid WmiPrvSE.exe 2136 explorer.exe 2728 BitTorrent.exe 2836 PresentationFo 724 mscorsvw.exe 412 mscorsvw.exe 3124 svchost.exe 3196 chrome.exe 4076 vmware-tray.ex 3720 WebCompanionIn 3880 Lavasoft.WCAss 3496 WebCompanion.e 3856 这些是可能的恶意进程，需要找到题目要求的恶意进程，看看进程的cmd指令，使用如下指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 cmdline 得到：\n可以看到有一个进程是在Temp目录下进行执行，这个进程应该就是恶意进程了，一般恶意进程会在Temp目录中运行。\n故恶意进程就是vmware-tray.exe\n故此题的flag就是CTF{vmware-tray.exe}\nPath To Glory 查看题目描述：\nHow did the malware got to rick's PC? It must be one of rick old illegal habits... 应该是要寻找的Rick的不良习惯，进行文件扫描来尝试确定可疑的文件\n文件扫描使用filescan指令，由于是要寻找Rick的文件需要进行简单过滤下，使用如下命令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i \"Rick\" 说明\ngrep -i \"Rick\" 忽略大小写检索Rick 得到：\n发现一个torrent文件，可以猜测Rick应该平时会进行torrent种子文件的下载，而且这个种子文件的位置一般是在Rick And Morty文件夹下面。因此，进一步过滤查看相关信息，使用如下指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i \"Rick And Morty\" 得到：\n发现有一个文件的权限比较可疑，尝试将这个文件进行dump，来查看文件具体信息\n使用如下命令进行dump：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007dae9350 -D ./ 说明\ndumpfiles dump文件指令 -Q 0x000000007dae9350 以物理偏移为0x000000007dae9350的文件作为对象 -D ./ dump文件目录在./目录下 得到：\n查看下dump文件中的可打印字符串数据\n执行如下命令：\nstrings file.None.0xfffffa801b42c9e0.dat 得到可打印字符串信息：\n故此题的flag应该是藏在e7:website19:M3an_T0rren7_4_R!cke这段字符串中，对这段字符串仔细观察，可以发现这段字符串是有一些明显特征的\n可以发现e是作为开头结尾的引用，中间的数据就是7:website19:M3an_T0rren7_4_R!ck，应该是三个对象显然最后一个对象应该是就是flag\n故此题的flag就是CTF{M3an_T0rren7_4_R!ck}\nPath To Glory 2 查看题目描述：\nContinue the search after the way that malware got in. 需要继续寻找关于恶意软件的信息，要往深入探索应该需要探索浏览器的相关信息，由于Rick被恶意攻击是由于Rick在浏览器上下载种子文件\n把浏览器的进程内存dump出来查看关键的信息\n使用如下指令来dump相关信息：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -n chrome -D ./f/ 说明\nmemdump dump内存命令 -n chrome 以进程名称作为内存对象 -D ./f/ dump内存文件./f/目录 使用strings命令来获取内存文件的可打印字符串，并添加download.exe.torrent作为过滤，由于恶意文件名是download.exe.torrent，因此采用这种方式进行过滤\n使用如下指令：\nstrings ./f/* | grep \"download\\.exe\\.torrent\" -A 10 -B 10 得到：\n这串字符看样子是挺奇怪的，应该就是flag信息\n尝试发现真正的flag数据是Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@in\n故此题的flag是CTF{Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@in}\nBit 4 Bit 查看题目描述：\nWe've found out that the malware is a ransomware. Find the attacker's bitcoin address. 恶意软件是一个勒索软件，需要将那个恶意软件进行分析\n首先需要dump出恶意软件的进程，使用procdump将进程dump作为一个可执行程序\n使用如下命令进行dump：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 procdump -p 3720 -D ./ 说明\nprocdump dump进程作为一个可执行文件 -p 3720 以PID作为进程对象 -D ./ 将可执行文件存储在./目录 得到：\n需要对文件进行分析，首先查看软件的相关信息：\n发现恶意软件是一个.NET的文件，可以使用dnSpy进行查看，拖进dnSpy进行寻找发现：\n一个GUI绘制流，根据GUI的代码信息，使用PS绘制出GUI：\n比特币地址显而易见就是：1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M\n故此题的flag就是CTF{1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M}\nGraphic’s For The Weak 查看题目描述：\nThere's something fishy in the malware's graphics. 使用dnSpy加载恶意软件，可以在资源目录中找到：\n故本题的flag就是CTF{S0_Just_M0v3_Socy}\nRecovery 查看题目描述：\nRick got to have his files recovered! What is the random password used to encrypt the files? 对恶意软件进行审计，找到关键的密码发送函数：\n发现密码是根据计算机名称和用户名以及密码一起发送的，要dump恶意软件的内存信息，使用如下指令进行dump：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 3720 -D ./ 执行命令得到：\n使用strings命令进行检索，由于程序的数据是16字节小端序数据，.NET程序的用2字节表示一个字符串，所以是16字节小端序数据，因此使用如下命令进行过滤检索：\nstrings -el 3720.dmp | grep WIN-LO6FAF3DTFE-Rick 运行得到：\n故此，密码就是aDOBofVYUNVnmp7\n故此题的flag就是CTF{aDOBofVYUNVnmp7}\nClosure 查看题目描述：\nNow that you extracted the password from the memory, could you decrypt rick's files? 要找文件并且解密文件。猜测存在一个flag文件，使用如下指令进行文件扫描：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i \"flag\" 运行命令得到：\n应该是桌面上的Flag.txt文件\n将文件进行dump，使用如下命令进行文件dump：\nol.py -f OtterCTF.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007e410890 -D ./ 运行得到：\n下面就需要对文件进行解密了\n首先对dnSpy反编译的代码进行审计可以看到是：\nhidden tear的程序算法\n继续进行分析，可以发现一个AES的加密算法：\n进行跟进分析可以发现一个加密文件的函数：\n对这两个关键函数进行代码审计发现，核心的加密算法还是AES的算法\n根据目前的分析情况，如果要解密这个文件主要有两种思路\n根据加密算法写解密脚本进行解密 使用HiddenTearDecrypt工具进行解密 HiddenTearDecrypt工具解密 由于在文件中发现了HiddenTear的关键信息，可以直接去检索HiddenTearDecrypt:\nHiddenTearDecrypt工具在网络上都是可以进行下载的\n尝试使用工具进行解密发现不能成功求解。由于加密代码是采用CBC模式进行加密，会对文件进行填充，只要删除掉文件的填充应该就可以正常解密，使用winhex打开文件：\n可以发现有很多00字节的填充，只要删除00字节的填充就可以进行正常的解密，使用工具进行解密\n解密成功，打开文件得到flag：\nCTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll} 解密脚本解密 由于加密代码已经进行分析，对于加密的情况已经基本清晰\nPython编写解密脚本的难点应该是在于生成器的替代，CS中的Rfc2898DeriveBytes可以使用Python中的PBKDF2进行替代\n解密脚本主要难度其实已经克服，根据加密写解密脚本：\nfrom Crypto.Protocol.KDF import PBKDF2 from Crypto.Cipher import AES from hashlib import sha256 def AES_Decrypt(c,password): salt = bytes([1, 2, 3, 4, 5, 6, 7, 8]) kdf = PBKDF2(password, salt, 48, count = 1000) key = kdf[:32] iv = kdf[32:] aes = AES.new(key=key,iv=iv,mode=AES.MODE_CBC) m = aes.decrypt(c) return m password = b\"aDOBofVYUNVnmp7\" p = sha256(password).digest() with open(\"./file.dat\",\"rb\") as f: data = f.read() raw = AES_Decrypt(data,p) with open(\"./file.txt\",\"wb\") as new: new.write(raw) 运行后得到解密文件，打开文件得到flag：\nCTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll} 两种解法都可以正常进行求解，求解得到flag。\n用工具求解可能比较快，但是存在一定的局限性，需要对加密文件进行一定的处理\n用脚本求解可能相对较慢，但是比较灵活可以灵活地处理文件，对解密脚本编写熟练的，可以尝试写脚本求解，速度也不慢\n","wordCount":"785","inLanguage":"en","datePublished":"2022-10-04T23:18:37+08:00","dateModified":"2022-10-04T23:18:37+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/otterctf_2018_memory_forensic_writeup/"},"publisher":{"@type":"Organization","name":"Jasmine❀Hiker","logo":{"@type":"ImageObject","url":"favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li><li><a href=/posts/ title=Posts><span>Posts</span></a></li><li><a href=/about/ title=About><span>About</span></a></li><li><a href=/link/ title=Link><span>Link</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>OtterCTF 2018 内存取证复现</h1><div class=post-meta><span title='2022-10-04 23:18:37 +0800 CST'>October 4, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;785 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#otterctf-2018-memory-forensic-reappearance aria-label="OtterCTF 2018 Memory Forensic Reappearance">OtterCTF 2018 Memory Forensic Reappearance</a><ul><li><a href=#info aria-label=Info>Info</a></li><li><a href=#what-the-password aria-label="What the password?">What the password?</a></li><li><a href=#general-info aria-label="General Info">General Info</a></li><li><a href=#play-time aria-label="Play Time">Play Time</a></li><li><a href=#name-game aria-label="Name Game">Name Game</a></li><li><a href=#name-game-2 aria-label="Name Game 2">Name Game 2</a><ul><li><a href=#method-1 aria-label="Method 1">Method 1</a></li><li><a href=#method-2 aria-label="Method 2">Method 2</a></li></ul></li><li><a href=#silly-rick aria-label="Silly Rick">Silly Rick</a></li><li><a href=#hide-and-seek aria-label="Hide And Seek">Hide And Seek</a></li><li><a href=#path-to-glory aria-label="Path To Glory">Path To Glory</a></li><li><a href=#path-to-glory-2 aria-label="Path To Glory 2">Path To Glory 2</a></li><li><a href=#bit-4-bit aria-label="Bit 4 Bit">Bit 4 Bit</a></li><li><a href=#graphics-for-the-weak aria-label="Graphic’s For The Weak">Graphic’s For The Weak</a></li><li><a href=#recovery aria-label=Recovery>Recovery</a></li><li><a href=#closure aria-label=Closure>Closure</a><ul><li><a href=#hiddenteardecrypt%e5%b7%a5%e5%85%b7%e8%a7%a3%e5%af%86 aria-label=HiddenTearDecrypt工具解密>HiddenTearDecrypt工具解密</a></li><li><a href=#%e8%a7%a3%e5%af%86%e8%84%9a%e6%9c%ac%e8%a7%a3%e5%af%86 aria-label=解密脚本解密>解密脚本解密</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=otterctf-2018-memory-forensic-reappearance>OtterCTF 2018 Memory Forensic Reappearance<a hidden class=anchor aria-hidden=true href=#otterctf-2018-memory-forensic-reappearance>#</a></h1><p>想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。
Volatility项目地址：<a href=https://github.com/volatilityfoundation/volatility>https://github.com/volatilityfoundation/volatility</a>
Volatility3项目地址：<a href=https://github.com/volatilityfoundation/volatility3>https://github.com/volatilityfoundation/volatility3</a></p><p>环境配置：Kali Linux 2022
工具配置：volatility + mimikatz</p><h2 id=info>Info<a hidden class=anchor aria-hidden=true href=#info>#</a></h2><p>题目附件就一个镜像，先查看下镜像的指纹数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872  OtterCTF.vmem
</span></span></code></pre></div><p>使用vol简单查看下镜像信息数据，查看数据的指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem imageinfo
</span></span></code></pre></div><blockquote><p><strong>说明</strong></p><ul><li><code>vol.py</code> volatility程序</li><li><code>-f OtterCTF.vmem</code> 加载<code>OtterCTF.vmem</code>内存镜像文件</li><li><code>imageinfo</code> 查看内存镜像的基本信息</li></ul></blockquote><p>得到如下信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221002204848160.png alt=image-20221002204848160></p><p>可以看到大致的镜像系统是Win7系统</p><h2 id=what-the-password>What the password?<a hidden class=anchor aria-hidden=true href=#what-the-password>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>you got a sample of rick&#39;s PC&#39;s memory. can you get his user password?
</span></span></code></pre></div><p>要得到用户名的密码，先获取到hash数据，使用获取hash的指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 hashdump  
</span></span></code></pre></div><blockquote><ul><li><code>--profile=Win7SP1x64</code> 设置配置为<code>Win7SP1x64</code>配置</li><li><code>hashdump</code> 从内存中dump出密码的hash信息</li></ul></blockquote><p>得到hash信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221002212051508.png alt=image-20221002212051508></p><p>对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取</p><p>使用如下指令使用mimikatz插件进行获取：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 mimikatz
</span></span></code></pre></div><p>得到如下信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221002214545148.png alt=image-20221002214545148></p><p>已经获取到了密码信息，提交flag，攻破此题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>CTF{MortyIsReallyAnOtter}
</span></span></code></pre></div><h2 id=general-info>General Info<a hidden class=anchor aria-hidden=true href=#general-info>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Let&#39;s start easy - whats the PC&#39;s name and IP address?
</span></span></code></pre></div><p>需要获取PC’s name和IP， PC的名字已经很明确了，应该就是刚刚获取密码信息得到的<code>WIN-LO6FAF3DTFE</code></p><p>下面需要获取的应该就是IP地址，使用网络扫描指令应该可以获取到相应的信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003001348636.png alt=image-20221003001348636></p><p>可以看出IP地址应该是：<code>192.168.202.131</code></p><p>根据题目要求，flag应该是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>CTF{WIN-LO6FAF3DTFE}
</span></span><span class=line><span class=cl>CTF{192.168.202.131}
</span></span></code></pre></div><h2 id=play-time>Play Time<a hidden class=anchor aria-hidden=true href=#play-time>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Rick just loves to play some good old videogames.
</span></span><span class=line><span class=cl>can you tell which game is he playing?
</span></span><span class=line><span class=cl>whats the IP address of the server?
</span></span></code></pre></div><p>玩游戏肯定会有进程的存储在内存中，扫描下进程情况，使用如下指令进行查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 psscan
</span></span></code></pre></div><p>得到如下信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003002817020.png alt=image-20221003002817020></p><p>可以发现到了一个不熟悉的进程，猜测这个进程是游戏进程，也就是游戏名称是<code>LunarMS.exe</code></p><p>再使用<code>netscan</code>查看下网络通信信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003003940157.png alt=image-20221003003940157></p><p>可以发现一个ip地址，应该是游戏下载的ip地址，可以得到flag：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>CTF{LunarMS.exe}
</span></span><span class=line><span class=cl>CTF{77.102.199.102}
</span></span></code></pre></div><h2 id=name-game>Name Game<a hidden class=anchor aria-hidden=true href=#name-game>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>We know that the account was logged in to a channel called Lunar-3. what is the account name?
</span></span></code></pre></div><p>应该需要找到游戏的用户名，应该存储在游戏的内存中，尝试将游戏进程进行dump来获取到游戏进程的内存信息</p><p>vol程序进行内存dump的指令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 memdump -p <span class=m>708</span> -D ./
</span></span></code></pre></div><blockquote><p><strong>说明</strong></p><ul><li><code>memdump</code> 内存dump的命令</li><li><code>-p 708</code> 指定PID号708的进程</li><li><code>-D ./</code> 指定内存dump进程文件存储位置</li></ul></blockquote><p>运行指令得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003014902581.png alt=image-20221003014902581></p><p>尝试检索dump出来的文件的字符串，使用如下命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>strings 708.dmp <span class=p>|</span> grep Lunar-3
</span></span></code></pre></div><blockquote><p><strong>说明</strong></p><ul><li><code>strings 708.dmp</code> 打印出<code>708.dmp</code>二进制文件中的可打印字符</li><li><code>|</code> 管道符，可以将左边命令输出的数据传递右边的命令处理</li><li><code>grep Lunar-3</code> 检索有<code>Lunar</code>字符串所在的行并打印</li></ul></blockquote><p>运行命令得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003015212113.png alt=image-20221003015212113></p><p>发现是存在相关字符串内容，增加点参数来获得字符串的上下文内容，执行如下命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>strings 708.dmp <span class=p>|</span> grep Lunar-3 -A <span class=m>3</span> -B <span class=m>3</span>
</span></span></code></pre></div><blockquote><p><strong>说明</strong></p><ul><li><code>-A 3</code> 检索字符串所在行的前3行</li><li><code>-B 3</code> 检索字符串所在行的后3行</li></ul></blockquote><p>执行命令得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003020425640.png alt=image-20221003020425640></p><p>发现存在可疑字符串：<code>0tt3r8r33z3</code></p><p>感觉这个字符串应该就是用户名，尝试提交成功</p><p>故flag是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>CTF{0tt3r8r33z3}
</span></span></code></pre></div><h2 id=name-game-2>Name Game 2<a hidden class=anchor aria-hidden=true href=#name-game-2>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>From a little research we found that the username of the logged on character is always after this signature: 0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2}
</span></span><span class=line><span class=cl>What&#39;s rick&#39;s character&#39;s name?
</span></span></code></pre></div><p>这道题目应该寻找相关的字符，需要进行模糊搜索</p><p>这道题目有两种解题方法：</p><ol><li>使用Linux的<code>hexdump</code>和<code>grep</code>命令来进行联合检索</li><li>使用Hexedit类工具进行逐一寻找来确定相应位置</li></ol><h3 id=method-1>Method 1<a hidden class=anchor aria-hidden=true href=#method-1>#</a></h3><p>使用如下Linux命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hexdump -C 708.dmp <span class=p>|</span> grep <span class=s2>&#34;64&#34;</span> -A <span class=m>5</span> -B <span class=m>5</span> <span class=p>|</span> grep <span class=s2>&#34;40 06&#34;</span> -A <span class=m>5</span> -B <span class=m>5</span> <span class=p>|</span> grep <span class=s2>&#34;5a 0c 00 00&#34;</span> -A <span class=m>5</span> -B <span class=m>5</span>
</span></span></code></pre></div><p>执行命令获得：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003113309491.png alt=image-20221003113309491></p><p>由于dump文件比较大，因此，这个命令可能需要执行4-5min才能执行出来结果，运行命令比较简单，但是运行时间相对比较长。</p><p>运行得到的字符串就是<code>M0rtyL0L</code></p><p>故此题的flag就是<code>CTF{M0rtyL0L}</code></p><h3 id=method-2>Method 2<a hidden class=anchor aria-hidden=true href=#method-2>#</a></h3><p>使用WinHex之类的工具进行查看搜索<code>5a0c0000</code></p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003115058149.png alt=image-20221003115058149></p><p>进行Hex value的搜索，依次对搜索列表进行比对和寻找：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003115148926.png alt=image-20221003115148926></p><p>最后找到目标位置：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003115217012.png alt=image-20221003115217012></p><p>这种方式要进行查找比对，查找速度快的话是比Linux命令要快些，但是就是需要不断的人工比对和查看</p><p>得到字符串<code>M0rtyL0L</code></p><p>故此题的flag就是<code>CTF{M0rtyL0L}</code></p><p>这两种解题方法各有利弊，可以根据个人的喜好选择求解，个人更倾向于Linux那种解法，输入完命令就可以喝杯茶慢慢等，一会儿结果就出来了</p><h2 id=silly-rick>Silly Rick<a hidden class=anchor aria-hidden=true href=#silly-rick>#</a></h2><p>查看题目描述</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Silly rick always forgets his email&#39;s password, so he uses a Stored Password Services online to store his password. He always copy and paste the password so he will not get it wrong. whats rick&#39;s email password?
</span></span></code></pre></div><p>根据题目描述，可以确定的关键语句<code>copy and paste</code>，说明邮箱地址应该是存储在粘贴板上面，可以查看下内存的粘贴板。</p><p>使用vol的如下指令查看粘贴板信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003131135095.png alt=image-20221003131135095></p><p>可以发现的粘贴板信息：<code>M@il_Pr0vid0rs</code></p><p>故此题的flag就是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>CTF{M@il_Pr0vid0rs}
</span></span></code></pre></div><h2 id=hide-and-seek>Hide And Seek<a hidden class=anchor aria-hidden=true href=#hide-and-seek>#</a></h2><p>查看题目描述</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>The reason that we took rick&#39;s PC memory dump is because there was a malware infection. Please find the malware process name (including the extension)
</span></span></code></pre></div><p>根据题目描述，应该是需要寻找下恶意软件进程名称，vol这个软件功能非常强大，可以直接使用<code>malfind</code>的参数进行扫描，使用如下指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 malfind <span class=p>|</span> grep Process
</span></span></code></pre></div><p>得到恶意进程信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003180849409.png alt=image-20221003180849409></p><p>可以简单的归纳下恶意进程的信息：</p><table><thead><tr><th>Name</th><th>Pid</th></tr></thead><tbody><tr><td><code>WmiPrvSE.exe</code></td><td>2136</td></tr><tr><td><code>explorer.exe</code></td><td>2728</td></tr><tr><td><code>BitTorrent.exe</code></td><td>2836</td></tr><tr><td><code>PresentationFo</code></td><td>724</td></tr><tr><td><code>mscorsvw.exe</code></td><td>412</td></tr><tr><td><code>mscorsvw.exe</code></td><td>3124</td></tr><tr><td><code>svchost.exe</code></td><td>3196</td></tr><tr><td><code>chrome.exe</code></td><td>4076</td></tr><tr><td><code>vmware-tray.ex</code></td><td>3720</td></tr><tr><td><code>WebCompanionIn</code></td><td>3880</td></tr><tr><td><code>Lavasoft.WCAss</code></td><td>3496</td></tr><tr><td><code>WebCompanion.e</code></td><td>3856</td></tr></tbody></table><p>这些是可能的恶意进程，需要找到题目要求的恶意进程，看看进程的cmd指令，使用如下指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 cmdline
</span></span></code></pre></div><p>得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004150006413.png alt=image-20221004150006413></p><p>可以看到有一个进程是在Temp目录下进行执行，这个进程应该就是恶意进程了，一般恶意进程会在Temp目录中运行。</p><p>故恶意进程就是<code>vmware-tray.exe</code></p><p>故此题的flag就是<code>CTF{vmware-tray.exe}</code></p><h2 id=path-to-glory>Path To Glory<a hidden class=anchor aria-hidden=true href=#path-to-glory>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>How did the malware got to rick&#39;s PC? It must be one of rick old illegal habits...
</span></span></code></pre></div><p>应该是要寻找的Rick的不良习惯，进行文件扫描来尝试确定可疑的文件</p><p>文件扫描使用<code>filescan</code>指令，由于是要寻找Rick的文件需要进行简单过滤下，使用如下命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 filescan <span class=p>|</span> grep -i <span class=s2>&#34;Rick&#34;</span>
</span></span></code></pre></div><blockquote><p><strong>说明</strong></p><ul><li><code>grep -i "Rick"</code> 忽略大小写检索<code>Rick</code></li></ul></blockquote><p>得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004163351355.png alt=image-20221004163351355></p><p>发现一个torrent文件，可以猜测Rick应该平时会进行torrent种子文件的下载，而且这个种子文件的位置一般是在<code>Rick And Morty</code>文件夹下面。因此，进一步过滤查看相关信息，使用如下指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 filescan <span class=p>|</span> grep -i <span class=s2>&#34;Rick And Morty&#34;</span>
</span></span></code></pre></div><p>得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004164710378.png alt=image-20221004164710378></p><p>发现有一个文件的权限比较可疑，尝试将这个文件进行dump，来查看文件具体信息</p><p>使用如下命令进行dump：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 dumpfiles -Q 0x000000007dae9350 -D ./
</span></span></code></pre></div><blockquote><p><strong>说明</strong></p><ul><li><code>dumpfiles</code> dump文件指令</li><li><code>-Q 0x000000007dae9350</code> 以物理偏移为<code>0x000000007dae9350</code>的文件作为对象</li><li><code>-D ./</code> dump文件目录在<code>./</code>目录下</li></ul></blockquote><p>得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004170421613.png alt=image-20221004170421613></p><p>查看下dump文件中的可打印字符串数据</p><p>执行如下命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>strings file.None.0xfffffa801b42c9e0.dat
</span></span></code></pre></div><p>得到可打印字符串信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004170725684.png alt=image-20221004170725684></p><p>故此题的flag应该是藏在<code>e7:website19:M3an_T0rren7_4_R!cke</code>这段字符串中，对这段字符串仔细观察，可以发现这段字符串是有一些明显特征的</p><p>可以发现<code>e</code>是作为开头结尾的引用，中间的数据就是<code>7:website19:M3an_T0rren7_4_R!ck</code>，应该是三个对象显然最后一个对象应该是就是flag</p><p>故此题的flag就是<code>CTF{M3an_T0rren7_4_R!ck}</code></p><h2 id=path-to-glory-2>Path To Glory 2<a hidden class=anchor aria-hidden=true href=#path-to-glory-2>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Continue the search after the way that malware got in.
</span></span></code></pre></div><p>需要继续寻找关于恶意软件的信息，要往深入探索应该需要探索浏览器的相关信息，由于Rick被恶意攻击是由于Rick在浏览器上下载种子文件</p><p>把浏览器的进程内存dump出来查看关键的信息</p><p>使用如下指令来dump相关信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 memdump -n chrome -D ./f/
</span></span></code></pre></div><blockquote><p><strong>说明</strong></p><ul><li><code>memdump</code> dump内存命令</li><li><code>-n chrome</code> 以进程名称作为内存对象</li><li><code>-D ./f/</code> dump内存文件<code>./f/</code>目录</li></ul></blockquote><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004201432915.png alt=image-20221004201432915></p><p>使用<code>strings</code>命令来获取内存文件的可打印字符串，并添加<code>download.exe.torrent</code>作为过滤，由于恶意文件名是<code>download.exe.torrent</code>，因此采用这种方式进行过滤</p><p>使用如下指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>strings ./f/* <span class=p>|</span> grep <span class=s2>&#34;download\.exe\.torrent&#34;</span> -A <span class=m>10</span> -B <span class=m>10</span>
</span></span></code></pre></div><p>得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004204205771.png alt=image-20221004204205771></p><p>这串字符看样子是挺奇怪的，应该就是flag信息</p><p>尝试发现真正的flag数据是<code>Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@in</code></p><p>故此题的flag是<code>CTF{Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@in}</code></p><h2 id=bit-4-bit>Bit 4 Bit<a hidden class=anchor aria-hidden=true href=#bit-4-bit>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>We&#39;ve found out that the malware is a ransomware. Find the attacker&#39;s bitcoin address.
</span></span></code></pre></div><p>恶意软件是一个勒索软件，需要将那个恶意软件进行分析</p><p>首先需要dump出恶意软件的进程，使用<code>procdump</code>将进程dump作为一个可执行程序</p><p>使用如下命令进行dump：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 procdump -p 3720 -D ./
</span></span></code></pre></div><blockquote><p><strong>说明</strong></p><ul><li><code>procdump</code> dump进程作为一个可执行文件</li><li><code>-p 3720</code> 以PID作为进程对象</li><li><code>-D ./</code> 将可执行文件存储在<code>./</code>目录</li></ul></blockquote><p>得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004210324575.png alt=image-20221004210324575></p><p>需要对文件进行分析，首先查看软件的相关信息：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004210448989.png alt=image-20221004210448989></p><p>发现恶意软件是一个.NET的文件，可以使用dnSpy进行查看，拖进dnSpy进行寻找发现：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004210559036.png alt=image-20221004210559036></p><p>一个GUI绘制流，根据GUI的代码信息，使用PS绘制出GUI：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004211105657.png alt=image-20221004211105657></p><p>比特币地址显而易见就是：<code>1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M</code></p><p>故此题的flag就是<code>CTF{1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M}</code></p><h2 id=graphics-for-the-weak>Graphic’s For The Weak<a hidden class=anchor aria-hidden=true href=#graphics-for-the-weak>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>There&#39;s something fishy in the malware&#39;s graphics.
</span></span></code></pre></div><p>使用dnSpy加载恶意软件，可以在资源目录中找到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004212217979.png alt=image-20221004212217979></p><p>故本题的flag就是<code>CTF{S0_Just_M0v3_Socy}</code></p><h2 id=recovery>Recovery<a hidden class=anchor aria-hidden=true href=#recovery>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Rick got to have his files recovered! What is the random password used to encrypt the files?
</span></span></code></pre></div><p>对恶意软件进行审计，找到关键的密码发送函数：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004214117780.png alt=image-20221004214117780></p><p>发现密码是根据计算机名称和用户名以及密码一起发送的，要dump恶意软件的内存信息，使用如下指令进行dump：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 memdump -p <span class=m>3720</span> -D ./
</span></span></code></pre></div><p>执行命令得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004214626524.png alt=image-20221004214626524></p><p>使用<code>strings</code>命令进行检索，由于程序的数据是16字节小端序数据，.NET程序的用2字节表示一个字符串，所以是16字节小端序数据，因此使用如下命令进行过滤检索：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>strings -el 3720.dmp <span class=p>|</span> grep WIN-LO6FAF3DTFE-Rick
</span></span></code></pre></div><p>运行得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004215044513.png alt=image-20221004215044513></p><p>故此，密码就是<code>aDOBofVYUNVnmp7</code></p><p>故此题的flag就是<code>CTF{aDOBofVYUNVnmp7}</code></p><h2 id=closure>Closure<a hidden class=anchor aria-hidden=true href=#closure>#</a></h2><p>查看题目描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Now that you extracted the password from the memory, could you decrypt rick&#39;s files?
</span></span></code></pre></div><p>要找文件并且解密文件。猜测存在一个flag文件，使用如下指令进行文件扫描：</p><pre tabindex=0><code>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i &#34;flag&#34;
</code></pre><p>运行命令得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004215615853.png alt=image-20221004215615853></p><p>应该是桌面上的<code>Flag.txt</code>文件</p><p>将文件进行dump，使用如下命令进行文件dump：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ol.py -f OtterCTF.vmem --profile<span class=o>=</span>Win7SP1x64 dumpfiles -Q 0x000000007e410890 -D ./
</span></span></code></pre></div><p>运行得到：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004220208957.png alt=image-20221004220208957></p><p>下面就需要对文件进行解密了</p><p>首先对dnSpy反编译的代码进行审计可以看到是：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004225734265.png alt=image-20221004225734265></p><p>hidden tear的程序算法</p><p>继续进行分析，可以发现一个AES的加密算法：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230040181.png alt=image-20221004230040181></p><p>进行跟进分析可以发现一个加密文件的函数：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230149524.png alt=image-20221004230149524></p><p>对这两个关键函数进行代码审计发现，核心的加密算法还是AES的算法</p><p>根据目前的分析情况，如果要解密这个文件主要有两种思路</p><ul><li>根据加密算法写解密脚本进行解密</li><li>使用HiddenTearDecrypt工具进行解密</li></ul><h3 id=hiddenteardecrypt工具解密>HiddenTearDecrypt工具解密<a hidden class=anchor aria-hidden=true href=#hiddenteardecrypt工具解密>#</a></h3><p>由于在文件中发现了HiddenTear的关键信息，可以直接去检索HiddenTearDecrypt:</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230418792.png alt=image-20221004230418792></p><p>HiddenTearDecrypt工具在网络上都是可以进行下载的</p><p>尝试使用工具进行解密发现不能成功求解。由于加密代码是采用CBC模式进行加密，会对文件进行填充，只要删除掉文件的填充应该就可以正常解密，使用winhex打开文件：</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230652451.png alt=image-20221004230652451></p><p>可以发现有很多<code>00</code>字节的填充，只要删除<code>00</code>字节的填充就可以进行正常的解密，使用工具进行解密</p><p><img loading=lazy src=/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230849821.png alt=image-20221004230849821></p><p>解密成功，打开文件得到flag：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>CTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll}
</span></span></code></pre></div><h3 id=解密脚本解密>解密脚本解密<a hidden class=anchor aria-hidden=true href=#解密脚本解密>#</a></h3><p>由于加密代码已经进行分析，对于加密的情况已经基本清晰</p><p>Python编写解密脚本的难点应该是在于生成器的替代，CS中的<code>Rfc2898DeriveBytes</code>可以使用Python中的<code>PBKDF2</code>进行替代</p><p>解密脚本主要难度其实已经克服，根据加密写解密脚本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>Crypto.Protocol.KDF</span> <span class=kn>import</span> <span class=n>PBKDF2</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>Crypto.Cipher</span> <span class=kn>import</span> <span class=n>AES</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>hashlib</span> <span class=kn>import</span> <span class=n>sha256</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>AES_Decrypt</span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=n>password</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>salt</span> <span class=o>=</span> <span class=nb>bytes</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>kdf</span> <span class=o>=</span> <span class=n>PBKDF2</span><span class=p>(</span><span class=n>password</span><span class=p>,</span> <span class=n>salt</span><span class=p>,</span> <span class=mi>48</span><span class=p>,</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>key</span> <span class=o>=</span> <span class=n>kdf</span><span class=p>[:</span><span class=mi>32</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>iv</span> <span class=o>=</span> <span class=n>kdf</span><span class=p>[</span><span class=mi>32</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=n>aes</span> <span class=o>=</span> <span class=n>AES</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=n>key</span><span class=p>,</span><span class=n>iv</span><span class=o>=</span><span class=n>iv</span><span class=p>,</span><span class=n>mode</span><span class=o>=</span><span class=n>AES</span><span class=o>.</span><span class=n>MODE_CBC</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span> <span class=o>=</span> <span class=n>aes</span><span class=o>.</span><span class=n>decrypt</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>password</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;aDOBofVYUNVnmp7&#34;</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>sha256</span><span class=p>(</span><span class=n>password</span><span class=p>)</span><span class=o>.</span><span class=n>digest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;./file.dat&#34;</span><span class=p>,</span><span class=s2>&#34;rb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>raw</span> <span class=o>=</span> <span class=n>AES_Decrypt</span><span class=p>(</span><span class=n>data</span><span class=p>,</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;./file.txt&#34;</span><span class=p>,</span><span class=s2>&#34;wb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>new</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>new</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>raw</span><span class=p>)</span>
</span></span></code></pre></div><p>运行后得到解密文件，打开文件得到flag：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>CTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll}
</span></span></code></pre></div><p>两种解法都可以正常进行求解，求解得到flag。</p><p>用工具求解可能比较快，但是存在一定的局限性，需要对加密文件进行一定的处理</p><p>用脚本求解可能相对较慢，但是比较灵活可以灵活地处理文件，对解密脚本编写熟练的，可以尝试写脚本求解，速度也不慢</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/ctf/>ctf</a></li><li><a href=/tags/forensics/>Forensics</a></li><li><a href=/tags/writeup/>writeup</a></li></ul><nav class=paginav><a class=next href=/posts/xctf-reverse_daliy_002/><span class=title>Next »</span><br><span>攻防世界 RE 日常练习 002</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Jasmine❀Hiker</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
</script><script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script></body></html>