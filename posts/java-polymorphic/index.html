<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java面向对象之多态 笔记 | Jasmine❀Hiker</title><meta name=keywords content="java,note"><meta name=description content="Java面向对象之多态 方法重写 子类和父类同名方法 子类和父类同名方法，方法重写
前提：需要有继承关系
方法重写表现：
方法名必须相同
参数列表必须相同
返回值类型必须相同
修饰符：范围可以扩大或相同，但是不能缩小 public > protected >default
方法重写
public class Animal { public void eat() { System.out.println(&#34;动物去吃东西&#34;); } } public class Cat extends Animal { public void eat() { System.out.println(&#34;猫喜欢吃鱼&#34;); } } public class Dog { public void eat() { System.out.println(&#34;狗喜欢吃骨头&#34;); } } 不能重写父类的private方法，如果定义的话只是定义了一个新方法，不是方法重写
运行时多态 后期绑定
如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也被称之为后期绑定
运行时多态
方法重写是根据实际的类型决定调用哪个重写的方法，发生在运行期间，也叫做运行时多态
多态
public class Animal { public void eat() { System.out.println(&#34;动物去吃东西&#34;); } } public class Cat extends Animal { public void eat() { System."><meta name=author content="Me"><link rel=canonical href=/posts/java-polymorphic/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css integrity="sha256-v1+fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=apple-touch-icon href=apple-touch-icon.png><link rel=mask-icon href=safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Java面向对象之多态 笔记"><meta property="og:description" content="Java面向对象之多态 方法重写 子类和父类同名方法 子类和父类同名方法，方法重写
前提：需要有继承关系
方法重写表现：
方法名必须相同
参数列表必须相同
返回值类型必须相同
修饰符：范围可以扩大或相同，但是不能缩小 public > protected >default
方法重写
public class Animal { public void eat() { System.out.println(&#34;动物去吃东西&#34;); } } public class Cat extends Animal { public void eat() { System.out.println(&#34;猫喜欢吃鱼&#34;); } } public class Dog { public void eat() { System.out.println(&#34;狗喜欢吃骨头&#34;); } } 不能重写父类的private方法，如果定义的话只是定义了一个新方法，不是方法重写
运行时多态 后期绑定
如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也被称之为后期绑定
运行时多态
方法重写是根据实际的类型决定调用哪个重写的方法，发生在运行期间，也叫做运行时多态
多态
public class Animal { public void eat() { System.out.println(&#34;动物去吃东西&#34;); } } public class Cat extends Animal { public void eat() { System."><meta property="og:type" content="article"><meta property="og:url" content="/posts/java-polymorphic/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-29T19:01:51+08:00"><meta property="article:modified_time" content="2022-01-29T19:01:51+08:00"><meta property="og:site_name" content="Jasmine❀Hiker"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Java面向对象之多态 笔记"><meta name=twitter:description content="Java面向对象之多态 方法重写 子类和父类同名方法 子类和父类同名方法，方法重写
前提：需要有继承关系
方法重写表现：
方法名必须相同
参数列表必须相同
返回值类型必须相同
修饰符：范围可以扩大或相同，但是不能缩小 public > protected >default
方法重写
public class Animal { public void eat() { System.out.println(&#34;动物去吃东西&#34;); } } public class Cat extends Animal { public void eat() { System.out.println(&#34;猫喜欢吃鱼&#34;); } } public class Dog { public void eat() { System.out.println(&#34;狗喜欢吃骨头&#34;); } } 不能重写父类的private方法，如果定义的话只是定义了一个新方法，不是方法重写
运行时多态 后期绑定
如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也被称之为后期绑定
运行时多态
方法重写是根据实际的类型决定调用哪个重写的方法，发生在运行期间，也叫做运行时多态
多态
public class Animal { public void eat() { System.out.println(&#34;动物去吃东西&#34;); } } public class Cat extends Animal { public void eat() { System."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"Java面向对象之多态 笔记","item":"/posts/java-polymorphic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java面向对象之多态 笔记","name":"Java面向对象之多态 笔记","description":"Java面向对象之多态 方法重写 子类和父类同名方法 子类和父类同名方法，方法重写\n前提：需要有继承关系\n方法重写表现：\n方法名必须相同\n参数列表必须相同\n返回值类型必须相同\n修饰符：范围可以扩大或相同，但是不能缩小 public \u0026gt; protected \u0026gt;default\n方法重写\npublic class Animal { public void eat() { System.out.println(\u0026#34;动物去吃东西\u0026#34;); } } public class Cat extends Animal { public void eat() { System.out.println(\u0026#34;猫喜欢吃鱼\u0026#34;); } } public class Dog { public void eat() { System.out.println(\u0026#34;狗喜欢吃骨头\u0026#34;); } } 不能重写父类的private方法，如果定义的话只是定义了一个新方法，不是方法重写\n运行时多态 后期绑定\n如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也被称之为后期绑定\n运行时多态\n方法重写是根据实际的类型决定调用哪个重写的方法，发生在运行期间，也叫做运行时多态\n多态\npublic class Animal { public void eat() { System.out.println(\u0026#34;动物去吃东西\u0026#34;); } } public class Cat extends Animal { public void eat() { System.","keywords":["java","note"],"articleBody":"Java面向对象之多态 方法重写 子类和父类同名方法 子类和父类同名方法，方法重写\n前提：需要有继承关系\n方法重写表现：\n方法名必须相同\n参数列表必须相同\n返回值类型必须相同\n修饰符：范围可以扩大或相同，但是不能缩小 public \u003e protected \u003edefault\n方法重写\npublic class Animal { public void eat() { System.out.println(\"动物去吃东西\"); } } public class Cat extends Animal { public void eat() { System.out.println(\"猫喜欢吃鱼\"); } } public class Dog { public void eat() { System.out.println(\"狗喜欢吃骨头\"); } } 不能重写父类的private方法，如果定义的话只是定义了一个新方法，不是方法重写\n运行时多态 后期绑定\n如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也被称之为后期绑定\n运行时多态\n方法重写是根据实际的类型决定调用哪个重写的方法，发生在运行期间，也叫做运行时多态\n多态\npublic class Animal { public void eat() { System.out.println(\"动物去吃东西\"); } } public class Cat extends Animal { public void eat() { System.out.println(\"猫喜欢吃鱼\"); } } public class Dog { public void eat() { System.out.println(\"狗喜欢吃骨头\"); } } public class Test { public static void main(String[] args) { Animal an = new Cat(); an.eat(); } } 子类和父类static修饰的同名方法 子类和父类static修饰的同名方法\nstatic修饰的方法是静态方法，也叫做类方法使用\n使用private或static或final修饰的变量或者方法，是早期绑定\npublic class Animal { public static void eat() { System.out.println(\"动物在吃\"); } } public class Cat extends Animal { public static void eat() { System.out.println(\"猫吃鱼\"); } } public class Test { public static void main(String[] args) { Animal an = new Cat(); an.eat(); } } 动态绑定和解耦合简介 动态绑定\n在运行时根据具体对象的类型进行绑定，也就是后期绑定\n解耦合简介\n解耦合，字面意思就是解除耦合关系\n设计的核心思想：\n尽可能减少代码耦合，如果发现代码耦合，就要采用解耦技术\n数据模型，业务逻辑和视图显示三层之间彼此降低耦合\n解耦合简介\n父子关系和夫妻关系的区别\n从编程角度，父子关系是不能拆分的\n从编程角度，夫妻关系是可以拆分的\n同名变量和方法重写 子类和父类出现同名变量\npublic class Father { int a = 1; static int b = 1; public Father() { a = 10; b = 10; } } public class Son extends Father { int a = 2; static int b = 2; public Son() { a = 20; b = 20; } public static void main(String[] args) { Son s = new Son(); Father f = s; System.out.println(\"f.a = \"+f.a+\",f.b=\"+f.b); System.out.println(\"s.a = \"+s.a+\",s.b=\"+s.b); } } 方法重载和方法重写的区别和应用 名称 方法重载 方法重写 类 一个类 继承关系 方法名 参数个数不同、参数类型不同、参数顺序不同 参数列表相同 返回值类型 可以不同 必须相同 调用方式 参数决定 创建的实际对象决定 static修饰 是方法重载 不是方法重写 抽象类 抽象类 为什么需要抽象类？\n动物Animal都有自己的行为，小鸟和老虎继承了动物的行为，但小鸟和老虎的行动方式不一样。在动物中能给出行动的具体实现吗？\n抽象类和抽象方法来解决这个问题\n什么是抽象类？\n使用abstract关键字修饰的方法叫做抽象方法，抽象方法没有方法体。当一个类中包含了抽象方法，那么该类也必须使用abstract关键字来修饰，这种使用abstract关键字修饰的类就是抽象类。\n抽象类及抽象方法定义的语法格式\n[修饰符] abstract class 类名 { // 定义抽象方法 [修饰符] abstract 方法返回值类型 方法名([参数列表]); // 其他方法或属性 } 抽象类的作用 抽象类的作用类似于“模板”，其目的是方便开发人员根据抽象类的格式来修改和创建新类。\n抽象类主要用于继承，有利于程序的扩展。\npublic abstract class Book { public abstract String getAuthor(); } public class ComputerBook extends Book { @Override public String getAuthor() { return \"詹姆斯·高斯林 James Gosling\"; } } public class EnglishBook extends Book { @Override public String getAuthor() { return \"Tom\"; } } 抽象类的特点 抽象类不能创建对象，如果创建，编译无法通过而报错，只能创建其非抽象子类的对象。 抽象类中，可以有构造器，是供子类创建对象时，初始化父类成员使用的。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类，不然编译无法通过而报错。 抽象类中的抽象方法不能用private、final、static修饰 抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。 接口 接口的定义 为什么需要接口？\n可以使用接口解决Java多继承的问题 什么是接口\n接口就是某个事物对外提供的一些功能的声明 可以利用接口实现多态，同时接口也弥补了Java单一继承的弱点 使用interface关键字定义接口 接口的特性 JDK 1.8之前接口的特性：\n接口允许多继承 接口没有构造方法 接口中的属性默认是用public static final修饰 接口中的方法默认是用public abstract修饰的 接口继承接口用extends，不能implement JDK 1.8 之后接口的语法：\n[修饰符] interface 接口名 [extends 父接口1,父接口2,...] { [public] [static] [final] 常量类型 常量名 = 常量值; [public] [abstract] 方法返回值类型 方法名([参数列表]); [public] default 方法返回值类型 方法名([参数列表]){ // 默认方法的方法体 } [public] static 方法返回值类型 方法名([参数列表]){ // 类方法的方法体 } } JDK 1.8之后接口的特性：\n在接口内部可以定义多个常量和抽象方法，定义常量时必须进行初始化赋值，定义默认方法和静态方法时，可以有方法体。 在接口中定义常量时，可以省略“public static final”修饰符，接口会默认为常量添加”public static final“修饰符。与此类似，在接口中定义抽象方法时，也可以省略”public abstract“修饰符，定义default默认方法和static静态方法时，可以省略”public“修饰符，这些修饰符系统都会默认进行添加。 接口的作用 接口表示一种能力，例如：”做这项工作需要一个钳工/木匠/程序员“\n接口是一种能力\n体现在接口方法上 面向接口编程\n接口的设计 面向接口编程 需求：开发打印机 墨盒：彩色、黑白 纸张类型：A4、B5 墨盒和纸张都不是打印机厂商提供的 打印机厂商要兼容市场上的墨盒、纸张 结果： 使用黑白墨盒在A4纸上打印 使用彩色墨盒在B5纸上打印 使用彩色墨盒在A4纸上打印 接口与抽象类 抽象类的特点 何时使用继承？\n继承与真实世界类似，只要说”猫是哺乳动物“，猫的很多属性、行为就不言自明了。\n符合is-a关系的设计使用抽象类继承\n继承是代码重用的一种方式，将子类共有的属性和行为放到父类中，子类与父类是is-a关系\n接口的特点 USB接口本身没有实现任何功能\nUSB接口规定了数据传输的要求\nUSB接口可以被多种USB设备实现\n可以使用Java接口来实现\n编写USB接口 根据需求设计方法 实现USB接口 实现所有方法 使用USB接口 用多态的方式使用 符合has-is关系的设计使用接口\n","wordCount":"434","inLanguage":"en","datePublished":"2022-01-29T19:01:51+08:00","dateModified":"2022-01-29T19:01:51+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/java-polymorphic/"},"publisher":{"@type":"Organization","name":"Jasmine❀Hiker","logo":{"@type":"ImageObject","url":"favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li><li><a href=/posts/ title=Posts><span>Posts</span></a></li><li><a href=/about/ title=About><span>About</span></a></li><li><a href=/link/ title=Link><span>Link</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>Java面向对象之多态 笔记</h1><div class=post-meta><span title='2022-01-29 19:01:51 +0800 CST'>January 29, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;434 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#java%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b9%8b%e5%a4%9a%e6%80%81 aria-label=Java面向对象之多态>Java面向对象之多态</a><ul><li><a href=#%e6%96%b9%e6%b3%95%e9%87%8d%e5%86%99 aria-label=方法重写>方法重写</a><ul><li><a href=#%e5%ad%90%e7%b1%bb%e5%92%8c%e7%88%b6%e7%b1%bb%e5%90%8c%e5%90%8d%e6%96%b9%e6%b3%95 aria-label=子类和父类同名方法>子类和父类同名方法</a><ul><li><a href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%a4%9a%e6%80%81 aria-label=运行时多态>运行时多态</a></li></ul></li><li><a href=#%e5%ad%90%e7%b1%bb%e5%92%8c%e7%88%b6%e7%b1%bbstatic%e4%bf%ae%e9%a5%b0%e7%9a%84%e5%90%8c%e5%90%8d%e6%96%b9%e6%b3%95 aria-label=子类和父类static修饰的同名方法>子类和父类static修饰的同名方法</a></li><li><a href=#%e5%8a%a8%e6%80%81%e7%bb%91%e5%ae%9a%e5%92%8c%e8%a7%a3%e8%80%a6%e5%90%88%e7%ae%80%e4%bb%8b aria-label=动态绑定和解耦合简介>动态绑定和解耦合简介</a></li><li><a href=#%e5%90%8c%e5%90%8d%e5%8f%98%e9%87%8f%e5%92%8c%e6%96%b9%e6%b3%95%e9%87%8d%e5%86%99 aria-label=同名变量和方法重写>同名变量和方法重写</a></li><li><a href=#%e6%96%b9%e6%b3%95%e9%87%8d%e8%bd%bd%e5%92%8c%e6%96%b9%e6%b3%95%e9%87%8d%e5%86%99%e7%9a%84%e5%8c%ba%e5%88%ab%e5%92%8c%e5%ba%94%e7%94%a8 aria-label=方法重载和方法重写的区别和应用>方法重载和方法重写的区别和应用</a></li></ul></li><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb aria-label=抽象类>抽象类</a><ul><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb-1 aria-label=抽象类>抽象类</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=抽象类的作用>抽象类的作用</a><ul><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e7%9a%84%e7%89%b9%e7%82%b9 aria-label=抽象类的特点>抽象类的特点</a></li></ul></li></ul></li><li><a href=#%e6%8e%a5%e5%8f%a3 aria-label=接口>接口</a><ul><li><a href=#%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=接口的定义>接口的定义</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e7%9a%84%e7%89%b9%e6%80%a7 aria-label=接口的特性>接口的特性</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=接口的作用>接口的作用</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e7%9a%84%e8%ae%be%e8%ae%a1 aria-label=接口的设计>接口的设计</a></li></ul></li><li><a href=#%e6%8e%a5%e5%8f%a3%e4%b8%8e%e6%8a%bd%e8%b1%a1%e7%b1%bb aria-label=接口与抽象类>接口与抽象类</a><ul><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e7%9a%84%e7%89%b9%e7%82%b9-1 aria-label=抽象类的特点>抽象类的特点</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e7%9a%84%e7%89%b9%e7%82%b9 aria-label=接口的特点>接口的特点</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=java面向对象之多态>Java面向对象之多态<a hidden class=anchor aria-hidden=true href=#java面向对象之多态>#</a></h1><h2 id=方法重写>方法重写<a hidden class=anchor aria-hidden=true href=#方法重写>#</a></h2><h3 id=子类和父类同名方法>子类和父类同名方法<a hidden class=anchor aria-hidden=true href=#子类和父类同名方法>#</a></h3><ul><li><p>子类和父类同名方法，方法重写</p></li><li><p>前提：需要有继承关系</p></li><li><p>方法重写表现：</p><p>方法名必须相同</p><p>参数列表必须相同</p><p>返回值类型必须相同</p><p>修饰符：范围可以扩大或相同，但是不能缩小 <code>public</code> > <code>protected</code> ><code>default</code></p></li></ul><p>方法重写</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Animal</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>eat</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;动物去吃东西&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Cat</span> <span class=kd>extends</span> <span class=n>Animal</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>eat</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;猫喜欢吃鱼&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Dog</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>eat</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;狗喜欢吃骨头&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><em>不能重写父类的private方法，如果定义的话只是定义了一个新方法，不是方法重写</em></p><h4 id=运行时多态>运行时多态<a hidden class=anchor aria-hidden=true href=#运行时多态>#</a></h4><ul><li><p>后期绑定</p><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也被称之为后期绑定</p></li><li><p>运行时多态</p><p>方法重写是根据实际的类型决定调用哪个重写的方法，发生在运行期间，也叫做运行时多态</p></li></ul><p>多态</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Animal</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>eat</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;动物去吃东西&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Cat</span> <span class=kd>extends</span> <span class=n>Animal</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>eat</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;猫喜欢吃鱼&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Dog</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>eat</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;狗喜欢吃骨头&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Animal</span> <span class=n>an</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Cat</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>an</span><span class=o>.</span><span class=na>eat</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=子类和父类static修饰的同名方法>子类和父类static修饰的同名方法<a hidden class=anchor aria-hidden=true href=#子类和父类static修饰的同名方法>#</a></h3><ul><li><p>子类和父类static修饰的同名方法</p><p>static修饰的方法是静态方法，也叫做类方法使用</p><p>使用private或static或final修饰的变量或者方法，是早期绑定</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Animal</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>eat</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;动物在吃&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Cat</span> <span class=kd>extends</span> <span class=n>Animal</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>eat</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;猫吃鱼&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Animal</span> <span class=n>an</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Cat</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>an</span><span class=o>.</span><span class=na>eat</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=动态绑定和解耦合简介>动态绑定和解耦合简介<a hidden class=anchor aria-hidden=true href=#动态绑定和解耦合简介>#</a></h3><ul><li><p>动态绑定</p><p>在运行时根据具体对象的类型进行绑定，也就是后期绑定</p></li><li><p>解耦合简介</p><p>解耦合，字面意思就是解除耦合关系</p><p>设计的核心思想：</p><blockquote><p>尽可能减少代码耦合，如果发现代码耦合，就要采用解耦技术</p><p>数据模型，业务逻辑和视图显示三层之间彼此降低耦合</p></blockquote></li></ul><p>解耦合简介</p><ul><li><p>父子关系和夫妻关系的区别</p><p>从编程角度，父子关系是不能拆分的</p><p>从编程角度，夫妻关系是可以拆分的</p></li></ul><h3 id=同名变量和方法重写>同名变量和方法重写<a hidden class=anchor aria-hidden=true href=#同名变量和方法重写>#</a></h3><p>子类和父类出现同名变量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Father</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Father</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=mi>10</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Son</span> <span class=kd>extends</span> <span class=n>Father</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Son</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=mi>20</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Son</span> <span class=n>s</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Son</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>Father</span> <span class=n>f</span> <span class=o>=</span> <span class=n>s</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;f.a = &#34;</span><span class=o>+</span><span class=n>f</span><span class=o>.</span><span class=na>a</span><span class=o>+</span><span class=s>&#34;,f.b=&#34;</span><span class=o>+</span><span class=n>f</span><span class=o>.</span><span class=na>b</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;s.a = &#34;</span><span class=o>+</span><span class=n>s</span><span class=o>.</span><span class=na>a</span><span class=o>+</span><span class=s>&#34;,s.b=&#34;</span><span class=o>+</span><span class=n>s</span><span class=o>.</span><span class=na>b</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=方法重载和方法重写的区别和应用>方法重载和方法重写的区别和应用<a hidden class=anchor aria-hidden=true href=#方法重载和方法重写的区别和应用>#</a></h3><table><thead><tr><th style=text-align:center>名称</th><th style=text-align:center>方法重载</th><th style=text-align:center>方法重写</th></tr></thead><tbody><tr><td style=text-align:center>类</td><td style=text-align:center>一个类</td><td style=text-align:center>继承关系</td></tr><tr><td style=text-align:center>方法名</td><td style=text-align:center>参数个数不同、参数类型不同、参数顺序不同</td><td style=text-align:center>参数列表相同</td></tr><tr><td style=text-align:center>返回值类型</td><td style=text-align:center>可以不同</td><td style=text-align:center>必须相同</td></tr><tr><td style=text-align:center>调用方式</td><td style=text-align:center>参数决定</td><td style=text-align:center>创建的实际对象决定</td></tr><tr><td style=text-align:center>static修饰</td><td style=text-align:center>是方法重载</td><td style=text-align:center>不是方法重写</td></tr></tbody></table><h2 id=抽象类>抽象类<a hidden class=anchor aria-hidden=true href=#抽象类>#</a></h2><h3 id=抽象类-1>抽象类<a hidden class=anchor aria-hidden=true href=#抽象类-1>#</a></h3><p>为什么需要抽象类？</p><blockquote><p>动物Animal都有自己的行为，小鸟和老虎继承了动物的行为，但小鸟和老虎的行动方式不一样。在动物中能给出行动的具体实现吗？</p><p>抽象类和抽象方法来解决这个问题</p></blockquote><p>什么是抽象类？</p><blockquote><p>使用abstract关键字修饰的方法叫做抽象方法，抽象方法没有方法体。当一个类中包含了抽象方法，那么该类也必须使用abstract关键字来修饰，这种使用abstract关键字修饰的类就是抽象类。</p></blockquote><p>抽象类及抽象方法定义的语法格式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>[</span><span class=err>修饰符</span><span class=o>]</span> <span class=kd>abstract</span> <span class=kd>class</span> <span class=err>类名</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 定义抽象方法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>[</span><span class=err>修饰符</span><span class=o>]</span> <span class=kd>abstract</span> <span class=err>方法返回值类型</span> <span class=err>方法名</span><span class=o>([</span><span class=err>参数列表</span><span class=o>]);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 其他方法或属性
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div><h3 id=抽象类的作用>抽象类的作用<a hidden class=anchor aria-hidden=true href=#抽象类的作用>#</a></h3><p>抽象类的作用类似于“模板”，其目的是方便开发人员根据抽象类的格式来修改和创建新类。</p><p>抽象类主要用于继承，有利于程序的扩展。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>abstract</span> <span class=kd>class</span> <span class=nc>Book</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>abstract</span> <span class=n>String</span> <span class=nf>getAuthor</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ComputerBook</span> <span class=kd>extends</span> <span class=n>Book</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>getAuthor</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;詹姆斯·高斯林 James Gosling&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>EnglishBook</span> <span class=kd>extends</span> <span class=n>Book</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>getAuthor</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;Tom&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=抽象类的特点>抽象类的特点<a hidden class=anchor aria-hidden=true href=#抽象类的特点>#</a></h4><ol><li>抽象类不能创建对象，如果创建，编译无法通过而报错，只能创建其非抽象子类的对象。</li><li>抽象类中，可以有构造器，是供子类创建对象时，初始化父类成员使用的。</li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类，不然编译无法通过而报错。</li><li>抽象类中的抽象方法不能用private、final、static修饰</li><li>抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。</li></ol><h2 id=接口>接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h2><h3 id=接口的定义>接口的定义<a hidden class=anchor aria-hidden=true href=#接口的定义>#</a></h3><p>为什么需要接口？</p><ul><li>可以使用接口解决Java多继承的问题</li></ul><p>什么是接口</p><ul><li>接口就是某个事物对外提供的一些功能的声明</li><li>可以利用接口实现多态，同时接口也弥补了Java单一继承的弱点</li><li>使用interface关键字定义接口</li></ul><h3 id=接口的特性>接口的特性<a hidden class=anchor aria-hidden=true href=#接口的特性>#</a></h3><p>JDK 1.8之前接口的特性：</p><ul><li>接口允许多继承</li><li>接口没有构造方法</li><li>接口中的属性默认是用public static final修饰</li><li>接口中的方法默认是用public abstract修饰的</li><li>接口继承接口用extends，不能implement</li></ul><p>JDK 1.8 之后接口的语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>[</span><span class=err>修饰符</span><span class=o>]</span> <span class=kd>interface</span> <span class=err>接口名 [</span><span class=nc>extends</span> <span class=err>父接口</span><span class=mi>1</span><span class=o>,</span><span class=err>父接口</span><span class=mi>2</span><span class=o>,...]</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=kd>public</span><span class=o>]</span> <span class=o>[</span><span class=kd>static</span><span class=o>]</span> <span class=o>[</span><span class=kd>final</span><span class=o>]</span> <span class=err>常量类型</span> <span class=err>常量名</span> <span class=o>=</span> <span class=err>常量值</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=kd>public</span><span class=o>]</span> <span class=o>[</span><span class=kd>abstract</span><span class=o>]</span> <span class=err>方法返回值类型</span> <span class=err>方法名</span><span class=o>([</span><span class=err>参数列表</span><span class=o>]);</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=kd>public</span><span class=o>]</span> <span class=k>default</span> <span class=err>方法返回值类型</span> <span class=err>方法名</span><span class=o>([</span><span class=err>参数列表</span><span class=o>]){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 默认方法的方法体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=kd>public</span><span class=o>]</span> <span class=kd>static</span> <span class=err>方法返回值类型</span> <span class=err>方法名</span><span class=o>([</span><span class=err>参数列表</span><span class=o>]){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 类方法的方法体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>JDK 1.8之后接口的特性：</p><ul><li>在接口内部可以定义多个常量和抽象方法，定义常量时必须进行初始化赋值，定义默认方法和静态方法时，可以有方法体。</li><li>在接口中定义常量时，可以省略“public static final”修饰符，接口会默认为常量添加”public static final“修饰符。与此类似，在接口中定义抽象方法时，也可以省略”public abstract“修饰符，定义default默认方法和static静态方法时，可以省略”public“修饰符，这些修饰符系统都会默认进行添加。</li></ul><h3 id=接口的作用>接口的作用<a hidden class=anchor aria-hidden=true href=#接口的作用>#</a></h3><ul><li><p>接口表示一种能力，例如：”做这项工作需要一个钳工/木匠/程序员“</p></li><li><p>接口是一种能力</p><ul><li>体现在接口方法上</li></ul></li><li><p>面向接口编程</p><p><img loading=lazy src=/images/Java-Polymorphic/image-20210717200449346.png alt=image-20210717200449346></p></li></ul><h3 id=接口的设计>接口的设计<a hidden class=anchor aria-hidden=true href=#接口的设计>#</a></h3><ul><li>面向接口编程</li><li>需求：开发打印机<ul><li>墨盒：彩色、黑白</li><li>纸张类型：A4、B5</li><li>墨盒和纸张都不是打印机厂商提供的</li><li>打印机厂商要兼容市场上的墨盒、纸张</li></ul></li><li>结果：<ul><li>使用黑白墨盒在A4纸上打印</li><li>使用彩色墨盒在B5纸上打印</li><li>使用彩色墨盒在A4纸上打印</li></ul></li></ul><h2 id=接口与抽象类>接口与抽象类<a hidden class=anchor aria-hidden=true href=#接口与抽象类>#</a></h2><h3 id=抽象类的特点-1>抽象类的特点<a hidden class=anchor aria-hidden=true href=#抽象类的特点-1>#</a></h3><p>何时使用继承？</p><ul><li><p>继承与真实世界类似，只要说”猫是哺乳动物“，猫的很多属性、行为就不言自明了。</p><p><strong>符合is-a关系的设计使用抽象类继承</strong></p></li><li><p>继承是代码重用的一种方式，将子类共有的属性和行为放到父类中，子类与父类是is-a关系</p></li></ul><h3 id=接口的特点>接口的特点<a hidden class=anchor aria-hidden=true href=#接口的特点>#</a></h3><blockquote><p>USB接口本身没有实现任何功能</p><p>USB接口规定了数据传输的要求</p><p>USB接口可以被多种USB设备实现</p></blockquote><p>可以使用Java接口来实现</p><ul><li>编写USB接口 根据需求设计方法</li><li>实现USB接口 实现所有方法</li><li>使用USB接口 用多态的方式使用</li></ul><p><strong>符合has-is关系的设计使用接口</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/java/>java</a></li><li><a href=/tags/note/>note</a></li></ul><nav class=paginav><a class=prev href=/posts/c-basic/><span class=title>« Prev</span><br><span>C语言基础 笔记</span></a>
<a class=next href=/posts/java-extends/><span class=title>Next »</span><br><span>Java面向对象之继承 笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Jasmine❀Hiker</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
</script><script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script></body></html>