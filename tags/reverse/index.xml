<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reverse on Code &amp; Tea Cyberspace</title>
    <link>https://zcodetea.github.io/tags/reverse/</link>
    <description>Recent content in Reverse on Code &amp; Tea Cyberspace</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 23 Apr 2022 15:14:39 +0800</lastBuildDate><atom:link href="https://zcodetea.github.io/tags/reverse/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>攻防世界进阶区日常训练001</title>
      <link>https://zcodetea.github.io/posts/xctf-reverse-advanced_daliy_001/</link>
      <pubDate>Sat, 23 Apr 2022 15:14:39 +0800</pubDate>
      
      <guid>https://zcodetea.github.io/posts/xctf-reverse-advanced_daliy_001/</guid>
      <description>攻防世界 RE 进阶区 日常练习 001  ISCC比赛临近，CTF比赛题目也要开始继续训练起来 前段时间，由于准备升学相关的事宜，没有进行比赛的训练 手感相对而言，有些生疏 简单从攻防世界平台找几道逆向的题目进行简单的练习下
 这几道题目主要都是使用IDA pro的远程调试功能，使用虚拟机搭配IDA进行远程调试
re2-cpp-is-awesome 先查看一些文件的简单信息 ELF文件，GCC编译，无壳
IDA看下： C++编译的程序文件，看的心烦意乱基本上找不到关键的函数，和关键的位置。
尝试使用下IDA pro的动调寻找一下f关键位置(IDA pro的动态消失配置可以自己网络检索，有很多相关的内容)
先断在第一个跳转位置，即jz short loc_400BD7 位置上
进行几次调试，发现都直接退出，没有进行跳转 也就是 cmp [rbp+var_64], 2 的比较值没有改变ZF标志位 对上面汇编代码进行审计：
main proc near var_70= qword ptr -70h var_64= dword ptr -64h var_60= qword ptr -60h var_50= byte ptr -50h var_21= byte ptr -21h var_20= qword ptr -20h var_14= dword ptr -14h push rbp mov rbp, rsp push rbx sub rsp, 68h mov [rbp+var_64], edi mov [rbp+var_70], rsi cmp [rbp+var_64], 2 指令cmp [rbp+var_64], 2是一个条件判断，根据这个语句寻找下变量</description>
    </item>
    
    <item>
      <title>看穿你的逻辑 理解你表达的真谛</title>
      <link>https://zcodetea.github.io/posts/logic_re/</link>
      <pubDate>Sat, 26 Feb 2022 11:36:23 +0800</pubDate>
      
      <guid>https://zcodetea.github.io/posts/logic_re/</guid>
      <description>逻辑语句逆向分析 总结 if分支 if Debug
0x00411a30 cmp dword [var_ch], 0x41 0x00411a34 jne 0x411a47 0x00411a36 mov eax, dword [var_ch] 0x00411a39 push eax 0x00411a3a push str.This_is_current_alpha:_c 0x00411a3f call fcn.004110d7 0x00411a44 add esp, 8 0x00411a47 mov esi, esp Release
0x004010a1 cmp dword [var_8h], 0x41 0x004010a5 jne 0x4010b6 0x004010a7 push 0x41 0x004010a9 push str.This_is_current_alpha:_c 0x004010ae call fcn.00401020 0x004010b3 add esp, 8 0x004010b6 push str.pause if_else Debug
0x00411a30 cmp dword [var_ch], 0x41 0x00411a34 jne 0x411a49 0x00411a36 mov eax, dword [var_ch] 0x00411a39 push eax 0x00411a3a push str.</description>
    </item>
    
    <item>
      <title>寻找入口点 回归最开始的美好</title>
      <link>https://zcodetea.github.io/posts/entry_point/</link>
      <pubDate>Sat, 26 Feb 2022 11:12:10 +0800</pubDate>
      
      <guid>https://zcodetea.github.io/posts/entry_point/</guid>
      <description>寻找主函数 入口点（主函数）并不确定 &amp;ndash;&amp;gt; 编译器版本
寻找编译器特征 来确定 主函数
VS 2013-2017 特征 2015 Debug x86  jmp mainCRTStartup里面的call 第二个call movzx test jz mov mov push call add push call add call(main) 最后一个call jmp main  2015 Release x86  jmp call__p___argv mov call__p___argc mov call_get_initial_narrow_environment push push push call(main) main  2015 Debug x64  jmp call 第二个call movzx test jz mov mov call xor call call(main) 最后一个call jmp main  2015 Release x64  jmp call__p___argv movrdi, rax call__p___argc movrbx, rax call mov mov mov call(main) main  2017 Debug x86  jmp call 第二个call movzx ecx, al testecx, ecx jz short loc_411E82 mov mov push call add call (main) 最后一个call jmp main  2017 Release x86  jmp call mov call mov call push push push call(main) main  2017 Debug x64  jmp call 第二个call movzx test jz mov mov call call(main) 最后一个call jmp main  2017 Release x64  jmp call__p___argv mov call__p___argc mov call mov mov mov call(main) main  2019 Debug x86  jmp call 第二个call movzx test jz mov mov push call add call(main) 最后一个call jmp main  2019 Release x86  jmp call__p___argv mov call__p___argc push push push call(main) main  2019 Debug x64  jmp call 第二个call movzx test jz mov mov call call(main) 最后一个call jmp main  2019 Release x64  jmp call__p___argv mov call__p___argc push push push call(main) main  2022 Debug x86  jmp call 第二个call movzx test je mov mov push call add call(main) 最后一个call jmp main  2022 Release x86  call 第二个call movzx test je mov mov push call add call(main) 最后一个call main  2022 Debug x64  jmp call 第二个call movzx test je mov mov call call(main) 最后一个call jmp main  2022 Release x64  call__p___argv mov call__p___argc mov mov mov call(main) main  MinGW GCC x86 Debug  jmp call mov mov mov mov mov mov mov mov mov call(main) main  x86 Release   jmp</description>
    </item>
    
    <item>
      <title>进制笔记</title>
      <link>https://zcodetea.github.io/posts/base_note/</link>
      <pubDate>Tue, 22 Feb 2022 20:05:38 +0800</pubDate>
      
      <guid>https://zcodetea.github.io/posts/base_note/</guid>
      <description>进制 进制的概念 进制是什么？
对于任何一种进制—X进制，就表示每一位置上的数运算时都是逢X进一位。
二进制：0、1 八进制：0、1、2、3、4、5、6、7 十进制：0、1、2、3、4、5、6、7、8、9 十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F N进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F、N-1 进制的运算 进制转换
十六进制与二进制转换
   0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111     0 1 2 3 4 5 6 7 8 9 A B C D E F    二进制到十六进制转换
   1 1 1 1     8 4 2 1    8+4+2+1 = 15(F)</description>
    </item>
    
    <item>
      <title>汇编语言 笔记</title>
      <link>https://zcodetea.github.io/posts/asm/</link>
      <pubDate>Thu, 03 Feb 2022 09:56:53 +0800</pubDate>
      
      <guid>https://zcodetea.github.io/posts/asm/</guid>
      <description>汇编语言 概述 编程形式
 开关&amp;ndash;&amp;gt;打孔&amp;ndash;&amp;gt;输入设备
 汇编语言的出现
mov eax, 5 mov ebx, 6 add eax, ebx 汇编程序的执行
 汇编代码 -&amp;gt; 汇编程序 -&amp;gt; 处理器可识别 01010101 -&amp;gt; 处理器执行
 学习汇编的意义  开发时调试 逆向时候的代码阅读 某些特殊技术的使用（如shellcode、壳）   shellcode：可以运行在任意位置的代码（汇编语言）
壳：加壳或脱壳都需要用的汇编语言
 环境配置
  Ollydbg
  Visual Studio 2015
  x16 汇编 通用寄存器    16位寄存器 高8位 低8位     AX AH AL   BX BH BL   CX CH CL   DX DH DL   SI \ \   DI \ \   SP \ \   BP \ \    内存字节序 :chestnut: 0x12345678</description>
    </item>
    
    <item>
      <title>一花一世界，一码一千秋</title>
      <link>https://zcodetea.github.io/posts/%E4%B8%80%E8%8A%B1%E4%B8%80%E4%B8%96%E7%95%8C%E4%B8%80%E7%A0%81%E4%B8%80%E5%8D%83%E7%A7%8B/</link>
      <pubDate>Sat, 29 Jan 2022 08:02:58 +0800</pubDate>
      
      <guid>https://zcodetea.github.io/posts/%E4%B8%80%E8%8A%B1%E4%B8%80%E4%B8%96%E7%95%8C%E4%B8%80%E7%A0%81%E4%B8%80%E5%8D%83%E7%A7%8B/</guid>
      <description>一花一世界，一码一千秋 ”逆向工程初步“  逆向工程应该是一门优雅的艺术，而不是一些低层次者手中的粗陋工具；
逆向工程的目的是学习与再利用；
逆向工程的精神是“自由”。
《加密与解密》
 什么是逆向工程？ 逆向工程（Reverse engineering），又称反向工程，是一种技术过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能性能规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是，在无法轻易获得必要的生产信息下，直接从成品的分析，推导产品的设计原理。^1^
通俗来讲，逆向工程就是将机器才能够懂的机器代码（0101二进制代码）翻译成人能够读懂的代码（汇编、smali代码）。 但实际情况往往是，我们只寻找关键的代码去翻译或仅了解其业务逻辑，因为要将所有的机器代码翻译出来，工作量是极其巨大的且繁琐的。^2^
逆向技术在实际业务中一般应用于以下几个方面：二进制漏洞挖掘、软件破解、恶意代码分析、竞品分析等。
逆向工程涉及的知识面非常广，从计算机基础原理到计算机架构，再到各种编程语言的编译原理。逆向工程往往需要对算法进行逆向，对操作系统架构进行逆向，这就要求逆向工程师有不错的算法水平，而且对计算机相关的原理深入理解。
一个逆向工程大师，也许具有如下特征。
 永远保持好奇心，崇尚自由——既能促使探索，也能抵抗商业利益和欲望的侵袭。有了它，枯燥的代码世界才有了生气。 勤奋与毅力。在一篇关于逆向的文章中有这样的语句：“让我们搞清楚作为一名逆向工作者需要具备的基本条件，其实那并不是扎实的汇编功底和编程基础——可以完全不懂这些，秘诀就是勤奋加上执着！记住并做到这两点，你一样可以变得优秀。” 精通至少一门编程语言——不仅仅是代码，更重要的是编程思想。 扎实的汇编功底和系统编程知识。  基础知识  汇编语言 C语言 一门脚本语言(Python) Windows核心编程 PE文件格式 程序加载流程  基础工具  查壳工具（DIE、PEID、EXEINFO、LordPE、ResourceHacker等） 常用脱壳工具或脱壳脚本（专属壳的脱壳器例如upx等、各种壳的脱壳脚本） 十六进制编辑器（010Editor、winhex等） 反汇编工具（IDA、Hopper） 调试器（Ollydbg、gdb、windbg等）  这些都是比较常用的逆向工具。其中特别要熟练使用IDA与Ollydbg，IDA一般用来做静态分析，其中的F5功能更是强大到没朋友，新手必备。Ollydbg简称OD一般用来做动态调试使用，两者结合使用堪比倚天剑和屠龙刀，可谓是神挡杀神佛挡杀佛。^3^
逆向的分类  解释型语言的逆向 编译型语言的逆向  分析手段  静态分析 动态分析 网络流量分析 猜  静态分析 将机器代码反汇编成方便人类理解的代码，如smali代码（Java）、汇编代码或汇编代码翻译的C语言伪代码等等，通过分析这些比较低级的编程语言的代码，找到程序的业务流程或设计逻辑。
动态分析 通过断点调试手段，让程序单步执行进行分析。动态分析往往是在静态分析出一定的结果的基础上进行，找到合适的地方给代码打断点，即时地读取当前变量的值，来进一步分析程序的逻辑、获取程序关系数据。
网络流量分析 通过代理方式或者其他方式，截取程序与服务器通信的数据流量（抓包），来分析客户端和服务端的通信协议。网络流量分析比较有局限性，若客户端使用Http这种明文传输的协议，会比较容易分析；但如果客户端使用SSL、Https等加密传输协议与服务端进行通信，那么抓包的前提是需要拿到服务端下发给客户端的证书才能进一步解密分析，这种情况下就比较棘手。网上有方案通过安装插件拿到Chrome或者Firefox浏览器的本地证书，但只适用于客户端是网页的情况。若其他大佬有好的宝贵经验，还望能指点迷津。
猜 猜测的前提是，你需要有一定的编程经验，能够在逆向分析出一些代码后，对其上下的代码进行合理的推测，推测不出来的代码再通过以上手段分析。可以这么说，你的推测能力决定了你的逆向分析效率，而编程经验则是你猜测能力的基石。
 逆向工程的学习是一条漫长的道路，每一个逆向工程师都是一个优秀的开发者，只不过他们选择去挑战更有深度，更有趣味的事情。加密与解密，解开每一段代码的意味，看到软件背后潜藏的世界，正所谓，一花一世界，一码一千秋嘛。
 参考  逆向工程-维基百科 逆向工程入门概述-知乎 CTF逆向选手入坑指南-FreeBuf  闲聊到此为止，来喝杯茶可好？</description>
    </item>
    
  </channel>
</rss>