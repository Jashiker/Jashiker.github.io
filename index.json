[{"content":"","date":"October 4, 2022","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"October 4, 2022","permalink":"/categories/challange/","section":"Categories","summary":"","title":"challange"},{"content":"","date":"October 4, 2022","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"ctf"},{"content":"","date":"October 4, 2022","permalink":"/tags/forensics/","section":"Tags","summary":"","title":"Forensics"},{"content":"","date":"October 4, 2022","permalink":"/","section":"OPdbg","summary":"","title":"OPdbg"},{"content":"OtterCTF 2018 Memory Forensic Reappearance # 想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3\n环境配置：Kali Linux 2022 工具配置：volatility + mimikatz\nInfo # 题目附件就一个镜像，先查看下镜像的指纹数据：\n5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：\nvol.py -f OtterCTF.vmem imageinfo 说明\nvol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：\n可以看到大致的镜像系统是Win7系统\nWhat the password? # 查看题目描述：\nyou got a sample of rick\u0026#39;s PC\u0026#39;s memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：\n对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取\n使用如下指令使用mimikatz插件进行获取：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息：\n已经获取到了密码信息，提交flag，攻破此题：\nCTF{MortyIsReallyAnOtter} General Info # 查看题目描述：\nLet\u0026#39;s start easy - whats the PC\u0026#39;s name and IP address? 需要获取PC’s name和IP， PC的名字已经很明确了，应该就是刚刚获取密码信息得到的WIN-LO6FAF3DTFE\n下面需要获取的应该就是IP地址，使用网络扫描指令应该可以获取到相应的信息：\n可以看出IP地址应该是：192.168.202.131\n根据题目要求，flag应该是：\nCTF{WIN-LO6FAF3DTFE} CTF{192.168.202.131} Play Time # 查看题目描述：\nRick just loves to play some good old videogames. can you tell which game is he playing? whats the IP address of the server? 玩游戏肯定会有进程的存储在内存中，扫描下进程情况，使用如下指令进行查看：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 psscan 得到如下信息：\n可以发现到了一个不熟悉的进程，猜测这个进程是游戏进程，也就是游戏名称是LunarMS.exe\n再使用netscan查看下网络通信信息：\n可以发现一个ip地址，应该是游戏下载的ip地址，可以得到flag：\nCTF{LunarMS.exe} CTF{77.102.199.102} Name Game # 查看题目描述：\nWe know that the account was logged in to a channel called Lunar-3. what is the account name? 应该需要找到游戏的用户名，应该存储在游戏的内存中，尝试将游戏进程进行dump来获取到游戏进程的内存信息\nvol程序进行内存dump的指令如下：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 708 -D ./ 说明\nmemdump 内存dump的命令 -p 708 指定PID号708的进程 -D ./ 指定内存dump进程文件存储位置 运行指令得到：\n尝试检索dump出来的文件的字符串，使用如下命令：\nstrings 708.dmp | grep Lunar-3 说明\nstrings 708.dmp 打印出708.dmp二进制文件中的可打印字符 | 管道符，可以将左边命令输出的数据传递右边的命令处理 grep Lunar-3 检索有Lunar字符串所在的行并打印 运行命令得到：\n发现是存在相关字符串内容，增加点参数来获得字符串的上下文内容，执行如下命令：\nstrings 708.dmp | grep Lunar-3 -A 3 -B 3 说明\n-A 3 检索字符串所在行的前3行 -B 3 检索字符串所在行的后3行 执行命令得到：\n发现存在可疑字符串：0tt3r8r33z3\n感觉这个字符串应该就是用户名，尝试提交成功\n故flag是：\nCTF{0tt3r8r33z3} Name Game 2 # 查看题目描述：\nFrom a little research we found that the username of the logged on character is always after this signature: 0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2} What\u0026#39;s rick\u0026#39;s character\u0026#39;s name? 这道题目应该寻找相关的字符，需要进行模糊搜索\n这道题目有两种解题方法：\n使用Linux的hexdump和grep命令来进行联合检索 使用Hexedit类工具进行逐一寻找来确定相应位置 Method 1 # 使用如下Linux命令：\nhexdump -C 708.dmp | grep \u0026#34;64\u0026#34; -A 5 -B 5 | grep \u0026#34;40 06\u0026#34; -A 5 -B 5 | grep \u0026#34;5a 0c 00 00\u0026#34; -A 5 -B 5 执行命令获得：\n由于dump文件比较大，因此，这个命令可能需要执行4-5min才能执行出来结果，运行命令比较简单，但是运行时间相对比较长。\n运行得到的字符串就是M0rtyL0L\n故此题的flag就是CTF{M0rtyL0L}\nMethod 2 # 使用WinHex之类的工具进行查看搜索5a0c0000\n进行Hex value的搜索，依次对搜索列表进行比对和寻找：\n最后找到目标位置：\n这种方式要进行查找比对，查找速度快的话是比Linux命令要快些，但是就是需要不断的人工比对和查看\n得到字符串M0rtyL0L\n故此题的flag就是CTF{M0rtyL0L}\n这两种解题方法各有利弊，可以根据个人的喜好选择求解，个人更倾向于Linux那种解法，输入完命令就可以喝杯茶慢慢等，一会儿结果就出来了\nSilly Rick # 查看题目描述\nSilly rick always forgets his email\u0026#39;s password, so he uses a Stored Password Services online to store his password. He always copy and paste the password so he will not get it wrong. whats rick\u0026#39;s email password? 根据题目描述，可以确定的关键语句copy and paste，说明邮箱地址应该是存储在粘贴板上面，可以查看下内存的粘贴板。\n使用vol的如下指令查看粘贴板信息：\n可以发现的粘贴板信息：M@il_Pr0vid0rs\n故此题的flag就是：\nCTF{M@il_Pr0vid0rs} Hide And Seek # 查看题目描述\nThe reason that we took rick\u0026#39;s PC memory dump is because there was a malware infection. Please find the malware process name (including the extension) 根据题目描述，应该是需要寻找下恶意软件进程名称，vol这个软件功能非常强大，可以直接使用malfind的参数进行扫描，使用如下指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 malfind | grep Process 得到恶意进程信息：\n可以简单的归纳下恶意进程的信息：\nName Pid WmiPrvSE.exe 2136 explorer.exe 2728 BitTorrent.exe 2836 PresentationFo 724 mscorsvw.exe 412 mscorsvw.exe 3124 svchost.exe 3196 chrome.exe 4076 vmware-tray.ex 3720 WebCompanionIn 3880 Lavasoft.WCAss 3496 WebCompanion.e 3856 这些是可能的恶意进程，需要找到题目要求的恶意进程，看看进程的cmd指令，使用如下指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 cmdline 得到：\n可以看到有一个进程是在Temp目录下进行执行，这个进程应该就是恶意进程了，一般恶意进程会在Temp目录中运行。\n故恶意进程就是vmware-tray.exe\n故此题的flag就是CTF{vmware-tray.exe}\nPath To Glory # 查看题目描述：\nHow did the malware got to rick\u0026#39;s PC? It must be one of rick old illegal habits... 应该是要寻找的Rick的不良习惯，进行文件扫描来尝试确定可疑的文件\n文件扫描使用filescan指令，由于是要寻找Rick的文件需要进行简单过滤下，使用如下命令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i \u0026#34;Rick\u0026#34; 说明\ngrep -i \u0026quot;Rick\u0026quot; 忽略大小写检索Rick 得到：\n发现一个torrent文件，可以猜测Rick应该平时会进行torrent种子文件的下载，而且这个种子文件的位置一般是在Rick And Morty文件夹下面。因此，进一步过滤查看相关信息，使用如下指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i \u0026#34;Rick And Morty\u0026#34; 得到：\n发现有一个文件的权限比较可疑，尝试将这个文件进行dump，来查看文件具体信息\n使用如下命令进行dump：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007dae9350 -D ./ 说明\ndumpfiles dump文件指令 -Q 0x000000007dae9350 以物理偏移为0x000000007dae9350的文件作为对象 -D ./ dump文件目录在./目录下 得到：\n查看下dump文件中的可打印字符串数据\n执行如下命令：\nstrings file.None.0xfffffa801b42c9e0.dat 得到可打印字符串信息：\n故此题的flag应该是藏在e7:website19:M3an_T0rren7_4_R!cke这段字符串中，对这段字符串仔细观察，可以发现这段字符串是有一些明显特征的\n可以发现e是作为开头结尾的引用，中间的数据就是7:website19:M3an_T0rren7_4_R!ck，应该是三个对象显然最后一个对象应该是就是flag\n故此题的flag就是CTF{M3an_T0rren7_4_R!ck}\nPath To Glory 2 # 查看题目描述：\nContinue the search after the way that malware got in. 需要继续寻找关于恶意软件的信息，要往深入探索应该需要探索浏览器的相关信息，由于Rick被恶意攻击是由于Rick在浏览器上下载种子文件\n把浏览器的进程内存dump出来查看关键的信息\n使用如下指令来dump相关信息：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -n chrome -D ./f/ 说明\nmemdump dump内存命令 -n chrome 以进程名称作为内存对象 -D ./f/ dump内存文件./f/目录 使用strings命令来获取内存文件的可打印字符串，并添加download.exe.torrent作为过滤，由于恶意文件名是download.exe.torrent，因此采用这种方式进行过滤\n使用如下指令：\nstrings ./f/* | grep \u0026#34;download\\.exe\\.torrent\u0026#34; -A 10 -B 10 得到：\n这串字符看样子是挺奇怪的，应该就是flag信息\n尝试发现真正的flag数据是Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@in\n故此题的flag是CTF{Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@in}\nBit 4 Bit # 查看题目描述：\nWe\u0026#39;ve found out that the malware is a ransomware. Find the attacker\u0026#39;s bitcoin address. 恶意软件是一个勒索软件，需要将那个恶意软件进行分析\n首先需要dump出恶意软件的进程，使用procdump将进程dump作为一个可执行程序\n使用如下命令进行dump：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 procdump -p 3720 -D ./ 说明\nprocdump dump进程作为一个可执行文件 -p 3720 以PID作为进程对象 -D ./ 将可执行文件存储在./目录 得到：\n需要对文件进行分析，首先查看软件的相关信息：\n发现恶意软件是一个.NET的文件，可以使用dnSpy进行查看，拖进dnSpy进行寻找发现：\n一个GUI绘制流，根据GUI的代码信息，使用PS绘制出GUI：\n比特币地址显而易见就是：1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M\n故此题的flag就是CTF{1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M}\nGraphic’s For The Weak # 查看题目描述：\nThere\u0026#39;s something fishy in the malware\u0026#39;s graphics. 使用dnSpy加载恶意软件，可以在资源目录中找到：\n故本题的flag就是CTF{S0_Just_M0v3_Socy}\nRecovery # 查看题目描述：\nRick got to have his files recovered! What is the random password used to encrypt the files? 对恶意软件进行审计，找到关键的密码发送函数：\n发现密码是根据计算机名称和用户名以及密码一起发送的，要dump恶意软件的内存信息，使用如下指令进行dump：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 3720 -D ./ 执行命令得到：\n使用strings命令进行检索，由于程序的数据是16字节小端序数据，.NET程序的用2字节表示一个字符串，所以是16字节小端序数据，因此使用如下命令进行过滤检索：\nstrings -el 3720.dmp | grep WIN-LO6FAF3DTFE-Rick 运行得到：\n故此，密码就是aDOBofVYUNVnmp7\n故此题的flag就是CTF{aDOBofVYUNVnmp7}\nClosure # 查看题目描述：\nNow that you extracted the password from the memory, could you decrypt rick\u0026#39;s files? 要找文件并且解密文件。猜测存在一个flag文件，使用如下指令进行文件扫描：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i \u0026#34;flag\u0026#34; 运行命令得到：\n应该是桌面上的Flag.txt文件\n将文件进行dump，使用如下命令进行文件dump：\nol.py -f OtterCTF.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007e410890 -D ./ 运行得到：\n下面就需要对文件进行解密了\n首先对dnSpy反编译的代码进行审计可以看到是：\nhidden tear的程序算法\n继续进行分析，可以发现一个AES的加密算法：\n进行跟进分析可以发现一个加密文件的函数：\n对这两个关键函数进行代码审计发现，核心的加密算法还是AES的算法\n根据目前的分析情况，如果要解密这个文件主要有两种思路\n根据加密算法写解密脚本进行解密 使用HiddenTearDecrypt工具进行解密 HiddenTearDecrypt工具解密 # 由于在文件中发现了HiddenTear的关键信息，可以直接去检索HiddenTearDecrypt:\nHiddenTearDecrypt工具在网络上都是可以进行下载的\n尝试使用工具进行解密发现不能成功求解。由于加密代码是采用CBC模式进行加密，会对文件进行填充，只要删除掉文件的填充应该就可以正常解密，使用winhex打开文件：\n可以发现有很多00字节的填充，只要删除00字节的填充就可以进行正常的解密，使用工具进行解密\n解密成功，打开文件得到flag：\nCTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll} 解密脚本解密 # 由于加密代码已经进行分析，对于加密的情况已经基本清晰\nPython编写解密脚本的难点应该是在于生成器的替代，CS中的Rfc2898DeriveBytes可以使用Python中的PBKDF2进行替代\n解密脚本主要难度其实已经克服，根据加密写解密脚本：\nfrom Crypto.Protocol.KDF import PBKDF2 from Crypto.Cipher import AES from hashlib import sha256 def AES_Decrypt(c,password): salt = bytes([1, 2, 3, 4, 5, 6, 7, 8]) kdf = PBKDF2(password, salt, 48, count = 1000) key = kdf[:32] iv = kdf[32:] aes = AES.new(key=key,iv=iv,mode=AES.MODE_CBC) m = aes.decrypt(c) return m password = b\u0026#34;aDOBofVYUNVnmp7\u0026#34; p = sha256(password).digest() with open(\u0026#34;./file.dat\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() raw = AES_Decrypt(data,p) with open(\u0026#34;./file.txt\u0026#34;,\u0026#34;wb\u0026#34;) as new: new.write(raw) 运行后得到解密文件，打开文件得到flag：\nCTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll} 两种解法都可以正常进行求解，求解得到flag。\n用工具求解可能比较快，但是存在一定的局限性，需要对加密文件进行一定的处理\n用脚本求解可能相对较慢，但是比较灵活可以灵活地处理文件，对解密脚本编写熟练的，可以尝试写脚本求解，速度也不慢\n","date":"October 4, 2022","permalink":"/posts/otterctf_2018_memory_forensic_writeup/","section":"Posts","summary":"OtterCTF 2018 Memory Forensic Reappearance # 想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3\n环境配置：Kali Linux 2022 工具配置：volatility + mimikatz\nInfo # 题目附件就一个镜像，先查看下镜像的指纹数据：\n5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：\nvol.py -f OtterCTF.vmem imageinfo 说明\nvol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：\n可以看到大致的镜像系统是Win7系统\nWhat the password? # 查看题目描述：\nyou got a sample of rick\u0026#39;s PC\u0026#39;s memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：\n对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取\n使用如下指令使用mimikatz插件进行获取：\nvol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息：","title":"OtterCTF 2018 内存取证复现"},{"content":"","date":"October 4, 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"October 4, 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"October 4, 2022","permalink":"/tags/writeup/","section":"Tags","summary":"","title":"writeup"},{"content":"","date":"September 4, 2022","permalink":"/categories/practice/","section":"Categories","summary":"","title":"practice"},{"content":"","date":"September 4, 2022","permalink":"/tags/reverse/","section":"Tags","summary":"","title":"Reverse"},{"content":"攻防世界 RE 日常练习 002 # 由于攻防世界界面改版，题目划分与之前的题目划分出现了差异，变成了难度划分形式，和之前的不太一样。为了之前形式一致，故更改为日常练习\n新版攻防世界界面：\n本次把攻防世界难度为1的题目补了下，找下CTF题目的手感。不过攻防世界难度1的题目，难度真的很不一致。\nxxxorrr # 这道题目应该是攻防世界的一道新题目，难度应该是比较低的。\n首先使用die查看下程序信息： amd64架构的程序，无壳，使用ida pro直接看：\n进入到主程序可以发现：\n程序非常简单，仅仅只是进行了异或操作。觉得这个程序就是简单的异或操作。寻找关键的数据：\n以为这样就结束了，使用脚本跑，结果跑不出来flag，于是只能继续分析程序代码，主程序前面有一个程序函数执行，可能有进行操作：\n跟进这个函数发现返回了一个可能是系统函数的一个函数\n使用搜索引擎查找这个函数得到这个函数的功能描述：\n说明这个函数会注册一个函数在主函数结束的时候进行调用，跟进注册的函数：\n发现一个比较有意思的函数，应该就是进行判断的关键函数，中间进行了比较。\n由于对s1变量的操作存在有一定的怀疑，于是查找s1变量的交叉引用来查看信息找到一个交叉引用，这个交叉引用对s1进行操作\n继续跟进交叉引用，发现这个函数在init函数内部进行调用\n因此，s1变量进行了两次操作，根据原理编写exp：\ns1 =[ 0x71, 0x61, 0x73, 0x78, 0x63, 0x79, 0x74, 0x67, 0x73, 0x61, 0x73, 0x78, 0x63, 0x76, 0x72, 0x65, 0x66, 0x67, 0x68, 0x6E, 0x72, 0x66, 0x67, 0x68, 0x6E, 0x6A, 0x65, 0x64, 0x66, 0x67, 0x62, 0x68, 0x6E, 0x00 ] s2 = [ 0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46, 0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C, 0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43, 0x2B, 0x26, 0x89, 0xFE, 0x00 ] print(len(s1)) print(len(s2)) flag = [] for i in range(34): flag.append(s1[i]^(2 * i + 65)^s2[i]) print(bytes(flag)) 运行得到flag：flag{c0n5truct0r5_functi0n_in_41f}\nhappyctf # 题目给到了一个exe文件和一个pdb符号文件。使用die查看文件架构和文件信息：\n发现是一个PE32的命令行程序，无壳，使用ida直接看：\n加载程序的时候，也要加载pdb查看：\n看样子应该是一个C++的程序，很多程序名都已经被粉碎了，所在位置应该就是主函数的所在位置，直接F5来查看程序的伪代码：\n寻找到关键信息来进行突围，进行简单的代码审计发现：\n一串可疑的字符串，字符串应该是需要进行比较的字符串，但是这个字符串不像是flag的样子，应该需要进行一定的操作，发现字符串前面有一个lamda操作：\n跟进这个lamda操作的所在函数：\n发现有异或操作，这道题目的考点应该就是lamda函数的异或操作\n根据异或操作编写exp：\nc = b\u0026#39;brxusoCqxw{yqK`{KZqag{r`i\u0026#39; flag = [] for i in c: flag.append(i^0x14) print(bytes(flag)) 运行脚本得到flag，vflag{Welcome_to_Neusoft}\n纯纯的签到题目\ncrypt # 题目名是密码，应该会涉及到加密的问题\n使用die进行查看程序信息：\nPE64程序，无壳，直接丢进ida里面进行静态审计：\n整个程序写到挺简单的，没有复杂的逻辑\n看样子是进行了异或操作。\n前面有两个函数进行了加密操作，关键的应该就是这两个函数：\n两个函数，应该就是关键的加密函数，跟进函数进行审计：\n第一个函数的加密，在逻辑上还是稍微有些复杂的，至少我现在还审计不出来具体是什么样的加密算法。\n看第二个函数的加密：\n第二个函数的加密对于输入的数据进行异或操作。最开始，尝试使用正向的方式进下加密后求解，发现出错的可能性相对来说比较高，因此，尝试思考另一种思路：\n使用x64dbg动态调试，得到进行异或的数据，然后使用输入数据进行异或来获取需要进行异或的数据，再进行主程序的异或0x22来进行获取的flag。\n根据这个思路进行调试：\n在ida找到相应的地址位置\n然后再x64dbg定位的相应地址下断\n找到相应位置的数据，在内存中寻找：\n大致就是在这个位置的数据，将这个位置的数据复制出来，根据思路编写exp：\nc = \u0026#39;EB 98 42 2B CF 7C DC 23 2F 57 6D 5C BD 0D A7 78 CC 45 EE 72 EB 45 00 00\u0026#39;.split(\u0026#39; \u0026#39;) target = [ 158, 231, 48, 95, 167, 1, 166, 83, 89, 27, 10, 32, 241, 115, 209, 14, 171, 9, 132, 14, 141, 43 ] flag = [] for i in range(22): flag.append(target[i]^0x22^(int(c[i], 16)^0x31)) print(bytes(flag)) 运行脚本得到flag，b'flag{nice_to_meet_you}'\n1000Click # 题目应该是要点击1000次才会给出flag，首先使用die查看程序信息：\nPE32程序，无壳。使用64dbg进行调试找下位置进行下断修改数据，这是最开始的思路。这个思路相对来说是要进行定位。但是谁能想到flag就写在内存里面了呢？\n这样就get到了flag，flag{TIBntXVbdZ4Z9VRtoOQ2wRlvDNIjQ8Ra}\nreverse_re3 # 看下题目描述：\n看题目描述，应该是一道迷宫题目，使用die进行查看：\nELF程序，无壳，拖进ida pro直接看\n主程序非常简单关键的应该是函数sub_940\n跟进这个函数：\n应该是一个走迷宫的程序，ascii为97是a ，ascii为100是d，ascii为115是s，ascii为119是w 。这些操作就是很多小游戏都会采用到的移动操作，可以判断应该是一道迷宫题。既然是迷宫题，地图会在哪里，函数最开始有一个sub_86c的函数，不会根据我们的输入而进行修改，这个函数应该是一个初始化函数，跟进函数查看下信息：\n这个应该是迷宫数组，跟进查看发现果真就是迷宫数组的信息：\n看样子应该就是迷宫数组，下面应该是跟进迷宫逻辑：\n在初始化的过程中进行了入口点寻找来找到入口点，也就迷宫的起点位置。\n进行看操作逻辑：\n如果是1就更新一下所在位置，重新设置下起点，如果是4返回1，都不是就返回0。\n返回的1和0是什么意思？需要看一下主函数逻辑：\n根据主函数的逻辑，如果返回1就说明走到终点了，进入到下一层。相当于就是三层迷宫，走三遍路径，根据走出迷宫的操作数来获取相应的flag数据。所以这题还是要将迷宫的地图输出出来，看看究竟是什么样子：\n[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] [1, 1, 1, 1, 1, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0] [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0] [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0] [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0] [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0] [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0] [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0] [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0] [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0] [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] [1, 1, 0, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0] [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0] [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0] [1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0] [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0] [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0] [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0] [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0] [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0] [1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0] [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0] [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0] [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] [0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0] [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0] [0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0] [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0] [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0] 这个迷宫，如果写代码跑需要寻路算法来跑出来，手动走的话会比写程序快很多。因此，本菜鸡采用手动走迷宫的方式进行寻路，来找到路径，最终走出来的路径是：ddsssddddsssdssdddddsssddddsssaassssdddsddssddwddssssssdddssssdddss\n然后将这个数据加密成md5得到flag：flag{aeea66fcac7fa80ed8f79f38ad5bb953}\nlucknum # 题目纯纯签到题，使用die进行查看：\nELF程序，AMD64架构的，无壳程序。\n这道题目，可以直接丢进hex editor进行查找flag来得到flag。也可以使用ida pro直接看，本质上没有多大区别。\n这里直接使用ida看：\nflag直接就有了，flag是flag{c0ngr@tul@ti0n_f0r_luck_numb3r}\n","date":"September 4, 2022","permalink":"/posts/xctf-reverse_daliy_002/","section":"Posts","summary":"攻防世界 RE 日常练习 002 # 由于攻防世界界面改版，题目划分与之前的题目划分出现了差异，变成了难度划分形式，和之前的不太一样。为了之前形式一致，故更改为日常练习\n新版攻防世界界面：\n本次把攻防世界难度为1的题目补了下，找下CTF题目的手感。不过攻防世界难度1的题目，难度真的很不一致。\nxxxorrr # 这道题目应该是攻防世界的一道新题目，难度应该是比较低的。\n首先使用die查看下程序信息： amd64架构的程序，无壳，使用ida pro直接看：\n进入到主程序可以发现：\n程序非常简单，仅仅只是进行了异或操作。觉得这个程序就是简单的异或操作。寻找关键的数据：\n以为这样就结束了，使用脚本跑，结果跑不出来flag，于是只能继续分析程序代码，主程序前面有一个程序函数执行，可能有进行操作：\n跟进这个函数发现返回了一个可能是系统函数的一个函数\n使用搜索引擎查找这个函数得到这个函数的功能描述：\n说明这个函数会注册一个函数在主函数结束的时候进行调用，跟进注册的函数：\n发现一个比较有意思的函数，应该就是进行判断的关键函数，中间进行了比较。\n由于对s1变量的操作存在有一定的怀疑，于是查找s1变量的交叉引用来查看信息找到一个交叉引用，这个交叉引用对s1进行操作\n继续跟进交叉引用，发现这个函数在init函数内部进行调用\n因此，s1变量进行了两次操作，根据原理编写exp：\ns1 =[ 0x71, 0x61, 0x73, 0x78, 0x63, 0x79, 0x74, 0x67, 0x73, 0x61, 0x73, 0x78, 0x63, 0x76, 0x72, 0x65, 0x66, 0x67, 0x68, 0x6E, 0x72, 0x66, 0x67, 0x68, 0x6E, 0x6A, 0x65, 0x64, 0x66, 0x67, 0x62, 0x68, 0x6E, 0x00 ] s2 = [ 0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46, 0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C, 0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43, 0x2B, 0x26, 0x89, 0xFE, 0x00 ] print(len(s1)) print(len(s2)) flag = [] for i in range(34): flag.","title":"攻防世界 RE 日常练习 002"},{"content":"2022 网鼎杯 青龙组 Writeup # 今年网鼎杯的逆向题目是相对来说比较简单的，在比赛的时候做出了两道逆向题目。\n第二道逆向apk的题目找到文章了，但是去看Crypto的题目了，也就没有认真去钻逆向的那道题目。\nCrypto题目由于自身的数学敏感度不够没能解出，还需要继续提高\n解出 # fakeshell # 题目给到了一个exe文件，使用die查看该文件：\n发现是一个upx压缩壳加密的程序，尝试使用upx脱壳：\n发现壳可能被修改过，需要手动脱壳。先尝试运行下程序，寻找下可能存在的锚点字符串信息：\n找到两个锚点字符串，一个是\u0026lt;\u0026lt;Input your flag:，另一个是Wrong.\n使用x64dbg进行手动脱壳，进行入口点的测试找到一个关键跳转地址0x1400276CB\n这是一个长跳转指令，运行到这个指令的时候程序已经完成解密。可以对程序的内存引用进行查看：\n发现程序的内存引用中已经出现了锚点字符串，说明此时的程序已经完成了解密。然后跟进到锚点字符串所在的函数位置：\n这个位置应该是主函数空间，在这个主函数空间中对函数开头位置下断点，然后让程序运行到断点位置\n然后使用x64dbg的Scylla插件进行dump内存：\n从当前位置进行dump即可，得到一个dump的程序。\n现在完成手动脱壳，进入到下一步，进行ida pro的静态分析：\n使用F5插件来查看程序反编译的代码进行分析\n输入的数据存储到v4变量中，对v4变量处理的函数有两个，对这两个函数依次进行审计。\n首先分析第一个函数，这个函数要一直跟进跟进到和参数有关的位置\n第一个函数中，存在一个判断和一个异或运算。\n判断是对输入的数据进行了处理，猜测应该是进行长度判断，判断长度是否是20位。\n异或操作是单纯对于输入数据的运行对于程序运行流程没有太多影响\n分析第二个函数，和第一个函数的跟进方法类似\n第二个函数同样也有一个异或操作和一个特殊的函数，跟进这个函数查看：\n发现判断的位置有密文，跟进密文查看：\n使用shift+ E将数据提取出来，可以得到：\nunsigned char ida_chars[] = { 0x4B, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x6D, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; 显然是以4字节，小端序存储的\n现在获取的密文和两次运算，编写脚本：\nc = [ 0x4B, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x6D, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ] c = c[::4] flag = [0]*0x14 for i in range(0x14): flag[i] = chr(((c[i]^0x50)-10)^0x66) print(\u0026#34;\u0026#34;.join(flag)) 运行得到flag：\nwhy_m0dify_pUx_SheLL Handmake # 这道题目是手工，应该是需要手工寻找一些内容\n题目给到了一个go程序的源码：\n总共有大约15w行的代码，尝试编译运行：\n应该是英文的阅读理解找函数的题目，理解这两句话的意思就可以求解。\nInput the first function, which has 6 parameters and the third named gLIhR: 这句话就是找到一个有六个参数的函数而且第三个参数是gLIhR\nInput the second function, which has 3 callers and invokes the function named cHZv5op8rOmlAkb6:\n这句话就是找到一个函数，这个函数被调用了3次并且调用了一个名为cHZv5op8rOmlAkb6函数。\n根据要求去寻找函数名：\n然后进行程序的测试就可以得到flag：\n复现 # Crypto091 # 这道题目被队友解答，我就没有进行看了，赛后进行复现下\n这道题目要寻找到关键信息，本道题目的关键信息有：\n170号段首批放号的联通号码 Hash： c22a563acc2a587afbfaaaa6d67bc6e628872b00bd7e998873881f7c6fdc62fc flag格式：flag{13位电话号码（纯数字，含国家代码）} 使用搜索引擎进行查找：\n1709是首批号码段，下面是对hash的类型进行猜测，首先看看哈希的长度：\nhash数据的长度是64位可能是sha256加密，可以使用hacker工具Hashcat进行爆破求解：\nhashcat -m 1400 -a 3 c22a563acc2a587afbfaaaa6d67bc6e628872b00bd7e998873881f7c6fdc62fc 861709?d?d?d?d?d?d?d 运行得到：\n由此可以得到tel是8617091733716，故flag是flag{8617091733716}\ngrasshopper # 这道题目当时代码没有审计清楚，采用Z3-solver进行求解，未能求解成功\n题目给到一个python源码：\nfrom Crypto.Util.number import * from random import randrange from grassfield import flag p = getPrime(16) k = [randrange(1,p) for i in range(5)] for i in range(len(flag)): grasshopper = flag[i] for j in range(5): k[j] = grasshopper = grasshopper * k[j] % p print(\u0026#39;Grasshopper#\u0026#39;+str(i).zfill(2)+\u0026#39;:\u0026#39;+hex(grasshopper)[2:].zfill(4)) 进行审计可以发现：\n$$ k_{10} = g_0 = C_0 \\cdot k_{00}\\ \\text{mod}\\ p \\\\ k_{11} = g_0 = C_0 \\cdot k_{00} \\cdot k_{01}\\ \\text{mod}\\ p \\\\ k_{12} = g_0 = C_0 \\cdot k_{00} \\cdot k_{01}\\cdot k_{02}\\ \\text{mod}\\ p \\\\ k_{13} = g_0 = C_0 \\cdot k_{00} \\cdot k_{01}\\cdot k_{02}\\cdot k_{03}\\ \\text{mod}\\ p \\\\ k_{14} = g_0 = C_0 \\cdot k_{00} \\cdot k_{01}\\cdot k_{02}\\cdot k_{03} \\cdot k_{04}\\ \\text{mod}\\ p \\\\ $$\n$$ k_{20} = g_0 = C_1 \\cdot k_{10}\\ \\text{mod}\\ p \\\\ k_{21} = g_0 = C_1 \\cdot k_{10} \\cdot k_{11}\\ \\text{mod}\\ p \\\\ k_{22} = g_0 = C_1 \\cdot k_{10} \\cdot k_{11}\\cdot k_{12}\\ \\text{mod}\\ p \\\\ k_{23} = g_0 = C_1 \\cdot k_{10} \\cdot k_{11}\\cdot k_{12}\\cdot k_{13}\\ \\text{mod}\\ p \\\\ k_{24} = g_0 = C_1 \\cdot k_{10} \\cdot k_{11}\\cdot k_{12}\\cdot k_{13} \\cdot k_{14}\\ \\text{mod}\\ p \\\\ $$ 可以发现有规律存在，已知$k_{14}\\ k_{24}\\ k_{34}\\ k_{44}\\ k_{54}$ 可以推出$k_{23}\\ k_{33}\\ k_{43}\\ k_{53}$\n同理可以推出$k_{32}\\ k_{42}\\ k_{52}$，依此可以推出$k_{41}\\ k_{51}$ 和$k_{50}$\n推导公式： $$ k_{ij} = k_{i(j+1)} \\cdot k_{(i-1)j}^{-1}\\ \\text{mod}\\ p $$ 根据推导公式可以进行求解：\nfrom gmpy2 import invert,gcd from sympy import isprime know = b\u0026#39;flag{\u0026#39; g = [] with open(\u0026#39;./output.txt\u0026#39;,\u0026#39;r\u0026#39;) as f: for line in f.readlines(): line = line.strip(\u0026#39;\\n\u0026#39;) g.append(int(line[-4:],16)) maxg = max(g) for p in range(maxg+1, 2**16): if isprime(p): g04 = g[0] g14 = g[1] g13 = g14 * invert(g04, p) % p g24 = g[2] g23 = g24 * invert(g14, p) % p g22 = g23 * invert(g13, p) % p g34 = g[3] g33 = g34 * invert(g24, p) % p g32 = g33 * invert(g23, p) % p g31 = g32 * invert(g22, p) % p g44 = g[4] g43 = g44 * invert(g34, p) % p g42 = g43 * invert(g33, p) % p g41 = g42 * invert(g32, p) % p g40 = g41 * invert(g31, p) % p k = [g40, g41, g42, g43, g44] flag = \u0026#39;\u0026#39; for i in range(5,42): _k = k[0]*k[1]*k[2]*k[3]*k[4] alp = g[i] * invert(_k, p) % p flag += chr(alp) for j in range(5): k[j] = alp = alp * k[j] % p if flag.endswith(\u0026#39;}\u0026#39;): print(f\u0026#39;p = {p}\u0026#39;) print(b\u0026#39;flag{\u0026#39;+flag.encode()) 运行代码得到：\np = 59441 b\u0026#39;flag{749d39d4-78db-4c55-b4ff-bca873d0f18e}\u0026#39; 这种思路是由局部推断整体的想法，可能将题目的过程复杂化，而显得不是非常优雅。\n此题的求解脚本还可以使用sagemath进行相应的脚本求解，思路也是大致一样的思路。\n构造一个p的整数环，来进行运算求解，这种求解方法反而会更加简单，sagemath求解的脚本：\ng = [] with open(\u0026#39;./output.txt\u0026#39;,\u0026#39;r\u0026#39;) as f: for line in f.readlines(): line = line.strip(\u0026#39;\\n\u0026#39;) g.append(int(line[-4:],16)) maxg = max(g) for p in range(maxg, 2^16): if is_prime(p): flag = g F = GF(p) for _ in range(5): data = [] for j in range(len(flag)-1): data.append(F(flag[j+1])/F(flag[j])) flag = data try: print(b\u0026#39;flag{\u0026#39;+bytes(data)) except: pass 运行脚本就可以得到flag，b'flag{749d39d4-78db-4c55-b4ff-bca873d0f18e}'\n这种脚本的思路就是直接进行整体运算来求解。\ndavid_homework # 这道题目是当时考虑是将递归转循环来进行求解，但是时间复杂度还是很高，不能正常进行求解。想到线性代数的提示，时间已经所剩无几，故未能完成求解\n题目说到是一个线性代数的作业，应该是一个线性代码相关的问题求解。\n赛题给到的代码是一个含有递归的函数：\n通过搜索引擎搜索关键信息\n搜索 递归函数转线代 : (191条消息) 线性代数求解递推形式数列的通项公式_wdq347的博客-CSDN博客 搜索 递推 线代 : 线性代数-递推法解“数字型”行列式_哔哩哔哩_bilibili 搜索 线性代数-递推法解“数字型”行列式 : 递推公式法在行列式计算中的证明与应用 - 知乎 (zhihu.com) 搜索 递推公式法 行列式 找到文章：怎么用递归法计算行列式? - 知乎 (zhihu.com)\n根据文章：\n显然这道题目是要求求解出逆过程，首先需要抽象出递推函数的递归公式：\n$$ f(x,cof) = \\left\\{ \\begin{array}{l} x+1 \u0026amp; \u0026amp; {x \u0026lt; 3} \\\\ cof_2\\cdot f(x-3) + cof_1\\cdot f(x-2) + cof_0\\cdot f(x-1) \u0026amp; \u0026amp; {x \\geq 3} \\end{array} \\right. $$\n根据查找到的一系列文章中的(191条消息) 线性代数 —— 线性递推关系_Alex_McAvoy的博客-CSDN博客_线性递推关系，可以看到：\n根据关系可以得到\n$$ f(n) = A * f(n-1) $$\n$$ A = \\left[\\begin{array}{ccc} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ cof_2 \u0026amp; cof_1 \u0026amp; cof_0 \\end{array} \\right] $$\n$$ f(n-1) = \\left[ \\begin{array}{l} f(n-3) \\\\ f(n-2) \\\\ f(n-1) \\\\ \\end{array} \\right] $$\n紧接着根据这个：\n可以得到： $$ F(n) = A^{n-2}\\cdot f(2) $$\n$$ f(2) = \\left[ \\begin{array}{l} f(0)\\\\ f(1) \\\\ f(2) \\\\ \\end{array} \\right] = \\left[ \\begin{array}{l} 1\\\\ 2 \\\\ 3 \\\\ \\end{array} \\right] $$\n尝试使用sagemath求解，出现报错\n进行次方运算必须是一个方块矩阵，也就是矩阵的维度必须是2x2, 3x3 … n x n 的矩阵，进行运算推导下： $$ f(n) = A * f(n-1) = \\left[ \\begin{array}{c} f(n-3) \\\\ f(n-2) \\\\ f(n-1) \\\\ cof_2\\cdot f(n-3) + cof_1\\cdot f(n-2) + cof_0\\cdot f(n-1) \\end{array} \\right] $$\n继续进行推导： $$ f(n-1) = A * f(n-2) = \\left[ \\begin{array}{c} f(n-4) \\\\ f(n-3) \\\\ f(n-2) \\\\ cof_2\\cdot f(n-4) + cof_1\\cdot f(n-3) + cof_0\\cdot f(n-2) \\end{array} \\right] $$\n$$ A * f(n-1) \\\\ = \\left[\\begin{array}{l} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ cof_2 \u0026amp; cof_1 \u0026amp; cof_0 \\end{array} \\right] \\cdot \\left[ \\begin{array}{c} f(n-4) \\\\ f(n-3) \\\\ f(n-2) \\\\ cof_2\\cdot f(n-4) + cof_1\\cdot f(n-3) + cof_0\\cdot f(n-2) \\end{array} \\right] $$\n此时无法进行运算，进行推导发现将A修改成如下形式运算结果不变：\n$$ A = \\left[ \\begin{array}{ccc} 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ cof_2 \u0026amp; cof_1 \u0026amp; cof_0 \\end{array} \\right] $$\n再次尝试编写sage代码进行运算：\n# sagemath from hashlib import md5, sha256 from binascii import unhexlify cof_t = [ [353, -1162, 32767], [206, -8021, 42110], [262, -7088, 31882], [388, -6394, 21225], [295, -9469, 44468], [749, -3501, 40559], [528, -2690, 10210], [354, -5383, 18437], [491, -8467, 26892], [932, -6984, 20447], [731, -6281, 11340], [420, -5392, 44071], [685, -6555, 40938], [408, -8070, 47959], [182, -9857, 49477], [593, -3584, 49243], [929, -7410, 31929], [970, -4549, 17160], [141, -2435, 36408], [344, -3814, 18949], [291, -7457, 40587], [765, -7011, 32097], [700, -8534, 18013], [267, -2541, 33488], [249, -8934, 12321], [589, -9617, 41998], [840, -1166, 22814], [947, -5660, 41003], [206, -7195, 46261], [784, -9270, 28410], [338, -3690, 19608], [559, -2078, 44397], [534, -3438, 47830], [515, -2139, 39546], [603, -6460, 49953], [234, -6824, 12579], [805, -8793, 36465], [245, -5886, 21077], [190, -7658, 20396], [392, -7053, 19739], [609, -5399, 39959], [479, -8172, 45734], [321, -7102, 41224], [720, -4487, 11055], [208, -1897, 15237], [890, -4427, 35168], [513, -5106, 45849], [666, -1137, 23725], [755, -6732, 39995], [589, -6421, 43716], [866, -3265, 30017], [416, -6540, 34979], [840, -1305, 18242], [731, -6844, 13781], [561, -2728, 10298], [863, -5953, 23132], [204, -4208, 27492], [158, -8701, 12720], [802, -4740, 16628], [491, -6874, 29057], [531, -4829, 29205], [363, -4775, 41711], [319, -9206, 46164], [317, -9270, 18290], [680, -5136, 12009], [880, -2940, 34900], [162, -2587, 49881], [997, -5265, 20890], [485, -9395, 23048], [867, -1652, 18926], [691, -7844, 11180], [355, -5990, 13172], [923, -2018, 23110], [214, -4719, 23005], [921, -9528, 29351], [349, -7957, 20161], [470, -1889, 46170], [244, -6106, 23879], [419, -5440, 43576], [930, -1123, 29859], [151, -5759, 23405], [843, -6770, 36558], [574, -6171, 33778], [772, -1073, 44718], [932, -4037, 40088], [848, -5813, 27304], [194, -6016, 39770], [966, -6789, 14217], [219, -6849, 40922], [352, -6046, 18558], [794, -8254, 29748], [618, -5887, 15535], [202, -9288, 26590], [611, -4341, 46682], [155, -7909, 16654], [935, -5739, 39342], [998, -6538, 24363], [125, -5679, 36725], [507, -7074, 15475], [699, -5836, 47549] ] B = [[1], [2], [3]] B = matrix(B) s = 0 for i in range(100): A = [[0,1,0],[0,0,1], cof_t[i][::-1]] A = matrix(A) C = A ^ (200000-2) * B s += C[2][0] s = str(s)[-2000:-1000] key = unhexlify(md5(s.encode()).hexdigest()) check = sha256(key).hexdigest() verify = \u0026#39;2cf44ec396e3bb9ed0f2f3bdbe4fab6325ae9d9ec3107881308156069452a6d5\u0026#39; print(f\u0026#39;s= {s}\u0026#39;) print(f\u0026#39;key = {key}\u0026#39;) print(f\u0026#39;hash(key) = {check}\u0026#39;) print(f\u0026#39;check = {check==verify}\u0026#39;) 运行sagemath脚本得到：\ns= 8365222366127410597598169954399481033882921410074214649102398062373189165630613993923060190128768377015697889610969869189338768501949778819512483009804114510646333513147157016729806311717181191848898389803672575716843797638777123435881498143998689577186959772296072473194533856870919617472555638920296793205581043222881816090693269730028856738454951305575065708823347157677411074157254186955326531403441609073128679935513392779152628590893913048822608749327034655805831509883357484164977115164240733564895591006693108254829407400850621646091808483228634435805213269066211974452289769022399418497986464430356041737753404266468993201044272042844144895601296459104534111416147795404108912440106970848660340526207025880755825643455720871621993251258247195860214917957713359490024807893442884343732717743882154397539800059579470352302688717025991780505564794824908605015195865226780305658376169579983423732703921876787723921599023795922881747318116849413935343800909756656082327558085457335537828343666748 key = b\u0026#39;S29O\\x9a\\xf3Z\\x87\\xe5\\xbc{?D`xB\u0026#39; hash(key) = 2cf44ec396e3bb9ed0f2f3bdbe4fab6325ae9d9ec3107881308156069452a6d5 check = True 现在已经获取到了密钥key，使用python进行aes解密即可。\n注意：！！！\n如果使用的是Python3.10版本，可能会出现报错：\nSystemError: PY_SSIZE_T_CLEAN macro must be defined for '#' formats\n这种情况是由于pycrypto库导致的问题，进行求解可以尝试安装miniconda创建python虚拟环境，切换到python3.8安装pycrypto库进行求解就可以正常求解\n求解python脚本：\nfrom hashlib import md5, sha256 from binascii import unhexlify from Crypto.Cipher import AES s = \u0026#39;836522236612741059759816995439948103388292141007421464910239806237318916563061399392306019012876837701569788\\ 96109698691893387685019497788195124830098041145106463335131471570167298063117171811918488983898036725757168437976\\ 38777123435881498143998689577186959772296072473194533856870919617472555638920296793205581043222881816090693269730\\ 02885673845495130557506570882334715767741107415725418695532653140344160907312867993551339277915262859089391304882\\ 26087493270346558058315098833574841649771151642407335648955910066931082548294074008506216460918084832286344358052\\ 13269066211974452289769022399418497986464430356041737753404266468993201044272042844144895601296459104534111416147\\ 79540410891244010697084866034052620702588075582564345572087162199325125824719586021491795771335949002480789344288\\ 43437327177438821543975398000595794703523026887170259917805055647948249086050151958652267803056583761695799834237\\ 32703921876787723921599023795922881747318116849413935343800909756656082327558085457335537828343666748\u0026#39; key = unhexlify(md5(s.encode()).hexdigest()) aes = AES.new(key,AES.MODE_ECB) c = \u0026#39;4f12b3a3eadc4146386f4732266f02bd03114a404ba4cb2dabae213ecec451c9d52c70dc3d25154b5af8a304afafed87\u0026#39; print(aes.decrypt(unhexlify(c)).strip(b\u0026#39;\\x00\u0026#39;)) 运行脚本即可得到相应的flag: b'flag{519427b3-d104-4c34-a29d-5a7c128031ff}'\nwhereiscode # 这道题目当时是找到文章了但是当时去看密码学题目了，没有细看这道题目\n题目给到了一个apk程序文件，但是主程序里面没有程序的源代码：\n感觉没有什么思路去处理，对程序的具体结构仔细分析：\n发现有一个类似于壳的代码程序，尝试进行搜索找到了壳的相关博客和程序源码。\ndpt壳程序文章：Android函数抽取壳的实现 - luoyesiqiu - 博客园 (cnblogs.com)\ndpt壳源码：luoyesiqiu/dpt-shell: Android函数抽取壳实现 (github.com)\n下载壳工具的release版本，进行反编译查看dpt.jar java包文件，可以使用jadx进行反编译查看内容，找到dpt函数进行代码逻辑的审计\n根据文章，这个壳是一个函数抽取壳会进行函数的抽取壳：\n文章也把壳运行的整个流程逻辑写出来了：\n根据文章的信息，这道题目首先的一个子任务就是脱壳，而脱壳目前来说的目标就是对整个壳程序的逻辑进行分析。对整个流程大致分析下，发现主要是对于Dex进行操作，首先可以在dpt函数中搜索Dex关键字来定位到函数位置：\n找到一个关键的函数，跟进这个函数，可以找到些许信息\n这个函数打开了一个OoooooOooo的文件，这是一个关键的文件信息，可能依据文章中的逻辑找到原来字节码的存储位置。这个函数不长，简单来说就是对原有的Dex进行提取，然后将提取的Dex写入到这个文件中，主要是写入操作的具体实现\n跟进writeMultiDexCode查看内部实现情况：\n感觉是比较类似于pe结构的实现方式，也就是找到相应的位置进行求解\n应该就是类似的一种结构，知道相应的函数偏移位置和相应的数据大小来对dex文件的函数进行抽取，根据这个原理可以进行PE文件结构类似的操作方式进行处理。编写一个小的程序将抽取出来的数据重新填充到相应的位置中。\n可以编写一个python脚本进行脱壳处理：\nfrom struct import unpack with open(\u0026#39;./classes2.dex\u0026#39;,\u0026#39;rb\u0026#39;) as f: data = f.read() with open(\u0026#39;./OoooooOooo\u0026#39;, \u0026#39;rb\u0026#39;) as f: raw = f.read() print(f\u0026#34;version = {unpack(\u0026#39;\u0026lt;H\u0026#39;,raw[0:2])[0]}\u0026#34;) print(f\u0026#34;dexcount = {unpack(\u0026#39;\u0026lt;H\u0026#39;,raw[2:4])[0]}\u0026#34;) print(f\u0026#34;dexCodesIndex1 = {unpack(\u0026#39;\u0026lt;I\u0026#39;,raw[4:8])[0]}\u0026#34;) print(f\u0026#34;dexCodesIndex2 = {unpack(\u0026#39;\u0026lt;I\u0026#39;,raw[8:12])[0]}\u0026#34;) pos = 0x10 while(True): method_index = unpack(\u0026#39;\u0026lt;I\u0026#39;,raw[pos:pos+4])[0] pos += 4 offset_dex = unpack(\u0026#39;\u0026lt;I\u0026#39;,raw[pos:pos+4])[0] pos += 4 instruction_data_size = unpack(\u0026#39;\u0026lt;I\u0026#39;,raw[pos:pos+4])[0] pos += 4 instruction_data = raw[pos:pos+instruction_data_size] pos += instruction_data_size data = data[:offset_dex]+instruction_data + data[offset_dex+instruction_data_size:] if pos == len(raw): break with open(\u0026#39;./classes2_dump.dex\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(data) 脱壳后的程序，可以使用dex2jar程序进行解包，可以得到一个jar包程序：\n可以直接解压得到一个文件夹，文件夹里面含有程序的class文件：\n这个文件结构是Android程序包的文件结构，我们关注的点应该就是com文件夹，进入到com\\example\\nothingcode文件夹中：\n这两个核心文件应该就是程序的主要文件，使用jd-gui工具进行java字节码文件的反编译来获取到java源码文件来看到程序的真实代码：\n直接将程序保存成一个java源代码文件\n点击Save来保存反编译的源码\n使用java ide进行源码的审计，打开生成的源代码文件，一看多少会有些惊讶：\n有很多混淆和switch，应该是控制流平坦化的方式进行代码混淆的。这种混淆方式主要是由于一个发生器来形成switch结构，来混淆整个程序的主要流程结构。这种混淆的解决方式主要是脚本去混淆和静态代码审计来获取到主要的程序流程。\n尝试寻找些未进行混淆的字符串，来确定大致的逻辑特征：\n可以看出flag的数据应该是位于password的输入位置，往下继续寻找发现：\n发现，check函数对str2和str3进行了处理，而str2和str3就对应的是两个输入框的内容，根据一般输入行的原理，应该是第一个输入行是用户名，而第二个输入行是密码。进入到check函数中一探究竟：\n字符串str2有一个等于判断，判断str2是不是等于“helloctf” 这显然像是一个用户名，而不是密码。由于密码是flag这个设定，所以这个str2的形式显然不像是flag的形式。下面寻找字符串str3的操作：\n找到str3的相关操作，并且找到一组数据，暂时不清楚这组数据有什么用。这个操作显然是把str3转成一个Int数组的操作，跟进函数查看具体操作情况：\n函数内部有两个操作，一个是判断长度的操作，另一个是除法操作。应该是进行Int数组的初始化处理，继续探究后续操作：\n进行大端序处理的操作，以及后面有迭代的操作，根据目前分析的情况。可以判断这个函数就是将字符串以大端序的方式转成Int数组。\n这个函数分析完毕继续探究以下的内容：\n发现非常有趣的特征，一个特征是\u0026lt;32说明可能有32轮次，后面两个运算方程。这些特征和TEA加密算法的特征类似。尝试进行TEA算法的比对，TEA加密算法有32轮次加密并且每轮加密的算法也是相应的一致。由此可以判断这个加密算法应该就是TEA加密算法。\n现在找到了加密算法，一个加密算法应该有相应的密钥和相应的密文以及明文。由于我们输入的内容就是要加密的明文，因此找到密文和密钥就可能求解出此题。进行寻找相关信息：\n可以大致看出这个数据像是密文的，之前找到的四个成员的数组数据比较符号TEA加密算法的密钥形式，据此推断那个数据应该就是密钥。而且数据只对Int数组进行了加密前面两个成员。没有加密其他成员。\n可以大致总结下，加密的大致逻辑：\n根据整合的逻辑可以编写脚本进行求解：\nfrom ctypes import * def decrypt(v, k): x = c_int32(v[0]) y = c_int32(v[1]) delta = -1640531527 total = c_uint32(delta * 32) for i in range(32): y.value -= ((x.value \u0026lt;\u0026lt; 4) + k[2]) ^ (x.value + total.value) ^ ((x.value \u0026gt;\u0026gt; 5) + k[3]) x.value -= ((y.value \u0026lt;\u0026lt; 4) + k[0]) ^ (y.value + total.value) ^ ((y.value \u0026gt;\u0026gt; 5) + k[1]) total.value -= delta return x.value, y.value c_bytes = [ -63, -69, -86, 43, 126, 114, 32, -75, 102, 49, 65, 103, 121, 107, 111, 99 ] c = [] for i in range(0,len(c_bytes),4): num = \u0026#39;\u0026#39; for v in range(4): num += hex((c_bytes[i+v] + 256)%256)[2:].zfill(2) num = int(num,16) if num \u0026lt; pow(2,31): c.append(num) else: c.append(num-pow(2,32)) key = [2023708229, -158607964, -2120859654, 1167043672] m = list(decrypt(c,key)) + c[2:4] flag = b\u0026#39;\u0026#39; for i in m: f = [int(hex(i)[2:][v:v+2],16) for v in range(0,8,2)] flag += bytes(f) print(f\u0026#39;flag{{{flag.decode()}}}\u0026#39;) 运行得到flag：flag{Givey0urf1Agykoc}\n这道题目的脱壳方法也很多种，可以使用frida进行hook，然后让程序运行到解密的位置进行内存dump来进行脱壳。当然还有另一个方法也可以进行脱壳，在网上搜索到的一篇博客中有详细说明：(191条消息) Android脱壳之整体脱壳原理与实践，今天带你详细了解各组件原理_m0_64604636的博客-CSDN博客_android 脱壳\n","date":"August 31, 2022","permalink":"/posts/2022_wdb_ql-writeup/","section":"Posts","summary":"2022 网鼎杯 青龙组 Writeup # 今年网鼎杯的逆向题目是相对来说比较简单的，在比赛的时候做出了两道逆向题目。\n第二道逆向apk的题目找到文章了，但是去看Crypto的题目了，也就没有认真去钻逆向的那道题目。\nCrypto题目由于自身的数学敏感度不够没能解出，还需要继续提高\n解出 # fakeshell # 题目给到了一个exe文件，使用die查看该文件：\n发现是一个upx压缩壳加密的程序，尝试使用upx脱壳：\n发现壳可能被修改过，需要手动脱壳。先尝试运行下程序，寻找下可能存在的锚点字符串信息：\n找到两个锚点字符串，一个是\u0026lt;\u0026lt;Input your flag:，另一个是Wrong.\n使用x64dbg进行手动脱壳，进行入口点的测试找到一个关键跳转地址0x1400276CB\n这是一个长跳转指令，运行到这个指令的时候程序已经完成解密。可以对程序的内存引用进行查看：\n发现程序的内存引用中已经出现了锚点字符串，说明此时的程序已经完成了解密。然后跟进到锚点字符串所在的函数位置：\n这个位置应该是主函数空间，在这个主函数空间中对函数开头位置下断点，然后让程序运行到断点位置\n然后使用x64dbg的Scylla插件进行dump内存：\n从当前位置进行dump即可，得到一个dump的程序。\n现在完成手动脱壳，进入到下一步，进行ida pro的静态分析：\n使用F5插件来查看程序反编译的代码进行分析\n输入的数据存储到v4变量中，对v4变量处理的函数有两个，对这两个函数依次进行审计。\n首先分析第一个函数，这个函数要一直跟进跟进到和参数有关的位置\n第一个函数中，存在一个判断和一个异或运算。\n判断是对输入的数据进行了处理，猜测应该是进行长度判断，判断长度是否是20位。\n异或操作是单纯对于输入数据的运行对于程序运行流程没有太多影响\n分析第二个函数，和第一个函数的跟进方法类似\n第二个函数同样也有一个异或操作和一个特殊的函数，跟进这个函数查看：\n发现判断的位置有密文，跟进密文查看：\n使用shift+ E将数据提取出来，可以得到：\nunsigned char ida_chars[] = { 0x4B, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x6D, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; 显然是以4字节，小端序存储的","title":"2022 网鼎杯 青龙组 Writeup"},{"content":"攻防世界 RE 进阶区 日常练习 001 # ISCC比赛临近，CTF比赛题目也要开始继续训练起来 前段时间，由于准备升学相关的事宜，没有进行比赛的训练 手感相对而言，有些生疏 简单从攻防世界平台找几道逆向的题目进行简单的练习下\n这几道题目主要都是使用IDA pro的远程调试功能，使用虚拟机搭配IDA进行远程调试\nre2-cpp-is-awesome # 先查看一些文件的简单信息 ELF文件，GCC编译，无壳\nIDA看下： C++编译的程序文件，看的心烦意乱基本上找不到关键的函数，和关键的位置。\n尝试使用下IDA pro的动调寻找一下f关键位置(IDA pro的动态消失配置可以自己网络检索，有很多相关的内容)\n先断在第一个跳转位置，即jz short loc_400BD7 位置上\n进行几次调试，发现都直接退出，没有进行跳转 也就是 cmp [rbp+var_64], 2 的比较值没有改变ZF标志位 对上面汇编代码进行审计：\nmain proc near var_70= qword ptr -70h var_64= dword ptr -64h var_60= qword ptr -60h var_50= byte ptr -50h var_21= byte ptr -21h var_20= qword ptr -20h var_14= dword ptr -14h push rbp mov rbp, rsp push rbx sub rsp, 68h mov [rbp+var_64], edi mov [rbp+var_70], rsi cmp [rbp+var_64], 2 指令cmp [rbp+var_64], 2是一个条件判断，根据这个语句寻找下变量\nrbp+64 = edi 根据Linux x64 fastcall的调用约定，可以知道edi寄存器存储着函数的第一个参数，main函数的第一参数是运行程序附加的参数。所以根据条件，应该是程序运行的时候要携带一个参数进行运行。\n因此，尝试使用传参调用来进行寻找关键的函数（当然也可以使用修改ZF标志位）。现在进入下一步的探索：\n一路F8寻找退出位置，找到退出位置是在call sub_400B56位置 点开函数看下\nsub_400B56 proc near ; CODE XREF: main+F5↓p push rbp mov rbp, rsp mov esi, offset aBetterLuckNext ; \u0026#34;Better luck next time\\n\u0026#34; mov edi, offset _ZSt4cout ; std::cout call __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(std::ostream \u0026amp;,char const*) mov edi, 0 ; status call _exit 简单审计下，发现函数，就是一个错误输出的函数，应该不是关键判断的位置。因此，需要往上继续寻找。\n退出函数上面有jz short loc_400C83跳转，说明应该是存在条件判断，进行向上寻找条件判断的语句。\n找到cmp dl al指令这个应该是核心的条件判断指令 指令比较的是dl寄存器和al寄存器存储的值 dl寄存器是dx寄存器的低位，al寄存器是ax寄存器的低位。相应地，寻找下对eax或rax、edx或rdx的操作\nlea rax, [rbp+var_50] mov rdi, rax call __ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE3endEv ; std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::end(void) mov [rbp+var_20], rax lea rdx, [rbp+var_20] lea rax, [rbp+var_60] mov rsi, rdx mov rdi, rax call sub_400D3D test al, al jz short loc_400C95 lea rax, [rbp+var_60] mov rdi, rax call sub_400D9A movzx edx, byte ptr [rax] mov rcx, cs:off_6020A0 ; \u0026#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{\u0026#34;... mov eax, [rbp+var_14] cdqe mov eax, dword_6020C0[rax*4] cdqe add rax, rcx movzx eax, byte ptr [rax] 可以寻找到相应的关系，由于C++面向对象STL反汇编实在是比较难搞懂，经过反复调试，发现关键的函数是在这几行：\nmovzx edx, byte ptr [rax] mov rcx, cs:off_6020A0 ; \u0026#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{\u0026#34;... mov eax, [rbp+var_14] cdqe mov eax, dword_6020C0[rax*4] cdqe add rax, rcx movzx eax, byte ptr [rax] 对于这个指令，应该就是对数组进行取值组合，可以看下dword_6020C0存储的数据 中间的align 8 指令会根据不同编译器和cpu而呈现不同的行为，align指令简单来说也就是数据宽度对齐，根据数据的规律，可以大致知道是每隔三个0一个有效数据。\n上面存储了一个字符串：\n.rodata:0000000000400E58 aL3tMeT3llY0uS0 db \u0026#39;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t\u0026#39; .rodata:0000000000400E58 db \u0026#39;_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t\u0026#39;,0 提取出来的字符串是：\nL3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t 然后提取一下上面数组存储的数据：\nunsigned char ida_chars[] = { 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00 }; 现在知道一些已有的数据，下面需要对算法逻辑进行推导： 根据上面找到的关键指令进行C语言代码转化：\nint rax = 0; char str[] = \u0026#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t\u0026#34;; unsigned char ida_chars[] = { 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00 }; if (*(argv + rax) != str[ida_chars[rax*4]]) { Error_exit(); } 在继续跟逻辑，跟进上面的指令，整体看下汇编，进行C语言整合：\nchar str[] = \u0026#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t\u0026#34;; unsigned char ida_chars[] = { 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00 }; for (int i = 0; i \u0026lt; 31; i++) { if (*(argv + i) != str[ida_chars[i*4]]) { Error_exit(); } } 现在主要逻辑基本已经整合成C语言代码，下面根据主要的逻辑，编写一个C语言代码进行求解：\n#include \u0026lt;stdio.h\u0026gt; int main() { char string[] = \u0026#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1\u0026#34;; char ida_chars[] = { 0x24, 0x00, 0x05, 0x36, 0x65, 0x07, 0x27, 0x26, 0x2D, 0x01, 0x03, 0x00, 0x0D, 0x56, 0x01, 0x03, 0x65, 0x03, 0x2D, 0x16, 0x02, 0x15, 0x03, 0x65, 0x00, 0x29, 0x44, 0x44, 0x01, 0x44, 0x2B }; char flag[31]; for (int i = 0; i \u0026lt; 31; i++) { flag[i] = string[ida_chars[i]]; } printf(\u0026#34;%s\\n\u0026#34;, flag); return 0; } 编译并运行程序，得到：\nALEXCTF{W3_L0v3_C_W1th_CL45535} 补充知识：\nLinux x64 fastcall 调用约定\nLinux 下的调用约定叫做 “System V AMD64 ABI”，此约定主要在 Solaris，GNU/Linux，FreeBSD 和其他非微软OS上使用； Linux 的 x64 下也只有一种函数调用约定，即 __fastcall ，其他调用约定的关键字会被忽略，也就是说 ABI 只有__fastcall ； 一个函数在调用时，如果参数个数小于等于 6 个时，前 6 个参数是从左至右依次存放于 RDI，RSI，RDX，RCX，R8，R9 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈； 如果参数个数大于 6 个时，前 5 个参数是从左至右依次存放于 RDI，RSI，RDX，RCX，RAX 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈； 对于系统调用，使用 R10 代替 RCX； easyRE1 # 附件中是一个rar文件，解压后的文件夹含有两个文件 一个easy-32文件 一个easy-64文件\n查看下文件的大致信息： ELF x64位程序，通过gcc进行编译的，没有壳 使用IDA pro 查看下程序\npush rbp mov rbp, rsp sub rsp, 120h mov [rbp+var_114], edi mov [rbp+var_120], rsi mov rax, fs:28h mov [rbp+var_8], rax xor eax, eax mov edi, offset s ; \u0026#34;What is the password?\u0026#34; call _puts lea rax, [rbp+s1] mov rdi, rax mov eax, 0 call _gets lea rax, [rbp+s1] mov esi, offset s2 ; \u0026#34;the password\u0026#34; mov rdi, rax ; s1 call _strcmp test eax, eax jnz short loc_40068F mov edi, offset aFlagDb2f62a36a ; \u0026#34;FLAG:db2f62a36a018bce28e46d976e3f9864\u0026#34; call _puts jmp short loc_400699 loc_40068F: ; CODE XREF: main+5B↑j mov edi, offset aWrong ; \u0026#34;Wrong!!\u0026#34; call _puts 发现程序就挺简单的，关键信息就直接呈现出来了\nmov edi, offset aFlagDb2f62a36a ; \u0026#34;FLAG:db2f62a36a018bce28e46d976e3f9864\u0026#34; 这道题目的Flag应该就是：\nflag{db2f62a36a018bce28e46d976e3f9864} Reversing-x64Elf-100 # 查看下文件信息，应该是Elf的文件，使用DIE查看下程序信息 Elf x64程序，没有壳，gcc编译。 使用IDA看下，发现整个程序还是比较简单的，逻辑流程比较清晰\nmain proc near ; DATA XREF: start+1D↑o s = byte ptr -110h var_8 = qword ptr -8 ; __unwind { push rbp mov rbp, rsp sub rsp, 110h mov rax, fs:28h mov [rbp+var_8], rax xor eax, eax mov edi, offset format ; \u0026#34;Enter the password: \u0026#34; mov eax, 0 call _printf mov rdx, cs:stdin ; stream lea rax, [rbp+s] mov esi, 0FFh ; n mov rdi, rax ; s call _fgets test rax, rax jz short loc_400866 lea rax, [rbp+s] mov rdi, rax call sub_4006FD test eax, eax jnz short loc_400855 mov edi, offset s ; \u0026#34;Nice!\u0026#34; call _puts mov eax, 0 jmp short loc_40086B loc_400855: ; CODE XREF: main+5A↑j mov edi, offset aIncorrectPassw ; \u0026#34;Incorrect password!\u0026#34; call _puts mov eax, 1 其实也就是一个判断，来判断flag的数据是否正确，主要应该就是对sub_4006FD函数的分析， 下面就需要进入sub_4006FD函数里面，观察这个函数的行为\nsub_4006FD proc near ; CODE XREF: main+53↓p var_38 = qword ptr -38h var_24 = dword ptr -24h var_20 = qword ptr -20h var_18 = qword ptr -18h var_10 = qword ptr -10h push rbp mov rbp, rsp mov [rbp+var_38], rdi mov [rbp+var_24], 0 mov [rbp+var_20], offset aDufhbmf ; \u0026#34;Dufhbmf\u0026#34; mov [rbp+var_18], offset aPgImos ; \u0026#34;pG`imos\u0026#34; mov [rbp+var_10], offset aEwuglpt ; \u0026#34;ewUglpt\u0026#34; mov [rbp+var_24], 0 jmp short loc_40079B loc_40072D: ; CODE XREF: sub_4006FD+A2↓j mov ecx, [rbp+var_24] mov edx, 55555556h mov eax, ecx imul edx mov eax, ecx sar eax, 1Fh sub edx, eax mov eax, edx add eax, eax add eax, edx sub ecx, eax mov edx, ecx movsxd rax, edx mov rsi, [rbp+rax*8+var_20] mov ecx, [rbp+var_24] mov edx, 55555556h mov eax, ecx imul edx mov eax, ecx sar eax, 1Fh sub edx, eax mov eax, edx add eax, eax cdqe add rax, rsi movzx eax, byte ptr [rax] movsx edx, al mov eax, [rbp+var_24] movsxd rcx, eax mov rax, [rbp+var_38] add rax, rcx movzx eax, byte ptr [rax] movsx eax, al sub edx, eax mov eax, edx cmp eax, 1 jz short loc_400797 mov eax, 1 jmp short loc_4007A6 loc_400797: ; CODE XREF: sub_4006FD+91↑j add [rbp+var_24], 1 loc_40079B: ; CODE XREF: sub_4006FD+2E↑j cmp [rbp+var_24], 0Bh jle short loc_40072D mov eax, 0 loc_4007A6: ; CODE XREF: sub_4006FD+98↑j pop rbp retn sub_4006FD endp 算法分析 # 关键应该是根据汇编代码来进行算法解读 找到关键的汇编代码：\njmp short loc_40079B loc_40072D: ; CODE XREF: sub_4006FD+A2↓j mov ecx, [rbp+var_24] mov edx, 55555556h mov eax, ecx imul edx mov eax, ecx sar eax, 1Fh sub edx, eax mov eax, edx add eax, eax add eax, edx sub ecx, eax mov edx, ecx movsxd rax, edx mov rsi, [rbp+rax*8+var_20] mov ecx, [rbp+var_24] mov edx, 55555556h mov eax, ecx imul edx mov eax, ecx sar eax, 1Fh sub edx, eax mov eax, edx add eax, eax cdqe add rax, rsi movzx eax, byte ptr [rax] movsx edx, al mov eax, [rbp+var_24] movsxd rcx, eax mov rax, [rbp+var_38] add rax, rcx movzx eax, byte ptr [rax] movsx eax, al sub edx, eax mov eax, edx cmp eax, 1 jz short loc_400797 mov eax, 1 jmp short loc_4007A6 loc_400797: ; CODE XREF: sub_4006FD+91↑j add [rbp+var_24], 1 loc_40079B: ; CODE XREF: sub_4006FD+2E↑j cmp [rbp+var_24], 0Bh jle short loc_40072D mov eax, 0 这一大段代码应该就是关键的汇编代码，开始像剥洋葱一样，一层一层剥下这个程序的逻辑\nmov ecx, [rbp+var_24] mov edx, 55555556h mov eax, ecx imul edx mov eax, ecx sar eax, 1Fh sub edx, eax mov eax, edx 这段代码是 [rpb+var_24] / 3 ，可能看不明白，在《C++反汇编揭秘》一书中给出了除法的汇编运算模型，也算是编译器的一个模型。 $$ \\frac{\\text{ecx} \\cdot M}{2^{n+1}} $$ 这里的M是指mov edx, 55555556h中的数值55555556h， 这里的n是指sar eax, 1Fh中的数值1Fh 根据公式，可以推导出除数的计算公式\n$$ 除数 = \\frac{2^{n+1}}{M} $$ 根据根据推导的除法公式进行计算，得到除数是3。（关于除法的汇编分析可以阅读看雪一个师傅写的博客：[原创]#30天写作挑战#反汇编代码还原之除数为非2的幂-编程技术-看雪论坛-安全社区|安全招聘|bbs.pediy.com）\n现在可以清晰地明白了这段代码就是 ：n / 3\n接下来，看下面一段代码：\nadd eax, eax add eax, edx sub ecx, eax mov edx, ecx 这一段代码，是比较容易理解的，结合着上面的代码：\neax = n / 3 edx = n / 3 ecx = n 根据信息，这段代码应该就是n - 3 * (n / 3)，可能有些人感觉很晕乎，着其实是取余运算，简言之，就是 n % 3，仔细分析下，就会发现和 n % 3的结果一致。 现在这大段代码就是 n % 3\n继续往下走起！\nmovsxd rax, edx mov rsi, [rbp+rax*8+var_20] 这个非常简单，就是数组喽，即rbp[n % 3]\n接下来往下看\nmov ecx, [rbp+var_24] mov edx, 55555556h mov eax, ecx imul edx mov eax, ecx sar eax, 1Fh sub edx, eax mov eax, edx add eax, eax 非常明显的除法，这段代码就是2 * (n / 3) 后面紧跟着一段代码：\ncdqe add rax, rsi movzx eax, byte ptr [rax] movsx edx, al 其实就是对上面数据的一个整合，也就是\n*(rbp[n % 3] + 2 * (n / 3)) 现在最难读懂的部分已经过去了，剩下的部分就比较简单，一口气读完\nmov eax, [rbp+var_24] movsxd rcx, eax mov rax, [rbp+var_38] add rax, rcx movzx eax, byte ptr [rax] movsx eax, al 直接读就行了，结合程序的信息：\nrax : arg rcx : n 所以这段代码就是\n*(arg + n) 核心部分已经处理完毕了，再整体审计下代码得到\nfor (int i = 0; i \u0026lt;= 11; i++) { if ( *(rbp[ i % 3 ] + 2 * (i / 3)) - *(arg + i) != 1) { return 1; } } 根据这样的代码，可以继续优化下，得到\nfor (size_t i = 0; i \u0026lt;= 11; i++) { if ( rbp[i % 3][2 * (i / 3)] - str[i] != 1) { return 1; } } 求解 # 根据核心代码的分析，可以编写程序进行求解：\n#include \u0026lt;stdio.h\u0026gt; int main() { char *v3[4]; v3[0] = \u0026#34;Dufhbmf\u0026#34;; v3[1] = \u0026#34;pG`imos\u0026#34;; v3[2] = \u0026#34;ewUglpt\u0026#34;; char flag[13] = {0}; for(int i = 0; i \u0026lt;= 11; i++) { flag[i] = v3[i%3][2*(i/3)] - 1; } printf(\u0026#34;%s\\n\u0026#34;, flag); return 0; } 编译并运行程序，得到\nCode_Talkers 这道题目，主要考察运算的汇编理解。对于汇编的识别还是有一定要求的。至于我为什么不使用IDA pro的F5的Hex-rays插件的功能，我是想要进一步提高自身对于汇编语言的理解，而Hex-rays在很多时候都是无法使用，在真正的逆向工程中，更多的还是人工进行还原，而不是使用IDA的插件进行还原。而且，我是在进行练习，自然是希望挖掘到更多的知识点和技巧点。如果是比赛的话，肯定是更多采用F5的功能。\nBABYRE # 这道题目，有些技巧，不过总体还是挺有意思的。 看下程序信息先： ELF x64程序 GCC编译的程序 使用IDA pro看看\nmain proc near ; DATA XREF: _start+1D↑o s = byte ptr -20h var_8 = dword ptr -8 var_4 = dword ptr -4 ; __unwind { push rbp mov rbp, rsp sub rsp, 20h mov [rbp+var_4], 0 jmp short loc_400637 loc_400617: ; CODE XREF: main+38↓j mov eax, [rbp+var_4] cdqe movzx eax, judge[rax] xor eax, 0Ch mov edx, eax mov eax, [rbp+var_4] cdqe mov judge[rax], dl add [rbp+var_4], 1 loc_400637: ; CODE XREF: main+F↑j cmp [rbp+var_4], 0B5h jle short loc_400617 mov edi, offset format ; \u0026#34;Please input flag:\u0026#34; mov eax, 0 call _printf lea rax, [rbp+s] mov rsi, rax mov edi, offset a20s ; \u0026#34;%20s\u0026#34; mov eax, 0 call ___isoc99_scanf lea rax, [rbp+s] mov rdi, rax ; s call _strlen mov [rbp+var_8], eax cmp [rbp+var_8], 0Eh jnz short loc_400698 mov edx, offset judge lea rax, [rbp+s] mov rdi, rax call rdx ; judge test eax, eax jz short loc_400698 mov edi, offset s ; \u0026#34;Right!\u0026#34; call _puts jmp short loc_4006A2 loc_400698: ; CODE XREF: main+72↑j ; main+84↑j mov edi, offset aWrong ; \u0026#34;Wrong!\u0026#34; call _puts loc_4006A2: ; CODE XREF: main+90↑j mov eax, 0 leave retn ; } // starts at 400606 main endp 问题分析 # 主程序的汇编并不很难的样子，但是这里是有坑的\n如果直接看主逻辑的话，没有什么难度。 主逻辑就是一个函数判断的问题，如果函数判断成功，就返回正确，错误就返回错误。 但是仔细看下，调用了一个Judge数据，相当于调用了数据。根据这个数据转换成函数会发现这个数据被混淆了。一直集中这个区域，就不知道怎么混淆。怎么跳出这个坑？这个的解决方法就挺简单的，放大一些自己的观测区域，能看到一些关键点\nloc_400617: ; CODE XREF: main+38↓j mov eax, [rbp+var_4] cdqe movzx eax, judge[rax] xor eax, 0Ch mov edx, eax mov eax, [rbp+var_4] cdqe mov judge[rax], dl add [rbp+var_4], 1 loc_400637: ; CODE XREF: main+F↑j cmp [rbp+var_4], 0B5h jle short loc_400617 这段代码对judge数据进行异或处理，静态观察就不能看到准确的judge数据。如果想要正确看到这个函数的数据，就需要看到运行过程中的运行数据。解决方法有两个，一种是静态解决方案，另一种是动态解决方案。\n静态解决方案 # 采用静态反汇编的方案，也就比较简单，直接在IDA里面嵌入执行脚本，使用执行脚本对数据进行异或修改。IDA pro支持嵌入Python脚本进行异或操作来修改数据。进行异或来得到正确的数据。\n运行一次，然后将judge数据段进行代码转换，就能得到相应的函数：\njudge proc near ; CODE XREF: main+80↑p ; DATA XREF: main+16↑r ... var_28 = qword ptr -28h var_20 = byte ptr -20h var_1F = byte ptr -1Fh var_1E = byte ptr -1Eh var_1D = byte ptr -1Dh var_1C = byte ptr -1Ch var_1B = byte ptr -1Bh var_1A = byte ptr -1Ah var_19 = byte ptr -19h var_18 = byte ptr -18h var_17 = byte ptr -17h var_16 = byte ptr -16h var_15 = byte ptr -15h var_14 = byte ptr -14h var_13 = byte ptr -13h var_4 = dword ptr -4 push rbp mov rbp, rsp mov [rbp+var_28], rdi mov [rbp+var_20], 66h ; \u0026#39;f\u0026#39; mov [rbp+var_1F], 6Dh ; \u0026#39;m\u0026#39; mov [rbp+var_1E], 63h ; \u0026#39;c\u0026#39; mov [rbp+var_1D], 64h ; \u0026#39;d\u0026#39; mov [rbp+var_1C], 7Fh mov [rbp+var_1B], 6Bh ; \u0026#39;k\u0026#39; mov [rbp+var_1A], 37h ; \u0026#39;7\u0026#39; mov [rbp+var_19], 64h ; \u0026#39;d\u0026#39; mov [rbp+var_18], 3Bh ; \u0026#39;;\u0026#39; mov [rbp+var_17], 56h ; \u0026#39;V\u0026#39; mov [rbp+var_16], 60h ; \u0026#39;`\u0026#39; mov [rbp+var_15], 3Bh ; \u0026#39;;\u0026#39; mov [rbp+var_14], 6Eh ; \u0026#39;n\u0026#39; mov [rbp+var_13], 70h ; \u0026#39;p\u0026#39; mov [rbp+var_4], 0 jmp short loc_600B71 loc_600B49: ; CODE XREF: judge+75↓j mov eax, [rbp+var_4] movsxd rdx, eax mov rax, [rbp+var_28] add rax, rdx mov edx, [rbp+var_4] movsxd rcx, edx mov rdx, [rbp+var_28] add rdx, rcx movzx edx, byte ptr [rdx] mov ecx, [rbp+var_4] xor edx, ecx mov [rax], dl add [rbp+var_4], 1 loc_600B71: ; CODE XREF: judge+47↑j cmp [rbp+var_4], 0Dh jle short loc_600B49 mov [rbp+var_4], 0 jmp short loc_600BA9 loc_600B80: ; CODE XREF: judge+AD↓j mov eax, [rbp+var_4] movsxd rdx, eax mov rax, [rbp+var_28] add rax, rdx movzx edx, byte ptr [rax] mov eax, [rbp+var_4] cdqe movzx eax, [rbp+rax+var_20] cmp dl, al jz short loc_600BA5 mov eax, 0 jmp short loc_600BB4 loc_600BA5: ; CODE XREF: judge+9C↑j add [rbp+var_4], 1 loc_600BA9: ; CODE XREF: judge+7E↑j cmp [rbp+var_4], 0Dh jle short loc_600B80 mov eax, 1 loc_600BB4: ; CODE XREF: judge+A3↑j pop rbp retn judge endp 动态解决方案 # 动态解决相对来说会更简单些，就是进行动态调试，使代码运行到指定位置，然后查看数据即可，这样配置可能会有些难度，需要更高的运行性能，但是总体操作相对更简单些。\n断点断在mov edi, offset format ; \u0026quot;Please input flag:\u0026quot; 这个指令就好，然后运行下动态调试。断在这个位置，查看下Judge数据就可以得到这个函数：\njudge proc near ; CODE XREF: main+80↑p ; DATA XREF: main+16↑r ... var_28= qword ptr -28h var_20= byte ptr -20h var_1F= byte ptr -1Fh var_1E= byte ptr -1Eh var_1D= byte ptr -1Dh var_1C= byte ptr -1Ch var_1B= byte ptr -1Bh var_1A= byte ptr -1Ah var_19= byte ptr -19h var_18= byte ptr -18h var_17= byte ptr -17h var_16= byte ptr -16h var_15= byte ptr -15h var_14= byte ptr -14h var_13= byte ptr -13h var_4= dword ptr -4 push rbp mov rbp, rsp mov [rbp+var_28], rdi mov [rbp+var_20], 66h ; \u0026#39;f\u0026#39; mov [rbp+var_1F], 6Dh ; \u0026#39;m\u0026#39; mov [rbp+var_1E], 63h ; \u0026#39;c\u0026#39; mov [rbp+var_1D], 64h ; \u0026#39;d\u0026#39; mov [rbp+var_1C], 7Fh mov [rbp+var_1B], 6Bh ; \u0026#39;k\u0026#39; mov [rbp+var_1A], 37h ; \u0026#39;7\u0026#39; mov [rbp+var_19], 64h ; \u0026#39;d\u0026#39; mov [rbp+var_18], 3Bh ; \u0026#39;;\u0026#39; mov [rbp+var_17], 56h ; \u0026#39;V\u0026#39; mov [rbp+var_16], 60h ; \u0026#39;`\u0026#39; mov [rbp+var_15], 3Bh ; \u0026#39;;\u0026#39; mov [rbp+var_14], 6Eh ; \u0026#39;n\u0026#39; mov [rbp+var_13], 70h ; \u0026#39;p\u0026#39; mov [rbp+var_4], 0 jmp short loc_600B71 loc_600B49: ; CODE XREF: judge+75↓j mov eax, [rbp+var_4] movsxd rdx, eax mov rax, [rbp+var_28] add rax, rdx mov edx, [rbp+var_4] movsxd rcx, edx mov rdx, [rbp+var_28] add rdx, rcx movzx edx, byte ptr [rdx] mov ecx, [rbp+var_4] xor edx, ecx mov [rax], dl add [rbp+var_4], 1 loc_600B71: ; CODE XREF: judge+47↑j cmp [rbp+var_4], 0Dh jle short loc_600B49 mov [rbp+var_4], 0 jmp short loc_600BA9 loc_600B80: ; CODE XREF: judge+AD↓j mov eax, [rbp+var_4] movsxd rdx, eax mov rax, [rbp+var_28] add rax, rdx movzx edx, byte ptr [rax] mov eax, [rbp+var_4] cdqe movzx eax, [rbp+rax+var_20] cmp dl, al jz short loc_600BA5 mov eax, 0 jmp short loc_600BB4 loc_600BA5: ; CODE XREF: judge+9C↑j add [rbp+var_4], 1 loc_600BA9: ; CODE XREF: judge+7E↑j cmp [rbp+var_4], 0Dh jle short loc_600B80 mov eax, 1 loc_600BB4: ; CODE XREF: judge+A3↑j pop rbp retn judge endp judge函数分析 # 现在找到了函数，就需要对函数进行分析来发现关键的判断逻辑，来进行关键步骤的推理分析与判断\n对函数大致看一下，应该就是两个for循环了，第一个for循环是对参数进行异或操作，而第二个for循环是对局部变量进行操作。\n一段一段地分析吧\nmov [rbp+var_4], 0 jmp short loc_600B71 loc_600B49: ; CODE XREF: judge+75↓j mov eax, [rbp+var_4] movsxd rdx, eax mov rax, [rbp+var_28] add rax, rdx mov edx, [rbp+var_4] movsxd rcx, edx mov rdx, [rbp+var_28] add rdx, rcx movzx edx, byte ptr [rdx] mov ecx, [rbp+var_4] xor edx, ecx mov [rax], dl add [rbp+var_4], 1 loc_600B71: ; CODE XREF: judge+47↑j cmp [rbp+var_4], 0Dh jle short loc_600B49 首先对于这段代码，要知道的一些信息：\n[rbp+var_4] : i [rbp+var_28] : rdi \u0026ndash;\u0026gt; arg 所以根据这些信息，可以对这段汇编代码进行还原\nfor (int i = 0; i\u0026lt;= 0xD; i++) { *(arg+i) = *(arg+i)^i; } 接着看下面一个循环语句：\nmov [rbp+var_4], 0 jmp short loc_600BA9 loc_600B80: ; CODE XREF: judge+AD↓j mov eax, [rbp+var_4] movsxd rdx, eax mov rax, [rbp+var_28] add rax, rdx movzx edx, byte ptr [rax] mov eax, [rbp+var_4] cdqe movzx eax, [rbp+rax+var_20] cmp dl, al jz short loc_600BA5 mov eax, 0 jmp short loc_600BB4 loc_600BA5: ; CODE XREF: judge+9C↑j add [rbp+var_4], 1 loc_600BA9: ; CODE XREF: judge+7E↑j cmp [rbp+var_4], 0Dh jle short loc_600B80 这段代码应该就是核心判断的逻辑咯，需要知道点信息来进行审计：\n[rbp+var_4] : i [rbp+var_28] : rdi \u0026ndash;\u0026gt; arg [rbp+var_20] : str[0xD] 根据这些信息进行代码还原，非常简单\nfor (int i = 0; i \u0026lt;= 0xD; i++) { if(*(arg+i) != str[i]) { return 1; } } 这个函数的核心逻辑代码已经有了，现在对这个函数的代码进行整合就能得到：\nint judge(char *arg) { char str[0xD+1]; str[0] = \u0026#39;f\u0026#39;; str[1] = \u0026#39;m\u0026#39;; str[2] = \u0026#39;c\u0026#39;; str[3] = \u0026#39;d\u0026#39;; str[4] = 0x7F; str[5] = \u0026#39;k\u0026#39;; str[6] = \u0026#39;7\u0026#39;; str[7] = \u0026#39;d\u0026#39;; str[8] = \u0026#39;;\u0026#39;; str[9] = \u0026#39;V\u0026#39;; str[10] = \u0026#39;`\u0026#39;; str[11] = \u0026#39;;\u0026#39;; str[12] = \u0026#39;n\u0026#39;; str[13] = \u0026#39;p\u0026#39;; for (int i = 0; i\u0026lt;= 0xD; i++) { arg[i] = arg[i]^i; if(arg[i] != str[i]) { return 1; } } return 0; } 求解 # 现在Judge函数算是分析完成了，可以根据函数进行求解了\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char data[15] = {0}; char temp[9] = {0}; char flag[14] = {0}; memcpy(data, \u0026#34;fmcd\u0026#34;, 4); data[4] = 127; memcpy(temp, \u0026#34;k7d;V`;np\u0026#34;, 9); strcat(data,temp); for (int i = 0; i \u0026lt; 14; i++) { flag[i] = data[i] ^ i; } printf(\u0026#34;%s\\n\u0026#34;, flag); return 0; } 编译代码，并执行得到\nflag{n1c3_j0b}k7d;V`;npfmcdk7d;V`;npf flag就是前半部分，即flag{n1c3_j0b}\n这道题目也是可以使用IDA pro的Hex-Rays插件进行F5反编译的，和自己分析的结果基本上是一致的。本菜狗也只是想要提高一下自己的汇编水准，进行了相应的练习。因此并没有使用Hex-Rays插件进行反编译分析，而是直接查看汇编来进行阅读分析。\n","date":"April 23, 2022","permalink":"/posts/xctf-reverse-advanced_daliy_001/","section":"Posts","summary":"攻防世界 RE 进阶区 日常练习 001 # ISCC比赛临近，CTF比赛题目也要开始继续训练起来 前段时间，由于准备升学相关的事宜，没有进行比赛的训练 手感相对而言，有些生疏 简单从攻防世界平台找几道逆向的题目进行简单的练习下\n这几道题目主要都是使用IDA pro的远程调试功能，使用虚拟机搭配IDA进行远程调试\nre2-cpp-is-awesome # 先查看一些文件的简单信息 ELF文件，GCC编译，无壳\nIDA看下： C++编译的程序文件，看的心烦意乱基本上找不到关键的函数，和关键的位置。\n尝试使用下IDA pro的动调寻找一下f关键位置(IDA pro的动态消失配置可以自己网络检索，有很多相关的内容)\n先断在第一个跳转位置，即jz short loc_400BD7 位置上\n进行几次调试，发现都直接退出，没有进行跳转 也就是 cmp [rbp+var_64], 2 的比较值没有改变ZF标志位 对上面汇编代码进行审计：\nmain proc near var_70= qword ptr -70h var_64= dword ptr -64h var_60= qword ptr -60h var_50= byte ptr -50h var_21= byte ptr -21h var_20= qword ptr -20h var_14= dword ptr -14h push rbp mov rbp, rsp push rbx sub rsp, 68h mov [rbp+var_64], edi mov [rbp+var_70], rsi cmp [rbp+var_64], 2 指令cmp [rbp+var_64], 2是一个条件判断，根据这个语句寻找下变量","title":"攻防世界进阶区日常训练001"},{"content":"","date":"February 26, 2022","permalink":"/tags/note/","section":"Tags","summary":"","title":"note"},{"content":"","date":"February 26, 2022","permalink":"/categories/reverse/","section":"Categories","summary":"","title":"reverse"},{"content":"逻辑语句逆向分析 总结 # if分支 # if # Debug\n0x00411a30 cmp dword [var_ch], 0x41 0x00411a34 jne 0x411a47 0x00411a36 mov eax, dword [var_ch] 0x00411a39 push eax 0x00411a3a push str.This_is_current_alpha:_c 0x00411a3f call fcn.004110d7 0x00411a44 add esp, 8 0x00411a47 mov esi, esp Release\n0x004010a1 cmp dword [var_8h], 0x41 0x004010a5 jne 0x4010b6 0x004010a7 push 0x41 0x004010a9 push str.This_is_current_alpha:_c 0x004010ae call fcn.00401020 0x004010b3 add esp, 8 0x004010b6 push str.pause if_else # Debug\n0x00411a30 cmp dword [var_ch], 0x41 0x00411a34 jne 0x411a49 0x00411a36 mov eax, dword [var_ch] 0x00411a39 push eax 0x00411a3a push str.This_is_current_alpha:_c 0x00411a3f call fcn.004110d7 0x00411a44 add esp, 8 0x00411a47 jmp 0x411a56 0x00411a49 push str.error 0x00411a4e call fcn.004110d7 0x00411a53 add esp, 4 0x00411a56 mov esi, esp Release\n0x004010a1 cmp dword [var_8h], 0x41 0x004010a5 jne 0x4010b8 0x004010a7 push 0x41 0x004010a9 push str.This_is_current_alpha:_c 0x004010ae call fcn.00401020 0x004010b3 add esp, 8 0x004010b6 jmp 0x4010c5 0x004010b8 push str.error 0x004010bd call fcn.00401020 0x004010c2 add esp, 4 0x004010c5 push str.pause if_else if_else 3语句 # Debug\n0x00411a30 cmp dword [var_ch], 0x41 0x00411a34 jne 0x411a49 0x00411a36 mov eax, dword [var_ch] 0x00411a39 push eax 0x00411a3a push str.This_is_current_alpha:_c 0x00411a3f call fcn.004110d7 0x00411a44 add esp, 8 0x00411a47 jmp 0x411a6f 0x00411a49 cmp dword [var_ch], 0x42 0x00411a4d jne 0x411a62 0x00411a4f mov eax, dword [var_ch] 0x00411a52 push eax 0x00411a53 push str.This_is_error_alpha:_c 0x00411a58 call fcn.004110d7 0x00411a5d add esp, 8 0x00411a60 jmp 0x411a6f 0x00411a62 push str.error 0x00411a67 call fcn.004110d7 0x00411a6c add esp, 4 0x00411a6f mov esi, esp Release\n0x004010a4 cmp eax, 0x41 0x004010a7 jne 0x4010b9 0x004010a9 push eax 0x004010aa push str.This_is_current_alpha:_c 0x004010af call fcn.00401020 0x004010b4 add esp, 8 0x004010b7 jmp 0x4010db 0x004010b9 cmp eax, 0x42 0x004010bc jne 0x4010ce 0x004010be push eax 0x004010bf push str.This_is_error_alpha:_c 0x004010c4 call fcn.00401020 0x004010c9 add esp, 8 0x004010cc jmp 0x4010db 0x004010ce push str.error 0x004010d3 call fcn.00401020 0x004010d8 add esp, 4 0x004010db push str.pause if_else if_else 6语句 # Debug\n0x00411a30 cmp dword [var_ch], 0x41 0x00411a34 jne 0x411a49 0x00411a36 mov eax, dword [var_ch] 0x00411a39 push eax 0x00411a3a push str.This_is_current_alpha:_c 0x00411a3f call fcn.004110d7 0x00411a44 add esp, 8 0x00411a47 jmp 0x411aba 0x00411a49 cmp dword [var_ch], 0x42 0x00411a4d jne 0x411a62 0x00411a4f mov eax, dword [var_ch] 0x00411a52 push eax 0x00411a53 push str.This_is_error_alpha:_c 0x00411a58 call fcn.004110d7 0x00411a5d add esp, 8 0x00411a60 jmp 0x411aba 0x00411a62 cmp dword [var_ch], 0x43 0x00411a66 jne 0x411a7b 0x00411a68 mov eax, dword [var_ch] 0x00411a6b push eax 0x00411a6c push str.This_is_other_alpha:_c 0x00411a71 call fcn.004110d7 0x00411a76 add esp, 8 0x00411a79 jmp 0x411aba 0x00411a7b cmp dword [var_ch], 0x44 0x00411a7f jne 0x411a94 0x00411a81 mov eax, dword [var_ch] 0x00411a84 push eax 0x00411a85 push str.This_is_specify_alpha:_c 0x00411a8a call fcn.004110d7 0x00411a8f add esp, 8 0x00411a92 jmp 0x411aba 0x00411a94 cmp dword [var_ch], 0x45 0x00411a98 jne 0x411aad 0x00411a9a mov eax, dword [var_ch] 0x00411a9d push eax 0x00411a9e push str.This_is_different_alpha:_c 0x00411aa3 call fcn.004110d7 0x00411aa8 add esp, 8 0x00411aab jmp 0x411aba 0x00411aad push str.error 0x00411ab2 call fcn.004110d7 0x00411ab7 add esp, 4 0x00411aba mov esi, esp Release\n0x004010a4 cmp eax, 0x41 0x004010a7 jne 0x4010b9 0x004010a9 push eax 0x004010aa push str.This_is_current_alpha:_c 0x004010af call fcn.00401020 0x004010b4 add esp, 8 0x004010b7 jmp 0x40111a 0x004010b9 cmp eax, 0x42 0x004010bc jne 0x4010ce 0x004010be push eax 0x004010bf push str.This_is_error_alpha:_c 0x004010c4 call fcn.00401020 0x004010c9 add esp, 8 0x004010cc jmp 0x40111a 0x004010ce cmp eax, 0x43 0x004010d1 jne 0x4010e3 0x004010d3 push eax 0x004010d4 push str.This_is_other_alpha:_c 0x004010d9 call fcn.00401020 0x004010de add esp, 8 0x004010e1 jmp 0x40111a 0x004010e3 cmp eax, 0x44 0x004010e6 jne 0x4010f8 0x004010e8 push eax 0x004010e9 push str.This_is_specify_alpha:_c 0x004010ee call fcn.00401020 0x004010f3 add esp, 8 0x004010f6 jmp 0x40111a 0x004010f8 cmp eax, 0x45 0x004010fb jne 0x40110d 0x004010fd push eax 0x004010fe push str.This_is_different_alpha:_c 0x00401103 call fcn.00401020 0x00401108 add esp, 8 0x0040110b jmp 0x40111a 0x0040110d push str.error 0x00401112 call fcn.00401020 0x00401117 add esp, 4 0x0040111a push str.pause switch分支 # 规律：\n小于6条分支语句（不包括default），汇编语句不使用跳转表进行优化 大于等于6条分支语句（不包括default），汇编语句使用跳转表进行优化 最小case和最大case差值在255以内使用跳转表优化 最小case和最大case差值在255以外使用判定树优化 switch三语句 # Debug\n0x00411a39 cmp dword [var_d4h], 0 0x00411a40 je 0x411a56 0x00411a42 cmp dword [var_d4h], 1 0x00411a49 je 0x411a65 0x00411a4b cmp dword [var_d4h], 2 0x00411a52 je 0x411a74 0x00411a54 jmp 0x411a81 0x00411a56 push str.input_number_is_0 ; 0x417b34 ; int32_t arg_ch 0x00411a5b call fcn.004110d7 0x00411a60 add esp, 4 0x00411a63 jmp 0x411a81 0x00411a65 push str.input_number_is_1 ; 0x417b4c ; int32_t arg_ch 0x00411a6a call fcn.004110d7 0x00411a6f add esp, 4 0x00411a72 jmp 0x411a81 0x00411a74 push str.input_number_is_2 ; 0x417b64 ; int32_t arg_ch 0x00411a79 call fcn.004110d7 0x00411a7e add esp, 4 0x00411a81 mov esi, esp Release\n0x004010a4 sub eax, 0 0x004010a7 je 0x4010c1 0x004010a9 sub eax, 1 0x004010ac je 0x4010ba 0x004010ae sub eax, 1 0x004010b1 jne 0x4010ce 0x004010b3 push str.input_number_is_2 0x004010b8 jmp 0x4010c6 0x004010ba push str.input_number_is_1 0x004010bf jmp 0x4010c6 0x004010c1 push str.input_number_is_0 0x004010c6 call fcn.00401020 0x004010cb add esp, 4 0x004010ce push str.pause switch六语句 # Debug # 0x00411a39 cmp dword [var_d4h], 5 0x00411a40 ja case.default.0x411a48 0x00411a42 mov ecx, dword [var_d4h] 0x00411a48 jmp dword [ecx*4 + 0x411b0c] ; switch table (6 cases) at 0x411b0c 0x00411a4f push str.input_number_is_0 0x00411a54 call fcn.004110d7 0x00411a59 add esp, 4 0x00411a5c jmp case.default.0x411a48 0x00411a5e push str.input_number_is_1 0x00411a63 call fcn.004110d7 0x00411a68 add esp, 4 0x00411a6b jmp case.default.0x411a48 0x00411a6d push str.input_number_is_2 0x00411a72 call fcn.004110d7 0x00411a77 add esp, 4 0x00411a7a jmp case.default.0x411a48 0x00411a7c push str.input_number_is_3 0x00411a81 call fcn.004110d7 0x00411a86 add esp, 4 0x00411a89 jmp case.default.0x411a48 0x00411a8b push str.input_number_is_4 0x00411a90 call fcn.004110d7 0x00411a95 add esp, 4 0x00411a98 jmp case.default.0x411a48 0x00411a9a push str.input_number_is_5 0x00411a9f call fcn.004110d7 0x00411aa4 add esp, 4 ;-- default: ; from 0x411a48 0x00411aa7 mov esi, esp ;switch 跳转表 0x00411b0e .dword 0x1a5e0041 0x00411b10 .int32 4266590 ; case.0x411a48.1 0x00411b14 .int32 4266605 ; case.0x411a48.2 0x00411b18 .int32 4266620 ; case.0x411a48.3 0x00411b1c .int32 4266635 ; case.0x411a48.4 0x00411b20 .int32 4266650 ; case.0x411a48.5 整十连续\n0x140011a26 mov eax, dword [var_d4h] 0x140011a2c sub eax, 0x21c ; 540 0x140011a31 mov dword [var_d4h], eax 0x140011a37 cmp dword [var_d4h], 0x3c 0x140011a3e ja case.0x140011a64.1 0x140011a44 movsxd rax, dword [var_d4h] 0x140011a4b lea rcx, [0x140000000] 0x140011a52 movzx eax, byte [rcx + rax + 0x11b24] 0x140011a5a mov eax, dword [rcx + rax*4 + 0x11b04] 0x140011a61 add rax, rcx 0x140011a64 jmp rax 0x140011a66 lea rcx, str.input_number_is_540 0x140011a6d call fcn.14001119f 0x140011a72 jmp case.0x140011a64.1 0x140011a74 lea rcx, str.input_number_is_550 0x140011a7b call fcn.14001119f 0x140011a80 jmp case.0x140011a64.1 0x140011a82 lea rcx, str.input_number_is_560 0x140011a89 call fcn.14001119f 0x140011a8e jmp case.0x140011a64.1 0x140011a90 lea rcx, str.input_number_is_570 0x140011a97 call fcn.14001119f 0x140011a9c jmp case.0x140011a64.1 0x140011a9e lea rcx, str.input_number_is_580 0x140011aa5 call fcn.14001119f 0x140011aaa jmp case.0x140011a64.1 0x140011aac lea rcx, str.input_number_is_590 0x140011ab3 call fcn.14001119f 0x140011ab8 jmp case.0x140011a64.1 0x140011aba lea rcx, str.input_number_is_600 0x140011ac1 call fcn.14001119f 0x140011ac6 lea rcx, str.pause 0x140011acd call qword [system] ;分支跳转表 0x140011b04 .int32 72294 0x140011b08 .int32 72308 0x140011b0c .int32 72322 0x140011b10 .int32 72336 0x140011b14 .int32 72350 0x140011b18 .int32 72364 0x140011b1c .int32 72378 0x140011b20 .int32 72390 ;数据处理表 0x140011b24 .char 0 0x140011b25 .char 7 0x140011b26 .char 7 0x140011b27 .char 7 0x140011b28 .char 7 0x140011b29 .char 7 0x140011b2a .char 7 0x140011b2b .char 7 0x140011b2c .char 7 0x140011b2d .char 7 0x140011b2e .char 1 0x140011b2f .char 7 0x140011b30 .char 7 0x140011b31 .char 7 0x140011b32 .char 7 0x140011b33 .char 7 0x140011b34 .char 7 0x140011b35 .char 7 0x140011b36 .char 7 0x140011b37 .char 7 0x140011b38 .char 2 0x140011b39 .char 7 0x140011b3a .char 7 0x140011b3b .char 7 0x140011b3c .char 7 0x140011b3d .char 7 0x140011b3e .char 7 0x140011b3f .char 7 0x140011b40 .char 7 0x140011b41 .char 7 0x140011b42 .char 3 0x140011b43 .char 7 0x140011b44 .char 7 0x140011b45 .char 7 0x140011b46 .char 7 0x140011b47 .char 7 0x140011b48 .char 7 0x140011b49 .char 7 0x140011b4a .char 7 0x140011b4b .char 7 0x140011b4c .char 4 0x140011b4d .char 7 0x140011b4e .char 7 0x140011b4f .char 7 0x140011b50 .char 7 0x140011b51 .char 7 0x140011b52 .char 7 0x140011b53 .char 7 0x140011b54 .char 7 0x140011b55 .char 7 0x140011b56 .char 5 0x140011b57 .char 7 0x140011b58 .char 7 0x140011b59 .char 7 0x140011b5a .char 7 0x140011b5b .char 7 0x140011b5c .char 7 0x140011b5d .char 7 0x140011b5e .char 7 0x140011b5f .char 7 0x140011b60 .char 6 Release # 0x004010a4 cmp eax, 5 ; 5 0x004010a7 ja case.default.0x4010a9 0x004010a9 jmp dword [eax*4 + 0x401100] ; switch table (6 cases) at 0x401100 0x004010b0 push str.input_number_is_0 ; 0x40210c 0x004010b5 jmp 0x4010d8 0x004010b7 push str.input_number_is_1 ; 0x402120 0x004010bc jmp 0x4010d8 0x004010be push str.input_number_is_2 ; 0x402134 0x004010c3 jmp 0x4010d8 0x004010c5 push str.input_number_is_3 ; 0x402148 0x004010ca jmp 0x4010d8 0x004010cc push str.input_number_is_4 ; 0x40215c 0x004010d1 jmp 0x4010d8 0x004010d3 push str.input_number_is_5 ; 0x402170 0x004010d8 call fcn.00401020 0x004010dd add esp, 4 ;-- default: ; from 0x4010a9 0x004010e0 push str.pause ;switch 跳转表 0x00401100 .int32 4198576 ; case.0x4010a9.0 0x00401104 .int32 4198583 ; case.0x4010a9.1 0x00401108 .int32 4198590 ; case.0x4010a9.2 0x0040110c .int32 4198597 ; case.0x4010a9.3 0x00401110 .int32 4198604 ; case.0x4010a9.4 0x00401114 .int32 4198611 ; case.0x4010a9.5 整十连续\n0x1400010f4 mov eax, dword [var_20h] 0x1400010f8 add eax, 0xfffffde4 0x1400010fd cmp eax, 0x3c 0x140001100 ja case.0x14000111d.541 0x140001102 lea rdx, [0x140000000] 0x140001109 cdqe 0x14000110b movzx eax, byte [rdx + rax + 0x11a4] 0x140001113 mov ecx, dword [rdx + rax*4 + 0x1184] 0x14000111a add rcx, rdx 0x14000111d jmp rcx ; switch table (61 cases) at 0x140001184 0x14000111f lea rcx, str.input_number_is_540 0x140001126 jmp 0x14000115c 0x140001128 lea rcx, str.input_number_is_550 0x14000112f jmp 0x14000115c 0x140001131 lea rcx, str.input_number_is_560 0x140001138 jmp 0x14000115c 0x14000113a lea rcx, str.input_number_is_570 0x140001141 jmp 0x14000115c 0x140001143 lea rcx, str.input_number_is_580 0x14000114a jmp 0x14000115c 0x14000114c lea rcx, str.input_number_is_590 0x140001153 jmp 0x14000115c 0x140001155 lea rcx, str.input_number_is_600 0x14000115c call fcn.140001020 0x140001161 lea rcx, str.pause 0x140001168 call fcn.140013094 ;分支跳转表 0x140001184 .int32 4383 0x140001188 .int32 4392 0x14000118c .int32 4401 0x140001190 .int32 4410 0x140001194 .int32 4419 0x140001198 .int32 4428 0x14000119c .int32 4437 0x1400011a0 .int32 4449 ;数据处理表 0x1400011a4 .char 0 0x1400011a5 .char 7 0x1400011a6 .char 7 0x1400011a7 .char 7 0x1400011a8 .char 7 0x1400011a9 .char 7 0x1400011aa .char 7 0x1400011ab .char 7 0x1400011ac .char 7 0x1400011ad .char 7 0x1400011ae .char 1 0x1400011af .char 7 0x1400011b0 .char 7 0x1400011b1 .char 7 0x1400011b2 .char 7 0x1400011b3 .char 7 0x1400011b4 .char 7 0x1400011b5 .char 7 0x1400011b6 .char 7 0x1400011b7 .char 7 0x1400011b8 .char 2 0x1400011b9 .char 7 0x1400011ba .char 7 0x1400011bb .char 7 0x1400011bc .char 7 0x1400011bd .char 7 0x1400011be .char 7 0x1400011bf .char 7 0x1400011c0 .char 7 0x1400011c1 .char 7 0x1400011c2 .char 3 0x1400011c3 .char 7 0x1400011c4 .char 7 0x1400011c5 .char 7 0x1400011c6 .char 7 0x1400011c7 .char 7 0x1400011c8 .char 7 0x1400011c9 .char 7 0x1400011ca .char 7 0x1400011cb .char 7 0x1400011cc .char 4 0x1400011cd .char 7 0x1400011ce .char 7 0x1400011cf .char 7 0x1400011d0 .char 7 0x1400011d1 .char 7 0x1400011d2 .char 7 0x1400011d3 .char 7 0x1400011d4 .char 7 0x1400011d5 .char 7 0x1400011d6 .char 5 0x1400011d7 .char 7 0x1400011d8 .char 7 0x1400011d9 .char 7 0x1400011da .char 7 0x1400011db .char 7 0x1400011dc .char 7 0x1400011dd .char 7 0x1400011de .char 7 0x1400011df .char 7 0x1400011e0 .char 6 switch单不连续 # Debug # 少分支语句\n0x140011a26 cmp dword [var_d4h], 1 0x140011a2d je 0x140011a58 0x140011a2f cmp dword [var_d4h], 2 0x140011a36 je 0x140011a66 0x140011a38 cmp dword [var_d4h], 3 0x140011a3f je 0x140011a74 0x140011a41 cmp dword [var_d4h], 4 0x140011a48 je 0x140011a82 0x140011a4a cmp dword [var_d4h], 0xc8 0x140011a54 je 0x140011a90 0x140011a56 jmp 0x140011a9c 0x140011a58 lea rcx, str.input_number_is_1 0x140011a5f call fcn.14001119f 0x140011a64 jmp 0x140011a9c 0x140011a66 lea rcx, str.input_number_is_2 0x140011a6d call fcn.14001119f 0x140011a72 jmp 0x140011a9c 0x140011a74 lea rcx, str.input_number_is_3 0x140011a7b call fcn.14001119f 0x140011a80 jmp 0x140011a9c 0x140011a82 lea rcx, str.input_number_is_4 0x140011a89 call fcn.14001119f 0x140011a8e jmp 0x140011a9c 0x140011a90 lea rcx, str.input_number_is_5 0x140011a97 call fcn.14001119f 0x140011a9c lea rcx, str.pause 多分支语句\n0x140011a26 cmp dword [var_d4h], 0xc8 0x140011a30 ja case.0x140011a56.6 0x140011a36 movsxd rax, dword [var_d4h] 0x140011a3d lea rcx, [0x140000000] 0x140011a44 movzx eax, byte [rcx + rax + 0x11b14] 0x140011a4c mov eax, dword [rcx + rax*4 + 0x11af4] 0x140011a53 add rax, rcx 0x140011a56 jmp rax ; switch table (201 cases) at 0x140011af4 0x140011a58 lea rcx, str.input_number_is_0 0x140011a5f call fcn.14001119f 0x140011a64 jmp case.0x140011a56.6 0x140011a66 lea rcx, str.input_number_is_1 0x140011a6d call fcn.14001119f 0x140011a72 jmp case.0x140011a56.6 0x140011a74 lea rcx, str.input_number_is_2 0x140011a7b call fcn.14001119f 0x140011a80 jmp case.0x140011a56.6 0x140011a82 lea rcx, str.input_number_is_3 0x140011a89 call fcn.14001119f 0x140011a8e jmp case.0x140011a56.6 0x140011a90 lea rcx, str.input_number_is_4 0x140011a97 call fcn.14001119f 0x140011a9c jmp case.0x140011a56.6 0x140011a9e lea rcx, str.input_number_is_5 0x140011aa5 call fcn.14001119f 0x140011aaa jmp case.0x140011a56.6 0x140011aac lea rcx, str.input_number_is_200 0x140011ab3 call fcn.14001119f 0x140011ab8 lea rcx, str.pause 0x140011abf call qword [system] ; 分支跳转表 0x140011af4 .int32 72280 0x140011af8 .int32 72294 0x140011afc .int32 72308 0x140011b00 .int32 72322 0x140011b04 .int32 72336 0x140011b08 .int32 72350 0x140011b0c .int32 72364 0x140011b10 .int32 72376 0x140011a1d mov eax, dword [var_4h] 0x140011a20 mov dword [var_d4h], eax 0x140011a26 mov eax, dword [var_d4h] 0x140011a2c sub eax, 0xa 0x140011a2f mov dword [var_d4h], eax 0x140011a35 cmp dword [var_d4h], 0xbe 0x140011a3f ja case.0x140011a65.6 0x140011a45 movsxd rax, dword [var_d4h] 0x140011a4c lea rcx, [0x140000000] 0x140011a53 movzx eax, byte [rcx + rax + 0x11b24] 0x140011a5b mov eax, dword [rcx + rax*4 + 0x11b04] 0x140011a62 add rax, rcx 0x140011a65 jmp rax ; switch table (191 cases) at 0x140011b04 0x140011a67 lea rcx, str.input_number_is_0 ; 0x14001ad28 0x140011a6e call fcn.14001119f 0x140011a73 jmp case.0x140011a65.6 0x140011a75 lea rcx, str.input_number_is_1 ; 0x14001ad40 0x140011a7c call fcn.14001119f 0x140011a81 jmp case.0x140011a65.6 0x140011a83 lea rcx, str.input_number_is_2 ; 0x14001ad58 0x140011a8a call fcn.14001119f 0x140011a8f jmp case.0x140011a65.6 0x140011a91 lea rcx, str.input_number_is_3 ; 0x14001ad70 0x140011a98 call fcn.14001119f 0x140011a9d jmp case.0x140011a65.6 0x140011a9f lea rcx, str.input_number_is_4 ; 0x14001ad88 0x140011aa6 call fcn.14001119f 0x140011aab jmp case.0x140011a65.6 0x140011aad lea rcx, str.input_number_is_5 ; 0x14001ada0 0x140011ab4 call fcn.14001119f 0x140011ab9 jmp case.0x140011a65.6 0x140011abb lea rcx, str.input_number_is_200 ; 0x14001adb8 0x140011ac2 call fcn.14001119f 0x140011ac7 lea rcx, str.pause ; 0x14001add4 ; const char *string 0x140011ace call qword [system] ; 0x140021310 ; int system(const char *string) ;跳转分支表 0x140011b04 .int32 72295 0x140011b08 .int32 72309 0x140011b0c .int32 72323 0x140011b10 .int32 72337 0x140011b14 .int32 72351 0x140011b18 .int32 72365 0x140011b1c .int32 72379 0x140011b20 .int32 72391 Release # 少分支语句\n0x140001108 sub ecx, 1 0x14000110b je 0x140001148 0x14000110d sub ecx, 1 0x140001110 je 0x14000113f 0x140001112 sub ecx, 1 0x140001115 je 0x140001136 0x140001117 sub ecx, 1 0x14000111a je 0x14000112d 0x14000111c cmp ecx, 0xc4 ; 196 0x140001122 jne 0x140001154 0x140001124 lea rcx, str.input_number_is_5 0x14000112b jmp 0x14000114f 0x14000112d lea rcx, str.input_number_is_4 0x140001134 jmp 0x14000114f 0x140001136 lea rcx, str.input_number_is_3 0x14000113d jmp 0x14000114f 0x14000113f lea rcx, str.input_number_is_2 0x140001146 jmp 0x14000114f 0x140001148 lea rcx, str.input_number_is_1 0x14000114f call fcn.140001020 0x140001154 lea rcx, str.pause 0x14000115b call qword [system] 多分支语句\n0x140001109 cmp eax, 0xc8 ; 200 0x14000110e ja case.0x140001129.6 0x140001110 lea rdx, [0x140000000] 0x140001117 movzx eax, byte [rdx + rax + 0x11b0] 0x14000111f mov ecx, dword [rdx + rax*4 + 0x1190] 0x140001126 add rcx, rdx 0x140001129 jmp rcx ; switch table (201 cases) at 0x140001190 0x14000112b lea rcx, str.input_number_is_0 0x140001132 jmp 0x140001168 0x140001134 lea rcx, str.input_number_is_1 0x14000113b jmp 0x140001168 0x14000113d lea rcx, str.input_number_is_2 0x140001144 jmp 0x140001168 0x140001146 lea rcx, str.input_number_is_3 0x14000114d jmp 0x140001168 0x14000114f lea rcx, str.input_number_is_4 0x140001156 jmp 0x140001168 0x140001158 lea rcx, str.input_number_is_5 0x14000115f jmp 0x140001168 0x140001161 lea rcx, str.input_number_is_200 0x140001168 call fcn.140001020 0x14000116d lea rcx, str.pause ; 0x140002300 0x140001174 call qword [system] ; 0x140002168 ; 分支跳转表 0x140001190 .int32 4395 0x140001194 .int32 4404 0x140001198 .int32 4413 0x14000119c .int32 4422 0x1400011a0 .int32 4431 0x1400011a4 .int32 4440 0x1400011a8 .int32 4449 0x1400011ac .int32 4461 0x140001104 mov eax, dword [var_20h] 0x140001108 add eax, 0xfffffff6 0x14000110b cmp eax, 0xbe ; 190 0x140001110 ja case.0x14000112d.16 0x140001112 lea rdx, [0x140000000] 0x140001119 cdqe 0x14000111b movzx eax, byte [rdx + rax + 0x11b4] 0x140001123 mov ecx, dword [rdx + rax*4 + 0x1194] 0x14000112a add rcx, rdx 0x14000112d jmp rcx ; switch table (191 cases) at 0x140001194 0x14000112f lea rcx, str.input_number_is_0 ; 0x140002258 0x140001136 jmp 0x14000116c 0x140001138 lea rcx, str.input_number_is_1 ; 0x140002270 0x14000113f jmp 0x14000116c 0x140001141 lea rcx, str.input_number_is_2 ; 0x140002288 0x140001148 jmp 0x14000116c 0x14000114a lea rcx, str.input_number_is_3 ; 0x1400022a0 0x140001151 jmp 0x14000116c 0x140001153 lea rcx, str.input_number_is_4 ; 0x1400022b8 0x14000115a jmp 0x14000116c 0x14000115c lea rcx, str.input_number_is_5 ; 0x1400022d0 0x140001163 jmp 0x14000116c 0x140001165 lea rcx, str.input_number_is_200 ; 0x1400022e8 0x14000116c call fcn.140001020 ;-- default: ; from 0x14000112d 0x140001171 lea rcx, str.pause ; 0x140002300 ; const char *string 0x140001178 call qword [system] ; 0x140002168 ; int system(const char *string) ;跳转分支表 0x140001194 .int32 4399 0x140001198 .int32 4408 0x14000119c .int32 4417 0x1400011a0 .int32 4426 0x1400011a4 .int32 4435 0x1400011a8 .int32 4444 0x1400011ac .int32 4453 0x1400011b0 .int32 4465 switch多不连续 # Debug # 0x140011a1d mov eax, dword [var_4h] 0x140011a20 mov dword [var_d4h], eax 0x140011a26 cmp dword [var_d4h], 0x71 0x140011a2d jg 0x140011a5c 0x140011a2f cmp dword [var_d4h], 0x71 0x140011a36 je 0x140011aac 0x140011a38 cmp dword [var_d4h], 0x11 0x140011a3f je 0x140011ac8 0x140011a45 cmp dword [var_d4h], 0x22 0x140011a4c je 0x140011aba 0x140011a4e cmp dword [var_d4h], 0x3d 0x140011a55 je 0x140011a90 0x140011a57 jmp 0x140011ae2 0x140011a5c cmp dword [var_d4h], 0xc8 0x140011a66 je 0x140011ad6 0x140011a68 cmp dword [var_d4h], 0x21c 0x140011a72 je 0x140011a82 0x140011a74 cmp dword [var_d4h], 0x41c 0x140011a7e je 0x140011a9e 0x140011a80 jmp 0x140011ae2 0x140011a82 lea rcx, str.input_number_is_540 ; 0x14001ad28 0x140011a89 call fcn.14001119f 0x140011a8e jmp 0x140011ae2 0x140011a90 lea rcx, str.input_number_is_61 ; 0x14001ad48 0x140011a97 call fcn.14001119f 0x140011a9c jmp 0x140011ae2 0x140011a9e lea rcx, str.input_number_is_1052 ; 0x14001ad60 0x140011aa5 call fcn.14001119f 0x140011aaa jmp 0x140011ae2 0x140011aac lea rcx, str.input_number_is_113 ; 0x14001ad80 0x140011ab3 call fcn.14001119f 0x140011ab8 jmp 0x140011ae2 0x140011aba lea rcx, str.input_number_is_34 ; 0x14001ada0 0x140011ac1 call fcn.14001119f 0x140011ac6 jmp 0x140011ae2 0x140011ac8 lea rcx, str.input_number_is_17 ; 0x14001adb8 0x140011acf call fcn.14001119f 0x140011ad4 jmp 0x140011ae2 0x140011ad6 lea rcx, str.input_number_is_200 ; 0x14001add0 0x140011add call fcn.14001119f 0x140011ae2 lea rcx, str.pause ; 0x14001adec ; const char *string 0x140011ae9 call qword [system] ; 0x140021310 ; int system(const char *string) Release # 0x140001104 mov eax, dword [var_20h] 0x140001108 cmp eax, 0x71 ; 113 0x14000110b jg 0x140001142 0x14000110d je 0x140001139 0x14000110f cmp eax, 0x11 ; 17 0x140001112 je 0x140001130 0x140001114 cmp eax, 0x22 ; 34 0x140001117 je 0x140001127 0x140001119 cmp eax, 0x3d ; 61 0x14000111c jne 0x140001175 0x14000111e lea rcx, str.input_number_is_61 0x140001125 jmp 0x140001170 0x140001127 lea rcx, str.input_number_is_34 0x14000112e jmp 0x140001170 0x140001130 lea rcx, str.input_number_is_17 0x140001137 jmp 0x140001170 0x140001139 lea rcx, str.input_number_is_113 0x140001140 jmp 0x140001170 0x140001142 cmp eax, 0xc8 ; 200 0x140001147 je 0x140001169 0x140001149 cmp eax, 0x21c ; 540 0x14000114e je 0x140001160 0x140001150 cmp eax, 0x41c ; 1052 0x140001155 jne 0x140001175 0x140001157 lea rcx, str.input_number_is_1052 0x14000115e jmp 0x140001170 0x140001160 lea rcx, str.input_number_is_540 0x140001167 jmp 0x140001170 0x140001169 lea rcx, str.input_number_is_200 0x140001170 call fcn.140001020 0x140001175 lea rcx, str.pause 0x14000117c call qword [system] switch无break # Debug # 0x140011a26 mov eax, dword [var_d4h] 0x140011a2c dec eax 0x140011a2e mov dword [var_d4h], eax 0x140011a34 cmp dword [var_d4h], 5 0x140011a3b ja case.default.0x140011a55 0x140011a3d movsxd rax, dword [var_d4h] 0x140011a44 lea rcx, [0x140000000] 0x140011a4b mov eax, dword [rcx + rax*4 + 0x11adc] 0x140011a52 add rax, rcx 0x140011a55 jmp rax ; switch table (6 cases) at 0x140011adc 0x140011a57 lea rcx, str.input_number_is_1 0x140011a5e call fcn.14001119f 0x140011a63 lea rcx, str.input_number_is_2 0x140011a6a call fcn.14001119f 0x140011a6f lea rcx, str.input_number_is_3 0x140011a76 call fcn.14001119f 0x140011a7b lea rcx, str.input_number_is_4 0x140011a82 call fcn.14001119f 0x140011a87 lea rcx, str.input_number_is_5 0x140011a8e call fcn.14001119f 0x140011a93 lea rcx, str.input_number_is_6 0x140011a9a call fcn.14001119f 0x140011a9f lea rcx, str.pause 0x140011aa6 call qword [system] ;分支跳转表 0x140011adc .int32 72279 0x140011ae0 .int32 72291 0x140011ae4 .int32 72303 0x140011ae8 .int32 72315 0x140011aec .int32 72327 0x140011af0 .int32 72339 Release # 0x1400010f4 mov eax, dword [var_20h] 0x1400010f8 dec eax 0x1400010fa cmp eax, 5 ; 5 0x1400010fd ja case.default.0x140001112 0x1400010ff lea rdx, [0x140000000] 0x140001106 cdqe 0x140001108 mov ecx, dword [rdx + rax*4 + 0x117c] 0x14000110f add rcx, rdx ;-- switch 0x140001112 jmp rcx ; switch table (6 cases) at 0x14000117c ;-- case 1: ; from 0x140001112 0x140001114 lea rcx, str.input_number_is_1 ; 0x14005e548 ; int64_t arg1 0x14000111b call fcn.140001020 ;-- case 2: ; from 0x140001112 0x140001120 lea rcx, str.input_number_is_2 ; 0x14005e560 ; int64_t arg1 0x140001127 call fcn.140001020 ;-- case 3: ; from 0x140001112 0x14000112c lea rcx, str.input_number_is_3 ; 0x14005e578 ; int64_t arg1 0x140001133 call fcn.140001020 ;-- case 4: ; from 0x140001112 0x140001138 lea rcx, str.input_number_is_4 ; 0x14005e590 ; int64_t arg1 0x14000113f call fcn.140001020 ;-- case 5: ; from 0x140001112 0x140001144 lea rcx, str.input_number_is_5 ; 0x14005e5a8 ; int64_t arg1 0x14000114b call fcn.140001020 ;-- case 6: ; from 0x140001112 0x140001150 lea rcx, str.input_number_is_6 ; 0x14005e5c0 ; int64_t arg1 0x140001157 call fcn.140001020 ;-- default: ; from 0x140001112 0x14000115c lea rcx, str.pause ; 0x14005e5d4 ; int64_t arg1 0x140001163 call fcn.140013044 ;分支跳转表 0x14000117c .int32 4372 0x140001180 .int32 4384 0x140001184 .int32 4396 0x140001188 .int32 4408 0x14000118c .int32 4420 0x140001190 .int32 4432 switch无default # Debug # 0x140011a26 mov eax, dword [var_d4h] 0x140011a2c dec eax 0x140011a2e mov dword [var_d4h], eax 0x140011a34 cmp dword [var_d4h], 5 0x140011a3b ja case.default.0x140011a55 0x140011a3d movsxd rax, dword [var_d4h] 0x140011a44 lea rcx, [0x140000000] 0x140011a4b mov eax, dword [rcx + rax*4 + 0x11ae8] 0x140011a52 add rax, rcx 0x140011a55 jmp rax ; switch table (6 cases) at 0x140011ae8 0x140011a57 lea rcx, str.input_number_is_1 0x140011a5e call fcn.14001119f 0x140011a63 jmp case.default.0x140011a55 0x140011a65 lea rcx, str.input_number_is_2 0x140011a6c call fcn.14001119f 0x140011a71 jmp case.default.0x140011a55 0x140011a73 lea rcx, str.input_number_is_3 0x140011a7a call fcn.14001119f 0x140011a7f jmp case.default.0x140011a55 0x140011a81 lea rcx, str.input_number_is_4 0x140011a88 call fcn.14001119f 0x140011a8d jmp case.default.0x140011a55 0x140011a8f lea rcx, str.input_number_is_5 0x140011a96 call fcn.14001119f 0x140011a9b jmp case.default.0x140011a55 0x140011a9d lea rcx, str.input_number_is_6 0x140011aa4 call fcn.14001119f 0x140011aa9 lea rcx, str.pause 0x140011ab0 call qword [system] ;switch 跳转表 0x140011ae8 .int32 72279 0x140011aec .int32 72293 0x140011af0 .int32 72307 0x140011af4 .int32 72321 0x140011af8 .int32 72335 0x140011afc .int32 72349 Release # 0x140001104 mov eax, dword [var_20h] 0x140001108 dec eax 0x14000110a cmp eax, 5 ; 5 0x14000110d ja case.default.0x140001122 0x14000110f lea rdx, [0x140000000] 0x140001116 cdqe 0x140001118 mov ecx, dword [rdx + rax*4 + 0x1180] 0x14000111f add rcx, rdx 0x140001122 jmp rcx ; switch table (6 cases) at 0x140001180 0x140001124 lea rcx, str.input_number_is_1 0x14000112b jmp 0x140001158 0x14000112d lea rcx, str.input_number_is_2 0x140001134 jmp 0x140001158 0x140001136 lea rcx, str.input_number_is_3 0x14000113d jmp 0x140001158 0x14000113f lea rcx, str.input_number_is_4 0x140001146 jmp 0x140001158 0x140001148 lea rcx, str.input_number_is_5 0x14000114f jmp 0x140001158 0x140001151 lea rcx, str.input_number_is_6 0x140001158 call fcn.140001020 0x14000115d lea rcx, str.pause 0x140001164 call qword [system] ;switch 跳转表 0x140001180 .int32 4388 0x140001184 .int32 4397 0x140001188 .int32 4406 0x14000118c .int32 4415 0x140001190 .int32 4424 0x140001194 .int32 4433 while循环 # Debug\n0x14001187b mov qword [var_8h], 0 0x140011883 mov dword [var_24h], 0 0x14001188a cmp qword [var_8h], 0x64 0x14001188f jae 0x1400118a9 0x140011891 movsxd rax, dword [var_24h] 0x140011895 add rax, qword [var_8h] 0x140011899 mov dword [var_24h], eax 0x14001189c mov rax, qword [var_8h] 0x1400118a0 inc rax 0x1400118a3 mov qword [var_8h], rax 0x1400118a7 jmp 0x14001188a 0x1400118a9 mov edx, dword [var_24h] 0x1400118ac lea rcx, str.result_____d ; 0x140019c28 0x1400118b3 call fcn.140011190 Release\n0x140001074 xor eax, eax 0x140001076 mov edx, eax 0x140001078 nop dword [rax + rax] 0x140001080 add edx, eax 0x140001082 inc rax 0x140001085 cmp rax, 0x64 ; 100 0x140001089 jb 0x140001080 0x14000108b lea rcx, str.result_____d 0x140001092 call fcn.140001010 for循环 # Debug\n0x140011883 mov dword [var_24h], 0 0x14001188a mov qword [var_8h], 0 0x140011892 jmp 0x14001189f 0x140011894 mov rax, qword [var_8h] 0x140011898 inc rax 0x14001189b mov qword [var_8h], rax 0x14001189f cmp qword [var_8h], 0x64 0x1400118a4 jae 0x1400118b3 0x1400118a6 movsxd rax, dword [var_24h] 0x1400118aa add rax, qword [var_8h] 0x1400118ae mov dword [var_24h], eax 0x1400118b1 jmp 0x140011894 0x1400118b3 mov edx, dword [var_24h] 0x1400118b6 lea rcx, str.result_____d ; 0x140019c28 0x1400118bd call fcn.140011190 Release\n0x140001074 xor ecx, ecx 0x140001076 mov eax, ecx 0x140001078 nop dword [rax + rax] 0x140001080 add ecx, eax 0x140001082 inc rax 0x140001085 cmp rax, 0x64 ; 100 0x140001089 jb 0x140001080 0x14000108b mov edx, ecx ; int64_t arg2 0x14000108d lea rcx, str.result_____d 0x140001094 call fcn.140001010 do while循环 # Debug\n0x14001187b mov qword [var_8h], 0 0x140011883 mov dword [var_24h], 0 0x14001188a movsxd rax, dword [var_24h] 0x14001188e add rax, qword [var_8h] 0x140011892 mov dword [var_24h], eax 0x140011895 mov rax, qword [var_8h] 0x140011899 inc rax 0x14001189c mov qword [var_8h], rax 0x1400118a0 cmp qword [var_8h], 0x64 0x1400118a5 jb 0x14001188a 0x1400118a7 mov edx, dword [var_24h] 0x1400118aa lea rcx, str.result_____d 0x1400118b1 call fcn.140011190 Release\n0x140001074 xor eax, eax 0x140001076 mov edx, eax 0x140001078 nop dword [rax + rax] 0x140001080 add edx, eax 0x140001082 inc rax 0x140001085 cmp rax, 0x64 ; 100 0x140001089 jb 0x140001080 0x14000108b lea rcx, str.result_____d 0x140001092 call fcn.140001010 分支嵌套 # Debug\nx14001197d cmp dword [var_4h], 0x41 0x140011981 jl 0x1400119aa 0x140011983 cmp dword [var_4h], 0x5a 0x140011987 jg 0x1400119aa 0x140011989 cmp dword [var_4h], 0x58 0x14001198d jne 0x14001199e 0x14001198f mov edx, dword [var_4h] 0x140011992 lea rcx, str.input_alpha_is:__c 0x140011999 call fcn.140011195 0x14001199e lea rcx, str.You_are_right 0x1400119a5 call fcn.140011195 0x1400119aa lea rcx, str.pause 0x1400119b1 call qword [system] Release\n0x140001104 mov ecx, dword [var_20h] 0x140001108 lea eax, [rcx - 0x41] 0x14000110b cmp eax, 0x19 ; 25 0x14000110e ja 0x14000112f 0x140001110 cmp ecx, 0x58 ; 88 0x140001113 jne 0x140001123 0x140001115 mov edx, ecx ; int64_t arg2 0x140001117 lea rcx, str.input_alpha_is:__c 0x14000111e call fcn.140001020 0x140001123 lea rcx, str.You_are_right 0x14000112a call fcn.140001020 0x14000112f lea rcx, str.pause 0x140001136 call qword [system] 循环嵌套 # Debug\n0x14001187b mov qword [var_8h], 0 0x140011883 mov qword [var_28h], 0 0x14001188b mov dword [var_44h], 0 0x140011892 cmp qword [var_8h], 0x64 0x140011897 jae 0x1400118c8 0x140011899 mov rax, qword [var_8h] 0x14001189d cmp qword [var_28h], rax 0x1400118a1 jae 0x1400118bb 0x1400118a3 movsxd rax, dword [var_44h] 0x1400118a7 add rax, qword [var_28h] 0x1400118ab mov dword [var_44h], eax 0x1400118ae mov rax, qword [var_28h] 0x1400118b2 inc rax 0x1400118b5 mov qword [var_28h], rax 0x1400118b9 jmp 0x140011899 0x1400118bb mov rax, qword [var_8h] 0x1400118bf inc rax 0x1400118c2 mov qword [var_8h], rax 0x1400118c6 jmp 0x140011892 0x1400118c8 mov edx, dword [var_44h] 0x1400118cb lea rcx, str.result_____d ; 0x140019c28 0x1400118d2 call fcn.140011190 Release\n0x140001074 xor eax, eax 0x140001076 mov edx, eax 0x140001078 mov ecx, eax 0x14000107a nop word [rax + rax] 0x140001080 cmp rax, rcx 0x140001083 jae 0x14000108f 0x140001085 add edx, eax 0x140001087 inc rax 0x14000108a cmp rax, rcx 0x14000108d jb 0x140001085 0x14000108f inc rcx 0x140001092 cmp rcx, 0x64 ; 100 0x140001096 jb 0x140001080 0x140001098 lea rcx, str.result_____d ; 0x140002240 ; int64_t arg1 0x14000109f call fcn.140001010 ","date":"February 26, 2022","permalink":"/posts/logic_re/","section":"Posts","summary":"逻辑语句逆向分析 总结 # if分支 # if # Debug\n0x00411a30 cmp dword [var_ch], 0x41 0x00411a34 jne 0x411a47 0x00411a36 mov eax, dword [var_ch] 0x00411a39 push eax 0x00411a3a push str.This_is_current_alpha:_c 0x00411a3f call fcn.004110d7 0x00411a44 add esp, 8 0x00411a47 mov esi, esp Release\n0x004010a1 cmp dword [var_8h], 0x41 0x004010a5 jne 0x4010b6 0x004010a7 push 0x41 0x004010a9 push str.This_is_current_alpha:_c 0x004010ae call fcn.00401020 0x004010b3 add esp, 8 0x004010b6 push str.pause if_else # Debug\n0x00411a30 cmp dword [var_ch], 0x41 0x00411a34 jne 0x411a49 0x00411a36 mov eax, dword [var_ch] 0x00411a39 push eax 0x00411a3a push str.","title":"看穿你的逻辑 理解你表达的真谛"},{"content":"寻找主函数 # 入口点（主函数）并不确定 \u0026ndash;\u0026gt; 编译器版本\n寻找编译器特征 来确定 主函数\nVS 2013-2017 特征 # 2015 Debug x86 # jmp mainCRTStartup里面的call 第二个call movzx test jz mov mov push call add push call add call(main) 最后一个call jmp main 2015 Release x86 # jmp call__p___argv mov call__p___argc mov call_get_initial_narrow_environment push push push call(main) main 2015 Debug x64 # jmp call 第二个call movzx test jz mov mov call xor call call(main) 最后一个call jmp main 2015 Release x64 # jmp call__p___argv movrdi, rax call__p___argc movrbx, rax call mov mov mov call(main) main 2017 Debug x86 # jmp call 第二个call movzx ecx, al testecx, ecx jz short loc_411E82 mov mov push call add call (main) 最后一个call jmp main 2017 Release x86 # jmp call mov call mov call push push push call(main) main 2017 Debug x64 # jmp call 第二个call movzx test jz mov mov call call(main) 最后一个call jmp main 2017 Release x64 # jmp call__p___argv mov call__p___argc mov call mov mov mov call(main) main 2019 Debug x86 # jmp call 第二个call movzx test jz mov mov push call add call(main) 最后一个call jmp main 2019 Release x86 # jmp call__p___argv mov call__p___argc push push push call(main) main 2019 Debug x64 # jmp call 第二个call movzx test jz mov mov call call(main) 最后一个call jmp main 2019 Release x64 # jmp call__p___argv mov call__p___argc push push push call(main) main 2022 Debug x86 # jmp call 第二个call movzx test je mov mov push call add call(main) 最后一个call jmp main 2022 Release x86 # call 第二个call movzx test je mov mov push call add call(main) 最后一个call main 2022 Debug x64 # jmp call 第二个call movzx test je mov mov call call(main) 最后一个call jmp main 2022 Release x64 # call__p___argv mov call__p___argc mov mov mov call(main) main MinGW GCC # x86 Debug # jmp call mov mov mov mov mov mov mov mov mov call(main) main x86 Release # jmp\ncall mov mov mov mov mov mov mov mov mov call(main)\nmain\nx64 Debug # 第二个call call mov mov mov mov mov mov mov call(main) main x64 Release # 第二个call call mov mov mov mov mov mov mov call(main) main Clang # x86 Debug # jmp call mov call mov call push push push call main x86 Release # jmp call mov call mov call push push push call main x64 Debug # jmp call mov call mov call mov mov mov call main x64 Release # jmp call mov call mov call mov mov mov call main Go Build # jmp\njmp\ncall mov mov mov mov call call call learax, mainflag\ndq offset runtime_main\nlea call mov mov call mov call cmp jnz cmp jnz mov lea callmain\nmain\n","date":"February 26, 2022","permalink":"/posts/entry_point/","section":"Posts","summary":"寻找主函数 # 入口点（主函数）并不确定 \u0026ndash;\u0026gt; 编译器版本\n寻找编译器特征 来确定 主函数\nVS 2013-2017 特征 # 2015 Debug x86 # jmp mainCRTStartup里面的call 第二个call movzx test jz mov mov push call add push call add call(main) 最后一个call jmp main 2015 Release x86 # jmp call__p___argv mov call__p___argc mov call_get_initial_narrow_environment push push push call(main) main 2015 Debug x64 # jmp call 第二个call movzx test jz mov mov call xor call call(main) 最后一个call jmp main 2015 Release x64 # jmp call__p___argv movrdi, rax call__p___argc movrbx, rax call mov mov mov call(main) main 2017 Debug x86 # jmp call 第二个call movzx ecx, al testecx, ecx jz short loc_411E82 mov mov push call add call (main) 最后一个call jmp main 2017 Release x86 # jmp call mov call mov call push push push call(main) main 2017 Debug x64 # jmp call 第二个call movzx test jz mov mov call call(main) 最后一个call jmp main 2017 Release x64 # jmp call__p___argv mov call__p___argc mov call mov mov mov call(main) main 2019 Debug x86 # jmp call 第二个call movzx test jz mov mov push call add call(main) 最后一个call jmp main 2019 Release x86 # jmp call__p___argv mov call__p___argc push push push call(main) main 2019 Debug x64 # jmp call 第二个call movzx test jz mov mov call call(main) 最后一个call jmp main 2019 Release x64 # jmp call__p___argv mov call__p___argc push push push call(main) main 2022 Debug x86 # jmp call 第二个call movzx test je mov mov push call add call(main) 最后一个call jmp main 2022 Release x86 # call 第二个call movzx test je mov mov push call add call(main) 最后一个call main 2022 Debug x64 # jmp call 第二个call movzx test je mov mov call call(main) 最后一个call jmp main 2022 Release x64 # call__p___argv mov call__p___argc mov mov mov call(main) main MinGW GCC # x86 Debug # jmp call mov mov mov mov mov mov mov mov mov call(main) main x86 Release # jmp","title":"寻找入口点 回归最开始的美好"},{"content":"进制 # 进制的概念 # 进制是什么？\n对于任何一种进制—X进制，就表示每一位置上的数运算时都是逢X进一位。\n二进制：0、1 八进制：0、1、2、3、4、5、6、7 十进制：0、1、2、3、4、5、6、7、8、9 十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F N进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F、N-1 进制的运算 # 进制转换\n十六进制与二进制转换\n0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0 1 2 3 4 5 6 7 8 9 A B C D E F 二进制到十六进制转换\n1 1 1 1 8 4 2 1 8+4+2+1 = 15(F)\n原码反码补码 # 原码： # 最高位是符号位，1是负数，0是正数，其他位是原值的绝对值。\n反码： # 反码通常是用来由原码求补码或者由补码求原码的过渡码。反码跟原码是正数时，一样；负数时，反码就是原码符号位除外，其他位按位取反。\n补码： # 正数时，补码和原码一样。负数时，补码是反码+1.\n移码： # 移码是符号位取反的补码\n只存在于符号数中，不存在无符号数中\n原值 1 0 0 0 0 0 0 1 原码 1 0 0 0 0 0 0 1 反码 1 1 1 1 1 1 1 0 补码 1 1 1 1 1 1 1 1 移码 0 1 1 1 1 1 1 1 逻辑运算 # 或运算 # 或：两个数二进制按位进行比对，两个数该位其中有一个或两个为1结果就为1，全部为0结果就是0\n汇编语言：OR\nC语言：|\n值1 1 0 1 0 1 0 1 0 值2 0 1 0 0 0 1 0 1 结果 1 1 1 0 1 1 1 1 与运算 # 与：两个数二进制按位进行比对，两个数该位都是1结果就是1，否则就是0\n汇编语言：AND\nC语言：\u0026amp;\n值1 1 0 1 0 1 0 1 0 值2 0 1 0 0 0 1 1 1 结果 0 0 0 0 0 0 1 0 异或运算 # 异或：两个数二进制按位进行比对，两个数该位相同就为0，不同就为1\n汇编语言：XOR\nC语言：^\n值1 1 0 1 0 1 0 1 0 值2 0 1 0 0 0 1 1 1 结果 1 1 1 0 1 1 0 1 非运算 # 非：两个数二进制按位进行比对，按位取反，！1=0；！0=1；\n汇编语言：NOT\nC语言：！\n值1 1 0 1 0 1 0 1 0 结果 0 1 0 1 0 1 0 1 左移运算 # 左移：右侧填零，二进制数据向左移动N位，使用符号\u0026laquo;代表，例如：\n00010000 \u0026laquo; 1 = 00100000\n原值 0 0 0 1 0 0 0 0 结果 0 0 1 0 0 0 0 0 右移运算 # 右移：左侧填零，二进制数据向右移动N位，使用符号\u0026raquo;代表，例如：\n00100000 \u0026raquo; 1 = 00010000\n原值 0 0 1 0 0 0 0 0 结果 0 0 0 1 0 0 0 0 ","date":"February 22, 2022","permalink":"/posts/base_note/","section":"Posts","summary":"进制 # 进制的概念 # 进制是什么？\n对于任何一种进制—X进制，就表示每一位置上的数运算时都是逢X进一位。\n二进制：0、1 八进制：0、1、2、3、4、5、6、7 十进制：0、1、2、3、4、5、6、7、8、9 十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F N进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F、N-1 进制的运算 # 进制转换\n十六进制与二进制转换\n0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0 1 2 3 4 5 6 7 8 9 A B C D E F 二进制到十六进制转换\n1 1 1 1 8 4 2 1 8+4+2+1 = 15(F)\n原码反码补码 # 原码： # 最高位是符号位，1是负数，0是正数，其他位是原值的绝对值。\n反码： # 反码通常是用来由原码求补码或者由补码求原码的过渡码。反码跟原码是正数时，一样；负数时，反码就是原码符号位除外，其他位按位取反。\n补码： # 正数时，补码和原码一样。负数时，补码是反码+1.","title":"进制笔记"},{"content":"","date":"February 22, 2022","permalink":"/categories/develop/","section":"Categories","summary":"","title":"develop"},{"content":"MFC # 默认UNICODE编码\nCTIME类 # 获取时间的类对象，可以通过类方法获取时间\n使用方法\nCTime m_Time = CTime::GetCurrentTime(); int nYear = m_Time.GetYear(); int nMonth = m_Time.GetMonth(); int nDay = m_Time.GetDay(); int nHour = m_Time.GetHour(); int nMinute = m_Time.GetMinute(); int nSecond = m_Time.GetSecond(); MFC三种开发模式 # SDK \u0026ndash;\u0026gt; Win32 MFC \u0026ndash;\u0026gt; MFC 托管 \u0026ndash;\u0026gt; CLR 字符串 # ASCII char CHAR UNICODE wchar_t WCHAR T TCHAR\nCString类 # 定义与初始化\nCString str(L\u0026#34;大大大\u0026#34;); CString str1; str1 = L\u0026#34;小小小\u0026#34;; CString str2 = str1; CString str3 = L\u0026#39;A\u0026#39;; CString str4(L\u0026#34;A\u0026#34;,66); 格式化字符串\nCString str; int nFlag = 100; char strz[] = \u0026#34;Hello World!\u0026#34;; str.Format(L\u0026#34;char = %S int = %d\u0026#34;, strz, nFlag); 字符串长度获取\nint count = str.GetLength(); 判断字符串为空\nbool flag = str.IsEmpty(); 字符串拼接\nCString A(L\u0026#34;A\u0026#34;); CString B(L\u0026#34;B\u0026#34;); A = A + B; 切片操作\nCString A(L\u0026#34;ABCDEFGH\u0026#34;); CString B = A.Left(2); CString C = A.Mid(2, 2); CString D = A.Right(2); 删除操作\nCString A(L\u0026#34;ABCDEFGH\u0026#34;); A.Remove(L\u0026#34;A\u0026#34;); 获取字符串\nCString A(L\u0026#34;ABCDEFGH\u0026#34;); LPTSTR TSTR = A.GetBuffer(); Windows消息基础 # 消息的来源\n由操作系统产生 用户触发事件转换 由另一个消息产生 消息的定义\n前缀 说明 WM 普通窗口 BM 按钮 CB 组合框 CDM 通用对话框 DBT 设备信息 DL 下拉列表 EM 编辑框 HKM 热键 IPM IP控件 LB 列表框 LVM 列表视图 MCM 日历控件 PBM 进度条 PSM 属性 RB 伸缩条 SB 状态栏 STM 静态栏 TB 工具条 TBM 跟踪条 TCM 标签控件 TVM 树视图 UDM 微调按钮控件 MSG结构体\ntypedef struct tagMSG{ HWND hwnd; UINT message; WPARAM wParam; LPARAM lParam; DWORD time; POINT pt; #ifdef _MAC DWORD lPrivate; #endif } MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG; 预定义消息 # 窗口消息 # WM_CREATE 创建窗口 WM_PAINT 绘制窗口 WM_DESTROY 销毁窗口 WM_KILLFOCUS 失去焦点 WM_SETFOCUS 获得焦点 WM_MEASUREITEM WM_DRAWTEM\n命令消息 WM_COMMAND\n控件通知消息 # WM_xxxx\nWM_PARENTNOTIFY WM_CTLCOLOR \u0026hellip; WM_VSCROLL/WM_HSCROLL 按钮控件 组合框控件 编辑框控件 列表框控件\nWM_NOTIFY 控件绘制结构体\ntypedef struct tagDRAWITEMSTRUCT { UINT CtlType; UINT CtlID; UINT itemID; UINT itemAction; UINT itemState; HWND hwndItem; HDC hDC; RECT rcItem; ULONG_PTR itemData; } DRAWITEMSTRUCT, NEAR *PDRAWITEMSTRUCT, FAR *LPDRAWITEMSTRUCT; typedef struct tagNMHDR { HWND hwndFrom; UINT_PTR idFrom; UINT code; // NM_ code } NMHDR; typedef struct tagLVKEYDOWN { NMHDR hdr; WORD wVKey; UINT flags; } NMLVKEYDOWN, *LPNMLVKEYDOWN; 自定义消息 # #define MY_MSG WM_USER+1 使用方法 SendMessage 同步方式 PostMessage 异步方式\nWin32(SDK) # WinMain MSG结构体 注册窗口 创建窗口 显示窗口 刷新窗口 消息循环 WindowProc // WindowsSDK.cpp : 定义应用程序的入口点。 // #include \u0026#34;framework.h\u0026#34; #include \u0026#34;WindowsSDK.h\u0026#34; #define MAX_LOADSTRING 100 // 全局变量: HINSTANCE hInst; // 当前实例 WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本 WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名 // 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance); BOOL InitInstance(HINSTANCE, int); LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM); int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) { UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此处放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_WINDOWSSDK, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) { return FALSE; } HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSSDK)); MSG msg; // 主消息循环: while (GetMessage(\u0026amp;msg, nullptr, 0, 0)) { if (!TranslateAccelerator(msg.hwnd, hAccelTable, \u0026amp;msg)) { TranslateMessage(\u0026amp;msg); DispatchMessage(\u0026amp;msg); } } return (int) msg.wParam; } // // 函数: MyRegisterClass() // // 目标: 注册窗口类。 // ATOM MyRegisterClass(HINSTANCE hInstance) { WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSSDK)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_WINDOWSSDK); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(\u0026amp;wcex); } // // 函数: InitInstance(HINSTANCE, int) // // 目标: 保存实例句柄并创建主窗口 // // 注释: // // 在此函数中，我们在全局变量中保存实例句柄并 // 创建和显示主程序窗口。 // BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) { hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) { return FALSE; } ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE; } // // 函数: WndProc(HWND, UINT, WPARAM, LPARAM) // // 目标: 处理主窗口的消息。 // // WM_COMMAND - 处理应用程序菜单 // WM_PAINT - 绘制主窗口 // WM_DESTROY - 发送退出消息并返回 // // LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { switch (message) { case WM_COMMAND: { int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) { case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } } break; case WM_PAINT: { PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, \u0026amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... EndPaint(hWnd, \u0026amp;ps); } break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } return 0; } // “关于”框的消息处理程序。 INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) { UNREFERENCED_PARAMETER(lParam); switch (message) { case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) { EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; } break; } return (INT_PTR)FALSE; } 键盘消息 # 与key有关的\n相关代码\nBOOL CMFCKeyDlg::PreTranslateMessage(MSG* pMsg) { // TODO: 在此添加专用代码和/或调用基类 SHORT nShift = GetKeyState(VK_SHIFT); switch (pMsg-\u0026gt;message) { case WM_KEYDOWN: { switch (pMsg-\u0026gt;wParam) { case VK_F2: { if (nShift \u0026lt; 0) { AfxMessageBox(L\u0026#34;F2 + shift Message!\u0026#34;); break; } AfxMessageBox(L\u0026#34;F2 Message!\u0026#34;); break; } case 0x41: { AfxMessageBox(L\u0026#34;A Message!\u0026#34;); break; } case VK_ESCAPE: return 0; case VK_RETURN: return 0; default: break; } break; } default: break; } return CDialogEx::PreTranslateMessage(pMsg); } 虚拟键码\nVK_xxx ASCII码 虚拟键码表\n虚拟键码 对应值 对应键 VK_LBUTTON 1 鼠标左键 VK_RBUTTON 2 鼠标右键 VK_CANCEL 3 Cancel VK_MBUTTON 4 鼠标中键 VK_XBUTTON1 5 VK_XBUTTON2 6 VK_BACK 8 Backspace VK_TAB 9 Tab VK_CLEAR 12 Clear VK_RETURN 13 Enter VK_SHIFT 16 Shift VK_CONTROL 17 Ctrl VK_MENU 18 Alt VK_PAUSE 19 Pause VK_CAPITAL 20 Caps Lock VK_KANA 21 VK_HANGUL 21 VK_JUNJA 23 VK_FINAL 24 VK_HANJA 25 VK_KANJI 25* VK_ESCAPE 27 Esc VK_CONVERT 28 VK_NONCONVERT 29 VK_ACCEPT 30 VK_MODECHANGE 31 VK_SPACE 32 Space VK_PRIOR 33 Page Up VK_NEXT 34 Page Down VK_END 35 End VK_HOME 36 Home VK_LEFT 37 Left Arrow VK_UP 38 Up Arrow VK_RIGHT 39 Right Arrow VK_DOWN 40 Down Arrow VK_SELECT 41 Select VK_PRINT 42 Print VK_EXECUTE 43 Execute VK_SNAPSHOT 44 Snapshot VK_INSERT 45 Insert VK_DELETE 46 Delete VK_HELP 47 Help 48 0 49 1 50 2 51 3 52 4 53 5 54 6 55 7 56 8 57 9 65 A 66 B 67 C 68 D 69 E 70 F 71 G 72 H 73 I 74 J 75 K 76 L 77 M 78 N 79 O 80 P 81 Q 82 R 83 S 84 T 85 U 86 V 87 W 88 X 89 Y 90 Z VK_LWIN 91 VK_RWIN 92 VK_APPS 93 VK_SLEEP 95 VK_NUMPAD0 96 小键盘 0 VK_NUMPAD1 97 小键盘 1 VK_NUMPAD2 98 小键盘 2 VK_NUMPAD3 99 小键盘 3 VK_NUMPAD4 100 小键盘 4 VK_NUMPAD5 101 小键盘 5 VK_NUMPAD6 102 小键盘 6 VK_NUMPAD7 103 小键盘 7 VK_NUMPAD8 104 小键盘 8 VK_NUMPAD9 105 小键盘 9 VK_MULTIPLY 106 小键盘 * VK_ADD 107 小键盘 + VK_SEPARATOR 108 小键盘 Enter VK_SUBTRACT 109 小键盘 - VK_DECIMAL 110 小键盘 . VK_DIVIDE 111 小键盘 / VK_F1 112 F1 VK_F2 113 F2 VK_F3 114 F3 VK_F4 115 F4 VK_F5 116 F5 VK_F6 117 F6 VK_F7 118 F7 VK_F8 119 F8 VK_F9 120 F9 VK_F10 121 F10 VK_F11 122 F11 VK_F12 123 F12 VK_F13 124 VK_F14 125 VK_F15 126 VK_F16 127 VK_F17 128 VK_F18 129 VK_F19 130 VK_F20 131 VK_F21 132 VK_F22 133 VK_F23 134 VK_F24 135 VK_NUMLOCK 144 Num Lock VK_SCROLL 145 Scroll VK_LSHIFT 160 VK_RSHIFT 161 VK_LCONTROL 162 VK_RCONTROL 163 VK_LMENU 164 VK_RMENU 165 VK_BROWSER_BACK 166 VK_BROWSER_FORWARD 167 VK_BROWSER_REFRESH 168 VK_BROWSER_STOP 169 VK_BROWSER_SEARCH 170 VK_BROWSER_FAVORITES 171 VK_BROWSER_HOME 172 VK_VOLUME_MUTE 173 VolumeMute VK_VOLUME_DOWN 174 VolumeDown VK_VOLUME_UP 175 VolumeUp VK_MEDIA_NEXT_TRACK 176 VK_MEDIA_PREV_TRACK 177 VK_MEDIA_STOP 178 VK_MEDIA_PLAY_PAUSE 179 VK_LAUNCH_MAIL 180 VK_LAUNCH_MEDIA_SELECT 181 VK_LAUNCH_APP1 182 VK_LAUNCH_APP2 183 VK_OEM_1 186 ; : VK_OEM_PLUS 187 = + VK_OEM_COMMA 188 VK_OEM_MINUS 189 - _ VK_OEM_PERIOD 190 VK_OEM_2 191 / ? VK_OEM_3 192 ` ~ VK_OEM_4 219 [ { VK_OEM_5 220 \\ | VK_OEM_6 221 ] } VK_OEM_7 222 \u0026rsquo; \u0026quot; VK_OEM_8 223 VK_OEM_102 226 VK_PACKET 231 VK_PROCESSKEY 229 VK_ATTN 246 VK_CRSEL 247 VK_EXSEL 248 VK_EREOF 249 VK_PLAY 250 VK_ZOOM 251 VK_NONAME 252 VK_PA1 253 VK_OEM_CLEAR 254 鼠标消息 # 与BUTTON有关 L左键 M中键 R右键\n相关代码\nswitch (pMsg-\u0026gt;message) { case WM_LBUTTONDOWN: { AfxMessageBox(L\u0026#34;客户区鼠标左键点击\u0026#34;); break; } case WM_NCLBUTTONDOWN: { AfxMessageBox(L\u0026#34;非客户区鼠标左键点击\u0026#34;); break; } case WM_LBUTTONDBLCLK: { AfxMessageBox(L\u0026#34;客户区鼠标左键双击\u0026#34;); break; } case WM_NCLBUTTONDBLCLK: { AfxMessageBox(L\u0026#34;非客户区鼠标左键双击\u0026#34;); break; } case WM_LBUTTONUP: { AfxMessageBox(L\u0026#34;鼠标左键被释放\u0026#34;); break; } default: break; } Windows控制台 # #include \u0026lt;Windows.h\u0026gt; int main() { DWORD dwCount; HANDLE hStd = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStd, FOREGROUND_RED | FOREGROUND_BLUE | BACKGROUND_BLUE); WriteConsole(hStd, L\u0026#34;Hello World!\u0026#34;, wcslen(L\u0026#34;Hello World!\u0026#34;), \u0026amp;dwCount, NULL); SetConsoleTitle(L\u0026#34;Title\u0026#34;); return 0; } 内存申请与释放 # HeapAlloc 内存申请 HeapFree 内存释放\n相关代码\nHANDLE hHeap = GetProcessHeap(); char * str = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x100); HeapFree(hHeap, 0, str); 文件操作 # Win32 # 查看官方文档学习\n#include \u0026lt;Windows.h\u0026gt; int main() { HANDLE hFile = CreateFile(L\u0026#34;C:\\\\Users\\\\15890\\\\Desktop\\\\Test.txt\u0026#34;,GENERIC_ALL,NULL,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL); if (INVALID_HANDLE_VALUE == hFile) { MessageBox(0, L\u0026#34;CreateFile Failed!\u0026#34;, L\u0026#34;Error\u0026#34;, MB_OK); ExitProcess(0); system(\u0026#34;pause\u0026#34;); } DWORD dwFileLen = GetFileSize(hFile, NULL); PTCHAR szBuffer; HANDLE hHeap = GetProcessHeap(); szBuffer = (PTCHAR)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwFileLen); DWORD dwReadSize; ReadFile(hFile, szBuffer, dwFileLen,\u0026amp;dwReadSize, NULL); CHAR szWriteBuffer[] = \u0026#34;Hello Windows API\u0026#34;; DWORD dwWriteSize; WriteFile(hFile, szWriteBuffer,strlen(szWriteBuffer), \u0026amp;dwWriteSize, NULL); HeapFree(hHeap, 0, szBuffer); CloseHandle(hFile); return 0; } CFile类 # 官方文档非常详细\nCFile cFile; cFile.Open(L\u0026#34;C:\\\\Users\\\\15890\\\\Desktop\\\\Test.txt\u0026#34;, CFile::modeReadWrite); DWORD dwFileLen = cFile.GetLength(); PTCHAR szBuffer; HANDLE hHeap = GetProcessHeap(); szBuffer = (PTCHAR)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwFileLen); cFile.Read(szBuffer, dwFileLen); CHAR pbufWrite[] = \u0026#34;Hello CFile\u0026#34;; cFile.Write(pbufWrite, strlen(pbufWrite)); cFile.Flush(); 消息框 # MessageBox Win32\nDWORD ret = MessageBox(L\u0026#34;Hello World!\u0026#34;, L\u0026#34;Title\u0026#34;, MB_YESNO); if (ret == IDYES) { MessageBox(L\u0026#34;Yes\u0026#34;, L\u0026#34;Tip\u0026#34;, MB_OK); } else if(ret == IDNO) { MessageBox(L\u0026#34;No\u0026#34;, L\u0026#34;Tip\u0026#34;, MB_OK); } AfxMessageBox MFC\nDWORD ret = AfxMessageBox(L\u0026#34;Hello World!\u0026#34;, MB_YESNO); if (ret == IDYES) { AfxMessageBox(L\u0026#34;Yes\u0026#34;, MB_OK); } else if (ret == IDNO) { AfxMessageBox(L\u0026#34;No\u0026#34;, MB_OK); } 对话框 # 模态对话框 # 会占用主对话框\n相关代码\nvoid CMFCAppModDlg::OnBnClickedButton1() { // TODO: 在此添加控件通知处理程序代码 CDialogMod dlg; dlg.DoModal(); } 非模态对话框 # 不会占用主对话框\n相关代码\nvoid CMFCAppModDlg::OnBnClickedButton2() { // TODO: 在此添加控件通知处理程序代码 CDialogModLess* m_Dlg = NULL; if (!m_Dlg) { m_Dlg = new CDialogModLess; m_Dlg-\u0026gt;Create(IDD_DIALOG2,this); m_Dlg-\u0026gt;ShowWindow(SW_SHOW); } } 通用对话框-文件选择 # 相关代码\nCFileDialog m_dlg(TRUE, NULL, NULL, NULL, L\u0026#34;文本文件|*.txt|可执行文件|*.exe|所有文件|*.*||\u0026#34;, this); m_dlg.DoModal(); CString szPath = m_dlg.GetPathName(); if(!szPath.IsEmpty()) AfxMessageBox(szPath); 状态栏 # 相关代码\nm_StatusBar.Create(this); UINT arr[] = { 1,2,3 }; m_StatusBar.SetIndicators(arr, 3); m_StatusBar.SetPaneInfo(0, arr[0], SBPS_NORMAL, 100); m_StatusBar.SetPaneInfo(1, arr[1], SBPS_NORMAL, 100); m_StatusBar.SetPaneInfo(2, arr[2], SBPS_NORMAL, 100); m_StatusBar.SetPaneText(0, L\u0026#34;Text1\u0026#34;); m_StatusBar.SetPaneText(1, L\u0026#34;Text2\u0026#34;); m_StatusBar.SetPaneText(2, L\u0026#34;Text3\u0026#34;); RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0); 控件 # 常用控件\n单选控件 复选控件 按钮控件 静态文本控件 编辑控件 列表控件 下拉框控件 进度条控件 滑块控件 IP控件 树状控件 tab控件 (可参考微软官方文档进行学习)\ntab控件 # 初始化\nm_Tab.InsertItem(0, L\u0026#34;Text\u0026#34;); m_Tab.InsertItem(1, L\u0026#34;List\u0026#34;); m_Tab.InsertItem(2, L\u0026#34;Tree\u0026#34;); m_Tab.InsertItem(3, L\u0026#34;Other\u0026#34;); m_dlgText.Create(IDD_DIALOG1, \u0026amp;m_Tab); m_dlgList.Create(IDD_DIALOG2, \u0026amp;m_Tab); m_dlgTree.Create(IDD_DIALOG3, \u0026amp;m_Tab); m_dlgOther.Create(IDD_DIALOG4, \u0026amp;m_Tab); CRect rs; m_Tab.GetClientRect(rs); rs.top += 20; m_dlgText.MoveWindow(rs); m_dlgList.MoveWindow(rs); m_dlgTree.MoveWindow(rs); m_dlgOther.MoveWindow(rs); m_dlgText.ShowWindow(SW_SHOW); 使用\nint nCurSel; nCurSel = m_Tab.GetCurSel(); switch (nCurSel) { case 0: { m_dlgText.ShowWindow(SW_SHOW); m_dlgList.ShowWindow(SW_HIDE); m_dlgTree.ShowWindow(SW_HIDE); m_dlgOther.ShowWindow(SW_HIDE); break; } case 1: { m_dlgText.ShowWindow(SW_HIDE); m_dlgList.ShowWindow(SW_SHOW); m_dlgTree.ShowWindow(SW_HIDE); m_dlgOther.ShowWindow(SW_HIDE); break; } case 2: { m_dlgText.ShowWindow(SW_HIDE); m_dlgList.ShowWindow(SW_HIDE); m_dlgTree.ShowWindow(SW_SHOW); m_dlgOther.ShowWindow(SW_HIDE); break; } case 3: { m_dlgText.ShowWindow(SW_HIDE); m_dlgList.ShowWindow(SW_HIDE); m_dlgTree.ShowWindow(SW_HIDE); m_dlgOther.ShowWindow(SW_SHOW); break; } default: break; } 热键 # 相关代码\n注册\nRegisterHotKey(m_hWnd, HOT_KEY_MESSAGEBOX, MOD_WIN, VK_F2); 使用\nvoid CMFCAppUseDlg::OnHotKey(UINT nHotKeyId, UINT nKey1, UINT nKey2) { // TODO: 在此添加消息处理程序代码和/或调用默认值 switch (nHotKeyId) { case HOT_KEY_MESSAGEBOX: { AfxMessageBox( L\u0026#34;\\u2764\\u2721\\u262a\\u2600\\u2602\\u2622\\u2648\\u2649\\u264a\\u264b\\u264c\\u264d\u0026#34; L\u0026#34;\\u264e\\u264f\\u2650\\u2651\\u2652\\u2653\\u2690\\u2691\\u26c4\\u2620\\u27bc\\u2200\u0026#34; ); break; } default: break; } CDialogEx::OnHotKey(nHotKeyId, nKey1, nKey2); } ","date":"February 22, 2022","permalink":"/posts/mfc_basic/","section":"Posts","summary":"MFC # 默认UNICODE编码\nCTIME类 # 获取时间的类对象，可以通过类方法获取时间\n使用方法\nCTime m_Time = CTime::GetCurrentTime(); int nYear = m_Time.GetYear(); int nMonth = m_Time.GetMonth(); int nDay = m_Time.GetDay(); int nHour = m_Time.GetHour(); int nMinute = m_Time.GetMinute(); int nSecond = m_Time.GetSecond(); MFC三种开发模式 # SDK \u0026ndash;\u0026gt; Win32 MFC \u0026ndash;\u0026gt; MFC 托管 \u0026ndash;\u0026gt; CLR 字符串 # ASCII char CHAR UNICODE wchar_t WCHAR T TCHAR\nCString类 # 定义与初始化\nCString str(L\u0026#34;大大大\u0026#34;); CString str1; str1 = L\u0026#34;小小小\u0026#34;; CString str2 = str1; CString str3 = L\u0026#39;A\u0026#39;; CString str4(L\u0026#34;A\u0026#34;,66); 格式化字符串","title":"MFC基础 笔记"},{"content":"","date":"February 22, 2022","permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows"},{"content":"","date":"February 7, 2022","permalink":"/tags/css/","section":"Tags","summary":"","title":"css"},{"content":"CSS3样式 # 盒子 # 与盒子模型相关的一些样式属性\n圆角 # 复合属性\ndiv{ width:100px; height:100px; border-radius:2px; /* 四个圆角值均为2px */ border-radius:2px 4px; /* 左上角与右下角为2px，右上角和左下角为4px */ border-radius:2px 4px 3px; /* 左上角为2px，右上角和左下角为4px，右下角为3px */ border-radius:2px 4px 3px 1px; /* 左上角为2px，右上角为4px，右下角为3px，左下角为1px */ } 复合属性分开书写\ndiv{ width:100px; height:100px; border-top-left-radius:2px; border-top-right-radius:4px; border-bottom-right-radius:3px; border-bottom-left-radius:1px; } 盒阴影 # .box1{ width:100px; height:100px; box-shadow:10px 5px blue; /* 设置竖直偏移10px 水平偏移5px的蓝色盒阴影 */ } .box2{ width:100px; height:100px; box-shadow:10px 5px 3px blue; /* 设置竖直偏移10px 水平偏移5px 模糊半径3px的蓝色盒阴影 */ } .box3{ width:100px; height:100px; box-shadow:10px 5px 3px 6px blue; /* 设置竖直偏移10px 水平偏移5px 模糊半径3px 扩散半径6px的蓝色盒阴影 */ } .box4{ width:100px; height:100px; box-shadow:10px 5px 5px 5px blue inset; /* 设置竖直偏移10px 水平偏移5px 模糊半径3px 扩散半径6px的蓝色盒内阴影 */ } 边界图片 # 构建美丽的可扩展按钮\ndiv{ border-image:url(../img/img.png) 10 10 stretch; } hi{ border-image:linear-gradient(red, yellow) 10 10 round; } p{ border-image:url(../img/img.svg) 10 10 repeat; } 背景 # [[CSS-selector#背景|查看CSS背景属性]]\ndiv{ width:100px; height:100px; background-clip:content-box; /* 指定背景绘制区域，有border-box、padding-box和content-box属性值 */ background-origin:content-box; /* 设置元素背景图片的原始起始位置，指定background-position属性应该是相对属性 */ background-size:cover; /* 指定背景图片大小 */ background-image:url(../img/1.jpg),url(../img/2.jpg); /* 设置多重背景（前遮后显） */ } 背景属性整合\ndiv{ width:100px; height:100px; background:red center cover no-repeat content-box content-box fixed url(../img/img.png); } 渐变 # 可以在两个或多个指定的颜色之间显示平稳的过渡\n线性渐变 # 沿着一根轴线改变颜色，从起点到终点颜色进行顺序渐变（从一边拉向另一边）\nlinear-gradient属性\n.box1{ width:100px; height:100px; background:linear-gradient(red,yellow); } .box2{ width:100px; height:100px; background:linear-gradient(to right,red,yellow); } .box3{ width:100px; height:100px; background:linear-gradient(to right top,red,yellow); } /* 使用角度 */ .box4{ width:100px; height:100px; background:linear-gradient(45deg,red,yellow); /* 默认情况 */ background:-webkit-linear-gradient(45deg,red,yellow) /* -webkit-情况 */ } /* 使用百分比调节 */ .box5{ width:100px; height:100px; background:linear-gradient(red 0%, orange 25%, yellow 50%, green 75%, blue 100%); } 默认情况\n-webkit-情况\n拓展：重复渐变\n.box{ width:100px; height:100px; background:repeating-linear-gradient(red 0%,yellow 10%,red 20%); } 径向渐变 # 从起点到终点颜色从内到外进行圆形渐变（从中间向外拉）\n.box1{ background:radial-gradient(#e66465, #9198e5); } .box2{ background:radial-gradient(circle, #e66465, #9198e5); } .box3{ background:radial-gradient(circle closest-side, #e66465, #9198e5); } .box4{ background:radial-gradient(circle at 50%, #e66465, #9198e5); } 尺寸关键字\nclosest-side最近边 farthest-side最远边 closest-corner最近角 farthest-corner最远角 拓展：重复渐变\n.box{ background:repeating-radial-gradient(red 0%, yellow 10%, red 20%); } IE渐变 # .box{ filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\u0026#39;red\u0026#39;,endColorstr=\u0026#39;yellow\u0026#39;,GradientType=0); } 文本 # p{ text-shadow:5px 5px 3px yellow; /* 设置水平偏移5px竖直偏移5px模糊半径3px颜色是黄色的文本阴影 */ text-outline:2px 1px red; /* 设置文本轮廓粗细为2px模糊半径为1px颜色为红色的文本轮廓 */ word-break:keep-all; /* 规定自动换行的处理方法 */ word-wrap:break-word; /* 允许长单词或URL地址换行到下一行 */ } 新文本属性\ntext-align-last属性\n规定如何对齐文本的最后一行\n.text1{ text-align-last:auto; } .text2{ text-align-last:center; } .text3{ text-align-last:justify; } 兼容性：text-align-last属性只有IE支持，在Firefox中需要加上其前缀 “-moz” ，Chrome50.0.2661.102以上\n注意：text-align-last属性只有在text-align属性设置为 ”justify”时才起作用\ntext-overflow属性\n规定当文本溢出包含元素时发生的事情\n.text1{ text-overflow:clip; /* 截断 */ } .text2{ text-overflow:ellipsis; /* 省略号 */ } .text3{ text-overflow:string; /* 火狐独有 */ } 字体 # @font-face字体\nCSS3字体模块，把字体文件放在服务器上，读取字体\n字体格式\nTrueType(.ttf)格式\n.ttf字体是Windows和Mac的最常用字体，是一种RAW格式，因此他不为网站优化\nOpenType(.otf)格式\n.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，所以也提供了更多的功能\nWeb Open Font Format(.woff)格式\n.woff字体是Web字体中最佳格式，他是一个开发的TrueType/OpenType的压缩版本，同时也支持元数据包的分离\nEmbedded Open Type(.eot)格式\n.eot字体是IE专用字体，可以从TrueType创建此格式字体\nSVG(.svg)格式\n.svg字体是基于SVG字体渲染的一种格式\n通用书写模板\n@font-face{ font-family:\u0026#39;YourWebFontName\u0026#39;; src:url(\u0026#34;YourWebFontName.eot\u0026#34;); src:url(\u0026#34;YourWebFontName.eot?#iefix\u0026#34;)format(\u0026#39;embedded-opentype\u0026#39;), url(\u0026#34;YourWebFontName.ttf\u0026#34;)format(\u0026#39;turetype\u0026#39;), url(\u0026#34;YourWebFontName.woff\u0026#34;)format(\u0026#39;woff\u0026#39;), url(\u0026#34;YourWebFontName.svg#YourWebFontName\u0026#34;)format(\u0026#34;svg\u0026#34;); } 取值说明\nYourWebFontName ：自定义的字体名称，他将被引用到Web元素中的font-family\nsource ：自定义的字体的存放路径，可以是相对路径也可以是绝对路径\nformat ：自定义字体的格式，主要用来帮助浏览器识别\n获取特殊字体\n","date":"February 7, 2022","permalink":"/posts/css3-style/","section":"Posts","summary":"CSS3样式 # 盒子 # 与盒子模型相关的一些样式属性\n圆角 # 复合属性\ndiv{ width:100px; height:100px; border-radius:2px; /* 四个圆角值均为2px */ border-radius:2px 4px; /* 左上角与右下角为2px，右上角和左下角为4px */ border-radius:2px 4px 3px; /* 左上角为2px，右上角和左下角为4px，右下角为3px */ border-radius:2px 4px 3px 1px; /* 左上角为2px，右上角为4px，右下角为3px，左下角为1px */ } 复合属性分开书写\ndiv{ width:100px; height:100px; border-top-left-radius:2px; border-top-right-radius:4px; border-bottom-right-radius:3px; border-bottom-left-radius:1px; } 盒阴影 # .box1{ width:100px; height:100px; box-shadow:10px 5px blue; /* 设置竖直偏移10px 水平偏移5px的蓝色盒阴影 */ } .box2{ width:100px; height:100px; box-shadow:10px 5px 3px blue; /* 设置竖直偏移10px 水平偏移5px 模糊半径3px的蓝色盒阴影 */ } .box3{ width:100px; height:100px; box-shadow:10px 5px 3px 6px blue; /* 设置竖直偏移10px 水平偏移5px 模糊半径3px 扩散半径6px的蓝色盒阴影 */ } .","title":"CSS3样式 笔记"},{"content":"","date":"February 7, 2022","permalink":"/tags/website/","section":"Tags","summary":"","title":"website"},{"content":"CSS3基础 # 选择器 # 基础选择器 # section \u0026gt; div{ /* 子元素选择器 */ color:#ffffff; } .brother + div{ /* 相邻兄弟元素选择器 */ color:#ff0000; } .brother ~ div{ /* 通用兄弟元素选择器 */ color:#00ff00; } div, p, section, .brother, #id{ /* 群组选择器 */ color:#0000ff; } 属性选择器 # a[href]{ color:#000000; } a[href=\u0026#34;http://www.baidu.com\u0026#34;]{ /* 元素属性值 */ color:#666666; } input[value~=\u0026#34;password\u0026#34;]{ /* 元素包含指定属性值 */ color:#333333; } input[value^=\u0026#34;pass\u0026#34;]{ /* 元素开头属性值 */ color:#223333; } input[value$=\u0026#34;rd\u0026#34;]{ /* 元素结尾属性值 */ color:#222233; } input[value*=\u0026#34;word\u0026#34;]{ /* 元素属性值包含 */ color:#222222; } input[name|=\u0026#34;use\u0026#34;]{ /* 元素属性值-开头 */ color:#454545; } 伪类选择器 # 动态伪类 # 不存在于HTML中，只有当用户和网站交互的时候才能体现出来\na:link{ color:red; } a:visited{ color:green; } a:hover{ color:blue; } a:action{ color:white; } input:focus{ border:green 2px solid; } UI元素状态伪类 # input:enabled{ /* 设置可编辑状态样式 */ background-color:#ffff00; } input:disabled{ /* 设置不可编辑状态样式 */ background-color:#dddddd; } input:checked{ background-color:#ff0000; /* 设置多选框选中颜色，只兼容Opera浏览器 */ } 结构类选择器:nth选择器 # div:first-child{ /* 相对父元素首个子元素 */ background-color:#000000; } div:last-child{ /* 相对父元素最后一个子元素 */ backgroud-color:#880000; } /* 相对于父元素的第n个子元素 */ div:nth-child(2n-1){ background-color:#008800; } div:nth-child(1){ background-color:#000088; } div:nth-child(odd){ background-color:#800000; } /* 相对于父元素倒数第n个子元素 */ div:nth-last-child(2n-1){ background-color:#080000; } /* 相对于父元素特定类型的第n个子元素 */ div:nth-of-type(2n-1){ background-color:#008000; } /* 相对于父元素特定类型的倒数第n个子元素 */ div:nth-last-of-type(2n-1){ background-color:#000800; } /* 相对于父元素特定类型的第一个子元素 */ div:first-of-type{ background-color:#000080; } /* 相对于父元素特定类型的最后一个子元素 */ div:last-of-type{ background-color:#000008; } /* 相对于父元素唯一子元素 */ div:only-child{ background-color:#808000; } /* 相对于父元素唯一特定类型的子元素 */ div:only-of-type{ background-color:#800800; } /* 匹配没有子元素（包括文本节点）的每一个元素 */ div:empty{ background-color:#800080; } 否定选择器（：not） # /* 匹配非指定元素/选择器的每个元素 */ section:not(div){ background-color:#008888; } section:not(.child){ background-color:#888800; } 伪类和伪元素 # 伪元素：只是一个选择器，不存在的一种元素\n伪类：实际存在的一种元素\n伪元素 # CSS伪元素用于向某些选择器设置特殊效果\n语法格式：元素::伪元素\n/* 类型 */ div::first-line{ /* 对元素的第一行文本进行格式化， 只用于块级元素 */ font-size:24px; } div::first-letter{ /* 对元素的第一个字符进行格式化， 只用于块级元素 */ font-size:32px; } div::before{ /* 在元素的内容前面插入新内容，常用\u0026#34;content\u0026#34;配合使用 */ content:\u0026#34;\u0026#34;; display:block; width:100px; height:100px; background-color:#ff0000; } div::after{ /* 在元素的内容后面插入新内容，常用\u0026#34;content\u0026#34;配合使用。多用于清除浮动 */ content:\u0026#34;\u0026#34;; clear:both; width:100px; height:100px; background-color:#00ff00; } ::selection{ /* 用于设置在浏览器中选中文本后的背景色与前景色 */ color:#ff0000; background-color:#00ff00; } ::after和::before特点总结\n行级元素 最后/第一个子元素 内容通过content写入 支持一切css属性 标签里找不到对应标签 CSS权重 # 当很多的规则被应用到某一个元素上时，权重是一个决定哪种规则生效，或者是优先级的过程\n权重等级与[[CSS-basic#权值|权值]]\n行内样式(1000)\u0026gt;ID选择器(100)\u0026gt;类、属性选择器和伪类选择器(10)\u0026gt;元素和伪元素(1)\u0026gt;*(0)\n权重计算口诀\n从0开始，一个行内样式+1000，一个id+100，一个属性选择器、class或者伪类+10，一个元素名或者伪元素+1\nCSS权重规则 # 包含更高权重选择器的一条规则拥有更高的权重\nID选择器(#idValue)的权重比属性选择器([id=\u0026quot;idValue\u0026quot;])高\n带有上下文关系的选择器比单纯的元素选择器权重要高\n与元素 “挨得近” 的规则生效\n最后定义的这条规则覆盖上面与之冲突的规则\n无论多少给元素组成的选择器，都没有一个class选择器权重高\n通配符选择器权重是0，被继承的css属性也带有权重，权重也是0\n","date":"February 7, 2022","permalink":"/posts/css3-basic/","section":"Posts","summary":"CSS3基础 # 选择器 # 基础选择器 # section \u0026gt; div{ /* 子元素选择器 */ color:#ffffff; } .brother + div{ /* 相邻兄弟元素选择器 */ color:#ff0000; } .brother ~ div{ /* 通用兄弟元素选择器 */ color:#00ff00; } div, p, section, .brother, #id{ /* 群组选择器 */ color:#0000ff; } 属性选择器 # a[href]{ color:#000000; } a[href=\u0026#34;http://www.baidu.com\u0026#34;]{ /* 元素属性值 */ color:#666666; } input[value~=\u0026#34;password\u0026#34;]{ /* 元素包含指定属性值 */ color:#333333; } input[value^=\u0026#34;pass\u0026#34;]{ /* 元素开头属性值 */ color:#223333; } input[value$=\u0026#34;rd\u0026#34;]{ /* 元素结尾属性值 */ color:#222233; } input[value*=\u0026#34;word\u0026#34;]{ /* 元素属性值包含 */ color:#222222; } input[name|=\u0026#34;use\u0026#34;]{ /* 元素属性值-开头 */ color:#454545; } 伪类选择器 # 动态伪类 # 不存在于HTML中，只有当用户和网站交互的时候才能体现出来","title":"CSS3基础 笔记"},{"content":"选择器 # 标签选择器\na{ text-decoration:none; } class选择器\n.class{ font-size:24px; color:#666; } ID选择器\n#id{ line-height:30px; background-color:#666; } 全局选择器\n*{ margin:0; padding:0; border:none; } 群组选择器\na,.class,#id{ font-size:20px; } 后代选择器\ndiv a{ color:#000; } 拓展应用：组合使用多种选择器\n伪类选择器 # 特点\n定义特殊状态下的样式 无法使用标签、id、class及其他属性实现 [[CSS3-basic#伪类选择器|伪类]]\n链接\na:active{/*链接激活*/ color:#fff; } a:visited{/*链接已访问*/ color:#00ff00; } a:link{/*链接未访问*/ color:#ff0000; } a:hover{/*鼠标悬停*/ color:#0000ff; } 顺序：link\u0026gt;visited\u0026gt;hover\u0026gt;active\n说明：伪类对大小写不敏感、link和visited顺序无所谓\nactive和hover可以适用其他元素\n注意：兼容性问题\n样式 # ==单位== # 绝对单位\n不能根据浏览器或父元素大小的改变而改变\nin、cm、mm、pt、pc 属性xx-small、x-small、small、medium、large、x-large、xx-large 相对单位\npx(受分辨率影响)、em/%(相对于父元素 继承计算值) 属性值：large、smaller(相对父元素) 字体 # p{ font-family:\u0026#34;微软雅黑\u0026#34;;/* 字体 */ font-size:16px;/* 字体大小 */ color:#000; /* 前景颜色 */ font-weight:normal; /* 字体粗细 */ font-style:normal; /* 字体样式 */ font-variant:small-caps; /* 字体变形 */ } h1{ font:italic normal bolder 24px/32px Serif; /* 注意书写顺序：font-style font-variant font-weight(顺序任意) font-size/line-height font-family 不设置自己单独下载的字体 */ } 文字 # p{ text-indent:2em; text-align:center;/* 水平对齐 对于块级元素进行设置，可以继承*/ line-height:24px;/* 可以继承、继承是继承计算值*/ } span{ vertical-align:middle;/* 对于行内元素和单元格元素进行设置 文字基线 */ } p{ word-spacing:1px;/* 单词间距 */ letter-spacing:0.5px;/* 字母间距 */ text-transform:capitalize;/* 设置大小写 */ text-decoration:none;/* 设置装饰，应用于所用元素，不能继承*/ } 背景 # [[CSS3-style#背景|了解CSS3的新增背景属性]]\ndiv{ background-color:#fff; /* 设置背景颜色，可用颜色名、rgb、rgba、十六进制 */ background-image:url(../img/img.png); background-position:center; /* 背景图片的起始位置，可以使用百分比和位置关键词 */ background-attachment:fixed; /* 显示方式 */ background-repeat:no-repeat; /* 背景图片重复 */ } background-position属性说明\nsection{ background:#fff url(../img/img.png) no-repeat fixed center; /* 顺序不固定 */ } 列表 # ul{ list-style-type:none; list-style-image:url(../icon/icon.svg); list-style-positon:outside; /* 列表标记文字，有两个属性值：inside和outside. inside: 列表项目标标记放置在文本内，且环绕文本根据标记对齐 outside： 默认值，列表项目标记放置在文本意外，且环绕文本不根据标记对齐 */ } 列表项标记说明\nol{ list-style: none url(../icon/icon.svg) outside; /* 顺序不固定，list-style-image属性会覆盖list-style-type的设置 */ opacity:0;/* 透明度设置 */ } ","date":"February 7, 2022","permalink":"/posts/css-selector/","section":"Posts","summary":"选择器 # 标签选择器\na{ text-decoration:none; } class选择器\n.class{ font-size:24px; color:#666; } ID选择器\n#id{ line-height:30px; background-color:#666; } 全局选择器\n*{ margin:0; padding:0; border:none; } 群组选择器\na,.class,#id{ font-size:20px; } 后代选择器\ndiv a{ color:#000; } 拓展应用：组合使用多种选择器\n伪类选择器 # 特点\n定义特殊状态下的样式 无法使用标签、id、class及其他属性实现 [[CSS3-basic#伪类选择器|伪类]]\n链接\na:active{/*链接激活*/ color:#fff; } a:visited{/*链接已访问*/ color:#00ff00; } a:link{/*链接未访问*/ color:#ff0000; } a:hover{/*鼠标悬停*/ color:#0000ff; } 顺序：link\u0026gt;visited\u0026gt;hover\u0026gt;active\n说明：伪类对大小写不敏感、link和visited顺序无所谓\nactive和hover可以适用其他元素\n注意：兼容性问题\n样式 # ==单位== # 绝对单位\n不能根据浏览器或父元素大小的改变而改变\nin、cm、mm、pt、pc 属性xx-small、x-small、small、medium、large、x-large、xx-large 相对单位\npx(受分辨率影响)、em/%(相对于父元素 继承计算值) 属性值：large、smaller(相对父元素) 字体 # p{ font-family:\u0026#34;微软雅黑\u0026#34;;/* 字体 */ font-size:16px;/* 字体大小 */ color:#000; /* 前景颜色 */ font-weight:normal; /* 字体粗细 */ font-style:normal; /* 字体样式 */ font-variant:small-caps; /* 字体变形 */ } h1{ font:italic normal bolder 24px/32px Serif; /* 注意书写顺序：font-style font-variant font-weight(顺序任意) font-size/line-height font-family 不设置自己单独下载的字体 */ } 文字 # p{ text-indent:2em; text-align:center;/* 水平对齐 对于块级元素进行设置，可以继承*/ line-height:24px;/* 可以继承、继承是继承计算值*/ } span{ vertical-align:middle;/* 对于行内元素和单元格元素进行设置 文字基线 */ } p{ word-spacing:1px;/* 单词间距 */ letter-spacing:0.","title":"CSS选择器 笔记"},{"content":"CSS进阶 # 盒子模型 # 盒子模型用来“放”网页中的各种元素\n网页设计中内容，如文字、图片等元素， 都可是盒子（div嵌套）\n生活中的盒子：\npadding内填充 border边框 margin外边距 物体content内容：\nwidth宽 height高 属性 # div{ width:80%; max-width:1000px; min-width:300px; height:auto; max-height:1000px; min-height:300px; border-width:medium; border-color:red; border-style:solid; /* 内边距的属性值不能为负值 */ padding:20px; /* 4个方向都是20px */ padding:20px 40px; /* 上下=20px 左右=40px */ padding:20px 40px 10px; /* 上=20px 左右=40px 下=10px */ padding:20px 30px 10px 40px; /* 上=20px 右=30px 下=10px 左=40px */ margin:20px; margin:20px 40px; margin:20px 40px 10px; margin:20px 30px 10px 40px; /* 垂直方向，两个相邻元素都设置外边距，外边距会发生合并 合并后外边距高度=两个发生合并外边距的高度中最大值 */ } 宽高属性总结\nwidth和height属性设置是内容的高和宽 width和height属性设置对块级元素和替换元素有效 max-height(width)/min-height(width)有兼容问题，IE不支持 盒子模型的属性值均有四个方向： top bottom left right\n盒子模型属性值简写\ndiv{ margin:20px 30px 10px 40px; padding:20px 30px 10px 40px; border:2px red solid; height:auto; width:auto; } 计算 # 标准盒子模型：\n宽度=左边距+左边框+左填充+内容宽度+右填充+右边框+右边距 高度=上边距+上边框+上填充+内容高度+下填充+下边框+下边距 doctype声明 –\u0026gt; 标准盒子模型\ndisplay属性 # div{ display:inline; } span{ display:block; } img{ display:inline-block; } ul{ display:none; } 样式继承关系\n定位 # 定位机制\n普通流（标准流）：默认状态，元素自动从左往右，从上往下的排列 浮动 绝对定位 浮动 # 基础知识\n会使元素向左或向右移动，只能左右，不能上下 浮动元素碰到包含框或另一浮动框，浮动停止 浮动元素之后的元素将围绕它，之前的不受影响 浮动元素会脱离标准流 语法\n.box_1{ float:left; } .box_2{ float:right; } .box_3{ float:none; } 不会脱离文本流，会脱离文档流（普通流）\n问题： 浮动塌陷，浮动溢出\n清除浮动 # .box{ clear:both; } 设置了float的元素会影响其他相邻元素，需要使用clear清除浮动，clear只会影响自身，不会对其他相邻元素造成影响\n常用方法\n在浮动元素后使用一个空元素加clear\n给浮动元素的容器添加overflow:hidden\n使用CSS3的:after[[CSS3-basic#伪元素|伪元素]]\n.clearfix:after{ content:\u0026#34;\u0026#34;; display:block; height:0; visibility:hidden; clear:both; } .clearfix{ zoom:1;/* 触发hasLayout兼容IE6、7 */ } 其他方法\n父级元素定义height。只适合高度固定的布局。 父级元素也一起浮动。不推荐，会产生新的浮动问题。 浮动总结 # 会使元素左右移动 浮动元素会脱离普通流 元素浮动后具备inline-block属性 清除方法推荐\n使用CSS3:after伪元素清除浮动 使用overflow:hidden清除浮动 绝对定位 # position模块\nPositioned Layout Module\n提供与元素定位和层叠相关功能，它是核心模块\n盒子模型的类型和尺寸 布局模型 元素之间的关系 视口大小、图像大小等其他相关方面 小知识点\nDocument tree 文档树\nnormal-flow 自然顺序\ncontaining-block 容器\n定位模型 # 自然模型static\n静态定位/常规定位/自然定位 —— 定位中的一股清流-回归本真\n相对定位模型relative\n绝对定位模型absoluate\n固定定位模型fixed\n磁贴定位模型sticky\n磁贴定位/粘性定位/吸附定位 ——赛季新秀 实力布局糖\n定位总结 # 布局 # 认识布局\n以最合适浏览的方式将图片和文字排放在页面的不同位置 布局模式有多种，不同的制作者有不同的布局设计 ==前端工程师 = 技术 + 艺术==\n经典行布局\n基础的行布局 行布局自适应限制最大宽 行布局垂直水平居中 经典的列布局\n两列布局固定 两列布局自适应 三列布局固定 三列布局自适应 混合布局\n混合布局固定 混合布局自适应 圣杯布局 # 由来\n圣杯布局是由国外的Kevin Cornell 提出的一个布局模型概念\n在国内由淘宝UED的工程师传播开来\n布局要求\n三列布局，中间宽度自适应，两边定宽 中间栏要在浏览器中优先展示渲染 允许任意列高度最高 用最简单的CSS、最少的HACK语句 \u0026lt;div class=\u0026#34; container\u0026#34; \u0026gt; \u0026lt;div\u0026gt; 中间 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; 左侧 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; 右侧 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 双飞翼布局 # 经淘宝UED的工程师针对圣杯布局改良后得出双飞翼布局 去掉相对布局，只需要浮动和负边距 \u0026lt;div class=\u0026#34;main\u0026#34; \u0026gt; \u0026lt;div\u0026gt; 中间 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; 左侧 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; 右侧 \u0026lt;/div\u0026gt; ","date":"February 7, 2022","permalink":"/posts/css-up/","section":"Posts","summary":"CSS进阶 # 盒子模型 # 盒子模型用来“放”网页中的各种元素\n网页设计中内容，如文字、图片等元素， 都可是盒子（div嵌套）\n生活中的盒子：\npadding内填充 border边框 margin外边距 物体content内容：\nwidth宽 height高 属性 # div{ width:80%; max-width:1000px; min-width:300px; height:auto; max-height:1000px; min-height:300px; border-width:medium; border-color:red; border-style:solid; /* 内边距的属性值不能为负值 */ padding:20px; /* 4个方向都是20px */ padding:20px 40px; /* 上下=20px 左右=40px */ padding:20px 40px 10px; /* 上=20px 左右=40px 下=10px */ padding:20px 30px 10px 40px; /* 上=20px 右=30px 下=10px 左=40px */ margin:20px; margin:20px 40px; margin:20px 40px 10px; margin:20px 30px 10px 40px; /* 垂直方向，两个相邻元素都设置外边距，外边距会发生合并 合并后外边距高度=两个发生合并外边距的高度中最大值 */ } 宽高属性总结","title":"CSS进阶 笔记"},{"content":"CSS基础 # Cascading Style Sheets 层叠样式表\n发展历史 # 1996W3C：CSS1\n1998W3C：CSS2\n现在W3C：CSS3\n特点 # CSS简化[[HTML]]相关标签，网页体积小，下载快 解决内容与表现相分离的问题 更好地维护网页，提高工作效率 样式规则 # 选择器，声明（声明有属性和值构成）不区分大小写\n书写规范：\n书写采用小写书写\n每一个属性占一行\n注释：\n/*注释*/ 使用方法\n行内样式表（内联样式表） [同时加载]\n\u0026lt;h1 style=\u0026#34;attribute:value\u0026#34;\u0026gt; title \u0026lt;/h1\u0026gt; 内部样式表 [同时加载]\n\u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; *{ margin:0; border:none; padding:0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; title \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; 外部样式表（外联样式表）：\n创建CSS文件（扩展名是.css)、引用CSS样式 [html加载时，同时加载CSS]\n\u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; 外部样式表的优势：\ncss与html分离 多个文件可以同时使用一个样式文件 多文件引用同一个css文件，css只需下载一次 导入式 (不推荐使用) [先html后css]\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; @import \u0026#34;style.css\u0026#34;; @import url(style.css); @import url(\u0026#34;style.css\u0026#34;); \u0026lt;/style\u0026gt; 优先级：\n行内样式\u0026gt;内部样式\u0026gt;导入式样式？外部样式\n注意：内部样式和外部样式根据就近原则\n拓展 # HTML文档结构是一个文档树\ncss继承：从父元素继承属性 # 好处：\n父元素设置样式，子元素可以继承__部分属性__ 减少css代码 特点：继承优先级较低，冲突时采用默认\ncss层叠：样式叠加效果 # 可以定义多个样式 不冲突时，多个样式可层叠为一个 冲突时，按不同样式规则优先级来应用样式 优先级 # 选择器优先级\nid选择器\u0026gt;class选择器\u0026gt;标签选择器 后面定义的优先级\u0026gt;前面定义的优先级 css优先级规则\n同一样式表中：\n权值相同：就近原则 权值不同 根据权值来判断CSS样式 哪种CSS样式权值高，就使用哪种样式 权值 # 选择器权值\n标签：1 class：10 ID：100 通配符*：0 行内：1000 权值规则\n统计不同选择器的个数 每类选择器的个数乘以相应权值 把所有的值相加得出选择器的权值 命名 # 命名规则：\n采用英文字母、数字以及‘-’和‘_’命名 以小写字母开头，不能以数字和‘-’、‘_’开头 命名形式：单字、连字符、下划线和驼峰 使用意义命名 常用的CSS样式命名\n页面结构 页头：header 页面主体：main 页尾：footer 内容：content/container 导航：nav 侧栏：sidebar 栏目：column 页面外围控制：wrapper 左右中：left right center 导航 导航：nav 主导航：mainnav 子导航：subnav 顶导航：topnav 边导航：sidebar 右导航：rightsidebar 左导航：leftsidebar 菜单：menu 子菜单：submenu 标题：title 摘要：summary 功能 标志：logo 广告：banner 登录：login 登录条：loginbar 注册：register 搜索：search 功能区：shop 标题：title 使用id\u0026amp;class # id不要滥用，谨慎使用 class适当使用 ","date":"February 7, 2022","permalink":"/posts/css-basic/","section":"Posts","summary":"CSS基础 # Cascading Style Sheets 层叠样式表\n发展历史 # 1996W3C：CSS1\n1998W3C：CSS2\n现在W3C：CSS3\n特点 # CSS简化[[HTML]]相关标签，网页体积小，下载快 解决内容与表现相分离的问题 更好地维护网页，提高工作效率 样式规则 # 选择器，声明（声明有属性和值构成）不区分大小写\n书写规范：\n书写采用小写书写\n每一个属性占一行\n注释：\n/*注释*/ 使用方法\n行内样式表（内联样式表） [同时加载]\n\u0026lt;h1 style=\u0026#34;attribute:value\u0026#34;\u0026gt; title \u0026lt;/h1\u0026gt; 内部样式表 [同时加载]\n\u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; *{ margin:0; border:none; padding:0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; title \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; 外部样式表（外联样式表）：\n创建CSS文件（扩展名是.css)、引用CSS样式 [html加载时，同时加载CSS]\n\u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; 外部样式表的优势：\ncss与html分离 多个文件可以同时使用一个样式文件 多文件引用同一个css文件，css只需下载一次 导入式 (不推荐使用) [先html后css]\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; @import \u0026#34;style.css\u0026#34;; @import url(style.","title":"CSS基础 笔记"},{"content":"","date":"February 3, 2022","permalink":"/tags/html/","section":"Tags","summary":"","title":"html"},{"content":"HTML5 # 介绍 # HTML5发展历程\n标签变化\nDTD、新增的标签、删除的标签、重定义标签\n网页布局\n新的页面布局、区别和意义\n属性变化\ninput、表单属性、链接属性、其他属性\n标签 # HTML标签\n定义和用法\n\u0026lt;!DOCTYPE\u0026gt;声明必须是HTML文档的第一行，位于\u0026lt;html\u0026gt;标签之前\n不是HTML标签\n指示web浏览器关于页面使用哪个HTML版本进行编写的指令\n常用的DOCYPE声明\nDTD文档类型定义\n新增元素 # 结构标签（块状元素）——有意义的div\n\u0026lt;article\u0026gt;article\u0026lt;/article\u0026gt; \u0026lt;header\u0026gt;header of page\u0026lt;/header\u0026gt; \u0026lt;nav\u0026gt;nav of page\u0026lt;/nav\u0026gt; \u0026lt;section\u0026gt;the area\u0026lt;/section\u0026gt; \u0026lt;hgroup\u0026gt;information about\u0026lt;/hgroup\u0026gt; \u0026lt;figure\u0026gt;multimedia\u0026lt;/figure\u0026gt; \u0026lt;footer\u0026gt;footer of page\u0026lt;/footer\u0026gt; \u0026lt;dialog\u0026gt; \u0026lt;dt\u0026gt; chat title \u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt; chat content \u0026lt;/dd\u0026gt; \u0026lt;/dialog\u0026gt; \u0026lt;!-- 补充 1. header/section/aside/article/footer 不要使用嵌套 2. header/section/footer级别最高\u0026gt;aside/article/figure/hgroup/nav \u0026gt;div\u0026gt;figcaption --\u0026gt; 多媒体标签（意义：富媒体的发展，提升用户体验）\n\u0026lt;video src=\u0026#34;video path\u0026#34; autoplay=\u0026#34;\u0026#34; controls=\u0026#34;\u0026#34; width=\u0026#34;400px\u0026#34; height=\u0026#34;300px\u0026#34;\u0026gt;video\u0026lt;/video\u0026gt; \u0026lt;audio src=\u0026#34;audio path\u0026#34; autoplay=\u0026#34;\u0026#34; loop=\u0026#34;-1\u0026#34; control=\u0026#34;\u0026#34;\u0026gt;not read the text\u0026lt;/audio\u0026gt; \u0026lt;source src=\u0026#34;path\u0026#34; type=\u0026#34;recode type\u0026#34;/\u0026gt; \u0026lt;canvas\u0026gt;draw\u0026lt;/canvas\u0026gt; \u0026lt;embed src=\u0026#34;extra path\u0026#34; width=\u0026#34;100px\u0026#34; height=\u0026#34;20px\u0026#34;\u0026gt; ","date":"February 3, 2022","permalink":"/posts/html5/","section":"Posts","summary":"HTML5 # 介绍 # HTML5发展历程\n标签变化\nDTD、新增的标签、删除的标签、重定义标签\n网页布局\n新的页面布局、区别和意义\n属性变化\ninput、表单属性、链接属性、其他属性\n标签 # HTML标签\n定义和用法\n\u0026lt;!DOCTYPE\u0026gt;声明必须是HTML文档的第一行，位于\u0026lt;html\u0026gt;标签之前\n不是HTML标签\n指示web浏览器关于页面使用哪个HTML版本进行编写的指令\n常用的DOCYPE声明\nDTD文档类型定义\n新增元素 # 结构标签（块状元素）——有意义的div\n\u0026lt;article\u0026gt;article\u0026lt;/article\u0026gt; \u0026lt;header\u0026gt;header of page\u0026lt;/header\u0026gt; \u0026lt;nav\u0026gt;nav of page\u0026lt;/nav\u0026gt; \u0026lt;section\u0026gt;the area\u0026lt;/section\u0026gt; \u0026lt;hgroup\u0026gt;information about\u0026lt;/hgroup\u0026gt; \u0026lt;figure\u0026gt;multimedia\u0026lt;/figure\u0026gt; \u0026lt;footer\u0026gt;footer of page\u0026lt;/footer\u0026gt; \u0026lt;dialog\u0026gt; \u0026lt;dt\u0026gt; chat title \u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt; chat content \u0026lt;/dd\u0026gt; \u0026lt;/dialog\u0026gt; \u0026lt;!-- 补充 1. header/section/aside/article/footer 不要使用嵌套 2. header/section/footer级别最高\u0026gt;aside/article/figure/hgroup/nav \u0026gt;div\u0026gt;figcaption --\u0026gt; 多媒体标签（意义：富媒体的发展，提升用户体验）\n\u0026lt;video src=\u0026#34;video path\u0026#34; autoplay=\u0026#34;\u0026#34; controls=\u0026#34;\u0026#34; width=\u0026#34;400px\u0026#34; height=\u0026#34;300px\u0026#34;\u0026gt;video\u0026lt;/video\u0026gt; \u0026lt;audio src=\u0026#34;audio path\u0026#34; autoplay=\u0026#34;\u0026#34; loop=\u0026#34;-1\u0026#34; control=\u0026#34;\u0026#34;\u0026gt;not read the text\u0026lt;/audio\u0026gt; \u0026lt;source src=\u0026#34;path\u0026#34; type=\u0026#34;recode type\u0026#34;/\u0026gt; \u0026lt;canvas\u0026gt;draw\u0026lt;/canvas\u0026gt; \u0026lt;embed src=\u0026#34;extra path\u0026#34; width=\u0026#34;100px\u0026#34; height=\u0026#34;20px\u0026#34;\u0026gt; ","title":"HTML5 笔记"},{"content":"HTML 进阶 # 标签 # 标签分类\n块级标签：占据一行，需要换行\ndiv、p、h1～h6、ul、ol、li、dl、dt、dd\n特点：\n独占一行 可以设置宽、高 如果不设置宽度，宽度默认为容器的100% 行内标签：在一行，不换行\nspan、a、b、i、u、em\n特点：\n与其他元素同行显示 不可以设置宽、高 宽高就是文字或图片的宽高 标签嵌套规则\n块级元素可包含行内元素和某些块级元素\n行内元素不能包含块元素，只能包含行内元素\n块级元素不能放在p标签内\n特殊块级元素只能包含行内元素，不能再包含块级元素\n如：h1-h6、p、dt\n块级元素与块级元素并列，行内元素与行内元素并列\n结构分析 # 调试工具F12\n网页区块分析：网页整体结构\n网页制作流程 # 用户：提出需求 产品经理：规划和实现原型图 设计师：网页设计图 前端工程师：切图–html结构–css样式–js基础 项目 # 基本网页排版布局\n头部内容\nLOGO标签\n导航栏\nbanner图\n主题内容\n文章内容\n链接区\n页脚内容\n","date":"February 3, 2022","permalink":"/posts/html-up/","section":"Posts","summary":"HTML 进阶 # 标签 # 标签分类\n块级标签：占据一行，需要换行\ndiv、p、h1～h6、ul、ol、li、dl、dt、dd\n特点：\n独占一行 可以设置宽、高 如果不设置宽度，宽度默认为容器的100% 行内标签：在一行，不换行\nspan、a、b、i、u、em\n特点：\n与其他元素同行显示 不可以设置宽、高 宽高就是文字或图片的宽高 标签嵌套规则\n块级元素可包含行内元素和某些块级元素\n行内元素不能包含块元素，只能包含行内元素\n块级元素不能放在p标签内\n特殊块级元素只能包含行内元素，不能再包含块级元素\n如：h1-h6、p、dt\n块级元素与块级元素并列，行内元素与行内元素并列\n结构分析 # 调试工具F12\n网页区块分析：网页整体结构\n网页制作流程 # 用户：提出需求 产品经理：规划和实现原型图 设计师：网页设计图 前端工程师：切图–html结构–css样式–js基础 项目 # 基本网页排版布局\n头部内容\nLOGO标签\n导航栏\nbanner图\n主题内容\n文章内容\n链接区\n页脚内容","title":"HTML进阶 笔记"},{"content":"HTML基础 # Hypertext Markup Language 超文本标记语言\n概述 # 发展史 1993-2014 W3C\n概念 头部信息：网页不展示 网页内容：网页展示 标签：储存文本 成对出现 元素：标签+内容+标签 声明：\u0026lt;!DOCTYPE html 编码：\u0026lt;meta/\u0026gt;\n特点\n不需要编译 文本文件 html或htm为文件名后缀 大小写不敏感 语法\n\u0026lt;tagName attributeName1=\u0026#34;attributeValue\u0026#34; attributeName2=\u0026#34;attributeValue\u0026#34; ...\u0026gt;...\u0026lt;/tagName\u0026gt; 特殊符号采用实体符表示，即\u0026amp;\u0026hellip;\n标签使用：网页内容和整体分析得出**(语义化)**\n网页调试：F12\n路径\n相对路径：相对于html文件 绝对路径：盘符写\n标签 # 基本 标题：h1~h6 段落：p 辅助格式：br hr pre 修饰：i em b stronge sup sub\n常用\n图片 \u0026lt;img src=\u0026#34;img\u0026#34; alt=\u0026#34;image\u0026#34; width=\u0026#34;400px\u0026#34; height=\u0026#34;50%\u0026#34;/\u0026gt; 列表 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;item\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;describe\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 超链接 \u0026lt;a href=\u0026#34;link\u0026#34; target=\u0026#34;windowMethod\u0026#34; title=\u0026#34;tips\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; Link\u0026lt;/a\u0026gt; \u0026lt;!--link: file externalLink blank(refresh) --\u0026gt; \u0026lt;a mailto=\u0026#34;mailtoName\u0026#34;\u0026gt;mail\u0026lt;/a\u0026gt;\u0026lt;!--mail link--\u0026gt; \u0026lt;!--file download--\u0026gt; \u0026lt;a href=\u0026#34;#bttom\u0026#34; name=\u0026#34;#top\u0026#34;\u0026gt;top\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#top\u0026#34; name=\u0026#34;#bottom\u0026#34;\u0026gt;bottom\u0026lt;/a\u0026gt; \u0026lt;!-- anchor link--\u0026gt; 表格 # \u0026lt;table width=\u0026#34;400px\u0026#34; bgcolor=\u0026#34;blue\u0026#34; border=\u0026#34;1px\u0026#34; cellpadding=\u0026#34;2px\u0026#34; cellspacing=\u0026#34;3px\u0026#34; frame=\u0026#34;\u0026#34; rules=\u0026#34;\u0026#34;\u0026gt; \u0026lt;caption\u0026gt;Title\u0026lt;/caption\u0026gt; \u0026lt;!-- 1.同时使用同时操作 2.不影响表格布局 3.结构化加载 --\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; valign=\u0026#34;center\u0026#34; bgcolor=\u0026#34;red\u0026#34;\u0026gt; \u0026lt;th height=\u0026#34;20px\u0026#34; bgcolor=\u0026#34;red\u0026#34;\u0026gt;head1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;head2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;head3\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Itable\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td bgcolor=\u0026#34;green\u0026#34; height=\u0026#34;20px\u0026#34;\u0026gt;body1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;body2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;body3\u0026lt;/td\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;4\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;body4\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;body5\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;body6\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;footer1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;footer2\u0026lt;/td\u0026gt; \u0026lt;td colspan=\u0026#34;2\u0026#34;\u0026gt;footer3\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 表单 # \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;tipsText\u0026#34; maxlength=\u0026#34;20px\u0026#34; name=\u0026#34;text\u0026#34; size=\u0026#34;10px\u0026#34; value=\u0026#34;initValue\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;button\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;submit\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; value=\u0026#34;reset\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;image\u0026#34; src=\u0026#34;srcImage\u0026#34; alt=\u0026#34;submit\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;!--选择域--\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;female\u0026#34;/\u0026gt;female \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;male\u0026#34; checked/\u0026gt;male \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;love\u0026#34; value=\u0026#34;Math\u0026#34;/\u0026gt;Math\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;love\u0026#34; value=\u0026#34;English\u0026#34;/\u0026gt;English\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;love\u0026#34; value=\u0026#34;Biology\u0026#34;/\u0026gt;Biology\u0026lt;br/\u0026gt; \u0026lt;select name=\u0026#34;color\u0026#34; size=\u0026#34;\u0026#34; multiple=\u0026#34;\u0026#34;\u0026gt; \u0026lt;optgroup label=\u0026#34;light\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;red\u0026#34; select=\u0026#34;selected\u0026#34;\u0026gt; Red \u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;yellow\u0026#34;\u0026gt; Yellow \u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;orange\u0026#34;\u0026gt; Orange \u0026lt;/option\u0026gt; \u0026lt;/optgroup\u0026gt; \u0026lt;optgroup label=\u0026#34;dark\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;blue\u0026#34;\u0026gt; Blue \u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;green\u0026#34;\u0026gt; Green \u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;purple\u0026#34;\u0026gt; Purple \u0026lt;/option\u0026gt; \u0026lt;/optgroup\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;textarea name=\u0026#34;textarea\u0026#34; placeholder=\u0026#34;more text input\u0026#34; cols=\u0026#34;view width\u0026#34; rows=\u0026#34;view hight\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;!--value值是传给服务器的值--\u0026gt; \u0026lt;/form\u0026gt; ","date":"February 3, 2022","permalink":"/posts/html-basic/","section":"Posts","summary":"HTML基础 # Hypertext Markup Language 超文本标记语言\n概述 # 发展史 1993-2014 W3C\n概念 头部信息：网页不展示 网页内容：网页展示 标签：储存文本 成对出现 元素：标签+内容+标签 声明：\u0026lt;!DOCTYPE html 编码：\u0026lt;meta/\u0026gt;\n特点\n不需要编译 文本文件 html或htm为文件名后缀 大小写不敏感 语法\n\u0026lt;tagName attributeName1=\u0026#34;attributeValue\u0026#34; attributeName2=\u0026#34;attributeValue\u0026#34; ...\u0026gt;...\u0026lt;/tagName\u0026gt; 特殊符号采用实体符表示，即\u0026amp;\u0026hellip;\n标签使用：网页内容和整体分析得出**(语义化)**\n网页调试：F12\n路径\n相对路径：相对于html文件 绝对路径：盘符写\n标签 # 基本 标题：h1~h6 段落：p 辅助格式：br hr pre 修饰：i em b stronge sup sub\n常用\n图片 \u0026lt;img src=\u0026#34;img\u0026#34; alt=\u0026#34;image\u0026#34; width=\u0026#34;400px\u0026#34; height=\u0026#34;50%\u0026#34;/\u0026gt; 列表 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;item\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;describe\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 超链接 \u0026lt;a href=\u0026#34;link\u0026#34; target=\u0026#34;windowMethod\u0026#34; title=\u0026#34;tips\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; Link\u0026lt;/a\u0026gt; \u0026lt;!","title":"HTML基础语法 笔记"},{"content":"","date":"February 3, 2022","permalink":"/tags/assembly/","section":"Tags","summary":"","title":"assembly"},{"content":"汇编语言 # 概述 # 编程形式\n开关\u0026ndash;\u0026gt;打孔\u0026ndash;\u0026gt;输入设备\n汇编语言的出现\nmov eax, 5 mov ebx, 6 add eax, ebx 汇编程序的执行\n汇编代码 -\u0026gt; 汇编程序 -\u0026gt; 处理器可识别 01010101 -\u0026gt; 处理器执行\n学习汇编的意义 # 开发时调试 逆向时候的代码阅读 某些特殊技术的使用（如shellcode、壳） shellcode：可以运行在任意位置的代码（汇编语言）\n壳：加壳或脱壳都需要用的汇编语言\n环境配置\nOllydbg\nVisual Studio 2015\nx16 汇编 # 通用寄存器 # 16位寄存器 高8位 低8位 AX AH AL BX BH BL CX CH CL DX DH DL SI \\ \\ DI \\ \\ SP \\ \\ BP \\ \\ 内存字节序 # 🌰 0x12345678\n每个地址只有存储1字节\n大端序 小端序 12 78 34 56 56 34 78 12 CC CC CC CC CC CC 段的概念 # CS段只有16位，8086有20根地址线，那么地址如何存储？\n简单粗暴 除以0x10，因为只有以零结尾的地址才能作为段地址\nCS：代码段\nDS：数据段\nES：扩展段\nSS：堆栈段\n16位汇编基本框架 # assume cs:code ;设置代码段 code segment ;代码段开始 rkmain proc mov ax,0 mov cx, 10H rk: inc ax loop rk mov ax, 4c00H int 21H rkmain endp start: call rkmain ;指定开始位置 code ends ;代码段结束 end start add 加\nint 自增\nsub 减\ndec 自减\nloop 循环\n函数传参 # 寄存器传参 堆栈传参 内存传参 assume cs:code code segment addx proc push bp mov bp,sp mov si,[bp+4] mov di,[bp+6] add si,di mov ax,si pop bp ret addx endp rkmain proc mov ax,5 mov bx,6 push ax push bx call addx add sp,4 mov bx,ax mov ax, 4c00H int 21H rkmain endp start: call rkmain code ends end start FLAG寄存器 # 状态标志 # CF：进位位\nPF：奇偶位\nAF：辅助进位位\nZF：零值位\nSF：符号位\nOF：溢出位\nCMP指令 # CMP OPRD1, OPRD2\nSUB\n影响标志位\nmov ax,2 mov bx,1 cmp ax.bx 相等\nAX-BX = 0 ZF=1\n不等\nAX-BX !=0 ZF=0\nAX \u0026lt; BX:\nAX-BX = ? CF=1\nAX \u0026gt; BX:\nAX-BX=? CF=0 ZF=0\nAX \u0026lt;= BX:\nAX-BX=? CF=1 || ZF=1\nAX \u0026gt;= BX:\nAX-BX=? CF=0 || ZF=1\nJCC指令 # 一类指令 跳转\njmp address je address ;等于则跳转 ZF=1 jne address ;不等于则跳转 ZF=0 jb address ;低于则跳转 CF=1 ja address ;高于则跳转 CF=0 \u0026amp;\u0026amp; ZF=0 运算指令 # 四则运算\nmov ax,16 mov bx,5 add ax,5 sub ax,3 mul bx ; \u0026gt;16bit DX:AX 32bit 默认与ax操作 div bx ; DX-\u0026gt;余数 AX-\u0026gt;商 默认与ax操作 位运算\nxor ax,bx and ax,bx or ax,bx not ax x86汇编 # 通用寄存器\n寄存器 EAX EBX ECX EDX ESI EDI ESP EBP 段 # 段 CS DS ES SS FS GS 段选择子 # CS 代码段 1B\nDS ES SS 数据段 23\nFS 3B\nIndex：3\nTi：0\nRPL：3\n段描述符 # 代码段：\n00cffb00 0000ffff\n1100 1111 1111 1011 0000 0000\nBase：0000 0000\nLimit：ffffff\nffffff * 0x1000\nFFFFFF000+0X1000\n10 0000 0000 - 1\nFFFF FFFF\nG = 1 Limit单位是页\nG = 0 Limit单位是字节\n页\n大页 4M 小页 4K 寻址空间：0000 0000 ~ FFFF FFFF\n数据段\n00cff300 0000ffff\nBASE：0000 0000\nLimit：FFFF FFFF\nFS段\n0040f300 00000fff\nG=0 字节\n0000 0000 0100 0000 1111 0011 0000 0000\nfff * 1 fff字节\n0 ~ fff\n4GB空间 虚拟的4GB空间\n低2GB是每个进程独享的 高2GB是内核空间，是共享的 base+offset = 虚拟地址\n页 # 内存的一种管理模式\n29912\nCR3\nPDPTE -\u0026gt; PTE - PDE -\u0026gt; 物理页 (4k)\n76B26000 E9 A1 B0 76\n01 (PDPTE) （1 * 8)\n110110101(PTE) (1B5 * 8 )\n100100110(PDE) (126 * 8)\n00000000000(页内偏移) (000)\nR3 用户层 TEB（线程环境块）\nR0 系统内核 驱动 KPCR（CPU状态块）\n调用约定 # cdecl stdcall fastcall thiscall lib 静态链接库\ndll 动态链接库\ncdecl # C语言调用约定\npush eax push eax call printf add esp,8 stdcall # Win32调用约定\npush 1 push 2 push 3 push 4 call messagebox fastcall # x64 调用约定\n前四个参数使用寄存器传参，后面使用堆栈\nrcx rdx r8 r9\nx86基本框架 # .586 .model flat,stdcall option casemap:none includelib ucrt.lib includelib legacy_stdio_definitions.lib includelib User32.lib includelib Kernel32.lib MessageBoxA PROTO hWnd:DWORD,lpText:BYTE,lpCaption:BYTE,uType:DWORD ExitProcess PROTO uType:DWORD extern printf:proc extern scanf:proc extern putchar:proc .data szStr db \u0026#39;Hello World!\u0026#39;,0 .code main proc lea eax,szStr push eax call printf add esp,4 push 0 call ExitProcess add esp,4 main endp end 内联汇编 # 单行内联汇编\n_ASM/ mov nNum, 100; 多行内联汇编\n_ASM/ { mov nNum,100 mov eax,nNum push eax mov eax,fNum push eax call printf add esp,8 } 遍历数组\n按结尾数据遍历\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int nNum; char* fNum = \u0026#34;%d\\n\u0026#34;; int arr[] = { 1,2,3,4,5,6,7,8,9,0 }; _ASM/ { xor esi,esi jmp loopX loopM: inc esi loopX: mov edi,[arr+esi*4] push edi mov eax,fNum push eax call printf add esp,8 cmp edi,0 jne loopM } system(\u0026#34;pause\u0026#34;); return 0; } 按长度进行遍历\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int nNum; char* fNum = \u0026#34;%d\\n\u0026#34;; int arr[10]; for (size_t i = 0; i \u0026lt; 10; i++) { arr[i] = i; } _ASM/ { xor edi,edi xor esi,esi xor edx,edx mov edi,9h jmp Mloop Xloop: inc esi Mloop: mov edx, [arr + esi * 4] push edx mov eax,fNum push eax call printf add esp,8 cmp edi,esi jne Xloop } system(\u0026#34;pause\u0026#34;); return 0; } 结构体和API # 汇编语言结构体\n.586 .model flat,stdcall .data info struct ;声明结构体 x dword ? y dword ? info ends m_info info \u0026lt;\u0026gt; ;初始化结构体 .code main proc mov eax,5 mov m_info.x,eax mov ebx,m_info.x mov eax,eax main endp end main x64汇编 # x64和x86汇编寄存器区别\nx86 : eax ebx ecx edx esi edi ebp esp eip eflags\nx64 : rax rbx rcx rdx rsi rdi rbp rsp rip rflags x64扩展 ： r8 r9 r10 r11 r12 r13 r14 r15\n汇编代码剽窃小技巧 # 所有的jcc死地址，都要改成标号 所有的call，都要确定，是系统函数，还是自己的函数，想办法call过去 一切检查或者初始化类的无用代码，全部去掉 一些必要逻辑里的不合理东西，去掉这些，然后自己写代码，让他合理化 16位/32位/64位汇编的区别 # 区别\n16位：实模式，16位处理器内的内部，最多可以处理存储的长度为16位。\n32位：保护模式，32位处理器内的内部，最多可以处理存储的长度为32位。\n64位：保护模式，64位处理器内的内部，最多可以处理存储的长度为64位。\n通用寄存器简介\n位数 通用寄存器 扩展 16 AX BX CX DX SI DI BP SP R8W R9W R10W R11W R12W R13W R14W R15W 32 EAX EBX ECX EDX ESI EDI EBP ESP R8D R9D R10D R11D R12D R13D R14D R15D 64 RAX RBX RCX RDX RSI RDI RBP RSP R8 R9 R10 R11 R12 R13 R14 R15 基本执行环境\n32位 64位 8个32位通用寄存器 16个64位通用寄存器 标志寄存器EFLAGS 标志寄存器RFLAGS 指令寄存器EIP 指令寄存器RIP EFLAGS寄存器 # Eflags寄存器，Eflags寄存器包含了独立的二进制位，用于控制CPU操作。或是反应一些CPU操作的结果。有些指令可以测试和控制这些单独的处理器标志位。\nMMX寄存器 # 在实现高级多媒体和通信应用时，MMX技术提高了Intel处理器的性能。8个64位MMX寄存器支持成为SIMD的特殊指令。顾名思义，MMX指令对MMX寄存器中的数据值直接进行并行操作。虽然它们看上去是独立的寄存器，但是MMX寄存器实际上是浮点单元中使用的同样寄存器的别名。\n通用寄存器 # eax：累加器，操作数和结果数据累加器，返回值运算结果一般都存储在这里\nebx：基地址，DS段的数据指针，在内存寻址的时候存放基地址\necx：计数器，字符串和循环操作的计数器\nedx：用于存储部分乘法结果和部分除法被除数\nebp：基址指针，SS段的数据指针\nesp：栈帧指针，一般指向栈顶，所以也被称为栈顶指针\nedi：字符串操作的目标指针，ES段的数据指针\nesi：字符串操作的源指针，SS段的数据指针\n冯诺依曼 # 计算机科学的奠基者\n艾伦·麦锡森·图灵 - - - 图灵机 约翰·冯·诺依曼 - - - 数据存储的体系结构 约翰·冯·诺依曼\n1903年 出生犹太家庭\n1926年 布达佩斯大学数学博士学位\n1930年 接受了普林斯顿大学客座教授的职位\n1931年 普林斯顿大学终身教授\n1933年 普林斯顿高等研究院\n1937年 美国公民\n1938年 获博修奖\n1954年 美国原子能委员会委员\n1957 在华盛顿德里医院去世\n冯诺依曼体系 # 计算机由控制器、运算器、存储器、输入设备、输出设备五部分组成。\n冯诺依曼提出的计算机体系结构，奠定了现代计算机的结构理念\n内存基础 # 什么是内存 # 在冯诺依曼结构中用来存储程序和数据的部件叫做存储器，我们的计算机可以正常的运行，主要依靠的就是存储器的记忆能力。存储器分为主存储器和辅助存储器，主存储器也叫内存储器，也就是我们常说的内存\n内存寻址范围 # 现在主流的系统是32位系统和64位系统\n32位系统内存的寻址范围是0x00000000-0xFFFFFFFF\n32位系统内存最大寻址范围是0xFFFFFFFF+1(4294967296) - - - 4GB\n64位内存的寻址范围是0x0000000000000000-0xFFFFFFFFFFFFFFFF\n内存和寄存器的区别 # 寄存器：数量少，在CPU内部，速度极快，但是价格昂贵\n内存：数量庞大，相对寄存器而言，速度较慢，但是价格便宜\n内存的五种表现形式 # 立即数：\nMOV EAX, DWORD PTR DS:[0x???????] 寄存器：\nMOV EBX, 0x???????? MOV EAX, DWORD PTR DS:[EBX] 寄存器+立即数\nMOV EBX, 0x??????? MOV EAX, DWORD PTR DS:[EBX+4] 比例因子：[REG+REG*{1,2,4,8}]\n数组元素地址=数组首地址+元素索引*数组元素占用空间\nMOV EAX, 0x???????? MOV EBX, 0x2 MOV ECX, DWORD PTR DS:[EAX+EBX*4] 比例因子+立刻数：\nMOV EAX, 0x???????? MOV EBX, 0x2 MOV ECX, DWORD PTR DS:[EAX+EBX*4+1] 数据存储模式 # 大端序：数据高位在内存低位，数据低位在内存高位\n小端序：数据高位在内存高位，数据低位在内存低位\n地址0x77 66 55 44\n大端序：念的时候是77 66 55 44\n小端序：念的时候是44 55 66 77\n大端序常用于ARM架构\n小端序常用于x86、AMD64架构\nEFLAGS寄存器 # CF：进位借位标志位\nPF：奇偶标志位\nAF：辅助进位标志位\nZF：0标志位\nSF：符号标志位\nTF：单目标志位\nIF：中断标志位\nDF：方向标志位\nOF：溢出标志位\n数学运算 # 加法 # 加法指令 ADD（Addition）\n格式：ADD OPRD1, OPRD2\n功能：两数相加\n加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响\n不允许OPRD1与OPRD2同时为存储器\n带进位加法指令 ADC（Addition Carry)\n格式：ADC OPRD1, OPRD2\n功能：OPRD1 = OPRD1 + OPRD2 + CF\n减法 # 减法指令 SUB（Subtract）\n格式：SUB OPRD1, OPRD2\n功能：两个操作数的相减，即从OPRD1中减去OPRD2，其结果放在OPRD1中。指令的类型及对标志位的影响与ADD指令相同，注意立即数不能用于目的操作数，两个存储器操作数之间不能直接相减，操作数可为8位或16位的无符号数或带符号数。\n带借位减法指令 SBB（Subtraction with Borrow）\n格式：SBB OPRD1, OPRD2\n功能：进行两个操作数的相减再减去CF进位标志位，即从OPRD1 = OPRD1 - OPRD2 -CF，其结果放在OPDR1中。\n乘法 # 无符号数乘法指令 MUL（Multiply）\n格式：MUL OPRD\n带符号数乘法指令 IMUL（Integer Multiply）\n格式：IMUL OPRD、\n功能：乘法操作\nOPRD为通用寄存器或寄存器操作数\n本指令影响标志位CF及OF\n除法 # 无符号数除法指令 DIV（Division）\n格式：DIV OPRD\n功能：实现两个无符号二进制数除法运算\n带符号数除法指定 IDIV（Integer Division）\n格式：IDIV OPRD\n功能：这实现两个带符号数的二进制除法运算\n16bit，分存2个8bit AH:AL 商AL 余AH\n32bit，分存2个16bit DX:AX 商AX 余DX\n64bit，分存2个32bit EDX:EAX 商EAX 余EDX\n128bit，分存2个64bit RDX:RAX 商RAX 余RDX\n自增 # 加1指令 INC（Increment by 1）\n格式：INC OPRD\n功能：OPRD = OPRD + 1\n自减 # 减1指令 DEC（Decrement by 1）\n格式：DEC OPRD\n功能：OPRD = OPRD - 1\n逻辑运算 # 与 # 逻辑与运算指令 AND\n格式：AND OPRD1, OPRD2\n功能：对两个操作数实现按位逻辑与运算，结果送至目的操作数。本指令可以进行字节或字的 ‘与‘ 运算，OPRD1 \u0026lt; - - OPRD1 and OPRD2.\n本指令影响标志位PF、SF、ZF，使CF=0、OF=0.例如，在同一个通用寄存器自身相与时， 操作数虽不变，但使CF置零。本指令主要用于修改操作数或置某些位为零。\n或 # 逻辑或指令 OR\n格式：OR OPRD1, OPRD2\n功能：OR指令完成对两个操作数按位的 ‘或’ 运算，结果送至目的操作数中，本指令可以进 - - - - 行字节或字的 ‘或’ 运算。OPRD1 \u0026lt; - - OPRD1 OR OPRD2。\n异或操作 # 逻辑异或运算指令 XOR\n格式：XOR OPRD1, OPRD2\n功能：实现两个操作数按位 ‘异或’ 运算，结果送至目的操作数中。OPRD1 \u0026lt; - - OPRD1 XOR OPRD2\n非运算 # 逻辑操作符 NOT\n格式：NOT exp\n功能：按位求反\n堆栈操作 # 什么是堆栈 # 栈是一个后进先出的存储区域，位于堆栈段中，SS段寄存器描述的就是堆栈段的地址 栈的数据出口位于栈顶，也就是esp寄存器所指向的位置 栈顶是低位，也就是地址较小的一侧，由ebp寄存器指向的栈底，并不会改变 栈操作指令 # PUSH：压栈操作，32位汇编首先ESP-4，留出一个空间，然后把要压入栈中的内容压入\nPOP：出栈指令，32位汇编首先将栈顶的数据弹出给指定的目标，然后ESP+4，清掉空间\n栈的作用 # 存储少量数据 保存寄存器环境 传递参数 数据移动指令 # MOV指令 # 数据传送指令MOV\n格式：MOV OPRD1, OPRD2\n功能：本指令将一个源操作数送到目的操作数中，即OPRD1 \u0026lt; - - OPRD2\n说明：\nOPRD1为目的操作数，可以是寄存器、存储器、累加器 OPRD2为源操作数，可以是寄存器、存储器、累加器和立即数 LEA指令 # 有效地址传送指令 LEA\n格式：LEA OPRD1，OPRD2\n功能：将源操作数给出的有效地址传送到指定的寄存器中\nOPRD1必须是寄存器\nXCHG指令 # 数据交换指令 XCHG\n格式：XCHG OPRD1, OPRD2 其中的OPRD1为目的操作数，OPRD2为源操作数\n功能：将两个操作数相互交换位置，该指令把源操作数OPRD2与目的操作数OPRD1交换\n比较指令 # CMP指令 # 比较指令 CMP（Compare）\n格式：CMP OPRD1, OPRD2\n功能：对两数进行相减，进行比较\nTEST指令 # 测试指令 TEST\n格式：TEST OPRD1,OPRD2\n功能：其中OPRD1、OPRD2的含义同AND指令一样，也是对两个操作数进行按位的 ‘与’ 运算，- - - - 唯一不同之处是不将 ‘与’ 的结果送目的操作数，即本指令对两个操作数的内容均不进行修改，仅是在逻辑与操作后，对标志位重新置位\nJCC条件转移指令 # 常用的JCC指令 # JMP：无条件跳转\nJZ/JE：ZF = 1 等于0或相等跳转\nJNZ/JNE：ZF = 0 不等于0或者不相等跳转\nJBE/JNA：CF = 1/ZF = 1 低于等于/不高于跳转\nJNBE/JA：CF = 0/ ZF = 0 不低于等于/高于跳转\nJL/JNGE：SF！=OF 小于/不大于等于跳转\nJNL/JGE：SF = OF 不小于/大于等于跳转\nJCC表 # JCC指令 中文含义 英文原意 检查符号位 典型C应用 JZ/JE 若为0则跳转；若相等则跳转 jump if zero;jump if equal ZF=1 if (i == j);if (i == 0); JNZ/JNE 若不为0则跳转；若不相等则跳转 jump if not zero;jump if not equal ZF=0 if (i != j);if (i != 0); JS 若为负则跳转 jump if sign SF=1 if (i \u0026lt; 0); JNS 若为正则跳转 jump if not sign SF=0 if (i \u0026gt; 0); JP/JPE 若1出现次数为偶数则跳转 jump if Parity (Even) PF=1 (null) JNP/JPO 若1出现次数为奇数则跳转 jump if not parity (odd) PF=0 (null) JO 若溢出则跳转 jump if overflow OF=1 (null) JNO 若无溢出则跳转 jump if not overflow OF=0 (null) JC/JB/JNAE 若进位则跳转；若低于则跳转；若不高于等于则跳转 jump if carry;jump if below;jump if not above equal CF=1 if (i \u0026lt; j); JNC/JNB/JAE 若无进位则跳转；若不低于则跳转；若高于等于则跳转； jump if not carry;jump if not below;jump if above equal CF=0 if (i \u0026gt;= j); JBE/JNA 若低于等于则跳转；若不高于则跳转 jump if below equal;jump if not above ZF=1或CF=1 if (i \u0026lt;= j); JNBE/JA 若不低于等于则跳转；若高于则跳转 jump if not below equal;jump if above ZF=0或CF=0 if (i \u0026gt; j); JL/JNGE 若小于则跳转；若不大于等于则跳转 jump if less;jump if not greater equal SF != OF if (si \u0026lt; sj); JNL/JGE 若不小于则跳转；若大于等于则跳转； jump if not less;jump if greater equal SF = OF if (si \u0026gt;= sj); JLE/JNG 若小于等于则跳转；若不大于则跳转 jump if less equal;jump if not greater ZF != OF 或 ZF=1 if (si \u0026lt;= sj); JNLE/JG 若不小于等于则跳转；若大于则跳转 jump if not less equal;jump if greater SF=0F 且 ZF=0 if(si\u0026gt;sj) 串操作指令 # MOVS指令 # 字符串传送指令 MOVS\n格式：MOVS OPRD1, OPRD2 MOVSB MOVSW\n功能：OPRD1 \u0026lt; - - OPRD2\n说明：\n其中OPRD2为源串符号地址，OPRD1为目的串符号地址 STOS指令 # 字符串存储指令 STOS\n格式：STOS OPRD\n功能：把AL(字节)或AX(字)中的数据存储到DI为目的串地址指针所寻址的存储器单元中去指针DI将根据DF的值进行自动调整\nREP指令 # 重复前缀说明\n格式：\nREP ;CX\u0026lt;\u0026gt;0 重复执行字符串指令 REPZ/REPE ;CX\u0026lt;\u0026gt;0 且ZF=1重复执行字符串指令 REPNZ/REPNE ;CX\u0026lt;\u0026gt;0 且ZF=0重复执行字符串指令 功能：在串操作指令前加上重复前缀，可以对字符串进行重复处理。由于加上重复前缀后，对应的指令代码是不同的，所以指令的功能便具有重复处理的功能，重复的次数存放在CX寄存器中\nCALL与RETN # CALL指令 # 过程调用指令 CALL\n格式：CALL OPRD\n功能：过程调用指令\n相当于：\npush eip jmp OPRD RETN指令 # 返回指令，相当于： pop eip jmp eip 函数 # 过程调用-函数\nfunction proc code function end 参数传递方式：\n寄存器传参 堆栈传参 WIN32汇编入门 # 什么是API？\nAPI（Application Programming Interface, 应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节\nWindows系统除了协调应用程序的执行、内存的分配、系统资源的管理外，同时他也是一个很大的服务中心。调用这个服务中心的各种服务（每一种服务就是一个函数）可以帮助应用程序达到开启视窗、描绘图形和使用周边设备等目的，由于这些函数服务的对象是应用程序，所以称之为Application Programming Interface, 简称API函数。WIN32 API也就是Microsoft Windows 32位平台的应用程序编程接口\n凡是在 Windows 工作环境底下执行的应用程序，都可以调用Windows API\n","date":"February 3, 2022","permalink":"/posts/asm/","section":"Posts","summary":"汇编语言 # 概述 # 编程形式\n开关\u0026ndash;\u0026gt;打孔\u0026ndash;\u0026gt;输入设备\n汇编语言的出现\nmov eax, 5 mov ebx, 6 add eax, ebx 汇编程序的执行\n汇编代码 -\u0026gt; 汇编程序 -\u0026gt; 处理器可识别 01010101 -\u0026gt; 处理器执行\n学习汇编的意义 # 开发时调试 逆向时候的代码阅读 某些特殊技术的使用（如shellcode、壳） shellcode：可以运行在任意位置的代码（汇编语言）\n壳：加壳或脱壳都需要用的汇编语言\n环境配置\nOllydbg\nVisual Studio 2015\nx16 汇编 # 通用寄存器 # 16位寄存器 高8位 低8位 AX AH AL BX BH BL CX CH CL DX DH DL SI \\ \\ DI \\ \\ SP \\ \\ BP \\ \\ 内存字节序 # 🌰 0x12345678","title":"汇编语言 笔记"},{"content":"","date":"February 1, 2022","permalink":"/tags/c/","section":"Tags","summary":"","title":"C"},{"content":"C语言核心 # 函数 # 基本函数\n#include \u0026lt;stdio.h\u0026gt; // 函数的声明 void Hello(); int main() { // 最简单函数的调用 Hello(); return 0; } void Hello() { printf(\u0026#34;Hello!\\n\u0026#34;); } #include \u0026lt;stdio.h\u0026gt; void Hello() { printf(\u0026#34;Hello!\\n\u0026#34;); } int main() { // 最简单函数的调用 Hello(); return 0; } 函数的定义 # 返回值类型 函数名(参数列表) { 函数体 } 函数声明 # 所谓声明就是（Declaration）,就是告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上\n参数 # 形参 形式参数\n实参 实际参数\n传值和传址 # 传递数值 会受到作用域的限制\n传递地址 任意门不会受到作用域的限制\n可变参数 # #include \u0026lt;stdarg.h\u0026gt;\nva_list va_start va_arg va_end #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; int sum(int n, ...); int sum(int n, ...) { int i, sum = 0; va_list vap; va_start(vap, n); for(i = 0;i\u0026lt;n;i++) { sum += va_arg(vap,int); } va_end(vap); return sum; } int main() { int result; result = sum(3, 1, 2, 3); printf(\u0026#34;result = %d\\n\u0026#34;, result); } 带参数的函数\n#include \u0026lt;stdio.h\u0026gt; void add(int a, int b); int main() { add(5, 6); return 0; } // 参数里的a和b都是形式参数（形参），我们在调用的时候，需要填写实际参数（实参） void add(int a, int b){ int c = a + b; printf(\u0026#34;%d\u0026#34;, c); } 函数的返回值\n#include \u0026lt;stdio.h\u0026gt; int add(int a, int b); int main() { int nNum = add(5, 6); printf(\u0026#34;%d\u0026#34;, nNum); return 0; } int add(int a, int b){ int c = a + b; return c; } 递归 # #include \u0026lt;stdio.h\u0026gt; void hello(int n); int main() { hello(1); return 0; } void hello(int n) { if(n \u0026lt;= 10) { printf(\u0026#34;hello!\\n\u0026#34;); hello(n+1); } else { printf(\u0026#34;end\u0026#34;); } } 数组 # 定义\n类型 数组名 [元素个数]\nint a[6]; char b[24]; double c[3]; 数组不能动态定义\n访问\n数组名[下标]\na[0];//访问a数组中的第一个元素 b[1];//访问b数组中的第二个元素 c[5];//访问c数组中的第六个元素 注意\nint a[5]; // 创建一个具有五个的数组 a[0];// 访问第一个元素的下标是0，不是1 a[5];// 报错，因为第五个元素的下标是a[4] 循环跟数组的关系\n我们常常需要使用循环来访问数组\nint a[10]; for (i = 0;i \u0026lt; 10;i++) { a[i] = i; } 初始化\n将数组中所用元素初始化为0，可以这么写：\nint a[10] = {0};// 事实上这里只是将第一个元素赋值为0 如果是赋予不同的值，那么用逗号分隔开即可：\nint a[10] = {1,2,3,4,5,6,7,8,9,0}; 你还可以只给一部分元素赋值，未被赋值的元素自动初始化为0：\nint a[10] = {1,2,3,4,5,6}; // 表示为前边6个元素赋值，后边4个元素系统自动初始化为0 有时候还可以偷懒，可以只给出各个元素的值，而不指定数组的长度（因为编译器会根据值的个数自动判断数组的长度）：\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; C99增加了一种新特性：指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而来被赋值的元素自动初始化为0；\nint a[10] = {[3] = 3, [5] = 5, [8] = 8}; 最新的标准：会出现数组动态定义和越界问题的解决情况\n字符数组 # #include int main() {\t// 初始化字符数组的每个元素 char str1[10] = {\u0026#39;F\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;\\0\u0026#39;}; // 可以不写元素的个数，因为编译器会自动计算 char str3[] = {\u0026#39;F\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;\\0\u0026#39;}; // 使用字符串常量初始化字符数组 char str4[] = {\u0026#34;FishC\u0026#34;}; // 使用字符串常量初始化，可以省略大括号 char str5[] = \u0026#34;FishC\u0026#34; ; // 初始化字符串 char str6[128] = \u0026#34;FishC\u0026#34;; } 字符串处理函数\nint main() { // strlen 字符串长度 char str[] = \u0026#34;I love C language\u0026#34;; printf(\u0026#34;%u\u0026#34;,str) // strcpy 和 strncpy 复制和拷贝字符串 char str1[] = \u0026#34;Original String\u0026#34;; char str2[] = \u0026#34;New String\u0026#34;; strcpy(str1,str2);//大坑copy小坑会出现溢出 strncpy(str1,str2,5); // strcat和strncat 连接字符串 strcat(str1,str2); strncat(str1,str2,5); //strcmp和strncmp 比较字符串 if (!strcmp(str1,str2)) { printf(\u0026#34;两个字符串完全一致\\n\u0026#34;); } else { printf(\u0026#34;两个字符串存在差异！\\n\u0026#34;) } return 0 } 二维数组 # 平面、矩阵\n定义\n类型 数组名 [常用表达式][常量表达式]\nint a[6][6]; // 6*6, 6行6列 char b[4][5]; // 4*5, 4行5列 double c[6][3]; // 6*3, 6行3列 存放方式依然是线性\n访问\n1数组名[下标][下标]\na[0][0]; // 访问a数组中第1行第1列的元素 b[1][3]; // 访问b数组中第2行第4列的元素 c[3][3]; // 访问c数组中第4行第4列的元素 同样需要注意下标的取值范围，以防数组的越界访问\n二维数组初始化\n由于二维数组在内存中是线性存放的，因此可以将所有的数据写在一个花括号内：\nint a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12}; 为了更直观地表示元素的分布，可以用大括号将每一行的元素括起来：\nint a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}; 或者\nint a[3][4] = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12} }; 二维数组也可以仅对部分元素赋初值：\nint a[3][4] = {{1},{5},{9}}; 如果希望整个二维数组初始化为0，那么直接在大括号里写一个0即可：\nint a[3][4] = {0}; C99同样增加了一种新特性：指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为0：\nint a[3][4] = {[0][0] = 1, [1][1] = 2, [2][2] = 3}; 二维数组的初始化也能偷懒，让编译器根据元素的数量计算数组的长度。但只有第1维的元素个数可以不写，其他维度必须写上：\nint a[][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}; 矩阵的转置\n遍历数字变更\n进行转置\n字符串 # #include \u0026lt;stdio.h\u0026gt; int main() { // 这种声明方式会默认在最后添加一个\\0 // 在我们这个C和C++中，字符串都是以00，也就是、0结尾的 char szStr[] = { \u0026#34;My name is rkvir\u0026#34; }; // 像下面这种，没有默认添加的，就需要字节手动添加00，也就是\\0 char cStr[] = {\u0026#39;M\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;e\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;i\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;\\0\u0026#39;}; char * pStr = \u0026#34;My name is rkvir\u0026#34;; printf(\u0026#34;%s\u0026#34;,cStr); } 字符操作 # 获取一个字符并进行输出：\nchar a; a = getchar(); putchar(); C语言ctype.h\n#include \u0026lt;ctype.h\u0026gt; isalpha(); isalnum(); isblank(); iscntrl(); isdigit(); isgraph(); islower(); isprint(); ispunct(); isspace(); isupper(); isxdigit(); 大小写处理函数\nchar a = \u0026#39;a\u0026#39;; char flag = toupper(a); char flags = tolower(flag); 字符串接收输出\n#include \u0026lt;stdio.h\u0026gt; int main() { char string; while ((string = getchar()) != EOF) { putchar(string); } return 0; } // EOF // CTRL+C // CTRL+Z 字符串输入 # // gets fgets scanf char szStr[50] gets(szStr); // 以回车结尾 fget(szStr,50,stdin); // 接受指定长度,也会接受回车 scanf(\u0026#34;%s\u0026#34;,\u0026amp;szStr); // 接受地址 字符串输出 # char *pStr = \u0026#34;Hello World!\\n\u0026#34;; // puts printf // puts这个函数会自动添加换行符 puts(szStr); fputs(szStr, stdout); printf(\u0026#34;%s\u0026#34;,szStr); 字符串操作 # 字符串长度\n#include \u0026lt;string.h\u0026gt; int main() { // strlen char szStr[] = \u0026#34;Hello World!\u0026#34;; int Length = strlen(szStr); return 0; } 字符串拼接\n#include \u0026lt;string.h\u0026gt; int main() { // strcat strncat char szStr1[] = \u0026#34;Hello\u0026#34;; char szStr2[] = \u0026#34;rkvir\u0026#34;; /* *strcat有两个参数 *第一个参数是目的字符串，第二个参数是源字符串 *strcat的作用就是把源字符串拼接大屏目的字符串的末尾处，并且将拼接后的字符串存储到目的字符串中 */ strcat(); // 会出溢出 // strncat 控制拼接长度 strncat(); return 0; } 字符串比对\n#include \u0026lt;string.h\u0026gt; int main() { char szStr1[] = \u0026#34;Hello World!\u0026#34;; char szStr2[] = \u0026#34;Hello\u0026#34;; char szStr3[] = \u0026#34;Hello World!\u0026#34;; // strcmp strncmp /* strcmp有两个参数，就是待比较的两个字符串 * 返回值是结果 * 如果返回值等于0，那么两个字符串就相等 * 如果返回值不等于0，那么两个字符串就不相等 */ int ret = strcmp(szStr1, szStr3); /* strncmp有三个参数 * 前两个参数是待比较的两个字符串 * 但是第三个字符，是比对的字符数 */ int ret0 = strncmp(szStr1, szStr2, 6); return 0; } 字符串拷贝\n#include \u0026lt;string.h\u0026gt; int main() { char szStr1[50] = {0}; char szStr2[] = \u0026#34;Hello\u0026#34;; // strcpy strncpy /* strcpy有两个参数 * 第一个参数是目的字符串 * 第二个参数是源字符串 * strcpy的作用就是把源字符串拷贝到目的字符串 */ strcpy(szStr1,szStr2); strncpy(szStr1,szStr2.2); return 0; } 字符串格式化\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char szStr1[] = \u0026#34;Hello\u0026#34;; int nNum = 11; char cS = \u0026#39;A\u0026#39;; char szStr2[100] = {0}; /* sprintf 三个参数 * 第一个参数，就是目的字符串 * 第二个参数，是格式化符号 * 第三个参数就是变量 */ sprintf(szStr2, \u0026#34;%s %d %c\u0026#34;, szStr1,nNum,cs); } 指针 # 内存储存的真相：数据储存在内存地址上\n指针和指针变量 # 指针：指向内存储存的地址\n指针变量 # 定义指针变量\n类型名 *指针变量名\nchar *pa;// 定义一个指向字符型的指针变量 int *pb; // 定义一个指向整型的指针变量 取地址运算符和取值运算符\n如果需要获取某个变量的地址，可以使用取地址运算符（\u0026amp;）：\nchar *pa = \u0026amp;a; int *pb = \u0026amp;f; 如果需要访问指针变量指向的数据，可以使用取值运算符（*）：\nprintf(\u0026#34;%c,%d\\n\u0026#34;,*pa,*pd); 避免访问未初始化的指针\n#include \u0026lt;studio.h\u0026gt; int main() { int *a; *a = 123; return 0; } 操作非常危险\n指针和数组 # 数组名的真实身份\n数组名其实是数组第一个元素的地址！\n指向数组的指针\n如果用一个指针指向数组，应该怎么做呢？\nchar *p; p = a; // 语句1 p = \u0026amp;a[0]; // 语句2 ==指针的运算==\n当指针指向数组元素的时候，我们可以对指针变量进行加减运算，这样做的意义相当于指向距离指针所在位置向前或向后第n个元素 对比标准的下标法访问数组元素，这种使用指针进行间接访问的方法叫做指针法 需要郑重强调的是：p+1并不是简单地将地址加1，而是指向数组的下一个元素 指针和数组的区别 # 数组名只是一个地址，而指针是一个左值\n指针数组\nint *p1[5]; //指针数组 // 初始化 #include\u0026lt;stdio.h\u0026gt; int main() { int a = 1; int b = 2; int c = 3; int d = 4; int e = 5; int *pl[5] = {\u0026amp;a ,\u0026amp;b ,\u0026amp;c ,\u0026amp;d ,\u0026amp;e }; int i; for (i = 0;i \u0026lt; 5; i++) { printf(\u0026#34;%d\\n\u0026#34;,*pl[i]); } return 0; } 指针数组是一个数组，每个数组元素存放一个指针变量\n数组指针\nint (*p2)[5]; 数组指针是一个指针，它指向的是一个数组\n指针和二维数组 # array表示的是什么？\narray表示指向5个元素的数组指针（即指向一维数组的数组指针）\n*(array+i) == array[i]; *(*(array+i)+j) == array[i][j]; *(*(*(array+i)+j)+k) == array[i][j][k]; 数组指针和二维指针 # 初始化二维数组是可以偷懒的：\nint array[2][3] = {{0,1,2}, {3,4,5}}; 可以写成\nint array[][3] = {{0,1,2},{3,4,5}}; 定义一个数组指针是这样的：\nint (*p)[3]; void指针 # void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针\n取出void指针的数值需要使用到强制类型转换\nNULL指针 # NULL指针即为空指针\n#define NULL ((void *)0) 当你还不清楚要将指针初始化为什么地址时，请将它初始化NULL；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为你今后编写大型程序节省大量的调试时间。\n指针之指针 # 指向指针的指针\n#include \u0026lt;stdio.h\u0026gt; int main() { int num = 520; int *p = \u0026amp;num; int **pp = \u0026amp;p; return 0; } 指针数组和指向指针的指针 # 至少有两个好处：\n避免重复分配内存 只需要进行一处修改 代码的灵活性和安全性都有了显著地提高！\n数组指针和二维数组\n常量和指针 # const关键字，使变量可读取而不可修改\nconst int price = 520; const char a = \u0026#39;a\u0026#39;; const float pi = 3.14 指针可以修改为指向不同的常量 指针可以修改为指向不同的变量 可以通过解引用来读取指针指向的数据 不可以通过解引用修改指针指向的数据 常量指针\nint num = 520; int * const p = \u0026amp;num; 指向非常量的常量指针 指针自身不可以被修改 指针指向的值可以被修改 指向常量的常量指针 指针自身不可以被修改 指针指向的值也不可以被修改 指针与函数 # 指针函数，是函数\n函数指针，是指针\n函数指针 # int add(int a, int b) { return a + b; } typedef int(*Myadd)(int a, int b); Myadd my = add; int c = my(1, 2); 应用场景：\n系统库API load dll 模块基质 GetProcAddress 获取函数地址 #include \u0026lt;stdio.h\u0026gt; int add(int a, int b); int main() { int (*Myadd)(int a, int b); //不带括号不带参数的函数名，其实就是函数的首地址 MyAdd = add; return 0; } int add(int a, int b) { return a+b; } 指针函数 # #include \u0026lt;stdio.h\u0026gt; int *add(int *a); int main() { int arrNum[5] = {1,2,3,4,5}; int *ret = add(arrNum); int nNum = ret[2] return 0; } int *add(int *a) { return a; } 存储类 # 静态存储时期 自动存储时期 静态存储类\n自动 寄存器 register 具有外部链接的静态存储类 extern 具有内部链接的静态存储类 static 空链接的静态存储类 static 动态内存管理 # 申请内存\n释放内存\n数组是默认给你开辟了一块连续空间\nmalloc在堆上面申请内存，返回的是void * 单位是字节\nmemset，把一段内存，全部刷成你想要的值\nfree，释放一段内存的空间\n#include \u0026lt;stdlib.h\u0026gt; int main() { char * szStr; szStr = (char *)malloc(200 * sizeof(char)); memset(szStr, 0, 200 * sizeof(char)); free(szStr); return 0; } 文件操作 # 文件指针：位于文件头部的指针，然后可以对其移动，这样就可以读取文件任意位置的数据了，文件指针移动到末尾出的时候，文件就读取完了\nfopen的模式\n模式 描述 “r” 打开一个用于读取的文件，该文件必须存在。 “w” 创建一个用于写入的空文件，如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件视为一个新的空文件。 “a” 追加到一个文件，写操作向文件末尾追加数据，如果文件不存在，则创建文件。 “r+” 打开一个用于更新的文件，可读取也可写入，该文件必须存在。 “w+” 创建一个用于读写的空文件。 “a+” 打开一个用于读取和追加的文件。 #include \u0026lt;stdio.h\u0026gt; int main() { // 声明文件指针 FILE * pFile; // 存储读取到的文件的内存空间，也就是一个char * 类型的字符串 char * szReadTextBuffer; // 读取到的文件的尺寸 int nReadFileSize; // 获取读取到的文件缓冲区字节数 int nReadRetSize = 0; /* fopen,fopen有两个参数 * 第一个参数是需要打开的文件的路径 * 第二个参数是打开的模式 */ if((pFile = fopen(\u0026#34;file.txt\u0026#34;,\u0026#34;rb\u0026#34;)) == NULL) { // 处理一下如果打开文件失败了 printf(\u0026#34;Open File Failed!\\n\u0026#34;); exit(0); } // 因为设置文件指针到末尾处了，我们可以通过文件指针位置的方式，获取文件大小 //设置文件指针到末尾处 fseek(pFile, 0, SEEK_EMD); // 获取文件指针的位置，获取文件大小 nReadFileSize = ftell(pFile); //文件指针复位到初始位置 rewind(pFile); // 根据文件尺寸申请一块足够大小的内存空间 szReadTextBuffer = (char *)malloc(sizeof(char)*nReadFileSize +1); if(szReadTextBuffer == NULL) { // 处理内存申请失败代码 printf(\u0026#34;malloc memory failed!\\n\u0026#34;); exit(0) } // 对申请到的内存进行初始化 menset(szReadTextBuffer, 0, nReadFileSize + 1); // 将已经获取到文件指针的文件的内容读取到已经申请好的缓冲区中，并且返回真实读取到的内容长度 nReadRetSize = fread(szReadTextBuffer, 1, nReadFileSize, pFile); // 判断是否读取失败，真实读取到的内存长度 if(nReadFileSize != nReadRetSize) { // 处理读取失败的代码 printf(\u0026#34;Read File Failed!\\n\u0026#34;); exit(0); } fclose(pFile); return 0; } 读取文件\nint main() { FILE* pFile; char* szReadTextBuffer; int nReadFileSize; int nReadRetSize; pFile = fopen(\u0026#34;C:\\\\Users\\\\15890\\\\Desktop\\\\file.txt\u0026#34;,\u0026#34;rb\u0026#34;); if (pFile == NULL) { printf(\u0026#34;open file failed!\\n\u0026#34;); exit(0); } fseek(pFile, 0, SEEK_END); nReadFileSize = ftell(pFile); rewind(pFile); szReadTextBuffer = (char*)malloc((nReadFileSize * sizeof(char)) + 1); if (szReadTextBuffer == NULL) { printf(\u0026#34;mallco memory failed!\\n\u0026#34;); exit(0); } memset(szReadTextBuffer, 0, nReadFileSize + 1); nReadRetSize = fread(szReadTextBuffer, 1, nReadFileSize, pFile); if (nReadFileSize != nReadRetSize) { printf(\u0026#34;Read file failed!\\n\u0026#34;); exit(0); } puts(szReadTextBuffer); fclose(pFile); return 0; } 写入文件\nint main() { char* szWriteBuffer = \u0026#34;I love the reverse program!\\n\u0026#34;; int nWriteSize = 0; FILE* pFile; pFile = fopen(\u0026#34;C:\\\\Users\\\\15890\\\\Desktop\\\\myfile.txt\u0026#34;, \u0026#34;wb\u0026#34;); if (pFile == 0) { printf(\u0026#34;failed!\\n\u0026#34;); exit(0); } fwrite(szWriteBuffer, strlen(szWriteBuffer), 1, pFile); fclose(pFile); return 0; } 结构体、联合体、枚举 # 结构体 # int main() { // 用struct标记为结构体，然后后面是结构体的名字 struct NPC { // 名字 char * Name; // 血量 int HP; // 魔法值 int MP; // 坐标 int x; int y; int z; } // 给结构体小儿的各种变量赋值 NPC xiaoer; xiaoer.Name = \u0026#34;wangxiaoer\u0026#34;; xiaoer.HP = 100; xiaoer.MP = 0; xiaoer.x = 111; xiaoer.y = 222; xiaoer.z = 0; } 结构体指针\nint main() { // 用struct标记为结构体，然后后面是结构体的名字 struct NPC { // 名字 char * Name; // 血量 int HP; // 魔法值 int MP; // 坐标 int x; int y; int z; } struct NPC npcarry[100]; struct NPC *npcindex; npcindex = \u0026amp;npcarry[0]; npcindex -\u0026gt; Name = \u0026#34;xiaoyi\u0026#34;; // *npcindex.Name = \u0026#34;xiaoyi\u0026#34;; npcindex++; npcindex -\u0026gt; Name = \u0026#34;xiaoer\u0026#34;; // *npcindex.Name = \u0026#34;xiaoer\u0026#34;; return 0; } 结构体参数\n位域 # struct { int a : 8; int b : 8; int c : 8; int d : 8; }rk 联合体 # union Info { char PlayerName[20]; int MP; float x; } union Info MyInfo; strcpy(MyInfo.PlayerName, \u0026#34;NPC\u0026#34;); printf(\u0026#34;%s\\n%d\\n%f\\n\u0026#34;, MyInfo.PlayerName, MyInfo.MP, MyInfo.x); 联合体所有成员共用一个地址，只能使用一个成员\n枚举 # int main() { enum color { red; green; blue; } int flag = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;flag); switch(flag) { case red: printf(\u0026#34;red\\n\u0026#34;); break; case green: printf(\u0026#34;green\\n\u0026#34;); break; case blue: printf(\u0026#34;blue\\n\u0026#34;); break; default: break; } return 0; } 高级数据表示 # 顺序结构 # 数组\n栈\n队列\n链式结构 # 链表\n链栈\n链队列\n树 # 二叉树\n度不能超过2 有序树 无序树 遍历\n先序遍历：根 左 右 中序遍历：左 根 右 后序遍历：左 右 根 ","date":"February 1, 2022","permalink":"/posts/c-core/","section":"Posts","summary":"C语言核心 # 函数 # 基本函数\n#include \u0026lt;stdio.h\u0026gt; // 函数的声明 void Hello(); int main() { // 最简单函数的调用 Hello(); return 0; } void Hello() { printf(\u0026#34;Hello!\\n\u0026#34;); } #include \u0026lt;stdio.h\u0026gt; void Hello() { printf(\u0026#34;Hello!\\n\u0026#34;); } int main() { // 最简单函数的调用 Hello(); return 0; } 函数的定义 # 返回值类型 函数名(参数列表) { 函数体 } 函数声明 # 所谓声明就是（Declaration）,就是告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上\n参数 # 形参 形式参数\n实参 实际参数\n传值和传址 # 传递数值 会受到作用域的限制\n传递地址 任意门不会受到作用域的限制\n可变参数 # #include \u0026lt;stdarg.h\u0026gt;\nva_list va_start va_arg va_end #include \u0026lt;stdio.","title":"C语言核心内容 笔记"},{"content":"C语言基础 # 概述 # main函数 # main函数是C语言的主函数，每个C语言程序都必须存在一个main函数，因为在程序开始的时候就会调用，它是程序执行的起点，当main函数的类型为int的时候表示函数返回一个整数值，类型为VOID表示函数不接受任何参数。main函数的函数体包括左花括号和右花括号之间的任何内容。\nprintf函数 # printf()函数是格式化输出函数，一般用于向标准输出设备按规定格式输出信息\nprintf()函数的调用格式为：printf(\u0026quot;\u0026lt;格式化字符串\u0026gt;, \u0026lt;参量表\u0026gt;\u0026quot;)\n格式输出，它是c语言中产生格式化输出的函数（在stdio.h中定义）。用于向终端（显示器、控制台等）输出字符。格式控制由要输出的文字和数据格式说明组成。要输出的文字除了可以使用字母、数字、空格和一些数字符号以外，还可以使用一些转义字符表示特殊的含义。主要包括%d, %o, %x, %g, %c, %s, 以及换行符\\n\n空白与注释 # 空白在C语言里并没有什么特殊的约定来限制你的使用，它的作用仅仅只是似的程序更好理解，更好的显示出程序的结构，仅此而已\n在C语言里存在以下两种注释方式\n// 单行注释 /*多行注释*/ 基础介绍 # 运行机制：C语言–\u0026gt; 汇编语言–\u0026gt;机器语言–\u0026gt;CPU\n编译型语言VS解释性语言\n编译型语言：编译为可执行文件，直接由CPU执行 解释型语言：编译为字节码，由解释器交给CPU执行 程序执行 # 编写 gcc test.c -o test编译 ./test执行 格式化输入\n#include \u0026lt;studio.h\u0026gt; int main(){ printf(\u0026#39;hello world\u0026#39;); return 0; } 输入输出函数 # 输入函数 scanf(\u0026quot;%?\u0026quot;, temp);\n输出函数 printf(\u0026quot;%?\u0026quot;, temp);\n转义字符 # 转义字符 含义 \\a 响铃(BEL) \\b 退格(BS)，将当前位置移到前一列 \\f 换页(FF)，将当前位置移到下页开头 \\n 换行(LF)，将当前位置移到下一行开头 \\r 回车(CR)，将当前位置移到本行开头 \\t 水平制表(HT)，跳到下一个TAB位置 \\v 垂直制表 \\\\ 表示(\\) \\' 表示(‘) \\\u0026quot; 表示(“) \\? 表示(?) \\0 表示空字符(NULL) \\ddd 1到3位八进制数所代表的任意字符 \\xhh 1到2位十六进制所代表的任意字符 占位字符 # 关键字与保留标识符 # 关键字 # 变量常量命名不能使用\n32个关键字\n标识符 # 以下划线开始的标识符，例如：\n_Bool、_Complex、_Imaginary\n语言标准库函数名，例如：\nprintf() scanf() strlen() strcpy()\n命名规则 # 匈牙利命名法\n变量名前，加上属性、类型\n变量命名有意义\n驼峰命名法\n大驼峰命名法\n所有单词全部首字母大写\n小驼峰命名法\n除了第一个单词小写外，其他的单词首字母大写\n变量常量 # 变量 # 变量的意义就算确定目标并提供存放的空间\n变量名\n变量名只能三英文字母（A-Z，a-z）和数字（0-9）或者下划线（_)组成 第一个字母必须三字母或者下划线开头 变量名区分大小写 数据类型\nchar\n字符型，占用一个字节\nint\n整型，通常反映了所用机器中整数的最自然长度\nfloat\n单精度浮点型\ndouble\n双精度浮点型\n声明变量的语法\nint a; char b; float c; double d; 变量赋值方式 # 方式一：\nint a, b, c; a = 1; b = 2; c = 3; 方式二：\nint a = 1; int b = 2; int c = 3; 方式三：\nint a = 1, b = 2, c = 3 常量 # 类型\n整型常量：520，1314，123 实型常量：3.14，5.12，8.97 字符常量 普通字符：‘L’，‘o’，‘v’，’e‘ 转义字符：‘\\n’，’\\t‘，‘\\b’ 字符串常量：“FishC” 定义符号常量\n格式：#define 标识符 常量\n比如：\n#define URL \u0026#39;http://www.fishc.com\u0026#39; 一般用小写字母命名变量，用大写字母命名常量\n标识符\n命名规则同变量的命名规则 [[C-basic#变量|变量]]\n字符串常量\n字符：‘F’, ’i’, ‘s ‘ , ‘h’ , ‘C’\n字符串：\n“Hello world” “I love FishC.com!” 编译过程中会将字符串最后一个字符后面添加一个\\0的空字符，用于判断字符串结束\n数据类型 # 基本类型\n整数类型int\nshort int \u0026lt;= int \u0026lt;= long int \u0026lt;=long long int\n浮点数类型float double\nfloat\ndouble\nlong double\n字符类型char\n布尔类型 _Bool\nC99之前C语言没有布尔类型，需要引用#include \u0026lt;stdbool\u0026gt;\n枚举类型enum\n指针类型 type *\n构造类型\n数组类型 结构类型 union 联合类型 struct 空类型\n整型 # signed和unsigned\nsigned：可以储存负值\nunsigned：只能储存正值及0\n[signed] short [int]; unsigned short [int]; [signed] int; unsigned int; 取值范围\n二进制\n比特位\nCPU能读懂的最小单位——比特位，bit，b\n字节\n内存机构的最小寻址单位——字节，Byte，B\n1 Byte == 8 bit\n计算技巧 $2^n-1$\n符号位\n存放signed类型的存储单元中，左边第一位表示符号位。如果该位为0，表示该整数是一个正数；如果该位为1，表示该整数是一个负数 一个32位的整型变量，除去左边第一位符号位，剩下表示值的只有31个比特位 事实上计算机是用补码的形式来存放整数的值 正数的补码三该数的二进制形式 负数的补码需要通过以下几步获得： 先取得该数的绝对值 再将第1步的值按位取反 最后将第2步的值加1 数据类型 字节 取值范围 char 1 -128~127 unsigned char 1 0~255 short 2 -32768~32767 unsigned short 2 0~65535 int 4 -2147483648~2147483647 unsigned int 4 0~4294967295 long 4 -2147483648~2147483647 unsigned long 4 0~4294967295 long long 8 -9223372036854775808~9223372035854775807 unsigned long long 8 0~18446744073709551615 float 4 $1.1754910^{-38}～3.4028210^{38}$ double 8 $2.2250710^{-308}～1.7976910^{308}$ long double 12 $2.2250710^{-308}～1.7976910^{308}$ 字符和字符串 # ASCII编码表\n数据类型 字节数 取值范围 signed char 1 -128~127 unsigned char 1 0~255 short 2 -32768~32767 unsigned short 2 0~65535 int 4 -2147483648~2147483647 unsigned int 4 0~4294967295 long 4 -2147483648~2147483647 unsigned long 4 0~4294967295 long long 8 -9223372036854775808~9223372036854775807 unsigned long long 8 0~18446744073709551615 字符串一般不会默认unsigned\n// 声明字符串： char name[5]; // 给字符串赋值： name[0] = \u0026#39;F\u0026#39;; name[1] = \u0026#39;i\u0026#39;; name[2] = \u0026#39;s\u0026#39;; name[3] = \u0026#39;h\u0026#39;; name[4] = \u0026#39;C\u0026#39;; // 定义字符串： char name[5] = {\u0026#39;F\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;C\u0026#39;}; 类型转换\n小坑位数据会转变为大坑位数据\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;整型输出：%d\\n\u0026#34;,1+(int)1.8);// 类型强制转换 printf(\u0026#34;浮点型输出：%f\\n\u0026#34;,1+2.0); return 0; } 运算符 # 算术运算符 # C语言通过提供运算符来支持我们对数据进行处理\n算术运算府\n运算符 名称 例子 结果 + 加法运算符（双目） 5+3 8 - 减法运算符（双目） 5-3 2 * 乘法运算符（双目） 5*3 15 / 除法运算符（双目） 5/3 1 % 求余运算符（双目） 5%3 2 + 正号运算符（单目） +5 5 - 负号运算符（单目） -5 -5 %不能将浮点数进行取余\n目\n表达式\n用运算符和括号将操作数连接起来的式子，我们称之为表达式\n1+1; \u0026#39;a\u0026#39;+\u0026#39;b\u0026#39;; a+b; a+\u0026#39;b\u0026#39;+pow(a,b)*3/4+5; 运算符存在怕优先级\n关系运算符 # 使用关系运算符来比较两个数的大小关系：\n优先级相同（高）\n\u0026lt;（小于）\n\u0026lt; = （小于或等于）\n\u0026gt; （大于）\n优先级相同（低）\n== （等于）\n!= （不等于）\n关系表达式\n用关系运算符将两边的变量、数据或表达式连接起来，称之为关系表达式：\n1\u0026lt;2; a\u0026lt;b; a\u0026lt;=1+b; \u0026#39;a\u0026#39;+\u0026#39;b\u0026#39;\u0026lt;=\u0026#39;c\u0026#39;; (a=3)\u0026gt;(b=5);// 只会返回一个布尔值 关系表达式得到的值是一个逻辑值，即真或假，在C语言的逻辑运算中，用数字1表示真，用数字0表示假\n逻辑运算符 # 运算符 含义 优先级 举例 ! 逻辑非 高 !a \u0026amp;\u0026amp; 逻辑与 中 a\u0026amp;\u0026amp;b ` ` 逻辑或 逻辑与，参与的所有表达式，结果全部为真，才为真，只要有一个为假，就为假\n逻辑或，参与的所有表达式中，只有一个结果为真，结果就为真，所有的都为假，才会为假\n逻辑表达式\n用逻辑运算符将两边的变量、数据或表达式连接起来，称之为逻辑表达式\n短路求值\n短路求值又称最小化求值，是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值 C语言对于逻辑与和逻辑或采用短路求值的方式 位运算符 # 运算符 功能 \u0026amp; 与 | 或 ^ 异或 ~ 取反 \u0026raquo; 左移 \u0026laquo; 右移 赋值运算符 # 运算符 功能 = 赋值 += 加法且赋值 -= 减法且赋值 *= 乘法且赋值 /= 除法且赋值 %= 取余且赋值 \u0026raquo;= 左移且赋值 \u0026laquo;= 右移且赋值 \u0026amp;= 按位与且赋值 |= 按位或且赋值 ^= 按位异或且赋值 int a; a = 5; 赋值运算符的左边必须是一个lvalue,变量名就是lvalue\n复合的赋值运算符\nint a; a+=1; a-=1; a*=1; a/=1; 自增自减运算符\nint a; a++; ++a; a--; --a; 其他运算符 # sizeof运算符 # sizeof运算符\nsizeof运算符用于获得数据类型或表达式的长度\nsizeof(object); //sizeof(对象)； sizeof(type_name); // sizeof(类型)； sizeof object; // sizeof 对象 条件运算符 # 语法：exp1?exp2:exp3; exp1是条件表达式 如果结果为真，返回exp2 如果结果为假，返回exp3 真左假右\n逗号运算符 # 语法：表达式1，表达式2，……，表达式n 逗号表达式的运算过程为从左往右逐个计算表达式 逗号表达式作为一个整体，它的值为最后一个表达式（也即表达式n）的值 a = (b = 3, (c = b + 4 ) + 5) 先将变量b赋值为3 然后变量c赋值为b+4的和，也就是7 接下来把c的值加上5 最后赋值给变量a，得到变量a的值是12 运算符优先级 # 优先级 运算符 结合律 1 后缀运算符：[] () · -\u0026gt; ++ \u0026ndash;(类型名称){列表} 从左到右 2 一元运算符：++ \u0026ndash; ! ~ + - * \u0026amp; sizeof_Alignof 从右到左 3 类型转换运算符：(类型名称) 从右到左 4 乘除法运算符：* / % 从左到右 5 加减法运算符：+ - 从左到右 6 移位运算符：\u0026laquo; \u0026raquo; 从左到右 7 关系运算符：\u0026laquo;= \u0026raquo;= 从左到右 8 相等运算符：== != 从左到右 9 位运算符 AND：\u0026amp; 从左到右 10 位运算符 XOR：^ 从左到右 11 位运算符 OR：| 从左到右 12 逻辑运算符 AND：\u0026amp;\u0026amp; 从左到右 13 逻辑运算符 OR：|| 从左到右 14 条件运算符：?: 从右到左 15 赋值运算符： = += -= *= /= %= \u0026amp;= ^= |= \u0026laquo;= \u0026raquo;= 从右到左 16 逗号运算符：， 从左到右 逻辑结构 # C语言中，包括三种执行流程\n顺序结构，所谓的顺序结构呢，就是从上往下顺序的执行 选择结构，就是给出一个条件，如果条件符合，去哪里执行，不符合，又去哪里执行 循环结构，循环结构呢，就是重复执行某一段代码 分支结构 # if语句 # // if 语句（1） if(表达式) { ......// 逻辑值为真所执行的语句、程序块 } // if 语句（2） if(表达式) { ......// 逻辑值为真所执行的语句、程序块 } else { ......// 逻辑值为假所执行的语句、程序块 } // if 语句（3） if(表达式1){......} else if(表达式2){......} else if(表达式3){......} . . . else if(表达式n){......} else{......} switch语句 # break语句\nswitch(表达式) { case 常量表达式1:语句或程序块1;break; case 常量表达式2:语句或程序块2;break; ...... case 常量表达式n:语句或程序块n;break; default:语句或程序块n+1;break; } 分支结构的嵌套 # 根据流程图写代码\n悬挂else问题：else会匹配最近的if\n解决：{}\n循环结构 # while语句 # // while语句 入口条件循环 while(i\u0026lt;=100) { sum = sum +i; i= i + 1; } // do...while语句 出口条件循环 do{ sum = sum + i; i = i + 1; } while(i\u0026lt;=100); for循环 # for(表达式1;表达式2;表达式3){ 循环体 } 三个表达式用分号隔开，其中：\n表达式1是循环初始化表达式 表达式2是循环条件表达式 表达式3是循环调整表达式 灵活的for语句\n表达式1，表达式2和表达式3可以按照需要进行省略（但分号不能省） 表达式1和表达式3可以是一个简单的表达式，也可以是逗号表达式（即用逗号分隔多个表达式） C99允许在for语句的表达式1中定义变量 循环嵌套 # 先执行内部循环再执行外部循环\n跳出循环 # break语言\n跳出循环\ncontinue语言\n跳出本轮循环\n只能作用于一层循环\n预处理 # 宏 # 宏（Macro）是预处理命令的一种，它允许用一个标识符来表示一个字符串。\ndefine\n#define nNum 15 #define ADD (a+b) #define MAX(a,b) ((a\u0026gt;b)?(a):(b)) undef\n取消宏处理\n条件编译\n#ifdef RKVIR printf(\u0026#34;this is def\u0026#34;); #else printf(\u0026#34;this is else\u0026#34;); #endif #define SYS 2 #if SYS == 1 printf(\u0026#34;1\u0026#34;); #elif SYS == 2 printf(\u0026#34;2\u0026#34;); #endif 标准库 # #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;math.h\u0026gt; C的标准库\nHeader File Content stdio.h 输入和输出 stdlib.h 最常用的一些系统函数 string.h 字符串处理 math.h 数学函数 ctype.h 字符类测试 time.h 时间和日期 stdarg.h 可变参数列表 signal.h 信号 assert.h 断言 setjmp.h 非局部跳转 errno.h 定义错误代码 stddef.h 一些常数、类型和变量 locale.h 本土化 float.h 浮点数运算 limits.h 定义整数数据类型的取值范围 补充 # go to语句 # 类似于汇编语言的JMP\n语法：goto标签； #include \u0026lt;stdio.h\u0026gt; int main() { int nNum = 0; loop: printf(\u0026#34;%d\\n\u0026#34;, nNum); nNum++; goto loop; return 0; } 尽量永远不要用到\n不建议使用\ntypedef # 定义类型的别名\ntypedef int uint32; typedef DATEBASE_CLASS_ONE DCO; ","date":"February 1, 2022","permalink":"/posts/c-basic/","section":"Posts","summary":"C语言基础 # 概述 # main函数 # main函数是C语言的主函数，每个C语言程序都必须存在一个main函数，因为在程序开始的时候就会调用，它是程序执行的起点，当main函数的类型为int的时候表示函数返回一个整数值，类型为VOID表示函数不接受任何参数。main函数的函数体包括左花括号和右花括号之间的任何内容。\nprintf函数 # printf()函数是格式化输出函数，一般用于向标准输出设备按规定格式输出信息\nprintf()函数的调用格式为：printf(\u0026quot;\u0026lt;格式化字符串\u0026gt;, \u0026lt;参量表\u0026gt;\u0026quot;)\n格式输出，它是c语言中产生格式化输出的函数（在stdio.h中定义）。用于向终端（显示器、控制台等）输出字符。格式控制由要输出的文字和数据格式说明组成。要输出的文字除了可以使用字母、数字、空格和一些数字符号以外，还可以使用一些转义字符表示特殊的含义。主要包括%d, %o, %x, %g, %c, %s, 以及换行符\\n\n空白与注释 # 空白在C语言里并没有什么特殊的约定来限制你的使用，它的作用仅仅只是似的程序更好理解，更好的显示出程序的结构，仅此而已\n在C语言里存在以下两种注释方式\n// 单行注释 /*多行注释*/ 基础介绍 # 运行机制：C语言–\u0026gt; 汇编语言–\u0026gt;机器语言–\u0026gt;CPU\n编译型语言VS解释性语言\n编译型语言：编译为可执行文件，直接由CPU执行 解释型语言：编译为字节码，由解释器交给CPU执行 程序执行 # 编写 gcc test.c -o test编译 ./test执行 格式化输入\n#include \u0026lt;studio.h\u0026gt; int main(){ printf(\u0026#39;hello world\u0026#39;); return 0; } 输入输出函数 # 输入函数 scanf(\u0026quot;%?\u0026quot;, temp);\n输出函数 printf(\u0026quot;%?\u0026quot;, temp);\n转义字符 # 转义字符 含义 \\a 响铃(BEL) \\b 退格(BS)，将当前位置移到前一列 \\f 换页(FF)，将当前位置移到下页开头 \\n 换行(LF)，将当前位置移到下一行开头 \\r 回车(CR)，将当前位置移到本行开头 \\t 水平制表(HT)，跳到下一个TAB位置 \\v 垂直制表 \\\\ 表示(\\) \\' 表示(‘) \\\u0026quot; 表示(“) \\?","title":"C语言基础 笔记"},{"content":"","date":"January 29, 2022","permalink":"/tags/java/","section":"Tags","summary":"","title":"java"},{"content":"Java面向对象之多态 # 方法重写 # 子类和父类同名方法 # 子类和父类同名方法，方法重写\n前提：需要有继承关系\n方法重写表现：\n方法名必须相同\n参数列表必须相同\n返回值类型必须相同\n修饰符：范围可以扩大或相同，但是不能缩小 public \u0026gt; protected \u0026gt;default\n方法重写\npublic class Animal { public void eat() { System.out.println(\u0026#34;动物去吃东西\u0026#34;); } } public class Cat extends Animal { public void eat() { System.out.println(\u0026#34;猫喜欢吃鱼\u0026#34;); } } public class Dog { public void eat() { System.out.println(\u0026#34;狗喜欢吃骨头\u0026#34;); } } 不能重写父类的private方法，如果定义的话只是定义了一个新方法，不是方法重写\n运行时多态 # 后期绑定\n如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也被称之为后期绑定\n运行时多态\n方法重写是根据实际的类型决定调用哪个重写的方法，发生在运行期间，也叫做运行时多态\n多态\npublic class Animal { public void eat() { System.out.println(\u0026#34;动物去吃东西\u0026#34;); } } public class Cat extends Animal { public void eat() { System.out.println(\u0026#34;猫喜欢吃鱼\u0026#34;); } } public class Dog { public void eat() { System.out.println(\u0026#34;狗喜欢吃骨头\u0026#34;); } } public class Test { public static void main(String[] args) { Animal an = new Cat(); an.eat(); } } 子类和父类static修饰的同名方法 # 子类和父类static修饰的同名方法\nstatic修饰的方法是静态方法，也叫做类方法使用\n使用private或static或final修饰的变量或者方法，是早期绑定\npublic class Animal { public static void eat() { System.out.println(\u0026#34;动物在吃\u0026#34;); } } public class Cat extends Animal { public static void eat() { System.out.println(\u0026#34;猫吃鱼\u0026#34;); } } public class Test { public static void main(String[] args) { Animal an = new Cat(); an.eat(); } } 动态绑定和解耦合简介 # 动态绑定\n在运行时根据具体对象的类型进行绑定，也就是后期绑定\n解耦合简介\n解耦合，字面意思就是解除耦合关系\n设计的核心思想：\n尽可能减少代码耦合，如果发现代码耦合，就要采用解耦技术\n数据模型，业务逻辑和视图显示三层之间彼此降低耦合\n解耦合简介\n父子关系和夫妻关系的区别\n从编程角度，父子关系是不能拆分的\n从编程角度，夫妻关系是可以拆分的\n同名变量和方法重写 # 子类和父类出现同名变量\npublic class Father { int a = 1; static int b = 1; public Father() { a = 10; b = 10; } } public class Son extends Father { int a = 2; static int b = 2; public Son() { a = 20; b = 20; } public static void main(String[] args) { Son s = new Son(); Father f = s; System.out.println(\u0026#34;f.a = \u0026#34;+f.a+\u0026#34;,f.b=\u0026#34;+f.b); System.out.println(\u0026#34;s.a = \u0026#34;+s.a+\u0026#34;,s.b=\u0026#34;+s.b); } } 方法重载和方法重写的区别和应用 # 名称 方法重载 方法重写 类 一个类 继承关系 方法名 参数个数不同、参数类型不同、参数顺序不同 参数列表相同 返回值类型 可以不同 必须相同 调用方式 参数决定 创建的实际对象决定 static修饰 是方法重载 不是方法重写 抽象类 # 抽象类 # 为什么需要抽象类？\n动物Animal都有自己的行为，小鸟和老虎继承了动物的行为，但小鸟和老虎的行动方式不一样。在动物中能给出行动的具体实现吗？\n抽象类和抽象方法来解决这个问题\n什么是抽象类？\n使用abstract关键字修饰的方法叫做抽象方法，抽象方法没有方法体。当一个类中包含了抽象方法，那么该类也必须使用abstract关键字来修饰，这种使用abstract关键字修饰的类就是抽象类。\n抽象类及抽象方法定义的语法格式\n[修饰符] abstract class 类名 { // 定义抽象方法 [修饰符] abstract 方法返回值类型 方法名([参数列表]); // 其他方法或属性 } 抽象类的作用 # 抽象类的作用类似于“模板”，其目的是方便开发人员根据抽象类的格式来修改和创建新类。\n抽象类主要用于继承，有利于程序的扩展。\npublic abstract class Book { public abstract String getAuthor(); } public class ComputerBook extends Book { @Override public String getAuthor() { return \u0026#34;詹姆斯·高斯林 James Gosling\u0026#34;; } } public class EnglishBook extends Book { @Override public String getAuthor() { return \u0026#34;Tom\u0026#34;; } } 抽象类的特点 # 抽象类不能创建对象，如果创建，编译无法通过而报错，只能创建其非抽象子类的对象。 抽象类中，可以有构造器，是供子类创建对象时，初始化父类成员使用的。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类，不然编译无法通过而报错。 抽象类中的抽象方法不能用private、final、static修饰 抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。 接口 # 接口的定义 # 为什么需要接口？\n可以使用接口解决Java多继承的问题 什么是接口\n接口就是某个事物对外提供的一些功能的声明 可以利用接口实现多态，同时接口也弥补了Java单一继承的弱点 使用interface关键字定义接口 接口的特性 # JDK 1.8之前接口的特性：\n接口允许多继承 接口没有构造方法 接口中的属性默认是用public static final修饰 接口中的方法默认是用public abstract修饰的 接口继承接口用extends，不能implement JDK 1.8 之后接口的语法：\n[修饰符] interface 接口名 [extends 父接口1,父接口2,...] { [public] [static] [final] 常量类型 常量名 = 常量值; [public] [abstract] 方法返回值类型 方法名([参数列表]); [public] default 方法返回值类型 方法名([参数列表]){ // 默认方法的方法体 } [public] static 方法返回值类型 方法名([参数列表]){ // 类方法的方法体 } } JDK 1.8之后接口的特性：\n在接口内部可以定义多个常量和抽象方法，定义常量时必须进行初始化赋值，定义默认方法和静态方法时，可以有方法体。 在接口中定义常量时，可以省略“public static final”修饰符，接口会默认为常量添加”public static final“修饰符。与此类似，在接口中定义抽象方法时，也可以省略”public abstract“修饰符，定义default默认方法和static静态方法时，可以省略”public“修饰符，这些修饰符系统都会默认进行添加。 接口的作用 # 接口表示一种能力，例如：”做这项工作需要一个钳工/木匠/程序员“\n接口是一种能力\n体现在接口方法上 面向接口编程\n接口的设计 # 面向接口编程 需求：开发打印机 墨盒：彩色、黑白 纸张类型：A4、B5 墨盒和纸张都不是打印机厂商提供的 打印机厂商要兼容市场上的墨盒、纸张 结果： 使用黑白墨盒在A4纸上打印 使用彩色墨盒在B5纸上打印 使用彩色墨盒在A4纸上打印 接口与抽象类 # 抽象类的特点 # 何时使用继承？\n继承与真实世界类似，只要说”猫是哺乳动物“，猫的很多属性、行为就不言自明了。\n符合is-a关系的设计使用抽象类继承\n继承是代码重用的一种方式，将子类共有的属性和行为放到父类中，子类与父类是is-a关系\n接口的特点 # USB接口本身没有实现任何功能\nUSB接口规定了数据传输的要求\nUSB接口可以被多种USB设备实现\n可以使用Java接口来实现\n编写USB接口 根据需求设计方法 实现USB接口 实现所有方法 使用USB接口 用多态的方式使用 符合has-is关系的设计使用接口\n","date":"January 29, 2022","permalink":"/posts/java-polymorphic/","section":"Posts","summary":"Java面向对象之多态 # 方法重写 # 子类和父类同名方法 # 子类和父类同名方法，方法重写\n前提：需要有继承关系\n方法重写表现：\n方法名必须相同\n参数列表必须相同\n返回值类型必须相同\n修饰符：范围可以扩大或相同，但是不能缩小 public \u0026gt; protected \u0026gt;default\n方法重写\npublic class Animal { public void eat() { System.out.println(\u0026#34;动物去吃东西\u0026#34;); } } public class Cat extends Animal { public void eat() { System.out.println(\u0026#34;猫喜欢吃鱼\u0026#34;); } } public class Dog { public void eat() { System.out.println(\u0026#34;狗喜欢吃骨头\u0026#34;); } } 不能重写父类的private方法，如果定义的话只是定义了一个新方法，不是方法重写\n运行时多态 # 后期绑定\n如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也被称之为后期绑定\n运行时多态\n方法重写是根据实际的类型决定调用哪个重写的方法，发生在运行期间，也叫做运行时多态\n多态\npublic class Animal { public void eat() { System.out.println(\u0026#34;动物去吃东西\u0026#34;); } } public class Cat extends Animal { public void eat() { System.","title":"Java面向对象之多态 笔记"},{"content":"Java面向对象之继承 # 类的继承机制 # 继承的的作用 # 继承的作用：减少重复的冗余的相同属性和方法\n多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中\n那么多个类无需再定义这些相同属性和行为，只要继承那个类即可\npublic class Person { // 姓名 private String name; // 年龄 private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void eat() { System.out.println(\u0026#34;吃饭\u0026#34;); } } public class Student extends Person { } 子类和父类的继承机制 # 继承关系是两个类，一个为子类（派生类），一个父类（基类）。 子类继承父类，使用关键字extends来表示 extends的意思是“扩展”，子类是对父类的扩展 java中类只有单继承，没有多继承（一个儿子只有一个直接的爸爸，但是爸爸可以有多个儿子） Java的单继承 # Java不支持多继承，只允许一个类直接继承另一个类 子类只能有一个父类，extends关键字后面只能有一个类名 Java继承的顶级父类：Object类简介 # Object类是Java中所有类的始祖 Java中的每一个类都是由它扩展而来，但是并不需要明确写出要继承它 自然的，所有Java类都拥有了其方法 toString()方法\n该方法用来返回对象的字符串表示形式\npublic class Person { // 姓名 private String name; // 年龄 private int age; public String toString() { return \u0026#34;Person[\u0026#34;+name+\u0026#34;,\u0026#34;+age+\u0026#34;]\u0026#34;; } public static void main(String[] args) { Person p = new Person(); p.name = \u0026#34;张五\u0026#34;; p.age = 20; System.out.println(p.toString()); } } equals(Object obj)方法\n该方法用来判断两个对象是否相同\n如果没有被重写过，其与==等价\npublic class PersonOne { public static void main(String[] args) { PersonOne p1 = new PersonOne(); PersonOne p2 = new PersonOne(); System.out.println(p1.equals(p2)); } } hashCode()方法\nObject类的hashCode方法是返回对象存储地址\npublic class PersonOne { public static void main(String[] args) { PersonOne p1 = new PersonOne(); System.out.println(p1.hashCode()); PersonOne p2 = new PersonOne(); System.out.println(p2.hashCode()); } } 对象向上转型 # 引用类型的转换\n子类转换成为父类，向上转型 格式：父类名称 对象名称 = new 子类名称(); 含义：把创建的子类对象当做父类看待和使用 public class Person { public void run() { System.out.println(\u0026#34;Person Run\u0026#34;); } } public class Student extends Person { public void eat() { System.out.println(\u0026#34;Son eat\u0026#34;); } } public class Application { public static void main(String[] args) { // person(父类引用)可以指向子类 // 向上转型 Person s2 = new Student(); s2.run(); // 但不能调用子类特有的方法 //s2.eat(); } } 对象向下转型 # 引用类型转换\n父类转换为子类，向下转型 子类 引用 = （子类）父类对象 强制类型转换 public class Person { public void run() { System.out.println(\u0026#34;Person Run\u0026#34;); } } public class Student extends Person { public void eat() { System.out.println(\u0026#34;Son eat\u0026#34;); } } public class Test { public static void main(String[] args) { Person p = new Student(); // 报错 // p.eat(); // 向下转型 Student s = (Student) p; s.eat(); } } 对象向下转型注意：\n问题：可能会出现ClassCastException异常\npublic class Person { public void run() { System.out.println(\u0026#34;Person Run\u0026#34;); } } public class Student extends Person { public void eat() { System.out.println(\u0026#34;Son eat\u0026#34;); } } package TestDemo; public class Test1 { public static void main(String[] args) { Person p = new Person(); Student s = (Student) p; s.eat(); } } super关键字 # super在继承构造函数中定义和作用 # 在继承中子类的构造函数必须依赖父类提供的构造函数 super（参数列表）访问父类的构造函数 super调用父类的构造函数，必须在构造函数的第一行 如果父类的构造函数是无参构造函数，可以默认不写super关键字\n在继承中子类的构造函数必须依赖父类提供的构造函数 public class Person { private String name; private int age; public Person(String name, int age) { } } public class Student extends Person { public Student() { // 1. 如果父类提供的只有有参数的构造函数，子类的构造必须依赖父类提供的现有构造函数 // 2. super(参数列表)去访问父类的提供的构造函数，必须明确写出参数 // 3. super必须在第一行 super(\u0026#34;小张\u0026#34;, 20); } } super访问父类的属性 # 在子类的方法或构造器中，通过使用super属性 特殊情况：当子类和父类中定义了同名的属性时，想调用父类中声明的属性，就需要通过super.属性的方式来声明调用的是父类中声明的属性 public class Person { // 身份证号 int id = 1001; } public class Student extends Person { // 学生证号 int id = 80; public void show() { System.out.println(\u0026#34;身份证号是\u0026#34;+super.id+\u0026#34;，学生证号是\u0026#34;+id); } } package super_Demo; public class Test { public static void main(String[] args) { Student s = new Student(); s.show(); } } super访问父类的方法 # 在子类的方法或构造器中，通过使用super.方法名\npublic class Person { public void eat() { System.out.println(\u0026#34;人都要吃饭\u0026#34;); } } public class Student extends Person { public Student() { // 访问父类的方法 super.eat(); } public static void main(String[] args) { Student s = new Student(); } } super和this区别 # super()调用父类的构造函数，必须在构造函数的第一行 this()调用本类的构造函数，必须在构造函数的第一行 super()和this()不能同时调用构造函数 代表对象不同\nthis：本身调用者这个对象 super：代表父类对象的引用 前置\nthis：没有继承也可以使用 super：只能在继承条件下才能使用 构造方法\nthis()：本类的构造 super()：父类的构造 final关键字 # final关键字修饰变量 # final关键字修饰的变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能修改 final关键字修饰的变量，如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象 final修饰的变量都是常量 final可以修饰局部变量 final关键字修饰方法 # final修饰的成员方法不能被子类重写\n当父类的方法为final时，子类不能与父类有方法名、参数类型、参数个数及参数顺序都一样的方法\n父类方法为private修饰符的final方法 public class Person { private final void show() { System.out.println(\u0026#34;Person:show\u0026#34;); } } public class Student extends Person { public final void show() { System.out.println(\u0026#34;Student:show\u0026#34;); } } public class Test { public static void main(String[] args) { Person person = new Person(); Student stu = new Student(); //private的方法仅本类可见，该方法不可见 //person.show(); stu.show(); } } final修饰类 # final修饰的类不能被子类继承 final类中的成员方法也默认为final final类中的变量值是可以改变的 ","date":"January 29, 2022","permalink":"/posts/java-extends/","section":"Posts","summary":"Java面向对象之继承 # 类的继承机制 # 继承的的作用 # 继承的作用：减少重复的冗余的相同属性和方法\n多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中\n那么多个类无需再定义这些相同属性和行为，只要继承那个类即可\npublic class Person { // 姓名 private String name; // 年龄 private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void eat() { System.out.println(\u0026#34;吃饭\u0026#34;); } } public class Student extends Person { } 子类和父类的继承机制 # 继承关系是两个类，一个为子类（派生类），一个父类（基类）。 子类继承父类，使用关键字extends来表示 extends的意思是“扩展”，子类是对父类的扩展 java中类只有单继承，没有多继承（一个儿子只有一个直接的爸爸，但是爸爸可以有多个儿子） Java的单继承 # Java不支持多继承，只允许一个类直接继承另一个类 子类只能有一个父类，extends关键字后面只能有一个类名 Java继承的顶级父类：Object类简介 # Object类是Java中所有类的始祖 Java中的每一个类都是由它扩展而来，但是并不需要明确写出要继承它 自然的，所有Java类都拥有了其方法 toString()方法","title":"Java面向对象之继承 笔记"},{"content":"Java 面向对象之类和对象 # 面向对象与面向过程 # 面向过程 # 面向过程编程就是分析出解决问题的步骤 然后使用函数把这些步骤一步步实现 重心放在完成的每个过程上 面向对象 # 构成问题事务分解成各个对象 描述某个事物在整个解决问题的步骤中的行为 面向过程和面向对象区别 # 面向过程就是步骤，就是解决问题按部就班 面向对象关注的解决问题所需要的对象 面向过程就是自己办事，面向对象就是托人办事 现实世界的面向对象 # 类和对象：\n类(class)是抽象的 对象(object)是具体的 汽车类(class) –new–\u0026gt;实例(instance)\nJava的类和对象 # Java的类 # 类可以看作是一个模板 用于描述一类对象的行为和状态 Java的类的描述 # public class Person { // 姓名 String name; // 年龄 int age; // 身高 int height; // 唱歌 void sing() { } // 跳舞 void dance() { } } Java的对象 # 万物皆对象 对象是具体的物体 拥有属性 拥有行为 把很多零散的构建成一个整体 具有唯一性 类和创建对象 # public class Person { // 姓名 String name; // 年龄 int age; // 身高 int height; public static void main(String[] args) { Person p = new Person(); p.name = \u0026#34;小鸿蒙\u0026#34;; p.age = 2; p.height = 8848; System.out.println(\u0026#34;这个人的名字是：\u0026#34;+p.name+\u0026#34;，年龄是\u0026#34;+p.age+\u0026#34;，身高是：\u0026#34;+p.height); } } 类名 对象名=new 类名();\nPerson p = new Person(); 对象与new关键字 # new关键字表示创建一个对象 new关键字表示实例化对象 new关键字表示申请内存空间 Person person = null;\nPerson person = new Person();\nPerson person = new Person(); person.name = \u0026#34;小张\u0026#34;; person.age = 20; Java的内存中创建多个对象 # 类与对象的关系 # 类的作用 — 产生出具体的对象\n对象 – 抽象 – 类 – 实例化 – 对象\nJava对象的组成 # 实例变量和静态变量 # 实例变量 # public class Person { // 姓名 String name; // 年龄 int age; // 身高 int height; public static void main(String[] args) { Person p = new Person(); p.name = \u0026#34;小鸿蒙\u0026#34;; p.age = 2; p.height = 8848; System.out.println(\u0026#34;这个人的名字是\u0026#34;+p.name+\u0026#34;，年龄是\u0026#34;+p.age+\u0026#34;，身高是\u0026#34;+p.height); } } 静态变量 # 独立于方法之外的变量，用static修饰，静态变量，也可以叫做类变量 static不能修饰局部变量 构造函数 # java构造函数，也叫构造方法，是java中一种特殊的函数 构造函数没有返回类型，函数名和类名保持一致 new对象产生后，就调用了对象的属性和方法 作用：一般用来初始化成员属性和成员方法 格式：\n修饰符 类名（参数列表）{ } 直接类名 （参数列表）{ } 默认无参构造函数和有参构造函数\n// 无参构造函数 public class Employee { public Employee() { } } // 有参构造函数 public class Employee { public Employee(String name, int age) { } } 构造函数可以有return关键字，但是不能有具体的返回值类型\n构造函数\n构造函数不是手动调用的，是对象被创建的时候jvm调用 如果一个类没有定义构造方法，jvm在编译的时候会给这个类默认添加一个无参构造方法 如果定义了构造方法，那么jvm不会再创建无参构造方法 创建对象的时候，有几个参数，就要有相应的构造方法，也是对应的要有几个参数 构造函数可以调用构造函数 构造函数的作用\npublic class Employee { String name; int age; public Employee() // 构造函数的作用是给类中的属性赋值初始化 { name = \u0026#34;鸿蒙\u0026#34;; age = 2; } } 构造函数和创建对象\npublic class Student { String name; int age; public static void main(String[] args) { Student s = new Student(); // 创建对象会自动隐式的调用类中提供的构造函数 } } public class Student { String name; int age; public Student(String name, int age) { } public static void main(String[] args) { Student s = new Student();// 错误 Student s1 = new Student(\u0026#34;鸿蒙\u0026#34;,2);// 正确 // 创建对象必须依赖类中现在提供的构造函数 } } 匿名构造块 # 构造代码块的格式：{ } 代码块的作用：对象统一初始化 对象创建之前都会执行这个代码块 匿名构造块执行\npublic class Dept { { System.out.println(\u0026#34;这是匿名构造块\u0026#34;); } public static void main(String[] args) { Dept dept = new Dept();// 创建对象，如果类中提供了匿名构造块，都会执行 } } 创建对象之前都会执行匿名构造块，执行匿名构造块和构造函数的参数无关\n构造函数重载 # 构造函数重载是多态的一个典型的特例 类中有多个构造函数，参数列表不同 重载构造函数来表达对象的多种初始化行为 构造函数重载\npublic class Person { String name; int age; public Person() { } public Person(String pname, int page) { name = pname; age = page; } public static void main(String[] args) { Person p1 = new Person(); Person p2 = new Person(\u0026#34;张员工\u0026#34;,22); } } 方法的定义 # 方法是类或对象的行为特征的抽象 Java中的方法不能独立存在，必须定义在类体中 语法格式：\n权限修饰符 返回值类型 方法名（参数类型 参数名）\n{\n// 方法体\n// 返回值\n}\n方法的定义\n方法定义的先后顺序无所谓\n方法的定义不能产生嵌套包含关系\n方法定义中的返回值与传递的参数类型均为java中定义的数据类型\n在方法中可以进行返回数据的处理，格式：\nreturn 返回数据类型\nvoid 不返回数据类型\npublic class Person { public void eat() { System.out.println(\u0026#34;这个eat方法是声明了void类型，void类型就是没有返回值\u0026#34;); } public int getAge() { System.out.println(\u0026#34;这个getAge方法是声明了int类型，表示需要在方法的最后使用return返回具体的值\u0026#34;); return 20; } } 方法的调用 # 方法定义了，不会执行，如果想要执行，应进行方法调用\n本类中的方法调用\n方法名(参数列表)\n外部类中的方法调用\n调用类的对象.方法名(参数列表)\n方法的调用\npublic class Person { public void eat() { System.out.println(\u0026#34;这个eat方法是声明了void类型，void类型就是没有返回值\u0026#34;); } public int getAge() { System.out.println(\u0026#34;这个getAge方法是声明了int类型，表示需要在方法的最后使用return返回具体的值\u0026#34;); return 20; } public static void main(String[] args) { Person p = new Person(); p.eat(); int age = p.getAge(); System.out.println(\u0026#34;年龄是\u0026#34;+age); } } 构造函数和普通方法的区别 # 方法的重载 # 一个类中多个方法名称相同 参数的列表不同 返回值类型无关 与修饰符无关 方法重载的具体表现形式\npublic class Employee { public void eat() { System.out.println(\u0026#34;员工默认吃工作餐\u0026#34;); } public void eat(String food) { System.out.println(\u0026#34;在一些节日员工可以定制具体的食物，具体的事物是\u0026#34;+food); } public static void main(String[] args) { Employee e = new Employee(); e.eat(); e.eat(\u0026#34;北京烤鸭\u0026#34;); } } 编译时多态 # 早期绑定\n早期绑定就是指被调用的目标方法如果在编译期可知\n且运行期保持不变时，即可将这个方法与所属的类型进行绑定\n重载的方法是早期绑定完成\n调用了一个重载的方法，在编译时根据参数列表就可以确定方法\n面向对象的封装 # 封装是指隐藏对象的属性和实现细节，仅对外提供公式访问方式 封装原则：\n将不需要对外提供的内容都隐藏起来 把属性都隐藏，提供公共方法对其访问 封装好处：\n提高数据访问的安全性 隐藏了实现细节 从数据安全角度\n没有封装，在外部类中可以直接访问修改数据，造成数据不安全\n封装的控制与实现：private私有访问修饰符修饰变量\npublic class Employee { private double salary; } 该露的露，该藏的藏\n我们程序设计要追求“高内聚，低耦合” 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉 低耦合：仅暴露方法给外部使用 应禁止直接访问一个对象中数据的实际表示，而通过操着方法来访问，这称为数据的隐藏 this关键字 # this代表当前对象的一个引用 所谓当前对象，指的是调用类中方法或属性的那个对象 this只能在方法内部使用，表示对“调用方法的那个对象”的引用 this属性名：表示本对象自己的属性 对象的一个属性被方法或构造器的参数屏蔽\npublic class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public static void main(String[] args) { Person p1 = new Person(\u0026#34;小张\u0026#34;,20); Person p2 = new Person(\u0026#34;小李\u0026#34;,22); } } this关键字调用本类构造函数\nthis关键字调用类的重载构造函数 this关键字必须位于构造函数的第一行 public class Person { String name; int age; public Person(int age) { this.age = age; } public Person(String name) { this(1); this.name = name; } public static void main(String[] args) { Person p1 = new Person(\u0026#34;出生婴儿1\u0026#34;); Person p2 = new Person(\u0026#34;出生婴儿2\u0026#34;); } } this关键字调用本类方法\nthis.方法名 ：表示当前对象自己的方法 public class Student { public void eat() { System.out.println(\u0026#34;同学先吃点食物\u0026#34;); } public void talk() { this.eat(); System.out.println(\u0026#34;同学吃完饭再说\u0026#34;); } } this关键字使用注意\nthis不能用于静态方法和静态块 main方法也是静态的，所以this也不能用于main方法 public class Person { String name; int age; public static void main(String[] args) { this.name = \u0026#34;小妮子\u0026#34;; this.age = 20; } } static 关键字 # static修饰变量\nstatic变量也称作静态变量，也叫做类变量 静态变量被所用的对象所共享，在内存中只有一个副本 当且仅当在类初次加载时会被初始化 静态变量属于类 通过类名就可以调用静态变量 也可以通过对象名.静态变量名调用 static变量\npublic class Student { private String name; private static String schoolName; private static int count; public Student(String name) { this.name = name; count++; } public void showStuInfo() { System.out.println(\u0026#34;学生的姓名是\u0026#34;+this.name+\u0026#34;，学校的名字是\u0026#34;+Student.schoolName); } public static void main(String[] args) { Student.schoolName = \u0026#34;第五十七中\u0026#34;; Student s1 = new Student(\u0026#34;小张\u0026#34;); Student s2 = new Student(\u0026#34;小王\u0026#34;); Student s3 = new Student(\u0026#34;小美\u0026#34;); s1.showStuInfo(); s2.showStuInfo(); s3.showStuInfo(); System.out.println(\u0026#34;学生的数量是\u0026#34;+Student.count); } } static修饰方法\nstatic修饰的方法叫静态方法，也叫做类方法 静态方法中不能直接访问类的非静态成员变量和非静态成员方法 静态方法中不能使用this关键字 通过类名就可以调用静态方法 也可以通过对象名.静态方法名调用 静态方法和静态方法访问\npublic class Student { private String name; private int age; private int studentId; private static String classRoom; public static void showClassRoom() { System.out.println(\u0026#34;自习教室是公共教室1001\u0026#34;); } public static void main(String[] args) { Student.showClassRoom(); } } static块\n静态代码块在类加载时执行，并且只执行一次 静态代码块在类中可以有多个 静态代码块中不能有this关键字 静态块可以有多个按照顺序执行\npublic class Emp { static { System.out.println(\u0026#34;欢迎您员工\u0026#34;); } static { System.out.println(\u0026#34;每天上班都要打卡\u0026#34;); System.out.println(\u0026#34;每天下班都要打卡\u0026#34;); } } 注意静态块，匿名构造块，构造函数的执行顺序\n类的生命周期 # 类的生命周期由五部分组成：\n加载 连接 初始化 使用 卸载 其中，连接阶段又分为三个阶段：\n验证 准备 解析 总的生命周期如下图所示：\n加载 验证 准备 解析 初始化 使用 卸载 Java方法参数 # 方法参数的基本类型和引用类型\n在java方法中参数列表有两种类型的参数，基本类型和引用类型 参数类型是基本数据类型，那么传过来的就是这个参数的一个副本 参数类型是引用类型，那么传过来的就这个引用参数的脚本，这个副本存放的是参数的地址 Java方法的参数基本数据类型\npublic class Test1 { int a = 5; int b = 6; public void change(int a, int b) { a = 20; b = 30; System.out.println(\u0026#34;chang方法里，a的值是：\u0026#34;+a+\u0026#34;;b的值是：\u0026#34;+b); } public static void main(String[] args) { Test1 t = new Test1(); t.change(t.a,t.b); System.out.println(); System.out.println(\u0026#34;交换结束后，a的值是：\u0026#34;+t.a+\u0026#34;;b的值是：\u0026#34;+t.b); } } Java方法的参数引用数据类型\npublic class Test2 { int a = 5; int b = 6; public void change(Test2 t) { t.a = 20; t.b = 30; System.out.println(\u0026#34;change方法里，a的值是：\u0026#34;+a+\u0026#34;;b的值是：\u0026#34;+b); } public static void main(String[] args) { Test2 t = new Test2(); t.change(t); System.out.println(); System.out.println(\u0026#34;交换结束后，a的值是：\u0026#34;+t.a+\u0026#34;;b的值是：\u0026#34;+t.b); } } Java的可变参数列表\npublic class Test { public void add(int... a) { for(int i=0; i\u0026lt;a.length; i++) { System.out.println(a[i]); } } public static void main(String[] args) { Test t = new Test(); t.add(); t.add(1); t.add(1,2,5,8); } } Java参数传递基本数据类型和引用类型区别 # 说明 基本数据类型 引用数据类型 根本 会创建副本 不会创建副本 所以 函数中无法改变原始对象 函数中可以改变原始对象 ","date":"January 29, 2022","permalink":"/posts/java-object/","section":"Posts","summary":"Java 面向对象之类和对象 # 面向对象与面向过程 # 面向过程 # 面向过程编程就是分析出解决问题的步骤 然后使用函数把这些步骤一步步实现 重心放在完成的每个过程上 面向对象 # 构成问题事务分解成各个对象 描述某个事物在整个解决问题的步骤中的行为 面向过程和面向对象区别 # 面向过程就是步骤，就是解决问题按部就班 面向对象关注的解决问题所需要的对象 面向过程就是自己办事，面向对象就是托人办事 现实世界的面向对象 # 类和对象：\n类(class)是抽象的 对象(object)是具体的 汽车类(class) –new–\u0026gt;实例(instance)\nJava的类和对象 # Java的类 # 类可以看作是一个模板 用于描述一类对象的行为和状态 Java的类的描述 # public class Person { // 姓名 String name; // 年龄 int age; // 身高 int height; // 唱歌 void sing() { } // 跳舞 void dance() { } } Java的对象 # 万物皆对象 对象是具体的物体 拥有属性 拥有行为 把很多零散的构建成一个整体 具有唯一性 类和创建对象 # public class Person { // 姓名 String name; // 年龄 int age; // 身高 int height; public static void main(String[] args) { Person p = new Person(); p.","title":"Java 面向对象之类和对象 笔记"},{"content":"友情连接 # 经常会用到的一些连接和一些可爱的小伙伴们，嘤嘤嘤~\n小伙伴们 # 生化环材 (shhc.tech)\nviolet-233の博客\n风不及你甜 - 迷迷糊糊才是真 (wdraemv.github.io)\nsp4z\u0026rsquo;s Blog (sp4zcmd.github.io)\nmisc大佬\n学习网站 # 哔哩哔哩 (゜-゜)つロ 干杯~-bilibili\nGitHub\n","date":"January 29, 2022","permalink":"/link/","section":"OPdbg","summary":"友情连接 # 经常会用到的一些连接和一些可爱的小伙伴们，嘤嘤嘤~\n小伙伴们 # 生化环材 (shhc.tech)\nviolet-233の博客\n风不及你甜 - 迷迷糊糊才是真 (wdraemv.github.io)\nsp4z\u0026rsquo;s Blog (sp4zcmd.github.io)\nmisc大佬\n学习网站 # 哔哩哔哩 (゜-゜)つロ 干杯~-bilibili\nGitHub","title":"Link"},{"content":"Java基础语法 # 概述 # JVM\nJVM：Java虚拟机，简称JVM Java程序的跨平台性的核心是JVM JRE和JDK\nJRE：Java程序运行环境 JDK：Java程序开发工具包 安装 # Java官方网站：http://oracle.com\nJava JDK SE8\n环境变量：Java_Home\n%Java_Home% /bin\nbin目录：\njava.exe\njavac.exe\n第一个Java程序 # Java是纯面向对象高级编程语言\n开发步骤\n定义类 class public classclass名与源文件名一致，且一个文件只能有一个 主方法 main 入口函数 系统输出：编译 public class HelloWorld { /** * public class：公共类名，一个文件只有一个 * 类名：HelloWorld 与文件名一致 */ public static void main(String[] args) { /** * static：静态 * void：返回值的类型 * main：方法名，严格定义 * String：字符串 * []：数组 * args：参数名 */ Syetem.out.print(\u0026#34;1.Hello World!\u0026#34;); // 不换行输出 System.out.println(\u0026#34;2.Hello World\u0026#34;); // 换行输出 } } 编码规范 # 标识符 # 标识符：字符序列\n标识符规范：\n命名规范 # 类、接口\n单个单词：小驼峰命名 Hello\n多个单词：大驼峰命名 HelloWorld\n变量、方法\n单个单词：全小写 check()\n多个单词：首单词全小写，后面每个单词首字母大写 checkUserName()\n常量\n单个单词：全大写 NUMBER\n多个单词：全大写中间下划线 MAX_VALUE\n注释 # 注释：不进行编译处理 可读性\n类型：\n单行注释\n// 单行注释 可嵌套 多行注释（区块注释）\n/* 多行注释 不可嵌套 */ 文档注释 javadoc\n/** * 文档注释 Javadoc生成文档 */ javadoc 用法：\njavadoc [options] [packagenames] [sourcefiles] 数据类型和变量 # 变量 # 存储程序的数据 -\u0026gt; 申请存储空间 -\u0026gt; 变量\n比喻 概念 房间 变量 房间名 变量名 房间类型 变量类型 入住的客人 变量值 使用步骤 # 声明变量，即根据数据类型在内存申请空间\n// 数据类型 变量名; int age; 赋值，即将数据存储至对应的内存空间\n// 变量名 = 数值; age = 20 使用变量\n1 和 2 可进行合并\n变量名：标识符 -\u0026gt; 遵循规范\n变量类型 # 局部：某方法或代码块 全局：类的属性 静态：static修饰，整个类成员共享 作用域：全局 局部\n数据类型 # 数据类型 –\u0026gt; 分类数据\n基本数据类型 # 整型\n整型 bit 范围 byte 8 -128~127 short 16 -32768~32767 int 32 -2^31^ ~ 2^31^-1 long 64 -2^63^ ~ 2^63^-1 整型数据存在有符号为类进行补码：\nbit 符号 0 正数 1 负数 浮点型\n浮点型 bit float 32 double（默认类型） 64 float a = 3.14f; double b = 3.14; 布尔类型\n只有两个值 true和false\nboolean flag1 = true; boolean flag2 = false; if (flag1) { System.out.println(\u0026#34;flag1 is true\u0026#34;); } else if(flag2) { System.out.println(\u0026#34;flag2 is true\u0026#34;); } 字符型\n编码：二进制类型映射到字符\n编码表：如何编码字符\nASCII码：编码美国字符（8位） 7位二进制 剩下一位为0\nUnicode码：万国码（16位） 65536个字符\nchar 2字节 [0, 65536]\nchar c = \u0026#34;中\u0026#34; ; int i = c; // 数据类型自动转换 char c = 20013; 数据类型转换 # 大范围 -\u0026gt; 小范围 强制转换\n小范围 -\u0026gt; 大范围 自动转换\n强制转换语法：\n// 目标数据类型 变量名 = （目标数据类型）值/变量 int c = 5; short s = (short) c; 引用类型 # 在C和C++通过指针操作内存中的元素，Java使用“引用”，java中一切都被视为对象\n引用数据类型：\n数组 接口 对象 引用类型在内存中的存储方式：\n引用类型==比的是值，即内存地址\nString s1 = new String(\u0026#34;abc\u0026#34;); String s2 = new String(\u0026#34;abc\u0026#34;); System.out.println(s1 == s2); 运行结果：\nfalse 运算符 # 简介：对常量或变量进行操作的符号\n表达式：运算符和操作数的组合 $$ \\begin{equation} \\underbrace{Y = X * \\overbrace{(2+10)}^{子表达式}}_{表达式} \\end{equation} $$ 分类：\n赋值运算符 # 自右向左运行\nint a,b,c; a = b = c = 1; 算术运算符 # int a = 5; int b = 2; double c = 4.00; double m = 20.00; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b); // 值为 int System.out.println(a%b); System.out.println(a/c); // 值为 float System.out.println(m/b); // 值为 float 复合运算符：赋值运算符+算术运算符 （自左向右） 效率高于算术运算符\nint a = 1; a += 2; a -= 1; a *= 10; a /= 2; a %= 26; a += a += 6 // 等价于 a = a+(a+6) 自增/自减运算\n前缀运算“先运算后使用”\nint a = 5; int b = ++a; System.out.println(\u0026#34;a=\u0026#34;+a); System.out.println(\u0026#34;b=\u0026#34;+b); 后缀运算“先使用后运算”\nint a = 5; int b = a++; System.out.println(\u0026#34;a=\u0026#34;+a); System.out.println(\u0026#34;b=\u0026#34;+b); 关系运算符 # 运算结果为boolean类型 true或false\nint a = 10; int b = 15; System.out.println(a \u0026gt;= b); System.out.println(a \u0026lt;= b); System.out.println(a == b); // 引用类型不能使用 == 进行比较 System.out.println(a \u0026gt; b); System.out.println(a \u0026lt; b); 逻辑运算符 # 逻辑运算符也叫短路运算符 -\u0026gt; 复杂的逻辑表达式 -\u0026gt; boolean类型\nboolean a = true; boolean b = false; a \u0026amp;\u0026amp; b; // false a || b; // true !a; // false 三目运算符 # 语法：布尔表达式？表达式1：表达式2\ninstanceof运算符 # 判断类的实例是否属于该类\n引用实例-\u0026gt; 属于instanceof -\u0026gt; 引用数据类型\n位运算符 # C语言的低级操作 -\u0026gt; 操作二进制位\n位操作符 含义 说明 \u0026amp; 与 | 或 ^ 异或 \u0026laquo; 左移 高位丢弃，低位补0 \u0026raquo; 右移 低位丢弃，高位补1或0，根据计算结果 \u0026raquo;\u0026gt; 无符号右移 忽略符号位，高位补0 运算符优先级：\n顺序 运算符 1 () [] 2 ++ -- ! 3 * / % + - 4 \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= == != 5 \u0026amp;\u0026amp; ` 6 ?: = *= /= += -= 逻辑流程控制语句 # main函数和顺序结构 # 默认运行 public class -\u0026gt; main (可以传入参数)\npublic static void main(String[] args){} 顺序结构 自上而下运行\n选择结构 # if语句：\n// if形式 if(expr) { code block } // if-else形式 if(expr) { code block 1 }else { code block 2 } // if-else if-else形式 多条件分支 if(expr1) { code block 1 } else if(expr2) { code block 2 } else { code block 3 } switch语句：\nswitch(expr){ case value1: codeBlock1; break; case value2: codeBlock2; break; default:codeBlockn; } JDK 1.5 以前 expr: byte short int char\nJDK 1.5 支持 enmu\nJDK 1.7 支持 String\nif条件分支 可以进行嵌套，灵活性更高\nswitch-case条件分支 不能嵌套：\n效率更高 批处理 可读性更高 循环结构 # while循环结构：\nwhile(expr){ Loop body } do-while循环结构：\ndo { Loop body }while(expr) for循环结构：\n循环最清晰，for循环，预定次数执行语句\nint result = 0; for(int i = 1;i\u0026lt;=100;i++) { result += i; } System.out.println(result); for(;;) { //死循环 for三个语句都去掉依然可以执行 } 循环控制 # break 结束当前循环，语句块\ncontinue 结束本次循环，进入下次循环\nreturn 方法的结束，返回指定类型的值，也可以是对象\nreturn; // 无 void return i; // 有 循环嵌套 # for(int i=1;i\u0026lt;=9;i++) { for(int j=1;j\u0026lt;=i;j++) { System.out.print(j+\u0026#34;*\u0026#34;+i+\u0026#34;=\u0026#34;+(j*i)+\u0026#34; \u0026#34;); } System.out.println(); } ","date":"January 29, 2022","permalink":"/posts/java-basic/","section":"Posts","summary":"Java基础语法 # 概述 # JVM\nJVM：Java虚拟机，简称JVM Java程序的跨平台性的核心是JVM JRE和JDK\nJRE：Java程序运行环境 JDK：Java程序开发工具包 安装 # Java官方网站：http://oracle.com\nJava JDK SE8\n环境变量：Java_Home\n%Java_Home% /bin\nbin目录：\njava.exe\njavac.exe\n第一个Java程序 # Java是纯面向对象高级编程语言\n开发步骤\n定义类 class public classclass名与源文件名一致，且一个文件只能有一个 主方法 main 入口函数 系统输出：编译 public class HelloWorld { /** * public class：公共类名，一个文件只有一个 * 类名：HelloWorld 与文件名一致 */ public static void main(String[] args) { /** * static：静态 * void：返回值的类型 * main：方法名，严格定义 * String：字符串 * []：数组 * args：参数名 */ Syetem.out.print(\u0026#34;1.Hello World!\u0026#34;); // 不换行输出 System.","title":"Java基础语法 笔记"},{"content":"","date":"January 29, 2022","permalink":"/tags/crypto/","section":"Tags","summary":"","title":"crypto"},{"content":"","date":"January 29, 2022","permalink":"/categories/wiki/","section":"Categories","summary":"","title":"wiki"},{"content":"编码 # 编码是将信息从一种形式转换位另一种形式的过程。它用预先规定的方法将文字、数字或其他对象编成数码，或者将信息、数据转换成规定的电脉冲信号。编码被广泛应用于电子计算机、电视、遥控和通信等方面。解码是编码的逆过程。\n编码和解码是个相当广泛的话题，涉及计算机对信息处理的根本方式。编码的目的不是为了让别人看到后解不出来，而是代表信息的另一种表达方式。将原始信息转化为编码信息进行传输，可以解决一些特殊字符、不可见字符的传输问题。接收者将编码信息再转化成原始信息，转化的过程称之为解码。\n历史 # 编码的演变源于人对计算机需求的改变。\n编码的萌芽——控制码 ASCII码的出现 ASCII码的发展——扩展字符集 编码的中国化——GBK家族 编码的国家化——百家争鸣的编码时代 编码的国际化——Unicode编码 编码的互联网化——UTF家族 从本质上讲，编码/解码是在做将一种形式的数据翻译为另一种形式的数据的工作。\n编码类型 # ASCII码 # ASCII码是最常见的编码类型。ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符。\nASCII码现在也经常出现在计算编码运输过程中，进行编码，而且在很多编程语言中也经常有用到。\nBin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释 0000 0000 00 0 0x00 NUL(null) 空字符 0000 0001 01 1 0x01 SOH(start of headline) 标题开始 0000 0010 02 2 0x02 STX (start of text) 正文开始 0000 0011 03 3 0x03 ETX (end of text) 正文结束 0000 0100 04 4 0x04 EOT (end of transmission) 传输结束 0000 0101 05 5 0x05 ENQ (enquiry) 请求 0000 0110 06 6 0x06 ACK (acknowledge) 收到通知 0000 0111 07 7 0x07 BEL (bell) 响铃 0000 1000 010 8 0x08 BS (backspace) 退格 0000 1001 011 9 0x09 HT (horizontal tab) 水平制表符 0000 1010 012 10 0x0A LF (NL line feed, new line) 换行键 0000 1011 013 11 0x0B VT (vertical tab) 垂直制表符 0000 1100 014 12 0x0C FF (NP form feed, new page) 换页键 0000 1101 015 13 0x0D CR (carriage return) 回车键 0000 1110 016 14 0x0E SO (shift out) 不用切换 0000 1111 017 15 0x0F SI (shift in) 启用切换 0001 0000 020 16 0x10 DLE (data link escape) 数据链路转义 0001 0001 021 17 0x11 DC1 (device control 1) 设备控制1 0001 0010 022 18 0x12 DC2 (device control 2) 设备控制2 0001 0011 023 19 0x13 DC3 (device control 3) 设备控制3 0001 0100 024 20 0x14 DC4 (device control 4) 设备控制4 0001 0101 025 21 0x15 NAK (negative acknowledge) 拒绝接收 0001 0110 026 22 0x16 SYN (synchronous idle) 同步空闲 0001 0111 027 23 0x17 ETB (end of trans. block) 结束传输块 0001 1000 030 24 0x18 CAN (cancel) 取消 0001 1001 031 25 0x19 EM (end of medium) 媒介结束 0001 1010 032 26 0x1A SUB (substitute) 代替 0001 1011 033 27 0x1B ESC (escape) 换码(溢出) 0001 1100 034 28 0x1C FS (file separator) 文件分隔符 0001 1101 035 29 0x1D GS (group separator) 分组符 0001 1110 036 30 0x1E RS (record separator) 记录分隔符 0001 1111 037 31 0x1F US (unit separator) 单元分隔符 0010 0000 040 32 0x20 (space) 空格 0010 0001 041 33 0x21 ! 叹号 0010 0010 042 34 0x22 \u0026quot; 双引号 0010 0011 043 35 0x23 # 井号 0010 0100 044 36 0x24 $ 美元符 0010 0101 045 37 0x25 % 百分号 0010 0110 046 38 0x26 \u0026amp; 和号 0010 0111 047 39 0x27 ' 闭单引号 0010 1000 050 40 0x28 ( 开括号 0010 1001 051 41 0x29 ) 闭括号 0010 1010 052 42 0x2A * 星号 0010 1011 053 43 0x2B + 加号 0010 1100 054 44 0x2C , 逗号 0010 1101 055 45 0x2D - 减号/破折号 0010 1110 056 46 0x2E . 句号 0010 1111 057 47 0x2F / 斜杠 0011 0000 060 48 0x30 0 字符0 0011 0001 061 49 0x31 1 字符1 0011 0010 062 50 0x32 2 字符2 0011 0011 063 51 0x33 3 字符3 0011 0100 064 52 0x34 4 字符4 0011 0101 065 53 0x35 5 字符5 0011 0110 066 54 0x36 6 字符6 0011 0111 067 55 0x37 7 字符7 0011 1000 070 56 0x38 8 字符8 0011 1001 071 57 0x39 9 字符9 0011 1010 072 58 0x3A : 冒号 0011 1011 073 59 0x3B ; 分号 0011 1100 074 60 0x3C \u0026lt; 小于 0011 1101 075 61 0x3D = 等号 0011 1110 076 62 0x3E \u0026gt; 大于 0011 1111 077 63 0x3F ? 问号 0100 0000 0100 64 0x40 @ 电子邮件符号 0100 0001 0101 65 0x41 A 大写字母A 0100 0010 0102 66 0x42 B 大写字母B 0100 0011 0103 67 0x43 C 大写字母C 0100 0100 0104 68 0x44 D 大写字母D 0100 0101 0105 69 0x45 E 大写字母E 0100 0110 0106 70 0x46 F 大写字母F 0100 0111 0107 71 0x47 G 大写字母G 0100 1000 0110 72 0x48 H 大写字母H 0100 1001 0111 73 0x49 I 大写字母I 01001010 0112 74 0x4A J 大写字母J 0100 1011 0113 75 0x4B K 大写字母K 0100 1100 0114 76 0x4C L 大写字母L 0100 1101 0115 77 0x4D M 大写字母M 0100 1110 0116 78 0x4E N 大写字母N 0100 1111 0117 79 0x4F O 大写字母O 0101 0000 0120 80 0x50 P 大写字母P 0101 0001 0121 81 0x51 Q 大写字母Q 0101 0010 0122 82 0x52 R 大写字母R 0101 0011 0123 83 0x53 S 大写字母S 0101 0100 0124 84 0x54 T 大写字母T 0101 0101 0125 85 0x55 U 大写字母U 0101 0110 0126 86 0x56 V 大写字母V 0101 0111 0127 87 0x57 W 大写字母W 0101 1000 0130 88 0x58 X 大写字母X 0101 1001 0131 89 0x59 Y 大写字母Y 0101 1010 0132 90 0x5A Z 大写字母Z 0101 1011 0133 91 0x5B [ 开方括号 0101 1100 0134 92 0x5C \\ 反斜杠 0101 1101 0135 93 0x5D ] 闭方括号 0101 1110 0136 94 0x5E ^ 脱字符 0101 1111 0137 95 0x5F _ 下划线 0110 0000 0140 96 0x60 ` 开单引号 0110 0001 0141 97 0x61 a 小写字母a 0110 0010 0142 98 0x62 b 小写字母b 0110 0011 0143 99 0x63 c 小写字母c 0110 0100 0144 100 0x64 d 小写字母d 0110 0101 0145 101 0x65 e 小写字母e 0110 0110 0146 102 0x66 f 小写字母f 0110 0111 0147 103 0x67 g 小写字母g 0110 1000 0150 104 0x68 h 小写字母h 0110 1001 0151 105 0x69 i 小写字母i 0110 1010 0152 106 0x6A j 小写字母j 0110 1011 0153 107 0x6B k 小写字母k 0110 1100 0154 108 0x6C l 小写字母l 0110 1101 0155 109 0x6D m 小写字母m 0110 1110 0156 110 0x6E n 小写字母n 0110 1111 0157 111 0x6F o 小写字母o 0111 0000 0160 112 0x70 p 小写字母p 0111 0001 0161 113 0x71 q 小写字母q 0111 0010 0162 114 0x72 r 小写字母r 0111 0011 0163 115 0x73 s 小写字母s 0111 0100 0164 116 0x74 t 小写字母t 0111 0101 0165 117 0x75 u 小写字母u 0111 0110 0166 118 0x76 v 小写字母v 0111 0111 0167 119 0x77 w 小写字母w 0111 1000 0170 120 0x78 x 小写字母x 0111 1001 0171 121 0x79 y 小写字母y 0111 1010 0172 122 0x7A z 小写字母z 0111 1011 0173 123 0x7B { 开花括号 0111 1100 0174 124 0x7C | 垂线 0111 1101 0175 125 0x7D } 闭花括号 0111 1110 0176 126 0x7E ~ 波浪号 0111 1111 0177 127 0x7F DEL (delete) 删除 hex编码 # hex是最常用的编码方式之一，这一点非常容易理解，就是将信息转化为十六进制。要进行各类编码的转化，或者是要将信息在计算机存储中最为本质的一面表现出来的时候，都可以使用hex编码方式。Hex编码就是把一个8位的字节数据用两个十六进制数展示出来，编码时，将8位二进制码重新分组成两个4位的字节，其中一个字节的低4位是原字节的高四位，另一个字节的低4位是原数据的低4位，高4位都补0，然后输出这两个字节对应十六进制数字作为编码。Hex编码后的长度是源数据的2倍。\nBase家族 # Base家族，最著名的就是Base64编码，在计算机的数据传输过程中也经常用到，Base64编码在RSA签名算法也都有用到，是一种比较基础的编码方式。Base家族的编码实质上就是进制的转换。\nBase编码是怎么来的呢？\n1970~1980 年代，DEC（和其他公司）生产的“微型计算机”使用的字符编码为 ASCII。 每个字节使用 7 位，给出 128 个可用值。 这足以满足大写和小写拉丁字母，数字，标点，一些常见的数学符号，货币符号和控制字符的需要。此后 ASCII 变得非常流行，并在很长一段时间内占主导地位。ASCII 规定了范围在 [0,127] 之间的字符编码，其中 [0, 31] 以及 127 (del) 这 33 个属于不可打印的控制字符（可以使用 man ascii 查证）。互联网的杀手级应用——电子邮件系统当初是为了传输 7 位 ASCII 文本而设计的，于是在传输信息时，有些邮件网关会把 [0,31] 这些控制字符给清除，而有些会替换 10 (newline 或 \\n）和 13 (carrige 或 \\r) 字符，有些更加粗暴地将二进制的最高位清空，还有的程序在收到 [128, 255 ] 之间的国际字符会发生错误。\n如何在不同邮件网关之间安全地传输控制字符、国际字符和二进制文件呢？作为 MIME（RFC 2045 和 RFC 3548）多媒体电子邮件标准的一部分的 Base64 编码就被开发出来了。\nBase64 用于编码邮件内容、网页图片，意在减少传输过程中可能出现的错误；Base58 是比特币地址使用的编码方法，旨在提高地址的辨识度；Base32 用在一些对大小写不敏感的文件系统中。每种 Base-x 的编码都有适合它们的应用场景。\nBase编码从底层来说就是对数据进行进制转换，Base64是64进制，Base32是32进制，Base16是16进制。而中间的过程是为了更好地进行传输数据。\nURL编码 # url编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值 ，将它们以name/value参数编码（移去那些不能传送的字符，将数据排行等等）作为URL的一部分或者分离地发给服务器。\nURL编码是比较常见的编码类型，在浏览器进行数据传输的过程中会经常使用到，可以用于构造反序列化对象、SQL注入绕过、文件包含绕过等等。\nURL编码参考手册：\nASCII 字符 URL-编码 space %20 ! %21 \u0026quot; %22 # %23 $ %24 % %25 \u0026amp; %26 ' %27 ( %28 ) %29 * %2A + %2B , %2C - %2D . %2E / %2F 0 %30 1 %31 2 %32 3 %33 4 %34 5 %35 6 %36 7 %37 8 %38 9 %39 : %3A ; %3B \u0026lt; %3C = %3D \u0026gt; %3E ? %3F @ %40 A %41 B %42 C %43 D %44 E %45 F %46 G %47 H %48 I %49 J %4A K %4B L %4C M %4D N %4E O %4F P %50 Q %51 R %52 S %53 T %54 U %55 V %56 W %57 X %58 Y %59 Z %5A [ %5B \\ %5C ] %5D ^ %5E _ %5F ` %60 a %61 b %62 c %63 d %64 e %65 f %66 g %67 h %68 i %69 j %6A k %6B l %6C m %6D n %6E o %6F p %70 q %71 r %72 s %73 t %74 u %75 v %76 w %77 x %78 y %79 z %7A { %7B | %7C } %7D ~ %7E %7F ` %80  %81 ‚ %82 ƒ %83 „ %84 … %85 † %86 ‡ %87 ˆ %88 ‰ %89 Š %8A ‹ %8B Œ %8C  %8D Ž %8E  %8F  %90 ' %91 ' %92 \u0026quot; %93 \u0026quot; %94 • %95 – %96 — %97 ˜ %98 ™ %99 š %9A › %9B œ %9C  %9D ž %9E Ÿ %9F %A0 ¡ %A1 ¢ %A2 £ %A3 ¤ %A4 ¥ %A5 ¦ %A6 § %A7 ¨ %A8 © %A9 ª %AA « %AB ¬ %AC ­ %AD ® %AE ¯ %AF ° %B0 ± %B1 ² %B2 ³ %B3 ´ %B4 µ %B5 ¶ %B6 · %B7 ¸ %B8 ¹ %B9 º %BA » %BB ¼ %BC ½ %BD ¾ %BE ¿ %BF À %C0 Á %C1 Â %C2 Ã %C3 Ä %C4 Å %C5 Æ %C6 Ç %C7 È %C8 É %C9 Ê %CA Ë %CB Ì %CC Í %CD Î %CE Ï %CF Ð %D0 Ñ %D1 Ò %D2 Ó %D3 Ô %D4 Õ %D5 Ö %D6 × %D7 Ø %D8 Ù %D9 Ú %DA Û %DB Ü %DC Ý %DD Þ %DE ß %DF à %E0 á %E1 â %E2 ã %E3 ä %E4 å %E5 æ %E6 ç %E7 è %E8 é %E9 ê %EA ë %EB ì %EC í %ED î %EE ï %EF ð %F0 ñ %F1 ò %F2 ó %F3 ô %F4 õ %F5 ö %F6 ÷ %F7 ø %F8 ù %F9 ú %FA û %FB ü %FC ý %FD þ %FE ÿ %FF HTML编码 # HTML编码在HTML文件中经常会使用到，在信息传输过程中并不是非常常见。HTML编码也叫HTML字符实体。是HTML编写过程中使用特殊的编码符号来进行网页页面符号的正确显示，是网页上面的一种编码格式。\nHTML 实体是一段以连字号（\u0026amp;）开头、以分号（;）结尾的文本（字符串）。实体常常用于显示保留字符（这些字符会被解析为 HTML 代码）和不可见的字符（如“不换行空格”）。你也可以用实体来代替其他难以用标准键盘键入的字符。\n很多字符都有易于记忆的实体。例如版权符号 (©) 的实体是 ©。对于没那么容易记住的字符，例如 — 或 —，你可以查看 参考表 或使用 解码工具 。\n显示结果 描述 实体名称 实体编号 空格 \u0026amp;nbsp; \u0026lt; 小于号 \u0026amp;lt; \u0026amp;#60; \u0026gt; 大于号 \u0026amp;gt; \u0026amp;#62; \u0026amp; 和号 \u0026amp;amp; \u0026amp;#38; \u0026quot; 引号 \u0026amp;quot; \u0026amp;#34; ' 撇号 \u0026amp;apos; (IE不支持) \u0026amp;#39; ￠ 分（cent） \u0026amp;cent; \u0026amp;#162; £ 镑（pound） \u0026amp;pound; \u0026amp;#163; ¥ 元（yen） \u0026amp;yen; \u0026amp;#165; € 欧元（euro） \u0026amp;euro; \u0026amp;#8364; § 小节 \u0026amp;sect; \u0026amp;#167; © 版权（copyright） \u0026amp;copy; \u0026amp;#169; ® 注册商标 \u0026amp;reg; \u0026amp;#174; ™ 商标 \u0026amp;trade; \u0026amp;#8482; × 乘号 \u0026amp;times; \u0026amp;#215; ÷ 除号 \u0026amp;divide; \u0026amp;#247; Unicode编码 # Unicode 是一种字符集标准，用于对来自世界上不同语言、文字系统和符号进行编号和字符定义。通过给每个字符分配一个编号，程序员可以创建字符编码，让计算机在同一个文件或程序中存储、处理和传输任何语言组合。\n在 Unicode 定义之前，在同一数据中混合使用不同的语言是很困难的，而且容易出错。例如，一个字符集存储的是日文字符，而另一个字符集存储的是阿拉伯字母。如果没有明确标明数据的哪些部分属于哪个字符集，其他程序和计算机就会错误地显示文本，或者在处理过程中损坏文本。如果你曾经见过像 (“”) 被替换为胡言乱语 Ã‚Â£，那么你就已经看到过这个被称为 Mojibake 的问题。\n网络上最常见的 Unicode 字符编码是UTF-8。还存在一些其他编码，如 UTF-16或过时的 UCS-2，但推荐使用 UTF-8。\nUnicode编码也被称为万国码，是比较常见的编码格式，在计算机中经常会使用到Unicode编码进行互联网上应用的传输和编写。\nMorse电码 # Morse电码也叫Morsecode，是大家耳熟能详的编码方式，很多人都误认为它是一种加密方式，但其实它是一种编码，因为它并不存在密钥。\nMorsecode的编码形式非常容易识别，就是.--- .-.--等类似的形式，非常容易识别并进行解码。\nJSFuck # jsfuck是一种非常有意思的编码方式，仅使用6个字符就可以书写任意的JavaScript代码。从直观上非常容易辨别出这种编码方式，只需要“()+[]!”这6个字符组成的字符串。jsfuck的编码和解码与morsecode类似，只不过其表示的是JavaScript的语句。jsfuck源于一门编程语言brainfuck，其主要的思想就是只使用8种特定的符号来编写代码。jsfuck也是沿用了这个思想，它仅仅使用6种符号来编写代码。它们分别是()+[]!\nJSFuck可以使用jsfuck官方的网站进行解密：[JSFuck - Write any JavaScript with 6 Characters: !+](http://www.jsfuck.com/)\n比如：\nalert(1) 就可以被jsfuck编码为：\n[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+[+!+[]]+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]]) Quoted-Printable编码 # Quoted-printable 可译为“可打印字符引用编码”、“使用可打印字符的编码”，我们收邮件，查看信件原始信息，经常会看到这种类型的编码！\nQuoted-printable或QP encoding，没有规范的中文译名，可译为可打印字符引用编码或使用可打印字符的编码。Quoted-printable是使用可打印的ASCII字符（如字母、数字与“=”）表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。QP使用“=”开头的转义字符. 一般限制行宽为76，因为有些软件限制了行宽.\nMIME定义了在e-mail中发送各种信息的方法, 包括非英语的其它语言文本信息, 使用非ASCII的其它字符编码。这些编码常常使用ASCII范围以外的值来编码字符，因此需要进一步被编码以便适用于non-8-bit-clean环境。Quoted-printable编码就是把任意字节序列映射为ASCII字符序列。Quoted-printable自身并不是一种字符编码方案, 而是一种在面向字节的编码时的数据编码布置（data coding layer），即由编码的字符序列如何表示为字节流QP是可逆的，即可以由原来的非ASCII字符流与QP编码后的字节流来回转换而不失信息。\nQuoted-printable与Base64是两种基本的MIME内容传输编码, 如果通常的“8bit”编码不适用。如果文本不含很多非ASCII字符，quoted-printable编码的结果的可读性相当好[注 2]而且紧凑。但是，如果输入的大多数是非ASCII字符，那么quoted-printable编码将变得既不可读又非常低效。Base64并不是人可读的，但对于所有数据其成本均匀，适用于二进制数据与非拉丁字母语言文本。\n比如：\n密码学 可以使用Quoted-printable编码为：\n=E5=AF=86=E7=A0=81=E5=AD=A6=0A=09=09=09=09=09 Quoted-printable的编码形式也比较容易辨认，基本上就是字符加等于号构成编码文段格式。\nBrainFuck编码 # BrainFuck是一种编程语言，也可以作为一种编码的手段进行编码，对文本进行BrainFuck编码然后进行快速传输。\nBrainfuck，是一种极小化的程序语言，它是由Urban Müller在1993年创造的。由于fuck在英语中是脏话，这种语言有时被称为Brainf*ck或Brainf***，或被简称为BF。\nMüller的目标是创建一种简单的、可以用最小的编译器来实现的、符合图灵完全思想的编程语言。这种语言由八种运算符构成，为Amiga机器编写的编译器（第二版）只有240个字节大小。就像它的名字所暗示的，Brainfuck程序很难读懂。尽管如此，Brainfuck图灵机一样可以完成任何计算任务。虽然Brainfuck的计算方式如此与众不同，但它确实能够正确运行。这种语言基于一个简单的机器模型，除了指令，这个机器还包括：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针（初始时指向数组的第一个字节）、以及用于输入输出的两个字节流。\n比如：\nHello world! 使用BrainFuck进行编码就会得到\n+++++ +++[- \u0026gt;++++ ++++\u0026lt; ]\u0026gt;+++ +++++ .\u0026lt;+++ ++[-\u0026gt; +++++ \u0026lt;]\u0026gt;++ ++.++ +++++ ..+++ .\u0026lt;+++ +++++ [-\u0026gt;-- ----- -\u0026lt;]\u0026gt;- ----- ----- ----. \u0026lt;++++ +++[- \u0026gt;++++ +++\u0026lt;] \u0026gt;++++ ++.\u0026lt;+ +++[- \u0026gt;++++ \u0026lt;]\u0026gt;++ +++++ +.+++ .---- --.-- ----- -.\u0026lt;++ +++++ +[-\u0026gt;- ----- --\u0026lt;]\u0026gt; ---.\u0026lt; 可以使用Brainfuck/Ook! Obfuscation/Encoding 这个网站进行编码和解码\nOok编码 # Ook也是一种小型的编程语言，Ook是为红毛猩猩设计的编程语言，设计思路和BrainFuck的设计思路基本类似，但是Ook采用了更少的元素进行编程，语句更加简单。由于Ook的特点，因此Ook也可以设计为一种特殊的编码方式。\n比如：\nHello world! 使用Ook编码后，得到\nOok. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. 非常长，进行Ook编码和解码的网站也是Brainfuck/Ook! Obfuscation/Encoding\nUUencode编码 # 一种逐渐退出历史舞台的编码方式，编码的文段中有许多特殊的字符。\nuuencode这个名字是衍生自\u0026quot;Unix-to-Unix encoding\u0026quot;，原先是Unix系统下将二进制的资料借由uucp邮件系统传输的一个编码程式，是一种二进制到文字的编码。uudecode是与uuencode搭配的解码程式，uuencode/decode常见于电子邮件中的档案传送以及usenet新闻组和BBS的贴文等等。近来已被MIME所大量取代。\nUUencode的编码原理和Base64的编码原理非常相似。\n比如：\nHello World! 进行编码后得到：\n,2\u0026amp;5L;\u0026amp;\\@5V]R;\u0026amp;0A XXencode编码 # XXencode编码和base64编码类似，只不过是使用的转换表不同。\nXxencode编码，也是一个二进制字符转换为普通打印字符方法。跟UUencode编码原理方法很相似，唯独不同的是可打印字符不同。通个UUencode编码，我们知道它有个缺点就是，64个可打印字符中，有很多的特殊字符。而XXencode编码方法，对64个原字符有做规范。这里它有跟Base64类型了。都有指定可打印字符范围、及编号。Xxencode编码在上世纪后期，IBM大型机中得到很广泛的应用。现在逐渐被Base64编码转换方法所取代了。\n比如：\nHello World! 进行XXencode编码后，得到\nBG4JgP4wUJqxmP4EV0U++ JJencode编码 # 算是JSFuck编码的前身，是由18种字符组成的编码格式。是针对JavaScript进行设计的编码方式。\n长谷川阳介（Yosuke Hasegawa）于2009年7月创建了一个名为“jjencode”的网络应用程序，可将一切的JavaScript代码混淆为!+,\u0026quot;$.:;_{}~=这十八个字符的排列组合。\n比如：\nalert(\u0026#34;Hello, JavaScript\u0026#34; ) 进行jjencode编码，得到\n$=~[];$={___:++$,$$$$:(![]+\u0026#34;\u0026#34;)[$],__$:++$,$_$_:(![]+\u0026#34;\u0026#34;)[$],_$_:++$,$_$$:({}+\u0026#34;\u0026#34;)[$],$$_$:($[$]+\u0026#34;\u0026#34;)[$],_$$:++$,$$$_:(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$],$__:++$,$_$:++$,$$__:({}+\u0026#34;\u0026#34;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+\u0026#34;\u0026#34;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+\u0026#34;\u0026#34;)[$.__$])+((!$)+\u0026#34;\u0026#34;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$.__$])+($._=(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+\u0026#34;\\\u0026#34;\u0026#34;+$.$_$_+(![]+\u0026#34;\u0026#34;)[$._$_]+$.$$$_+\u0026#34;\\\\\u0026#34;+$.__$+$.$$_+$._$_+$.__+\u0026#34;(\\\\\\\u0026#34;\\\\\u0026#34;+$.__$+$.__$+$.___+$.$$$_+(![]+\u0026#34;\u0026#34;)[$._$_]+(![]+\u0026#34;\u0026#34;)[$._$_]+$._$+\u0026#34;,\\\\\u0026#34;+$.$__+$.___+\u0026#34;\\\\\u0026#34;+$.__$+$.__$+$._$_+$.$_$_+\u0026#34;\\\\\u0026#34;+$.__$+$.$$_+$.$$_+$.$_$_+\u0026#34;\\\\\u0026#34;+$.__$+$._$_+$._$$+$.$$__+\u0026#34;\\\\\u0026#34;+$.__$+$.$$_+$._$_+\u0026#34;\\\\\u0026#34;+$.__$+$.$_$+$.__$+\u0026#34;\\\\\u0026#34;+$.__$+$.$$_+$.___+$.__+\u0026#34;\\\\\\\u0026#34;\\\\\u0026#34;+$.$__+$.___+\u0026#34;)\u0026#34;+\u0026#34;\\\u0026#34;\u0026#34;)())(); AAencode编码 # aaencode编码是一个比较有意思的编码形式，同样也是对于JavaScript语言设计的编码方式，是把JavaScript的代码编码成日本的表情包。\n比如：\nalert(\u0026#34;Hello, JavaScript\u0026#34;) 通过aaencode编码，得到\nﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [\u0026#39;_\u0026#39;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: \u0026#39;_\u0026#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ \u0026#39;_\u0026#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [c^_^o];(ﾟДﾟ) [\u0026#39;c\u0026#39;] = ((ﾟДﾟ)+\u0026#39;_\u0026#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [\u0026#39;o\u0026#39;] = ((ﾟДﾟ)+\u0026#39;_\u0026#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [\u0026#39;c\u0026#39;]+(ﾟДﾟ) [\u0026#39;o\u0026#39;]+(ﾟωﾟﾉ +\u0026#39;_\u0026#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +\u0026#39;_\u0026#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [\u0026#39;c\u0026#39;]+((ﾟДﾟ)+\u0026#39;_\u0026#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [\u0026#39;o\u0026#39;]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ];(ﾟДﾟ) [\u0026#39;_\u0026#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+\u0026#39;_\u0026#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +\u0026#39;_\u0026#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=\u0026#39;\\\\\u0026#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +\u0026#39;_\u0026#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=\u0026#39;\\\u0026#34;\u0026#39;;(ﾟДﾟ) [\u0026#39;_\u0026#39;] ( (ﾟДﾟ) [\u0026#39;_\u0026#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (\u0026#39;_\u0026#39;); ","date":"January 29, 2022","permalink":"/posts/encode/","section":"Posts","summary":"编码 # 编码是将信息从一种形式转换位另一种形式的过程。它用预先规定的方法将文字、数字或其他对象编成数码，或者将信息、数据转换成规定的电脉冲信号。编码被广泛应用于电子计算机、电视、遥控和通信等方面。解码是编码的逆过程。\n编码和解码是个相当广泛的话题，涉及计算机对信息处理的根本方式。编码的目的不是为了让别人看到后解不出来，而是代表信息的另一种表达方式。将原始信息转化为编码信息进行传输，可以解决一些特殊字符、不可见字符的传输问题。接收者将编码信息再转化成原始信息，转化的过程称之为解码。\n历史 # 编码的演变源于人对计算机需求的改变。\n编码的萌芽——控制码 ASCII码的出现 ASCII码的发展——扩展字符集 编码的中国化——GBK家族 编码的国家化——百家争鸣的编码时代 编码的国际化——Unicode编码 编码的互联网化——UTF家族 从本质上讲，编码/解码是在做将一种形式的数据翻译为另一种形式的数据的工作。\n编码类型 # ASCII码 # ASCII码是最常见的编码类型。ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符。\nASCII码现在也经常出现在计算编码运输过程中，进行编码，而且在很多编程语言中也经常有用到。\nBin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释 0000 0000 00 0 0x00 NUL(null) 空字符 0000 0001 01 1 0x01 SOH(start of headline) 标题开始 0000 0010 02 2 0x02 STX (start of text) 正文开始 0000 0011 03 3 0x03 ETX (end of text) 正文结束 0000 0100 04 4 0x04 EOT (end of transmission) 传输结束 0000 0101 05 5 0x05 ENQ (enquiry) 请求 0000 0110 06 6 0x06 ACK (acknowledge) 收到通知 0000 0111 07 7 0x07 BEL (bell) 响铃 0000 1000 010 8 0x08 BS (backspace) 退格 0000 1001 011 9 0x09 HT (horizontal tab) 水平制表符 0000 1010 012 10 0x0A LF (NL line feed, new line) 换行键 0000 1011 013 11 0x0B VT (vertical tab) 垂直制表符 0000 1100 014 12 0x0C FF (NP form feed, new page) 换页键 0000 1101 015 13 0x0D CR (carriage return) 回车键 0000 1110 016 14 0x0E SO (shift out) 不用切换 0000 1111 017 15 0x0F SI (shift in) 启用切换 0001 0000 020 16 0x10 DLE (data link escape) 数据链路转义 0001 0001 021 17 0x11 DC1 (device control 1) 设备控制1 0001 0010 022 18 0x12 DC2 (device control 2) 设备控制2 0001 0011 023 19 0x13 DC3 (device control 3) 设备控制3 0001 0100 024 20 0x14 DC4 (device control 4) 设备控制4 0001 0101 025 21 0x15 NAK (negative acknowledge) 拒绝接收 0001 0110 026 22 0x16 SYN (synchronous idle) 同步空闲 0001 0111 027 23 0x17 ETB (end of trans.","title":"编码-编写你的快乐"},{"content":"现代密码 # 现代密码根据密钥的方式可以分为对称密码和非对称密码，这两类密码是现代密码的支柱，现代密码又可以根据加密的方式分为流密码和分组密码。流密码，分组密码在CTF中通常是以对称密码的方式进行而RSA、ECC、格密码通常是以非对称密码的方式进行。\n流密码 # 流密码一般逐字节或者逐比特处理信息。一般来说\n流密码的密钥长度会与明文的长度相同。 流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。 需要注意的是，流加密目前来说都是对称加密。\n伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。\n流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。\n流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。^1^\n分组密码 # 分组密码又叫块加密。所谓块加密就是每次加密一块明文，常见的加密算法有\nIDEA 加密 DES 加密 AES 加密 块加密也是对称加密。\n其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有 复杂 的加解密算法来加解密明密文。\n而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助\npadding，即 padding 到指定分组长度 分组加密模式，即明文分组加密的方式。 基本策略 # 在分组密码设计时，充分使用了Shannon提出的两大策略：混淆和扩散两大策略\n混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。\n扩散，Diffusion，使得明文中的每一位影响密文中的许多位。\n非对称密码 # 在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。\n非对称密码通常也被称为公钥密码\nDiffie和Hellman在1976年的论文《密码学的新方向》中提出了全新的密码思想，即一个密码体制中的加密密钥和解密密钥是保密的，且由公开的加密密钥难以推测出保密的解密密钥。这种密码体制称为公开密钥密码体制，也称为公钥密码体制。\n公钥密码体制的算法很多，所有的公钥密码算法都是基于某个困难的数学问题而产生的，其中，最受CTF青睐的就是RSA了。\n目前现代密码在CTF比赛出现比较频繁，现在CTF中主要考察的就是现代密码学的知识应用，和数学公式的理解。进行相应的密码学题目的求解。\n参考 # Introduction - CTF Wiki (ycdxsb.cn) ","date":"January 29, 2022","permalink":"/posts/modern_crypto/","section":"Posts","summary":"现代密码 # 现代密码根据密钥的方式可以分为对称密码和非对称密码，这两类密码是现代密码的支柱，现代密码又可以根据加密的方式分为流密码和分组密码。流密码，分组密码在CTF中通常是以对称密码的方式进行而RSA、ECC、格密码通常是以非对称密码的方式进行。\n流密码 # 流密码一般逐字节或者逐比特处理信息。一般来说\n流密码的密钥长度会与明文的长度相同。 流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。 需要注意的是，流加密目前来说都是对称加密。\n伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。\n流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。\n流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。^1^\n分组密码 # 分组密码又叫块加密。所谓块加密就是每次加密一块明文，常见的加密算法有\nIDEA 加密 DES 加密 AES 加密 块加密也是对称加密。\n其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有 复杂 的加解密算法来加解密明密文。\n而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助\npadding，即 padding 到指定分组长度 分组加密模式，即明文分组加密的方式。 基本策略 # 在分组密码设计时，充分使用了Shannon提出的两大策略：混淆和扩散两大策略\n混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。\n扩散，Diffusion，使得明文中的每一位影响密文中的许多位。\n非对称密码 # 在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。\n非对称密码通常也被称为公钥密码\nDiffie和Hellman在1976年的论文《密码学的新方向》中提出了全新的密码思想，即一个密码体制中的加密密钥和解密密钥是保密的，且由公开的加密密钥难以推测出保密的解密密钥。这种密码体制称为公开密钥密码体制，也称为公钥密码体制。\n公钥密码体制的算法很多，所有的公钥密码算法都是基于某个困难的数学问题而产生的，其中，最受CTF青睐的就是RSA了。\n目前现代密码在CTF比赛出现比较频繁，现在CTF中主要考察的就是现代密码学的知识应用，和数学公式的理解。进行相应的密码学题目的求解。\n参考 # Introduction - CTF Wiki (ycdxsb.cn) ","title":"现代密码-看尽如今的满目繁华"},{"content":"古典密码 # 密码和编码最大的区别就是密码多了一个很关键的信息：密钥。\n密码(Cryptology)是一种用来混淆的技术,它希望将正常的、可识别的信息转变为无法识别的信息。密码学是一个即古老又新兴的学科,密码学一词源自希腊文“krypto\u0026rsquo;s”及“logos”两字,直译即为“隐藏”及“讯息”之意。\n密码学是一门拥有几千年历史的学科。密码学的发展大概经历了三个阶段:古典密码阶段、近代密码阶段、现代密码阶段。下面我们一起了解古典密码阶段。\n古典密码阶段是指从密码的产生到发展成为近代密码之间的这段时期密码的发展历史。\n值得一提的是，在古典密码学中，设计者主要考虑消息的保密性，使得只有相关密钥的人才可以解密密文获得消息的内容，对于消息的完整性和不可否认性则并没有进行太多的考虑。(1)\n历史 # 古代中国:从古到今,军队历来是使用密码最频繁的地方,因为保护己方秘密并洞悉敌方秘密是克敌制胜的重要条件。正如中国古代军事著作《孙子兵法》中所说:知己知彼,百战不殆;不知彼而知己,一胜一负;不知彼不知己,每战必败。中国古代有着丰富的军事实践和发达的军事理论,其中不乏巧妙、规范和系统的保密通信和身份认证方法。\n中国古代兵书《六韬》中的阴符和阴书:《六韬》又称《太公六韬》或《太公兵法》,据说是由西周的开国功臣太公望(又名吕尚或姜子牙,约公元前1128—公元前1015)所著。书中以周文王和周武王与太公问答的形式阐述军事理论,其中《龙韬•阴符》篇和《龙韬•阴书》篇,讲述了君主如何在战争中与在外的将领进行保密通信。\n以下是关于“阴符”使用方法对话的译文。\n武王问太公说:领兵深入敌国境内,军队突然遇到紧急情况,战事或有利,或失利。我要与各军远近相通,内外相应,保持密切的联系,以便及时应对战场上军队的需求,应该怎么办呢?\n太公回答说:国君与主将之间用阴符秘密联络。阴符共有八种:一种长一尺,表示大获全胜,摧毁敌人;一种长九寸,表示攻破敌军,杀敌主将;一种长八寸,表示守城的敌人已投降,我军已占领该城;一种长七寸,表示敌军已败退,远传捷报;一种长六寸,表示我军将誓死坚守城邑;一种长五寸,表示请拨运军粮,增派援军;一种长四寸,表示军队战败,主将阵亡;一种长三寸,表示战事失利,全军伤亡惨重。如奉命传递阴符的使者延误传递,则处死;如阴符的秘密被泄露,则无论无意泄密者或有意传告者也处死。只有国君和主将知道这八种阴符的秘密。这就是不会泄露朝廷与军队之间相互联系内容的秘密通信语言。敌人再聪明也不能识破它。\n以下是关于“阴书”使用方法对话的译文。\n武王问太公说:领兵深入敌国境内,君主和将帅各率一军,要使两支军队配合作战,实施变化无穷的作战方法,谋取敌人意想不到的胜利。但需要联络的事情很多,使用阴符难以说明,而两军之间又距离遥远,言语不能通达,应该怎么办呢?\n太公回答说:如果有军机大事需要联络,应该用书信而不用符。君主通过书信向主将指示,主将则通过书信向君主请示。书信都要拆分成三部分,并分派三人发出,每人拿一部分。只有这三部分合在一起才能读懂信的内容。这就是所谓的阴书(机密信),敌人再聪明,也看不懂这种书信。\n中国宋代兵书《武经总要》是北宋仁宗时期官修的一部兵书,成书于1040年—1044年,作者是天章阁待制曾公亮和工部侍郎丁度。该书前集第15卷中有“符契”、“信牌”和“字验”三节,专门讲述军队中秘密通信和身份验证的方法。\n“符契”是《六韬》中“阴符”方法的改进。其中的“符”是皇帝派人向军队调兵的凭证,共有5种符,各种符的组合表示调用兵力的多少,每符分左右两段,右段留京师,左段由各路军队的主将收掌。使者将带着皇帝的命令和由枢密院封印的相应的右符,前往军队调兵;主将听完使者宣读皇帝的命令后,须启封使者带来的右符,并与所藏的左符验合,才能接受命令;然后用本将军的印重封右符,交由使者带回京师。\n“契”是主将派人向镇守各方的下属调兵的凭证,共有三种契,每契都是鱼形,可分为上下两段。上段留主将收掌,下段交各处下属收掌,使用方法类似于上述的符。\n“信牌”是两军阵前交战时,派人传送紧急命令的信物和文件。北宋初期使用的信物是一分两半的铜钱,后来改用木牌,上面可以写字。\n“字验”则是秘密传送军情的一套方法。先约定40种不同的军情,然后用一首含有40个不同字的诗,令其中每一个字对应一种军情。传送军情时,写一封普通的书信或文件,在其中的关键字旁加印记。军使在送信途中,不怕被敌方截获并破解信中内容。将军们收到信后,找出其中加印记的关键字,然后根据约定的40字诗来查出该字所告知的情况,还可以在这些字上再加印记,以表示对有关情况的处理,并令军使带回。\n我们看到,宋代的“字验”方法与近代以来军队、外交官和间谍们常用的借助密码字典进行秘密通信和联络的原理相同。\n古代中国的君王常以虎符作为调用军队的凭证。如在春秋战国时期,就有魏信陵君使如姬窃取魏王的虎符,并以此夺取大将晋鄙的兵权,然后率兵大破秦军,以解赵国之围的故事。虎符一般由铜、银等金属制成,背面刻有铭文,以示级别、身份、调用军队的对象和范围等;虎符分为两半,一半放在朝廷,另一半由在外的将帅保管。朝廷派来的使者,需携虎符验合,才可调兵遣将。\n顺便解释“符”字:其本义是指古代朝廷下命令的凭证;部首的“竹”表明最早的“符”是用竹子做的;“符”通常做成两部分,使用时一分为二,验证时合二为一;只有同一符的两部分才能完美地合在一起;这就是常用词“符合”的来历。近代间谍史上,常有人把纸币钞票一撕为二,作为接头联络的工具,其原理同“符”。现代密码学中,运用公钥—私钥体系进行身份认证的方法也与“符”相通。\n我国明末清初著名的军事理论家揭暄(1613—1695)所著的《兵经百言》用100个字条系统阐述了中国古代的军事理论。其中的“传”字诀则是古代军队通信方法的总结,其解释如下:\n军队分开行动后,如相互之间不能通信,就要打败仗;如果能通信但不保密,则也要被敌人暗算。所以除了用锣鼓、旌旗、骑马送信、燃火、烽烟等联系外,两军相遇,还要对暗号(口令)。当军队分开有千里之远时,宜用机密信(素书)进行通信。机密信分为三种:改变字的通常书写或阅读方式(“不成字”,如传统密码学的文字替换或移位方法);隐写术(“无形文”,用含有某种化学物质的液体来书写,收信者用特殊方法使文字显现出来,如矾书);不是把书信写在常用的纸上(“非纸简”),而是写在特殊的、不引人注意的载体上(如服饰,甚至人体上等)。这些通信方式连送信的使者都不知道信中的内容,但收信人却可以接收到信息。\n古埃及:公元前2000年人类文明刚刚形成,大约就在那个时候古埃及就拥有了密码。贵族克努姆霍特普二世的墓碑上记载了在阿梅连希第二法老王朝供职期间它所建立的功勋。上面的象形文字与我们已知的埃及象形文字有所不同,那是由一位擅长书写的人对普通象形文字经过处理之后刻录的,但是具体的方法尚未可知。民众们推测这可能是庄严和权威的象征。\n古印度:印度公元前三百年写成的《经济论》旨在描述当时密探充斥全国时特务机关的官员用密写的方式给密探下达任务。\n古希腊:大约在公元前700年,古希腊军队用一种叫做Scytale的圆木棍来进行保密通信。其使用方法是:把长带子状羊皮纸缠绕在圆木棍上,然后在上面写字;解下羊皮纸后,上面只有杂乱无章的字符,只有再次以同样的方式缠绕到同样粗细的棍子上,才能看出所写的内容。\n这种Scytale圆木棍也许是人类最早使用的文字加密解密工具,据说主要是古希腊城邦中的斯巴达人(Sparta)在使用它,所以又被叫做“斯巴达棒”。\n斯巴达棒的加密原理属于密码学中的“换位法”(Transition)加密,因为它通过改变文本中字母的阅读顺序来达到加密的目的。(2)\n类型 # 古典密码在形式上可分成移位密码和替代密码两类，其中替代密码又可分为单表替代密码和多表替代。\n移位密码 # 曲路密码 # 曲路密码是一种置换密码，其中密钥是从明文创建的块中读取密文时要遵循的路径,该密钥需双方事先约定好（曲路路径）。\n下面给出一个例子：\n明文：The quick brown fox jumps over the lazy dog 填入填入 5 行 7 列表（事先约定填充的行列数）\n加密的回路线（事先约定填充的行列数）\n密文：gesfc inpho dtmwu qoury zejre hbxva lookT 云影密码 # 该密码又称为01248，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1-\u0026gt;26 表示 A-\u0026gt;Z。\n可以看出该密码有以下特点：\n只有 0，1，2，4，8 这里举个栗子\n密文：WELLDONE 采用0进行分割，得到云影密码加密结果：\n8842101220480224404014224202480122 栅栏密码 # 栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。栅栏密码分为两种类型，一种是传统的栅栏密码，另一种是W型的栅栏密码。\n传统栅栏密码 # 明文：THEREISACIPHER 分成三栏，三个一组得到\nTHE REI SAC IPH ER 先取出第一个字母，再取出第二个字母\nTRSIE HEAPR EICH 连在一起就是密文\nTRSIEHEAPREICH W型栅栏密码 # W型栅栏密码和传统的栅栏密码原理类似，就排列方式有所差异\n明文：THEREISACIPHER 分成三栏，三个一组得到\nTHE REI SAC IPH ER 进行W型栅栏排列\nT E C E H R I A I H R E S P 连在一起就是密文\nTECEHRIAIHRESP 替换密码 # 单表替换密码 # 在单表替换加密中，所有的加密方式几乎都有一个共性，那就是明密文一一对应。所以说，一般有以下两种方式来进行破解 (4)\n在密钥空间较小的情况下，采用暴力破解方式 在密文长度足够长的时候，使用词频分析，http://quipqiup.com/ 当密钥空间足够大，而密文长度足够短的情况下，破解较为困难。\n凯撒密码 # 凯撒密码是非常著名的古典密码，也是非常经典的古典密码。\n凯撒密码（Caesar）加密时会将明文中的 每个字母 都按照其在字母表中的顺序向后（或向前）移动固定数目（循环移动）作为密文。例如，当偏移量是左移 3 的时候（解密时的密钥就是 3）：^4^\n明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ 密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC 使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：\n明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ 根据偏移量的不同，还存在若干特定的恺撒密码名称：\n偏移量为10：Avocat (A–\u0026gt;K) 偏移量为13：ROT13 偏移量为-5：Cassis (K 6) 偏移量为-6：Cassette (K 7) 举个栗子：\n明文：This is a fake flag 经过凯撒密码，位移3进行加密得到\n密文：Wklv lv d idnh iodj 埃特巴什码 # 与凯撒密码不同的是，埃特巴什码的提代表不是通过移位获得的，而是通过对称获得的。其通过将字母表的位置完全镜面对称后获得字母的替代表，然后进行加密。\n埃特巴什码（Atbash Cipher）其实可以视为下面要介绍的简单替换密码的特例，它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。在罗马字母表中，它是这样出现的：\n明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A 给出一个栗子：\n明文：the quick brown fox jumps over the lazy dog 密文：gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt 培根密码 # 培根密码一般使用两种不同的字体表示密文，密文的内容不是关键所在，关键是字体。使用AB代表两种字体，五个一组，表示密文，明密问对应如表：(5)\n明文 密文 a AAAAA b AAAAB c AAABA d AAABB e AABAA f AABAB g AABBA h AABBB i-j ABAAA k ABAAB l ABABA m ABABB n ABBAA o ABBAB p ABBBA q ABBBB r BAAAA s BAAAB t BAABA u-v BAABB w BABAA x BABAB y BABBA z BABBB 上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。\n下面这一段内容就是明文 steganography 加密后的内容，正常字体是 A，粗体是 B：\nTo encode a message each letter of the plaintext is replaced by a group of five of the letters \u0026lsquo;A\u0026rsquo; or \u0026lsquo;B\u0026rsquo;.\n可以看到，培根密码主要有以下特点:\n只有两种字符 每一段的长度为5 加密内容会有特殊的字体之分，亦或者大小写之分 图形替代密码 # 猪圈密码和跳舞的小人都是典型的图形替代密码，图形替代密码是通过将明文用图形进行替代以实现加密。解密时进行一样对应就可以进行解密。这里列出几种经典的图形替代密码：\n猪圈密码\n标准银河字母\n圣堂武士密码\n跳舞的小人\n古埃及象形密码\nWingdings\n仿射密码 # 仿射密码的替代表生成方式依据： $$ c = am+b\\ \\text{mod}\\ n $$\n$m$ 为明文对应字母得到的数字 $a$ 和 $n$ 互质 $n$ 是编码系统中字母的数目 解密函数是 $D(x) = a^{-1} (m-b) \\ \\text{mod}\\ n$, 其中$a^{-1}$是$a$在$\\mathbb{Z}_m$群的乘法逆元。\n多表替换密码 # 对于多表替换加密来说，加密后的字母几乎不再保持原来的频率，所以我们一般只能通过寻找算法实现对应的弱点进行破解。\n棋盘类密码 # Playfair、Polybius和Nihilist均属于棋盘类密码。此类密码的密钥为一个5x5的棋盘。棋盘生成符号如下条件：\n顺序随意 不得出现重复字母 i和j可视为同一个字（也有将q去除的，以保证总数为25个） 生成棋盘后，不同加密方式使用不同的转换方式。\n维吉尼亚密码 # 凯撒密码是单表替代密码，其只使用了一个替代表，维吉尼亚密码则是标准的多表替代密码。\n首先，多表替代密码的密钥不再是固定不变的，而是随着位置发生改变的。在维吉尼亚密码中，根据密钥的字母来选择。\n使用数学语言进行描述：\n维吉尼亚密码是一种简单的多表代换密码(由26个类似的Caesar密码的代换表组成)，\n即由一些偏移量不同的恺撒密码组成，这些代换在一起组成了密钥。\n英文中a~z，由0~25表示。\n假设串长为：m，明文为P，密文为C，密钥为K则 $$ C = (P_1 +K_1,P_2+K_2,\\dots,P_m+K_m)\\text{mod}26 $$\n$$ P = (C_1 -K_1,C_2-K_2,\\dots,C_m-K_m)\\text{mod}26 $$\n举个栗子：\n如果密钥是LOVE，那么明文会四个一组进行循环。明文的第一个位置会使用“L”进行加密，第二个位置会使用“O”进行加密，第四个位置会使用“E”进行加密，到第五个位置时又会回归到使用“L”进行加密。\n一般情况下，维吉尼亚密码的破解必须依赖爆破+词频统计的方法来进行\n希尔密码 # 希尔密码（Hill）使用每个字母在字母表中的顺序作为其对应的数字，即 A=0，B=1，C=2 等，然后将明文转化为 n 维向量，跟一个 n × n 的矩阵相乘，再将得出的结果模 26。注意用作加密的矩阵（即密匙）在$\\mathbb{Z}^n_{26}$必须是可逆的，否则就不可能解码。只有矩阵的行列式和26互质，才是可逆的。下面举一个例子\n明文：ACT 将明文化为矩阵 $$ \\left[ \\begin{matrix} 0 \\\\ 2 \\\\ 19 \\end{matrix} \\right] $$\n假设密钥为： $$ \\left[ \\begin{matrix} 6 \u0026amp; 24 \u0026amp; 1\\\\ 13 \u0026amp; 16 \u0026amp; 10\\\\ 20 \u0026amp; 17 \u0026amp; 15 \\end{matrix} \\right] $$ 加密过程为 $$ \\left[ \\begin{matrix} 6 \u0026amp; 24 \u0026amp; 1\\\\ 13 \u0026amp; 16 \u0026amp; 10\\\\ 20 \u0026amp; 17 \u0026amp; 15 \\end{matrix} \\right] \\left[ \\begin{matrix} 0\\\\ 2\\\\ 19 \\end{matrix} \\right] \\equiv \\left[ \\begin{matrix} 67\\\\ 222\\\\ 319 \\end{matrix} \\right] \\equiv \\left[ \\begin{matrix} 15\\\\ 14\\\\ 7 \\end{matrix} \\right] \\ \\text{mod}\\ 26 $$\n密文：POH 参考 # 古典密码简介 - CTF Wiki (ctf-wiki.org) 密码发展史之古典密码 _国家密码管理局门户 (oscca.gov.cn) 古典密码简介 - CTF Wiki (ctf-wiki.org) 单表代换加密 - CTF Wiki (dyf.ink) 其它类型加密 - CTF Wiki (ctf-wiki.org) ","date":"January 29, 2022","permalink":"/posts/classic_crypto/","section":"Posts","summary":"古典密码 # 密码和编码最大的区别就是密码多了一个很关键的信息：密钥。\n密码(Cryptology)是一种用来混淆的技术,它希望将正常的、可识别的信息转变为无法识别的信息。密码学是一个即古老又新兴的学科,密码学一词源自希腊文“krypto\u0026rsquo;s”及“logos”两字,直译即为“隐藏”及“讯息”之意。\n密码学是一门拥有几千年历史的学科。密码学的发展大概经历了三个阶段:古典密码阶段、近代密码阶段、现代密码阶段。下面我们一起了解古典密码阶段。\n古典密码阶段是指从密码的产生到发展成为近代密码之间的这段时期密码的发展历史。\n值得一提的是，在古典密码学中，设计者主要考虑消息的保密性，使得只有相关密钥的人才可以解密密文获得消息的内容，对于消息的完整性和不可否认性则并没有进行太多的考虑。(1)\n历史 # 古代中国:从古到今,军队历来是使用密码最频繁的地方,因为保护己方秘密并洞悉敌方秘密是克敌制胜的重要条件。正如中国古代军事著作《孙子兵法》中所说:知己知彼,百战不殆;不知彼而知己,一胜一负;不知彼不知己,每战必败。中国古代有着丰富的军事实践和发达的军事理论,其中不乏巧妙、规范和系统的保密通信和身份认证方法。\n中国古代兵书《六韬》中的阴符和阴书:《六韬》又称《太公六韬》或《太公兵法》,据说是由西周的开国功臣太公望(又名吕尚或姜子牙,约公元前1128—公元前1015)所著。书中以周文王和周武王与太公问答的形式阐述军事理论,其中《龙韬•阴符》篇和《龙韬•阴书》篇,讲述了君主如何在战争中与在外的将领进行保密通信。\n以下是关于“阴符”使用方法对话的译文。\n武王问太公说:领兵深入敌国境内,军队突然遇到紧急情况,战事或有利,或失利。我要与各军远近相通,内外相应,保持密切的联系,以便及时应对战场上军队的需求,应该怎么办呢?\n太公回答说:国君与主将之间用阴符秘密联络。阴符共有八种:一种长一尺,表示大获全胜,摧毁敌人;一种长九寸,表示攻破敌军,杀敌主将;一种长八寸,表示守城的敌人已投降,我军已占领该城;一种长七寸,表示敌军已败退,远传捷报;一种长六寸,表示我军将誓死坚守城邑;一种长五寸,表示请拨运军粮,增派援军;一种长四寸,表示军队战败,主将阵亡;一种长三寸,表示战事失利,全军伤亡惨重。如奉命传递阴符的使者延误传递,则处死;如阴符的秘密被泄露,则无论无意泄密者或有意传告者也处死。只有国君和主将知道这八种阴符的秘密。这就是不会泄露朝廷与军队之间相互联系内容的秘密通信语言。敌人再聪明也不能识破它。\n以下是关于“阴书”使用方法对话的译文。\n武王问太公说:领兵深入敌国境内,君主和将帅各率一军,要使两支军队配合作战,实施变化无穷的作战方法,谋取敌人意想不到的胜利。但需要联络的事情很多,使用阴符难以说明,而两军之间又距离遥远,言语不能通达,应该怎么办呢?\n太公回答说:如果有军机大事需要联络,应该用书信而不用符。君主通过书信向主将指示,主将则通过书信向君主请示。书信都要拆分成三部分,并分派三人发出,每人拿一部分。只有这三部分合在一起才能读懂信的内容。这就是所谓的阴书(机密信),敌人再聪明,也看不懂这种书信。\n中国宋代兵书《武经总要》是北宋仁宗时期官修的一部兵书,成书于1040年—1044年,作者是天章阁待制曾公亮和工部侍郎丁度。该书前集第15卷中有“符契”、“信牌”和“字验”三节,专门讲述军队中秘密通信和身份验证的方法。\n“符契”是《六韬》中“阴符”方法的改进。其中的“符”是皇帝派人向军队调兵的凭证,共有5种符,各种符的组合表示调用兵力的多少,每符分左右两段,右段留京师,左段由各路军队的主将收掌。使者将带着皇帝的命令和由枢密院封印的相应的右符,前往军队调兵;主将听完使者宣读皇帝的命令后,须启封使者带来的右符,并与所藏的左符验合,才能接受命令;然后用本将军的印重封右符,交由使者带回京师。\n“契”是主将派人向镇守各方的下属调兵的凭证,共有三种契,每契都是鱼形,可分为上下两段。上段留主将收掌,下段交各处下属收掌,使用方法类似于上述的符。\n“信牌”是两军阵前交战时,派人传送紧急命令的信物和文件。北宋初期使用的信物是一分两半的铜钱,后来改用木牌,上面可以写字。\n“字验”则是秘密传送军情的一套方法。先约定40种不同的军情,然后用一首含有40个不同字的诗,令其中每一个字对应一种军情。传送军情时,写一封普通的书信或文件,在其中的关键字旁加印记。军使在送信途中,不怕被敌方截获并破解信中内容。将军们收到信后,找出其中加印记的关键字,然后根据约定的40字诗来查出该字所告知的情况,还可以在这些字上再加印记,以表示对有关情况的处理,并令军使带回。\n我们看到,宋代的“字验”方法与近代以来军队、外交官和间谍们常用的借助密码字典进行秘密通信和联络的原理相同。\n古代中国的君王常以虎符作为调用军队的凭证。如在春秋战国时期,就有魏信陵君使如姬窃取魏王的虎符,并以此夺取大将晋鄙的兵权,然后率兵大破秦军,以解赵国之围的故事。虎符一般由铜、银等金属制成,背面刻有铭文,以示级别、身份、调用军队的对象和范围等;虎符分为两半,一半放在朝廷,另一半由在外的将帅保管。朝廷派来的使者,需携虎符验合,才可调兵遣将。\n顺便解释“符”字:其本义是指古代朝廷下命令的凭证;部首的“竹”表明最早的“符”是用竹子做的;“符”通常做成两部分,使用时一分为二,验证时合二为一;只有同一符的两部分才能完美地合在一起;这就是常用词“符合”的来历。近代间谍史上,常有人把纸币钞票一撕为二,作为接头联络的工具,其原理同“符”。现代密码学中,运用公钥—私钥体系进行身份认证的方法也与“符”相通。\n我国明末清初著名的军事理论家揭暄(1613—1695)所著的《兵经百言》用100个字条系统阐述了中国古代的军事理论。其中的“传”字诀则是古代军队通信方法的总结,其解释如下:\n军队分开行动后,如相互之间不能通信,就要打败仗;如果能通信但不保密,则也要被敌人暗算。所以除了用锣鼓、旌旗、骑马送信、燃火、烽烟等联系外,两军相遇,还要对暗号(口令)。当军队分开有千里之远时,宜用机密信(素书)进行通信。机密信分为三种:改变字的通常书写或阅读方式(“不成字”,如传统密码学的文字替换或移位方法);隐写术(“无形文”,用含有某种化学物质的液体来书写,收信者用特殊方法使文字显现出来,如矾书);不是把书信写在常用的纸上(“非纸简”),而是写在特殊的、不引人注意的载体上(如服饰,甚至人体上等)。这些通信方式连送信的使者都不知道信中的内容,但收信人却可以接收到信息。\n古埃及:公元前2000年人类文明刚刚形成,大约就在那个时候古埃及就拥有了密码。贵族克努姆霍特普二世的墓碑上记载了在阿梅连希第二法老王朝供职期间它所建立的功勋。上面的象形文字与我们已知的埃及象形文字有所不同,那是由一位擅长书写的人对普通象形文字经过处理之后刻录的,但是具体的方法尚未可知。民众们推测这可能是庄严和权威的象征。\n古印度:印度公元前三百年写成的《经济论》旨在描述当时密探充斥全国时特务机关的官员用密写的方式给密探下达任务。\n古希腊:大约在公元前700年,古希腊军队用一种叫做Scytale的圆木棍来进行保密通信。其使用方法是:把长带子状羊皮纸缠绕在圆木棍上,然后在上面写字;解下羊皮纸后,上面只有杂乱无章的字符,只有再次以同样的方式缠绕到同样粗细的棍子上,才能看出所写的内容。\n这种Scytale圆木棍也许是人类最早使用的文字加密解密工具,据说主要是古希腊城邦中的斯巴达人(Sparta)在使用它,所以又被叫做“斯巴达棒”。\n斯巴达棒的加密原理属于密码学中的“换位法”(Transition)加密,因为它通过改变文本中字母的阅读顺序来达到加密的目的。(2)\n类型 # 古典密码在形式上可分成移位密码和替代密码两类，其中替代密码又可分为单表替代密码和多表替代。\n移位密码 # 曲路密码 # 曲路密码是一种置换密码，其中密钥是从明文创建的块中读取密文时要遵循的路径,该密钥需双方事先约定好（曲路路径）。\n下面给出一个例子：\n明文：The quick brown fox jumps over the lazy dog 填入填入 5 行 7 列表（事先约定填充的行列数）\n加密的回路线（事先约定填充的行列数）\n密文：gesfc inpho dtmwu qoury zejre hbxva lookT 云影密码 # 该密码又称为01248，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1-\u0026gt;26 表示 A-\u0026gt;Z。","title":"古典密码-探寻曾经的故事"},{"content":"One-Time pad # 密码学中有一种加密方法叫做 One Time Pad ，翻译过来叫做“一次性密码本”。因为这种密码最早就是真的写在一个本子上传递的，所以有了这个名字。这是一种安全度最高的加密方法，需要通信双方事先去沟通一个一次性的和被加密信息长度相等或者更长的秘钥。\n次性密码本（英语：one-time pad，缩写为OTP）是古典密码学中的一种加密算法。是以随机的密钥（key）组成明文，且只使用一次。\n密码学安全性最强的密码OTP（One-Time pad），OTP的安全性依赖于 ”一次一密“ 理论的安全性。\n历史 # 1917年，Vernam发明一次一密，并为此申请了专利。\n安全性 # OTP是绝对安全的，是牢不可破的。香农已经证实了一次一密理论的安全性。\n虽然它在理论上的安全性无庸置疑，但在实际操作上却有着以下的问题：\n用以加密的文本，也就是一次性密码本，必须确实是随机产生的。 它至少必须和被加密的文件等长。 用以加密的文本只能用一次，且必须对非关系人小心保密，不再使用时，用以加密的文本应当要销毁，以防重复使用。 加密方式 # 首先手上要有一本一次性密码本用以加密文件，接着将一次性密码本里的字母，与被加密文件的字母给依序按某个事先约定的规定一一相混，其中一个相混的作法是将字母指定数字（如在英语中，将A至Z依序指定为0至25）然后将一次性密码文本上的字母所代表的数字和被加密文件上相对应的数字给相加，再除以该语言的字母数后获取其余数，假设字母数是 n（如英语为26），若就此得出来的某个数字小于零，则将该小于零的数给加上n，如此便完成加密。\n一次一密密码具有非常棒的安全性，但是理想很美好，现实很残酷，理想状态下的一次一密密码非常安全、非常简单同时也非常完美。但是，现实状态下的一次一密密码是几乎不可能实现的。\n使用 One Time Pad 有两个最佳实践。第一，一个 One Time Pad 只用一次。第二，每个 One Time Pad 中的数据要保证真正的随机。\n这意味着真正使用的时候，每次加密都需要重新生成并且再次发布给通信双方。互联网是一个不安全的环境，安全的发布 One Time Pad 其实是非常困难的，这就使得在很多的应用情形下是不能使用 One Time Pad 的。\n参考 # 一次性密码本 - 万维百科 (wanweibaike.net) One Time Pad 一次性密码本 - 知乎 (zhihu.com) ","date":"January 29, 2022","permalink":"/posts/one-time_pad/","section":"Posts","summary":"One-Time pad # 密码学中有一种加密方法叫做 One Time Pad ，翻译过来叫做“一次性密码本”。因为这种密码最早就是真的写在一个本子上传递的，所以有了这个名字。这是一种安全度最高的加密方法，需要通信双方事先去沟通一个一次性的和被加密信息长度相等或者更长的秘钥。\n次性密码本（英语：one-time pad，缩写为OTP）是古典密码学中的一种加密算法。是以随机的密钥（key）组成明文，且只使用一次。\n密码学安全性最强的密码OTP（One-Time pad），OTP的安全性依赖于 ”一次一密“ 理论的安全性。\n历史 # 1917年，Vernam发明一次一密，并为此申请了专利。\n安全性 # OTP是绝对安全的，是牢不可破的。香农已经证实了一次一密理论的安全性。\n虽然它在理论上的安全性无庸置疑，但在实际操作上却有着以下的问题：\n用以加密的文本，也就是一次性密码本，必须确实是随机产生的。 它至少必须和被加密的文件等长。 用以加密的文本只能用一次，且必须对非关系人小心保密，不再使用时，用以加密的文本应当要销毁，以防重复使用。 加密方式 # 首先手上要有一本一次性密码本用以加密文件，接着将一次性密码本里的字母，与被加密文件的字母给依序按某个事先约定的规定一一相混，其中一个相混的作法是将字母指定数字（如在英语中，将A至Z依序指定为0至25）然后将一次性密码文本上的字母所代表的数字和被加密文件上相对应的数字给相加，再除以该语言的字母数后获取其余数，假设字母数是 n（如英语为26），若就此得出来的某个数字小于零，则将该小于零的数给加上n，如此便完成加密。\n一次一密密码具有非常棒的安全性，但是理想很美好，现实很残酷，理想状态下的一次一密密码非常安全、非常简单同时也非常完美。但是，现实状态下的一次一密密码是几乎不可能实现的。\n使用 One Time Pad 有两个最佳实践。第一，一个 One Time Pad 只用一次。第二，每个 One Time Pad 中的数据要保证真正的随机。\n这意味着真正使用的时候，每次加密都需要重新生成并且再次发布给通信双方。互联网是一个不安全的环境，安全的发布 One Time Pad 其实是非常困难的，这就使得在很多的应用情形下是不能使用 One Time Pad 的。\n参考 # 一次性密码本 - 万维百科 (wanweibaike.net) One Time Pad 一次性密码本 - 知乎 (zhihu.com) ","title":"One Time_Pad"},{"content":"2021 绿城杯 Crypto Writeup # 河南郑州的绿城杯，也是第一届绿城杯比赛。使用的比赛平台是安恒的比赛平台。比赛过程中出现了卡顿的问题。绿城杯的整体题目难度还是比较友好的，至少密码学方向是相对比较简单的一部分内容。\n密码学题目有三道题目，一道古典密码学题目，两道RSA题目。本人太菜，仅仅做出了前两道题目。\n0x0 [warmup]加密算法 # 直接看看题目的源码\nfrom Crypto.Util.number import * from flag import flag assert flag[:5]==\u0026#39;flag{\u0026#39; str1 = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encode(plain_text, a, b, m): cipher_text = \u0026#39;\u0026#39; for i in plain_text: if i in str1: addr = str1.find(i) cipher_text += str1[(a*addr+b) % m] else: cipher_text += i print(cipher_text) encode(flag,37,23,52) # cipher_text = \u0026#39;aoxL{XaaHKP_tHgwpc_hN_ToXnnht}\u0026#39; 代码看样子是非常简单的，可以找到加密的关键代码：\ndef encode(plain_text, a, b, m): cipher_text = \u0026#39;\u0026#39; for i in plain_text: if i in str1: addr = str1.find(i) cipher_text += str1[(a*addr+b) % m] else: cipher_text += i print(cipher_text) 对加密函数进行审计可以发现有一个比较明显的数学运算：\n$$ cipher\\underline{~~}text \\equiv a \\times addr + b\\ \\text{mod}\\ m $$\n看到这个数学运算，应该可以自然而然的想到是仿射加密，对应的解密函数也就是该运算的逆运算：\n$$ plain\\underline{~~} text \\equiv {addr}^{-1} \\times (a-b)\\ \\text{mod}\\ m $$\n根据运算构造解密函数：\nimport libnum def decode(cipher_text,a,b,m): plain_text = \u0026#39;\u0026#39; a_inv = libnum.invmod(a,m) for i in cipher_text: if i in str1: addr = str1.find(i) plain_text += str1[(a_inv*(addr-b))%m] else: plain_text += i print(plain_text) 根据解密函数进行求解即可求解\n完整exp：\nfrom Crypto.Util.number import * import libnum str1 = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encode(plain_text, a, b, m): cipher_text = \u0026#39;\u0026#39; for i in plain_text: if i in str1: addr = str1.find(i) cipher_text += str1[(a*addr+b) % m] else: cipher_text += i print(cipher_text) def decode(cipher_text,a,b,m): plain_text = \u0026#39;\u0026#39; a_inv = libnum.invmod(a,m) for i in cipher_text: if i in str1: addr = str1.find(i) plain_text += str1[(a_inv*(addr-b))%m] else: plain_text += i print(plain_text) cipher_text = \u0026#39;aoxL{XaaHKP_tHgwpc_hN_ToXnnht}\u0026#39; decode(cipher_text,37,23,52) 0x1 RSA-1 # RSA的题目，康康题目源码\nfrom Crypto.Util.number import * import gmpy2 from flag import flag assert flag[:5]==b\u0026#39;flag{\u0026#39; m = bytes_to_long(flag) p = getPrime(1024) q = getPrime(1024) n = p * q print(\u0026#39;n =\u0026#39;,n) e = 0x10001 M = 2021 * m * 1001 * p c = pow(M,e,n) print(\u0026#39;c =\u0026#39;,c) #n = 17365231154926348364478276872558492775911760603002394353723603461898405740234715001820111548600914907617003806652492391686710256274156677887101997175692277729648456087534987616743724646598234466094779540729413583826355145277980479040157075453694250572316638348121571218759769533738721506811175866990851972838466307594226293836934116659685215775643285465895317755892754473332034234495795936183610569571016400535362762699517686781602302045048532131426035260878979892169441059467623523060569285570577199236309888155833013721997933960457784653262076135561769838704166810384309655788983073376941843467117256002645962737847 #c = 6944967108815437735428941286784119403138319713455732155925055928646536962597672941805831312130689338014913452081296400272862710447207265099750401657828165836013122848656839100854719965188680097375491193249127725599660383746827031803066026497989298856420216250206035068180963797454792151191071433645946245914916732637007117085199442894495667455544517483404006536607121480678688000420422281380539368519807162175099763891988648117937777951069899975260190018995834904541447562718307433906592021226666885638877020304005614450763081337082838608414756162253825697420493509914578546951634127502393647068722995363753321912676 进行代码审计，可以发现前面的加密过程是RSA的基本加密过程和步骤，但是到了后面的步骤，发现加密过程出现了异样，这很有可能就是我们的攻击点。找到题目源码中的可疑运算： $$ M = 2021 \\times m \\times 1001 \\times p $$ 观察这个等式可以得出一些微妙的关系： $$ c \\equiv M^e \\ \\text{mod}\\ n \\ n = p \\cdot q $$ 根据这个关系进一步推到可以得到 $$ c \\equiv {(2021 \\times m \\times 1001 \\times p)}^e\\ \\text{mod}\\ n $$ 观察这个等式可以显然发现 c 和 n 存在着有着微妙的关系，利用这个微妙的关系可以得到攻击这个密码体制的钥匙，即 $$ p = \\gcd (c,n) $$ 利用这个关系即可求解本题\n完整exp：\nfrom Crypto.Util.number import * import gmpy2 e = 0x10001 n = 17365231154926348364478276872558492775911760603002394353723603461898405740234715001820111548600914907617003806652492391686710256274156677887101997175692277729648456087534987616743724646598234466094779540729413583826355145277980479040157075453694250572316638348121571218759769533738721506811175866990851972838466307594226293836934116659685215775643285465895317755892754473332034234495795936183610569571016400535362762699517686781602302045048532131426035260878979892169441059467623523060569285570577199236309888155833013721997933960457784653262076135561769838704166810384309655788983073376941843467117256002645962737847 c = 6944967108815437735428941286784119403138319713455732155925055928646536962597672941805831312130689338014913452081296400272862710447207265099750401657828165836013122848656839100854719965188680097375491193249127725599660383746827031803066026497989298856420216250206035068180963797454792151191071433645946245914916732637007117085199442894495667455544517483404006536607121480678688000420422281380539368519807162175099763891988648117937777951069899975260190018995834904541447562718307433906592021226666885638877020304005614450763081337082838608414756162253825697420493509914578546951634127502393647068722995363753321912676 p = gmpy2.gcd(c,n) q = n // p assert(n == p*q) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi) M = pow(c,d,n) m = M//(2021*p*1001) flag = long_to_bytes(m) print(flag) 0x2 RSA-2 # 当时没做出来，没有认真进行数学分析，是本菜狗没错了，后来看大佬的Writeup发现是一道原题，大佬的博客：ISITDTU 2019 Quals CTF Writeups | Joseph Surin | joseph\u0026rsquo;s blog (jsur.in)\n这道题目，我根据对博客的学习和理解进行简单地复现，这道题目其实也就是数学的推导和猜测，又是暴力的美学和优雅地求解。\n看看题目源码：\nfrom Crypto.Util.number import * import gmpy2 from flag import flag assert flag[:5]==b\u0026#39;flag{\u0026#39; m1 = bytes_to_long(flag[:20]) p = getPrime(512) p1 = gmpy2.next_prime(p) q = getPrime(512) q1 = gmpy2.next_prime(q) n1 = p*q*p1*q1 print(\u0026#39;n1 =\u0026#39;,n1) e = 0x10001 c1 = pow(m1,e,n1) print(\u0026#39;c1 =\u0026#39;,c1) m2 = bytes_to_long(flag[20:]) p2 = getPrime(1024) q2 = getPrime(1024) print(\u0026#39;p2+q2 =\u0026#39;,p2+q2) print(\u0026#39;q2*q2 =\u0026#39;,p2*q2) n2 = p2*p2*q2*q2*q2 print(\u0026#39;n2 =\u0026#39;,n2) c2 = pow(m2,e,n2) print(\u0026#39;c2 =\u0026#39;,c2) #n1 = 6348779979606280884589422188738902470575876294643492831465947360363568026280963989291591157710389629216109615274754718329987990551836115660879103234129921943824061416396264358110216047994331119920503431491509529604742468032906950984256964560405062345280120526771439940278606226153077959057882262745273394986607004406770035459301695806378598890589432538916219821477777021460189140081521779103226953544426441823244765828342973086422949017937701261348963541035128661464068769033772390320426795044617751909787914185985911277628404632533530390761257251552073493697518547350246993679844132297414094727147161169548160586911 #c1 = 6201882078995455673376327652982610102807874783073703018551044780440620679217833227711395689114659144506630609087600915116940111002026241056808189658969089532597757995423694966667948250438579639890580690392400661711864264184444018345499567505424672090632235109624193289954785503512742400960515331371813467034511130432319427185134018830006918682733848618201088649690422818940385123599468595766345668931882249779415788129316594083269412221804774856038796248038700275509397599351533280014908894068141056694660319816046357462684688942519849441237878018480036145051967731081582598773076490918572392784684372694103015244826 #p2+q2 = 274773146761138462708137582309097386437793891793691383033856524303010811294101933454824485010521468914846151819876043508541879637544444256520741418495479393777132830985856522008561088410862815913292288683761657919121930016956916865849261153721097671315883469348972925757078089715102032241818526925988645578778 #q2*q2 = 18514724270030962172566965941723224386374076294232652258701085781018776172843355920566035157331579524980108190739141959926523082142273672741849552475156278397131571360099018592018959785627785130126477982765210498547680367230723634424036009539347854344573537848628061468892166199866227984167843139793429682559241317072979374002912607549039431398267184818771503468116379618249319324788996321340764624593443106354104274472601170229835219638093242557547840060892527576940077162990069687019966946826210112318408269749294366586682732614372434218768720577917368726530200897558912687470088583774711767599580037663378929000217 #n2 = 40588227045595304080360385041082238507044292731344465815296032905633525556943787610712651675460810768762763493579129831271018141591546207557410817432455139315527674932933085299277599173971912445226532235814580879585317211349524406424200622675880992390782025158621241499693400288031658194434641718026910652327933253877313106112861283314274635124734817398465059373562194694957841264834312640926278890386089611103714990646541470577351599526904458342660444968591197606820361364761648205241041444681145820799054413179462285509661124362074093583494932706249461954240408827087015525507173082129412234486228092002841868365895837463699200959915782767657258729794037776401995309244941171415842403617486719492483671490834562579225506831496881542530519595438932482796867853234159664409420977526102480385193101883785161080269573707156626838551506024455480650224305894501968583442346807126920740779780593650871645915149689424292912611578291912721896864772950410266629045542480009266574096080138709683466489568290569363478444349563498507530805502511051165160827192795520182720802422213364247355775222858214648603034743679187470844212529134374975737510982287957316878179964602394749601431823167982157434890459245394370728942790117156485268116758052636794417268680901420193002289035538753620555488506926366624641291881353268617130968991258983002165300186971963661666476600998389048880565199317280428349802824448329898502788492233381873026217202981921654673840142095839603360666049476100561268336225902504932800605464136192275593886736746497955270280541423593 #c2 = 25591090168544821761746024178724660839590948190451329227481168576490717242294520739865602061082558759751196452117720647426598261568572440942370039702932821941366792140173428488344932203576334292648255551171274828821657097667106792872200082579319963310503721435500623146012954474613150848083425126987554594651797477741828655238243550266972216752593788734836373144363217639612492397228808215205862281278774096317615918854403992620720969173788151215489908812749179861803144937169587452008097008940710091361183942268245271154461872102813602754439939747566507116519362821255724179093051041994730856401493996771276172343313045755916751082693149885922105491818225012844519264933137622929024918619477538521533548551789739698933067212305578480416163609137189891797209277557411169643568540392303036719952140554435338851671440952865151077383220305295001632816442144022437763089133141886924265774247290306669825085862351732336395617276100374237159580759999593028756939354840677333467281632435767033150052439262501059299035212928041546259933118564251119588970009016873855478556588250138969938599988198494567241172399453741709840486953189764289118312870580993115636710724139809708256360212728127786394411676427828431569046279687481368215137561500777480380501551616577832499521295655237360184159889151837766353116185320317774645294201044772828099074917077896631909654671612557207653830344897644115936322128351494551004652981550758791285434809816872381900401440743578104582305215488888563166054568802145921399726673752722820646807494657299104190123945675647 题目源码分为两个部分，将flag进行分割了，分成两个部分进行加密。\n第一部分需要使用暴力的美学进行求解。\n第二部分需要使用优雅的运算进行求解。\n首先，看一下第一部分的加密代码：\nm1 = bytes_to_long(flag[:20]) p = getPrime(512) p1 = gmpy2.next_prime(p) q = getPrime(512) q1 = gmpy2.next_prime(q) n1 = p*q*p1*q1 print(\u0026#39;n1 =\u0026#39;,n1) e = 0x10001 c1 = pow(m1,e,n1) print(\u0026#39;c1 =\u0026#39;,c1) 多素因子进行加密的，但是这几个素因子的生成是非常有意思的，有着微妙的关系，可以根据这个关系来寻找可能存在的漏洞 $$ p_1 = p + \\epsilon \\ q_1 = q + \\delta $$ 根据这种关系可以进行发现： $$ \\begin{aligned} p \\cdot q_1 - q \\cdot p_1 \u0026amp;= p \\cdot (q+\\delta) - q \\cdot (p+\\epsilon) \\ \u0026amp;= p \\cdot q + p \\cdot \\delta - p \\cdot q - q\\cdot \\epsilon \\ \u0026amp;= p \\cdot \\delta - q \\cdot \\epsilon \\end{aligned} $$ 根据运算可以发现 pq1 和 qp1 之间相差不是非常大，可以使用 Alpertron\u0026rsquo;s Integer Factorization Calculator算法进行求解得到 pq1 和 qp1的数值\nt1 = 79679231796035037354449627487236220201878797729093909877127396750043503300636464774059752126148617367251988043645511172901030621825575172979048675217345099706517900079260617448298874437193769061144201311929792287772928471712053565834702260975126852624433945451405258351557569670978748727663718174543709899747 t2 = 79679231796035037354449627487236220201878797729093909877127396750043503300636464774059752126148617367251988043645511172901030621825575172979048675217341753594180007984204016274224280609480494305040439035855109422239942522968468133274883986349646765947317076885918174299537297351936448296784166003890345486613 现在得到了一部分信息，继续进行求解： $$ \\begin{aligned} t_1 \u0026amp;= p\\cdot q_1 \\ \u0026amp;= p \\cdot (q+\\delta) \\ \\Rightarrow p \u0026amp;= \\frac{t_1}{q+\\delta} \\end{aligned} $$\n$$ \\begin{aligned} t_2 \u0026amp;= q\\cdot p_1 \\ \u0026amp;= q \\cdot (p+\\epsilon) \\ \\Rightarrow p \u0026amp;= \\frac{t_2-q \\cdot \\epsilon}{q} \\end{aligned} $$\n组合这两个等式有 $$ \\begin{aligned} \\frac{t_2 - q \\cdot \\epsilon}{q} \u0026amp;= \\frac{t_1}{q+\\delta} \\ (q+\\delta) \\cdot (t_2 - q\\cdot \\epsilon) \u0026amp;= t_1 \\cdot q \\ \\epsilon \\cdot q^2 + (\\epsilon \\cdot \\delta+t_1-t_2)\\cdot q - \\delta\\cdot t_2 \u0026amp;= 0 \\end{aligned} $$ 下面就是需要进行小素数的爆破求解以及，方程的求解\n根据式子可以写个程序进行求解，求解得到q然后可以根究q求出p1和q1，然后再根据求出的q1求出p，这道题目的前半部分就算是求解完成了\n前半部分的exp：\ndef quadratic(a, b, c): try: (d, _) = gmpy2.iroot(b*b - (4*a*c),2) return ((-b-d)//(2*a), (-b+d)//(2*a)) except: return 0 # flag[:20] n1 = 6348779979606280884589422188738902470575876294643492831465947360363568026280963989291591157710389629216109615274754718329987990551836115660879103234129921943824061416396264358110216047994331119920503431491509529604742468032906950984256964560405062345280120526771439940278606226153077959057882262745273394986607004406770035459301695806378598890589432538916219821477777021460189140081521779103226953544426441823244765828342973086422949017937701261348963541035128661464068769033772390320426795044617751909787914185985911277628404632533530390761257251552073493697518547350246993679844132297414094727147161169548160586911 c1 = 6201882078995455673376327652982610102807874783073703018551044780440620679217833227711395689114659144506630609087600915116940111002026241056808189658969089532597757995423694966667948250438579639890580690392400661711864264184444018345499567505424672090632235109624193289954785503512742400960515331371813467034511130432319427185134018830006918682733848618201088649690422818940385123599468595766345668931882249779415788129316594083269412221804774856038796248038700275509397599351533280014908894068141056694660319816046357462684688942519849441237878018480036145051967731081582598773076490918572392784684372694103015244826 e = 0x10001 t2 = 79679231796035037354449627487236220201878797729093909877127396750043503300636464774059752126148617367251988043645511172901030621825575172979048675217341753594180007984204016274224280609480494305040439035855109422239942522968468133274883986349646765947317076885918174299537297351936448296784166003890345486613 t1 = 79679231796035037354449627487236220201878797729093909877127396750043503300636464774059752126148617367251988043645511172901030621825575172979048675217345099706517900079260617448298874437193769061144201311929792287772928471712053565834702260975126852624433945451405258351557569670978748727663718174543709899747 q = 0 epsilon = 0 delta = 0 for (epsilon, delta) in ((epsilon, delta) for epsilon in range(1, 5000) for delta in range(1, 5000)): q1 = quadratic(epsilon, epsilon*delta+t1-t2, -delta*t2) if q1 != 0: q1 = q1[1] res = q1*q1*epsilon + q1*(epsilon*delta+t1-t2)-delta*t2 if res == 0 and isPrime(q1): q = q1 epsilon = epsilon delta = delta break q1 = gmpy2.next_prime(q) p1= t2 // q p = t1//q1 phi1 = (p-1)*(q-1)*(p1-1)*(q1-1) d1 = libnum.invmod(e,phi1) m1 = pow(c1,d1,n1) flag1 = long_to_bytes(m1) 然后，看一下第二部分的代码，第二部分是非常优雅的进行求解的\nm2 = bytes_to_long(flag[20:]) p2 = getPrime(1024) q2 = getPrime(1024) print(\u0026#39;p2+q2 =\u0026#39;,p2+q2) print(\u0026#39;q2*q2 =\u0026#39;,p2*q2) n2 = p2*p2*q2*q2*q2 print(\u0026#39;n2 =\u0026#39;,n2) c2 = pow(m2,e,n2) print(\u0026#39;c2 =\u0026#39;,c2) 对第二部分进行审计可以发现，第二部分就是一个解方程和Euler定理的应用，构造方程和Euler定理进行求解：\np2 = sympy.Symbol(\u0026#39;p2\u0026#39;) q2 = sympy.Symbol(\u0026#39;q2\u0026#39;) result = sympy.solve([p2+q2-274773146761138462708137582309097386437793891793691383033856524303010811294101933454824485010521468914846151819876043508541879637544444256520741418495479393777132830985856522008561088410862815913292288683761657919121930016956916865849261153721097671315883469348972925757078089715102032241818526925988645578778,p2*q2-18514724270030962172566965941723224386374076294232652258701085781018776172843355920566035157331579524980108190739141959926523082142273672741849552475156278397131571360099018592018959785627785130126477982765210498547680367230723634424036009539347854344573537848628061468892166199866227984167843139793429682559241317072979374002912607549039431398267184818771503468116379618249319324788996321340764624593443106354104274472601170229835219638093242557547840060892527576940077162990069687019966946826210112318408269749294366586682732614372434218768720577917368726530200897558912687470088583774711767599580037663378929000217],p2,q2) n2 = 40588227045595304080360385041082238507044292731344465815296032905633525556943787610712651675460810768762763493579129831271018141591546207557410817432455139315527674932933085299277599173971912445226532235814580879585317211349524406424200622675880992390782025158621241499693400288031658194434641718026910652327933253877313106112861283314274635124734817398465059373562194694957841264834312640926278890386089611103714990646541470577351599526904458342660444968591197606820361364761648205241041444681145820799054413179462285509661124362074093583494932706249461954240408827087015525507173082129412234486228092002841868365895837463699200959915782767657258729794037776401995309244941171415842403617486719492483671490834562579225506831496881542530519595438932482796867853234159664409420977526102480385193101883785161080269573707156626838551506024455480650224305894501968583442346807126920740779780593650871645915149689424292912611578291912721896864772950410266629045542480009266574096080138709683466489568290569363478444349563498507530805502511051165160827192795520182720802422213364247355775222858214648603034743679187470844212529134374975737510982287957316878179964602394749601431823167982157434890459245394370728942790117156485268116758052636794417268680901420193002289035538753620555488506926366624641291881353268617130968991258983002165300186971963661666476600998389048880565199317280428349802824448329898502788492233381873026217202981921654673840142095839603360666049476100561268336225902504932800605464136192275593886736746497955270280541423593 c2 = 25591090168544821761746024178724660839590948190451329227481168576490717242294520739865602061082558759751196452117720647426598261568572440942370039702932821941366792140173428488344932203576334292648255551171274828821657097667106792872200082579319963310503721435500623146012954474613150848083425126987554594651797477741828655238243550266972216752593788734836373144363217639612492397228808215205862281278774096317615918854403992620720969173788151215489908812749179861803144937169587452008097008940710091361183942268245271154461872102813602754439939747566507116519362821255724179093051041994730856401493996771276172343313045755916751082693149885922105491818225012844519264933137622929024918619477538521533548551789739698933067212305578480416163609137189891797209277557411169643568540392303036719952140554435338851671440952865151077383220305295001632816442144022437763089133141886924265774247290306669825085862351732336395617276100374237159580759999593028756939354840677333467281632435767033150052439262501059299035212928041546259933118564251119588970009016873855478556588250138969938599988198494567241172399453741709840486953189764289118312870580993115636710724139809708256360212728127786394411676427828431569046279687481368215137561500777480380501551616577832499521295655237360184159889151837766353116185320317774645294201044772828099074917077896631909654671612557207653830344897644115936322128351494551004652981550758791285434809816872381900401440743578104582305215488888563166054568802145921399726673752722820646807494657299104190123945675647 P2 = 0 Q2 = 0 for test in result: _p2 = test[0] _q2 = test[1] if n2 == _p2*_p2*_q2*_q2*_q2: P2 = _p2 Q2 = _q2 break phi2 = P2*(P2-1)*pow(Q2,2)*(Q2-1) d2 = int(libnum.invmod(e,phi2)) m2 = pow(c2,d2,n2) flag2 = libnum.n2s(m2) 完整exp：\nimport libnum import sympy import gmpy2 from Crypto.Util.number import * def quadratic(a, b, c): try: (d, _) = gmpy2.iroot(b*b - (4*a*c),2) return ((-b-d)//(2*a), (-b+d)//(2*a)) except: return 0 # flag[:20] n1 = 6348779979606280884589422188738902470575876294643492831465947360363568026280963989291591157710389629216109615274754718329987990551836115660879103234129921943824061416396264358110216047994331119920503431491509529604742468032906950984256964560405062345280120526771439940278606226153077959057882262745273394986607004406770035459301695806378598890589432538916219821477777021460189140081521779103226953544426441823244765828342973086422949017937701261348963541035128661464068769033772390320426795044617751909787914185985911277628404632533530390761257251552073493697518547350246993679844132297414094727147161169548160586911 c1 = 6201882078995455673376327652982610102807874783073703018551044780440620679217833227711395689114659144506630609087600915116940111002026241056808189658969089532597757995423694966667948250438579639890580690392400661711864264184444018345499567505424672090632235109624193289954785503512742400960515331371813467034511130432319427185134018830006918682733848618201088649690422818940385123599468595766345668931882249779415788129316594083269412221804774856038796248038700275509397599351533280014908894068141056694660319816046357462684688942519849441237878018480036145051967731081582598773076490918572392784684372694103015244826 e = 0x10001 t2 = 79679231796035037354449627487236220201878797729093909877127396750043503300636464774059752126148617367251988043645511172901030621825575172979048675217341753594180007984204016274224280609480494305040439035855109422239942522968468133274883986349646765947317076885918174299537297351936448296784166003890345486613 t1 = 79679231796035037354449627487236220201878797729093909877127396750043503300636464774059752126148617367251988043645511172901030621825575172979048675217345099706517900079260617448298874437193769061144201311929792287772928471712053565834702260975126852624433945451405258351557569670978748727663718174543709899747 q = 0 epsilon = 0 delta = 0 for (epsilon, delta) in ((epsilon, delta) for epsilon in range(1, 5000) for delta in range(1, 5000)): q1 = quadratic(epsilon, epsilon*delta+t1-t2, -delta*t2) if q1 != 0: q1 = q1[1] res = q1*q1*epsilon + q1*(epsilon*delta+t1-t2)-delta*t2 if res == 0 and isPrime(q1): q = q1 epsilon = epsilon delta = delta break q1 = gmpy2.next_prime(q) p1= t2 // q p = t1//q1 phi1 = (p-1)*(q-1)*(p1-1)*(q1-1) d1 = libnum.invmod(e,phi1) m1 = pow(c1,d1,n1) flag1 = long_to_bytes(m1) # flag[20:] p2 = sympy.Symbol(\u0026#39;p2\u0026#39;) q2 = sympy.Symbol(\u0026#39;q2\u0026#39;) result = sympy.solve([p2+q2-274773146761138462708137582309097386437793891793691383033856524303010811294101933454824485010521468914846151819876043508541879637544444256520741418495479393777132830985856522008561088410862815913292288683761657919121930016956916865849261153721097671315883469348972925757078089715102032241818526925988645578778,p2*q2-18514724270030962172566965941723224386374076294232652258701085781018776172843355920566035157331579524980108190739141959926523082142273672741849552475156278397131571360099018592018959785627785130126477982765210498547680367230723634424036009539347854344573537848628061468892166199866227984167843139793429682559241317072979374002912607549039431398267184818771503468116379618249319324788996321340764624593443106354104274472601170229835219638093242557547840060892527576940077162990069687019966946826210112318408269749294366586682732614372434218768720577917368726530200897558912687470088583774711767599580037663378929000217],p2,q2) n2 = 40588227045595304080360385041082238507044292731344465815296032905633525556943787610712651675460810768762763493579129831271018141591546207557410817432455139315527674932933085299277599173971912445226532235814580879585317211349524406424200622675880992390782025158621241499693400288031658194434641718026910652327933253877313106112861283314274635124734817398465059373562194694957841264834312640926278890386089611103714990646541470577351599526904458342660444968591197606820361364761648205241041444681145820799054413179462285509661124362074093583494932706249461954240408827087015525507173082129412234486228092002841868365895837463699200959915782767657258729794037776401995309244941171415842403617486719492483671490834562579225506831496881542530519595438932482796867853234159664409420977526102480385193101883785161080269573707156626838551506024455480650224305894501968583442346807126920740779780593650871645915149689424292912611578291912721896864772950410266629045542480009266574096080138709683466489568290569363478444349563498507530805502511051165160827192795520182720802422213364247355775222858214648603034743679187470844212529134374975737510982287957316878179964602394749601431823167982157434890459245394370728942790117156485268116758052636794417268680901420193002289035538753620555488506926366624641291881353268617130968991258983002165300186971963661666476600998389048880565199317280428349802824448329898502788492233381873026217202981921654673840142095839603360666049476100561268336225902504932800605464136192275593886736746497955270280541423593 c2 = 25591090168544821761746024178724660839590948190451329227481168576490717242294520739865602061082558759751196452117720647426598261568572440942370039702932821941366792140173428488344932203576334292648255551171274828821657097667106792872200082579319963310503721435500623146012954474613150848083425126987554594651797477741828655238243550266972216752593788734836373144363217639612492397228808215205862281278774096317615918854403992620720969173788151215489908812749179861803144937169587452008097008940710091361183942268245271154461872102813602754439939747566507116519362821255724179093051041994730856401493996771276172343313045755916751082693149885922105491818225012844519264933137622929024918619477538521533548551789739698933067212305578480416163609137189891797209277557411169643568540392303036719952140554435338851671440952865151077383220305295001632816442144022437763089133141886924265774247290306669825085862351732336395617276100374237159580759999593028756939354840677333467281632435767033150052439262501059299035212928041546259933118564251119588970009016873855478556588250138969938599988198494567241172399453741709840486953189764289118312870580993115636710724139809708256360212728127786394411676427828431569046279687481368215137561500777480380501551616577832499521295655237360184159889151837766353116185320317774645294201044772828099074917077896631909654671612557207653830344897644115936322128351494551004652981550758791285434809816872381900401440743578104582305215488888563166054568802145921399726673752722820646807494657299104190123945675647 P2 = 0 Q2 = 0 for test in result: _p2 = test[0] _q2 = test[1] if n2 == _p2*_p2*_q2*_q2*_q2: P2 = _p2 Q2 = _q2 break phi2 = P2*(P2-1)*pow(Q2,2)*(Q2-1) d2 = int(libnum.invmod(e,phi2)) m2 = pow(c2,d2,n2) flag2 = libnum.n2s(m2) flag = flag1+flag2 print(flag) ","date":"January 29, 2022","permalink":"/posts/2021-%E7%BB%BF%E5%9F%8E%E6%9D%AF-crypto_writeup/","section":"Posts","summary":"2021 绿城杯 Crypto Writeup # 河南郑州的绿城杯，也是第一届绿城杯比赛。使用的比赛平台是安恒的比赛平台。比赛过程中出现了卡顿的问题。绿城杯的整体题目难度还是比较友好的，至少密码学方向是相对比较简单的一部分内容。\n密码学题目有三道题目，一道古典密码学题目，两道RSA题目。本人太菜，仅仅做出了前两道题目。\n0x0 [warmup]加密算法 # 直接看看题目的源码\nfrom Crypto.Util.number import * from flag import flag assert flag[:5]==\u0026#39;flag{\u0026#39; str1 = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encode(plain_text, a, b, m): cipher_text = \u0026#39;\u0026#39; for i in plain_text: if i in str1: addr = str1.find(i) cipher_text += str1[(a*addr+b) % m] else: cipher_text += i print(cipher_text) encode(flag,37,23,52) # cipher_text = \u0026#39;aoxL{XaaHKP_tHgwpc_hN_ToXnnht}\u0026#39; 代码看样子是非常简单的，可以找到加密的关键代码：\ndef encode(plain_text, a, b, m): cipher_text = \u0026#39;\u0026#39; for i in plain_text: if i in str1: addr = str1.","title":"2021 绿城杯 Crypto_writeup"},{"content":"","date":"January 29, 2022","permalink":"/categories/challenge/","section":"Categories","summary":"","title":"challenge"},{"content":"2021-鹤城杯-Crypto Writeup # 鹤城杯的密码学题目，难度相对较低。但是也挺有意思的，可以学习点小知识。\n0x0 easy_Crypto # 签到题\n公正公正公正诚信文明公正民主公正法治法治诚信民主自由敬业公正友善公正平等平等法治民主平等平等和谐敬业自由诚信平等和谐平等公正法治法治平等平等爱国和谐公正平等敬业公正敬业自由敬业平等自由法治和谐平等文明自由诚信自由平等富强公正敬业平等民主公正诚信和谐公正文明公正爱国自由诚信自由平等文明公正诚信富强自由法治法治平等平等自由平等富强法治诚信和谐 社会主义核心价值观编码，直接解编码就可\nflag{IlUqU9O5guX6YiITsRNPiQmbhNRjGuTP} 0x1 A_Crypto # 传统密码学题目，应该是个套娃密码\n4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35 使用python的ciphey库进行求解就好\npython3 -m ciphey -t \u0026#34;4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35\u0026#34; 大约2s左右就能抛出flag了\n直接求解出传统密码学套娃题目的flag：\nflag{W0w_y0u_c4n_rea11y_enc0d1ng!} 0x2 babyrsa # from Crypto.Util.number import getPrime, bytes_to_long from secret import flag p = getPrime(1024) q = getPrime(1024) n = p * q e = 65537 hint1 = p \u0026gt;\u0026gt; 724 hint2 = q % (2 ** 265) ct = pow(bytes_to_long(flag), e, n) print(hint1) print(hint2) print(n) print(ct) 听大佬们说这是一道原题，我也不清楚是在哪里的原题，好像需要简单变化就能得到flag\n分析一下题目，题目泄露了p的高位数据，但是只泄露了300位，还不能使用coppersmith攻击，需要至少576位才能使用coppersmith攻击。但是题目给到了另一个因子，因此可以尝试使用另一个因子进行构造来求解。\n另一个因子该怎么使用呢？看来需要简单的数学推导了 XD $$ q\\ \\text{mod}\\ 2^{265} \\equiv q_0 \\ q = q_0 + 2^{265} \\times k \\ n = q_0\\cdot p + 2^{265} \\cdot k \\cdot p \\ n \\cdot q_0^{-1} = p + 2^{265} \\cdot k \\cdot p \\cdot q_0^{-1} \\ p_0 \\equiv n \\cdot q_0^{-1}\\ \\text{mod}\\ 2^{265} $$ 根据推导过程可以获取到p的低位p0，然后就可以使用coppersmith攻击进行快乐求解了。求解后可以得到p，然后根据p的数值来获得q的数值。现在得到这两个数值就可以进行RSA的正常求解啦！\nEXP:\nfrom Crypto.Util.number import * import gmpy2 n = 21815431662065695412834116602474344081782093119269423403335882867255834302242945742413692949886248581138784199165404321893594820375775454774521554409598568793217997859258282700084148322905405227238617443766062207618899209593375881728671746850745598576485323702483634599597393910908142659231071532803602701147251570567032402848145462183405098097523810358199597631612616833723150146418889589492395974359466777040500971885443881359700735149623177757865032984744576285054725506299888069904106805731600019058631951255795316571242969336763938805465676269140733371287244624066632153110685509892188900004952700111937292221969 c = 19073695285772829730103928222962723784199491145730661021332365516942301513989932980896145664842527253998170902799883262567366661277268801440634319694884564820420852947935710798269700777126717746701065483129644585829522353341718916661536894041337878440111845645200627940640539279744348235772441988748977191513786620459922039153862250137904894008551515928486867493608757307981955335488977402307933930592035163126858060189156114410872337004784951228340994743202032248681976932591575016798640429231399974090325134545852080425047146251781339862753527319093938929691759486362536986249207187765947926921267520150073408188188 e = 65537 p1 = 1514296530850131082973956029074258536069144071110652176122006763622293335057110441067910479 q0 = 40812438243894343296354573724131194431453023461572200856406939246297219541329623 mod = pow(2,265) p0 = n*(gmpy2.invert(q0, mod))%mod pbar=(p1\u0026lt;\u0026lt;724)+p0 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) for i in range(32): f=pbar+x*mod*32 f=f.monic() pp=f.small_roots(X=2^454,beta=0.4) if(pp): break pbar+=mod p=int(pbar+pp[0]*32*mod) assert n%p==0 q = n//p phi = (p-1)*(q-1) d = gmpy2.invert(e,phi) m = pow(c, d, n) flag = long_to_bytes(m) print(flag) # b\u0026#39;flag{ef5e1582-8116-4f61-b458-f793dc03f2ff}\u0026#39; 0x3 Crazy_Rsa_Tech # from Crypto.Util.number import * from Crypto.Util.Padding import * FLAG = bytes_to_long(pad(b\u0026#34;flag{??????}\u0026#34;,64)) def init_key(): p, q = getPrime(512), getPrime(512) n = p*q e = 9 while(GCD((p-1)*(q-1),e)!=1): p, q = getPrime(512), getPrime(512) n = p*q d = inverse(e,(p-1)*(q-1)) return n,e,d n_list=list() c_list=list() for i in range(9): N,e,d=init_key() n_list.append(N) c=pow(FLAG,e,N) c_list.append(pow(FLAG,e,N)) assert(pow(c,d,N)==FLAG) print(\u0026#34;n_list:\u0026#34;,n_list) print(\u0026#34;c_list:\u0026#34;,c_list) 多组加密，而且加密的明文是一致的，直接使用CRT求解，写个CRT的脚本直接求解出flag：\nfrom Crypto.Util.number import * import gmpy2 n_list= [71189786319102608575263218254922479901008514616376166401353025325668690465852130559783959409002115897148828732231478529655075366072137059589917001875303598680931962384468363842379833044123189276199264340224973914079447846845897807085694711541719515881377391200011269924562049643835131619086349617062034608799, 92503831027754984321994282254005318198418454777812045042619263533423066848097985191386666241913483806726751133691867010696758828674382946375162423033994046273252417389169779506788545647848951018539441971140081528915876529645525880324658212147388232683347292192795975558548712504744297104487514691170935149949, 100993952830138414466948640139083231443558390127247779484027818354177479632421980458019929149817002579508423291678953554090956334137167905685261724759487245658147039684536216616744746196651390112540237050493468689520465897258378216693418610879245129435268327315158194612110422630337395790254881602124839071919, 59138293747457431012165762343997972673625934330232909935732464725128776212729547237438509546925172847581735769773563840639187946741161318153031173864953372796950422229629824699580131369991913883136821374596762214064774480548532035315344368010507644630655604478651898097886873485265848973185431559958627423847, 66827868958054485359731420968595906328820823695638132426084478524423658597714990545142120448668257273436546456116147999073797943388584861050133103137697812149742551913704341990467090049650721713913812069904136198912314243175309387952328961054617877059134151915723594900209641163321839502908705301293546584147, 120940513339890268554625391482989102665030083707530690312336379356969219966820079510946652021721814016286307318930536030308296265425674637215009052078834615196224917417698019787514831973471113022781129000531459800329018133248426080717653298100515701379374786486337920294380753805825328119757649844054966712377, 72186594495190221129349814154999705524005203343018940547856004977368023856950836974465616291478257156860734574686154136925776069045232149725101769594505766718123155028300703627531567850035682448632166309129911061492630709698934310123778699316856399909549674138453085885820110724923723830686564968967391721281, 69105037583161467265649176715175579387938714721653281201847973223975467813529036844308693237404592381480367515044829190066606146105800243199497182114398931410844901178842049915914390117503986044951461783780327749665912369177733246873697481544777183820939967036346862056795919812693669387731294595126647751951, 76194219445824867986050004226602973283400885106636660263597964027139613163638212828932901192009131346530898961165310615466747046710743013409318156266326090650584190382130795884514074647833949281109675170830565650006906028402714868781834693473191228256626654011772428115359653448111208831188721505467497494581] c_list= [62580922178008480377006528793506649089253164524883696044759651305970802215270721223149734532870729533611357047595181907404222690394917605617029675103788705320032707977225447998111744887898039756375876685711148857676502670812333076878964148863713993853526715855758799502735753454247721711366497722251078739585, 46186240819076690248235492196228128599822002268014359444368898414937734806009161030424589993541799877081745454934484263188270879142125136786221625234555265815513136730416539407710862948861531339065039071959576035606192732936477944770308784472646015244527805057990939765708793705044236665364664490419874206900, 85756449024868529058704599481168414715291172247059370174556127800630896693021701121075838517372920466708826412897794900729896389468152213884232173410022054605870785910461728567377769960823103334874807744107855490558726013068890632637193410610478514663078901021307258078678427928255699031215654693270240640198, 14388767329946097216670270960679686032536707277732968784379505904021622612991917314721678940833050736745004078559116326396233622519356703639737886289595860359630019239654690312132039876082685046329079266785042428947147658321799501605837784127004536996628492065409017175037161261039765340032473048737319069656, 1143736792108232890306863524988028098730927600066491485326214420279375304665896453544100447027809433141790331191324806205845009336228331138326163746853197990596700523328423791764843694671580875538251166864957646807184041817863314204516355683663859246677105132100377322669627893863885482167305919925159944839, 2978800921927631161807562509445310353414810029862911925227583943849942080514132963605492727604495513988707849133045851539412276254555228149742924149242124724864770049898278052042163392380895275970574317984638058768854065506927848951716677514095183559625442889028813635385408810698294574175092159389388091981, 16200944263352278316040095503540249310705602580329203494665614035841657418101517016718103326928336623132935178377208651067093136976383774189554806135146237406248538919915426183225265103769259990252162411307338473817114996409705345401251435268136647166395894099897737607312110866874944619080871831772376466376, 31551601425575677138046998360378916515711528548963089502535903329268089950335615563205720969393649713416910860593823506545030969355111753902391336139384464585775439245735448030993755229554555004154084649002801255396359097917380427525820249562148313977941413268787799534165652742114031759562268691233834820996, 25288164985739570635307839193110091356864302148147148153228604718807817833935053919412276187989509493755136905193728864674684139319708358686431424793278248263545370628718355096523088238513079652226028236137381367215156975121794485995030822902933639803569133458328681148758392333073624280222354763268512333515] e = 9 def CRT(aList, mList): M = 1 for i in mList: M = M * i x = 0 for i in range(len(mList)): Mi = M // mList[i] Mi_inverse = gmpy2.invert(Mi, mList[i]) x += aList[i] * Mi * Mi_inverse x = x % M return x m_e = CRT(c_list, n_list) m = gmpy2.iroot(m_e, e)[0] flag = long_to_bytes(m) print(flag) # b\u0026#39;flag{H0w_Fun_13_HAstads_broadca5t_AtTack!}\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\\x16\u0026#39; 运行脚本就能拿到本道题目的flag了！\nflag{H0w_Fun_13_HAstads_broadca5t_AtTack!} ","date":"January 29, 2022","permalink":"/posts/2021-%E9%B9%A4%E5%9F%8E%E6%9D%AF-crypto_writeup/","section":"Posts","summary":"2021-鹤城杯-Crypto Writeup # 鹤城杯的密码学题目，难度相对较低。但是也挺有意思的，可以学习点小知识。\n0x0 easy_Crypto # 签到题\n公正公正公正诚信文明公正民主公正法治法治诚信民主自由敬业公正友善公正平等平等法治民主平等平等和谐敬业自由诚信平等和谐平等公正法治法治平等平等爱国和谐公正平等敬业公正敬业自由敬业平等自由法治和谐平等文明自由诚信自由平等富强公正敬业平等民主公正诚信和谐公正文明公正爱国自由诚信自由平等文明公正诚信富强自由法治法治平等平等自由平等富强法治诚信和谐 社会主义核心价值观编码，直接解编码就可\nflag{IlUqU9O5guX6YiITsRNPiQmbhNRjGuTP} 0x1 A_Crypto # 传统密码学题目，应该是个套娃密码\n4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35 使用python的ciphey库进行求解就好\npython3 -m ciphey -t \u0026#34;4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35\u0026#34; 大约2s左右就能抛出flag了\n直接求解出传统密码学套娃题目的flag：\nflag{W0w_y0u_c4n_rea11y_enc0d1ng!} 0x2 babyrsa # from Crypto.Util.number import getPrime, bytes_to_long from secret import flag p = getPrime(1024) q = getPrime(1024) n = p * q e = 65537 hint1 = p \u0026gt;\u0026gt; 724 hint2 = q % (2 ** 265) ct = pow(bytes_to_long(flag), e, n) print(hint1) print(hint2) print(n) print(ct) 听大佬们说这是一道原题，我也不清楚是在哪里的原题，好像需要简单变化就能得到flag","title":"2021 鹤城杯 Crypto_Writeup"},{"content":"2021 美团网络安全 MT-CTF writup # 本菜鸡比较菜，有些安详，仅仅只搞出了两道题目。两道简单的密码学题目：\nSymbol # 非常奇怪的题目：\n题目是一堆奇奇怪怪的符号，对字符进行搜索找到其内涵含义后发现找到了LaTex关键字\n于是想起了写个人简历和公式会经常用到的LaTeX语言，查找一下LaTeX的字符表得到：\n$$ \\flat\\lambda\\alpha\\gamma\\{\\forall\\uplus\\nu\\_\\Lambda\\alpha\\Tau\\epsilon\\Xi\\_ M \\approx\\triangleleft\\hbar\\} $$ 根据代码的首字母可以得到：\nflag{fun_LaTeX_Math} 根据题目要求用md5进行加密，然后套一个flag得到\nflag{639220f4b70bb4a3ac80d95efcfb2353} hamburgerRSA # RSA的题目看下题目源码：\nfrom Crypto.Util.number import * flag = open(\u0026#39;flag.txt\u0026#39;).read() nbit = 64 while True: p, q = getPrime(nbit), getPrime(nbit) PP = int(str(p) + str(p) + str(q) + str(q)) QQ = int(str(q) + str(q) + str(p) + str(p)) if isPrime(PP) and isPrime(QQ): break n = PP * QQ m = bytes_to_long(flag.encode()) c = pow(m, 65537, n) print(\u0026#39;n =\u0026#39;, n) 发现生成算法有些奇怪，感觉p*q和PP*QQ应该有些关系，使用python测试着生成一下，观察一下规律：（不想具体推到关系了）\n写一个测试脚本：\nfrom Crypto.Util.number import * nbit = 64 while True: p, q = getPrime(nbit), getPrime(nbit) PP = int(str(p) + str(p) + str(q) + str(q)) QQ = int(str(q) + str(q) + str(p) + str(p)) if isPrime(PP) and isPrime(QQ): break n = PP * QQ N = p*q print(\u0026#34;n:{}\u0026#34;.format(n)) print(\u0026#34;N:{}\u0026#34;.format(N)) 运行下脚本可以发现：\nn的前19位与N的前19位一致，n的后19位与N的后19位一致，可以根据这个特点来进行简单爆破，使用一个sage脚本进行简单爆破：\nn = 177269125756508652546242326065138402971542751112423326033880862868822164234452280738170245589798474033047460920552550018968571267978283756742722231922451193 n1 = str(n)[:19] n2 = str(n)[-19:] print(n1) print(n2) for i in range(10): N = int(n1+str(i)+n2) result = factor(N) if(len(result) == 2): print(result) break 运行得到p和q的数据：\n9788542938580474429 * 18109858317913867117 然后根据得到的p和q的数据写个脚本：\nfrom Crypto.Util.number import * from gmpy2 import invert n = 177269125756508652546242326065138402971542751112423326033880862868822164234452280738170245589798474033047460920552550018968571267978283756742722231922451193 c = 47718022601324543399078395957095083753201631332808949406927091589044837556469300807728484035581447960954603540348152501053100067139486887367207461593404096 p, q = 9788542938580474429, 18109858317913867117 PP = int(str(p) + str(p) + str(q) + str(q)) QQ = int(str(q) + str(q) + str(p) + str(p)) phi = (PP-1)*(QQ-1) d = invert(65537,phi) m = pow(c, d, n) flag = long_to_bytes(m) print(flag) 运行脚本就可以得到flag：\nb\u0026#39;flag{f8d8bfa5-6c7f-14cb-908b-abc1e96946c6}\u0026#39; ","date":"January 29, 2022","permalink":"/posts/2021_%E7%BE%8E%E5%9B%A2_mt-ctf_writeup/","section":"Posts","summary":"2021 美团网络安全 MT-CTF writup # 本菜鸡比较菜，有些安详，仅仅只搞出了两道题目。两道简单的密码学题目：\nSymbol # 非常奇怪的题目：\n题目是一堆奇奇怪怪的符号，对字符进行搜索找到其内涵含义后发现找到了LaTex关键字\n于是想起了写个人简历和公式会经常用到的LaTeX语言，查找一下LaTeX的字符表得到：\n$$ \\flat\\lambda\\alpha\\gamma\\{\\forall\\uplus\\nu\\_\\Lambda\\alpha\\Tau\\epsilon\\Xi\\_ M \\approx\\triangleleft\\hbar\\} $$ 根据代码的首字母可以得到：\nflag{fun_LaTeX_Math} 根据题目要求用md5进行加密，然后套一个flag得到\nflag{639220f4b70bb4a3ac80d95efcfb2353} hamburgerRSA # RSA的题目看下题目源码：\nfrom Crypto.Util.number import * flag = open(\u0026#39;flag.txt\u0026#39;).read() nbit = 64 while True: p, q = getPrime(nbit), getPrime(nbit) PP = int(str(p) + str(p) + str(q) + str(q)) QQ = int(str(q) + str(q) + str(p) + str(p)) if isPrime(PP) and isPrime(QQ): break n = PP * QQ m = bytes_to_long(flag.","title":"2021_美团_MT CTF_Writeup"},{"content":"2021 羊城杯 Crypto部分 Writeup # 菜鸡Crypto手，就解出来了两道题，都是相对比较简单的密码学题目，供各位大佬参考\nBigRSA # 题目源码\nfrom Crypto.Util.number import * from flag import * n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061 n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073 e = 65537 m = bytes_to_long(flag) c = pow(m, e, n1) c = pow(c, e, n2) print(\u0026#34;c = %d\u0026#34; % c) # output # c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264 手速题目，可以通过n1和n2直接的关系。\nn1和n2经过测试是存在有一个不等于1的最大公约数，这个最大公约数显然就是共同的p，可以根据这一线索进行。然后就是两层的加密数值，求出两个q，然后再求出两个phi和d，然后这道题目就像剥洋葱一样简单了\nEXP：\nimport gmpy2 import libnum from Crypto.Util.number import * n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061 n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073 e = 65537 # m = bytes_to_long(flag) # c = pow(m, e, n1) # c = pow(c, e, n2) c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264 p =int(gmpy2.gcd(n1,n2)) q1 = n1//p q2 = n2//p assert p*q1 == n1 assert p*q2 == n2 phi1 = (p-1)*(q1-1) phi2 = (p-1)*(q2-1) d1 = libnum.invmod(e,phi1) d2 = libnum.invmod(e,phi2) c1 = pow(c,d2,n2) m = pow(c1,d1,n1) flag = long_to_bytes(m) print(flag) RingRingRing # 这道题目需要使用羊城杯官方的VPN进行连接，是一个远程的动态靶机，其实也就是一个身份认证加一个简单是数学运算题目，我是采用从简单的形式入手，由简单推向复杂，找出规律就行遍历求解。 $$ a^4+b^4+c^4+d^4 = e^2 $$ 题目关键点也就是这个公式，根据这个公式的特点： $$ 1^4 + 1^4 +1^4 + 1^4 = 2^2 $$\n$$ 2^4 + 2^4 + 2^4 + 2^4 = 8^2 $$\n$$ 4^4 + 4^4 + 4^4 + 4^4 = 32^2 $$\n根据简单的数据推测出规律性的公式 $$ (2^n)^4+(2^n)^4+(2^n)^4+(2^n)^4 = (2^{2n+1})^2 $$ 根据公式进行代码编写即可求解\nEXP：\nfrom pwn import * import string import hashlib import itertools sh = remote(\u0026#34;192.168.39.50\u0026#34;,2378) line = sh.recvline().decode().strip(\u0026#34;\\n\u0026#34;) ans = line[-5:] s2 = line[line.find(\u0026#34;+\u0026#34;)+2:line.find(\u0026#34;)\u0026#34;)] for i in itertools.product(string.ascii_letters + string.digits, repeat=4): s1 = \u0026#39;\u0026#39;.join(i) ss = s1 + s2 if (hashlib.md5(ss.encode()).hexdigest()[0:5] == ans): sh.sendline(s1) break context.log_level = \u0026#39;debug\u0026#39; sh.recvline() sh.recvline() for j in range(100): for i in range(4): sh.sendline(str(2**j)) sleep(1) sh.sendline(str(2**(2*j+1))) sleep(1) sh.interactive() ","date":"January 29, 2022","permalink":"/posts/2021-%E7%BE%8A%E5%9F%8E%E6%9D%AF-crypto%E9%83%A8%E5%88%86_writeup/","section":"Posts","summary":"2021 羊城杯 Crypto部分 Writeup # 菜鸡Crypto手，就解出来了两道题，都是相对比较简单的密码学题目，供各位大佬参考\nBigRSA # 题目源码\nfrom Crypto.Util.number import * from flag import * n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061 n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073 e = 65537 m = bytes_to_long(flag) c = pow(m, e, n1) c = pow(c, e, n2) print(\u0026#34;c = %d\u0026#34; % c) # output # c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264 手速题目，可以通过n1和n2直接的关系。\nn1和n2经过测试是存在有一个不等于1的最大公约数，这个最大公约数显然就是共同的p，可以根据这一线索进行。然后就是两层的加密数值，求出两个q，然后再求出两个phi和d，然后这道题目就像剥洋葱一样简单了\nEXP：\nimport gmpy2 import libnum from Crypto.Util.number import * n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061 n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073 e = 65537 # m = bytes_to_long(flag) # c = pow(m, e, n1) # c = pow(c, e, n2) c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264 p =int(gmpy2.","title":"2021 羊城杯 Crypto部分_Writeup"},{"content":"Jarvisoj-Basic writeup # JarvisOJ是浙江大学系统安全实验室(USS Lab.)学生Jarvis所开发的一个CTF在线答题系统。题目形式与各大CTF比赛相同。目的主要是为自己整理历次比赛题目供以后查阅以及测试的作用，同时开放给广大爱好信息安全的朋友，可以在这里一起学习，一起进步。\n浙江大学的CTF刷题平台，使用起来还是比较不错的。界面简洁易用。\nBasic模块的题目都是非常简单的练手题，刷一刷，玩一玩。顺便学习一些奇淫技巧，😏\n0x00 base64? # GUYDIMZVGQ2DMN3CGRQTONJXGM3TINLGG42DGMZXGM3TINLGGY4DGNBXGYZTGNLGGY3DGNBWMU3WI=== 看样子像是Base32编码，直接解编码得到：\n504354467b4a7573745f743373745f683476335f66346e7d hex编码解编码得到：\nPCTF{Just_t3st_h4v3_f4n} 0x01 关于USS Lab # USS的英文全称是什么，请全部小写并使用下划线连接_，并在外面加上PCTF{}之后提交 USS Lab是Jarvis OJ的主要承办单位，在刷题平台就能找到相关的信息\nflag已经显而易见了，非常简单\nPCTF{UBIQUITOUS_SYSTEM_SECURITY} 0x02 veryeasy # 使用基本命令获取flag 直接使用cat命令查看附件内容，或者strings命令查看附件内容\n就能得到flag：\nPCTF{strings_i5_3asy_isnt_i7} 0x03 段子 # 程序猿圈子里有个非常著名的段子： 手持两把锟斤拷，口中疾呼烫烫烫。 请提交其中\u0026#34;锟斤拷\u0026#34;的十六进制编码。(大写) FLAG: PCTF{你的答案} 锟斤拷，是一串经常在搜索引擎页面和其他网站上看到的乱码字符。乱码源于GBK字符集和Unicode字符集之间的转换问题。\n可以直接在python解释器上进行调试得到：\n\u0026#34;锟斤拷\u0026#34;.encode(\u0026#39;gbk\u0026#39;).hex().upper() # \u0026#39;EFBFBDEFBFBD\u0026#39; 故flag：\nPCTF{EFBFBDEFBFBD} 0x04 手贱 # 某天A君的网站被日，管理员密码被改，死活登不上，去数据库一看，啥，这密码md5不是和原来一样吗？为啥登不上咧？ d78b6f302l25cdc811adfe8d4e7c9fd34 请提交PCTF{原来的管理员密码} 挺无聊的题目的，题目给出的md5的长度是33位，需要删去一位来进行爆破\n使用python脚本迭代出可能的md5数值：\n# coding:utf8 myMd5 = \u0026#34;\u0026#34; for i in range(len(myMd5)): for j in range(len(myMd5)): if i == j: pass else: print myMd5[j], print \u0026#34;\u0026#34; 然后依次在cmd5网站进行解密，直到解出flag\n当然也可以使用python结合批量工具进行MD5求解，这就需要使用到彩虹表的工具进行求解。\n这里就不深入说明这个工具的使用，批量脚本确实很快，但是编写和生成彩虹表比较麻烦。\n经测试，flag：\nPCTF{hack} 0x05 美丽的实验室logo # 出题人丢下个logo就走了，大家自己看着办吧 附件是个好康的图片：\n使用Stegsolve.jar工具，使用Analyse的Frame Browsers直接看\n直接就是flag了：\nPCTF{You_are_R3ally_Car3ful} 0x06 veryeasyRSA # 已知RSA公钥生成参数： p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 求d = 请提交PCTF{d} 非常简单的RSA题目，一个脚本：\nimport gmpy2 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) print(d) # 19178568796155560423675975774142829153827883709027717723363077606260717434369 根据题目要求稍加处理就是flag：\nPCTF{19178568796155560423675975774142829153827883709027717723363077606260717434369} 0x07 神秘的文件 # 出题人太懒，还是就丢了个文件就走了，你能发现里面的秘密吗？ 可能是文件隐写，查看一下文件格式\nbinwalk haha 发现是一个磁盘文件，装载一下磁盘\nmount haha mnt 然后进入到磁盘，发现磁盘里面有很多文件，而且每个文件里面都是单个字符\n可以使用cat命令把所有文件的字符拼接\ncat * 得到输出结果：\nHaha ext2 file system is easy, and I know you can easily decompress of it and find the content in it.But the content is spilted in pieces can you make the pieces together. Now this is the flag PCTF{P13c3_7oghter_i7}. The rest is up to you. Cheer up, boy.cat: lost+found: Permission denied 可以清晰地看到flag：\nPCTF{P13c3_7oghter_i7} 思路和考察的角度还是比较简单，虽然只是记录下简单的题目\n0x08 公倍数 # 请计算1000000000以内3或5的倍数之和。 如：10以内这样的数有3,5,6,9，和是23 请提交PCTF{你的答案} 算法题目，非常简单就是有些吃内存\n#include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main() { ll a=1000000000; ll sum=0; for(ll i=1;i\u0026lt;a;i++) { if(i%3==0||i%5==0) { sum+=i; } } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; return 0; } 运行程序，就可以得到：\n233333333166666668 故本题的flag：\nflag{233333333166666668} 0x09 Easy Crackme # 应该是简单的逆向的题目，走下逆向的流程，使用DIE进行查看：\n64位ELF，先进行静态分析查看：\nint __cdecl main(int argc, const char **argv, const char **envp) { char v3; // cl char *v4; // rsi int v5; // edx int v6; // ecx int v7; // er8 int v8; // er9 char *v9; // rdx int v10; // ecx unsigned int v11; // eax bool v12; // zf int v13; // ecx __int64 v14; // rdx __int64 v15; // rdi char v17; // [rsp+0h] [rbp-38h] unsigned __int8 v18; // [rsp+10h] [rbp-28h] BYREF _BYTE v19[39]; // [rsp+11h] [rbp-27h] BYREF printf((unsigned int)\u0026#34;Input your password:\u0026#34;, (_DWORD)argv, (_DWORD)envp, v3); v4 = (char *)\u0026amp;v18; _isoc99_scanf((unsigned int)\u0026#34;%s\u0026#34;, (unsigned int)\u0026amp;v18, v5, v6, v7, v8, 171); v9 = (char *)\u0026amp;v18; do { v10 = *(_DWORD *)v9; v9 += 4; v11 = ~v10 \u0026amp; (v10 - 16843009) \u0026amp; 0x80808080; } while ( !v11 ); v12 = (~v10 \u0026amp; (v10 - 16843009) \u0026amp; 0x8080) == 0; if ( (~v10 \u0026amp; (v10 - 16843009) \u0026amp; 0x8080) == 0 ) LOBYTE(v11) = (~v10 \u0026amp; (v10 - 16843009) \u0026amp; 0x80808080) \u0026gt;\u0026gt; 16; LOBYTE(v13) = (_BYTE)v9 + 2; if ( v12 ) v9 += 2; v14 = \u0026amp;v9[-__CFADD__((_BYTE)v11, (_BYTE)v11) - 3] - (char *)\u0026amp;v18; if ( v14 == 26 ) { v15 = 0LL; v4 = v19; if ( (v18 ^ 0xAB) == list1 ) { while ( 1 ) { LODWORD(v14) = ((int)v15 + 1) / 6; v13 = ((int)v15 + 1) % 6; if ( (v19[v15] ^ (unsigned __int8)*(\u0026amp;v17 + v13)) != byte_6B41D1[v15] ) break; if ( ++v15 == 25 ) { printf((unsigned int)\u0026#34;Congratulations!\u0026#34;, (unsigned int)v19, v14, v13); return 0; } } } } printf((unsigned int)\u0026#34;Password Wrong!! Please try again.\u0026#34;, (_DWORD)v4, v14, v13); return 0; } 进行代码审计可以轻松手撸出解题程序：\n#include \u0026lt;iostream\u0026gt; int main() { int n[] = {251, 158, 103, 18, 78, 157, 152, 171, 0, 6, 70, 138, 244, 180, 6, 11, 67, 220, 217, 164, 108, 49, 116, 156, 210, 160}; int key[] = { 0xab, 0xdd, 0x33, 0x54, 0x35, 0xef }; for(size_t i = 0; i \u0026lt; 26; i++) putchar(n[i] ^ key[i % 6]); return 0; } 编译并运行程序可以得到：\nPCTF{r3v3Rse_i5_v3ry_eAsy} 0x0A Secret # web题目，可是这个平台的web题目炸了，不能继续开心地刷题了\n进入网站F12 然后使用F5查看请求头来拿到flag\nflag为：\nPCTF{Welcome_to_phrackCTF_2016} 0x0B 爱吃培根的出题人 # 看题目应该是培根密码，看下题目\n听说你也喜欢吃培根？那我们一起来欣赏一段培根的介绍吧： bacoN is one of aMerICa\u0026#39;S sWEethEartS. it\u0026#39;s A dARlinG, SuCCulEnt fOoD tHAt PaIRs FlawLE 什么，不知道要干什么？上面这段巨丑无比的文字，为什么会有大小写呢？你能发现其中的玄机吗？ 提交格式：PCTF{你发现的玄机} 看文段应该就是培根密码，直接进行解密：\nBACONISNOTFOOD 0x0C Easy RSA # 还记得veryeasy RSA吗？是不是不难？那继续来看看这题吧，这题也不难。 已知一段RSA加密的信息为：0xdc2eeeb2782c且已知加密所用的公钥： (N=322831561921859 e = 23) 请解密出明文，提交时请将数字转化为ascii码提交 比如你解出的明文是0x6162，那么请提交字符串ab 提交格式:PCTF{明文字符串} N的数值非常小，直接对N进行yafu大数分解可以得到：\np = 23781539 q = 13574881 知道p和q，直接一个脚本求解\nimport gmpy2 from Crypto.Util.number import long_to_bytes p = 23781539 q = 13574881 e = 23 n = 322831561921859 c = 0xdc2eeeb2782c phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c,d,n) flag = long_to_bytes(m) print(flag) # b\u0026#39;3a5Y\u0026#39; 根据题目要求，flag：\nPCTF{3a5Y} 0x0D ROPGadget # 都说学好汇编是学习PWN的基础，以下有一段ROPGadget的汇编指令序列，请提交其十六进制机器码(大写，不要有空格) XCHG EAX,ESP RET MOV ECX,[EAX] MOV [EDX],ECX POP EBX RET 提交格式：PCTF{你的答案} 非常简单，使用python的pwntools模块就可以进行求解\nfrom pwn import * print asm(\u0026#39;XCHG EAX,ESP\\nRET\\nMOV ECX,[EAX]\\nMOV [EDX],ECX\\nPOP EBX\\nRET\u0026#39;.lower()).encode(\u0026#39;hex\u0026#39;).upper() 运行得到：\n94C38B08890A5BC3 0x0E 取证 # 有一款取证神器如下图所示，可以从内存dump里分析出TureCrypt的密钥，你能找出这款软件的名字吗？名称请全部小写。 提交格式：PCTF{软件名字} 常识性题目，可以直接作答\nflag为：\nPCTF{volatility} 0x0F 熟悉的声音 # 两种不同的元素，如果是声音的话，听起来是不是很熟悉呢，据说前不久神盾局某位特工领便当了大家都很惋惜哦 XYYY YXXX XYXX XXY XYY X XYY YX YYXX 请提交PCTF{你的答案} 看样子像是，莫尔斯电码，转换成.-，使用Morse电码求解\n.--- -... .-.. ..- .-- . .-- -. --.. 使用Morse求解得到：\nJBLUWEWNZ 然后发现并不是有意义的字符串，这时候可能需要进行凯撒密码的处理就可以得到flag：\nPHRACKCTF 0x10 Baby’s Crack # 应该是道逆向题目，看下题目：\n既然是逆向题，我废话就不多说了，自己看着办吧。 先使用DIE进行探测吧：\n64位PE程序，使用x64 IDA pro的静态分析\nint __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax char Buffer[104]; // [rsp+20h] [rbp-80h] BYREF FILE *v5; // [rsp+88h] [rbp-18h] FILE *Stream; // [rsp+90h] [rbp-10h] char v7; // [rsp+9Fh] [rbp-1h] _main(); if ( argc \u0026lt;= 1 ) { printf(\u0026#34;Usage: %s [FileName]\\n\u0026#34;, *argv); printf(aFilename); exit(1); } Stream = fopen(argv[1], \u0026#34;rb+\u0026#34;); if ( Stream ) { v5 = fopen(\u0026#34;tmp\u0026#34;, \u0026#34;wb+\u0026#34;); while ( !feof(Stream) ) { v7 = fgetc(Stream); if ( v7 != -1 \u0026amp;\u0026amp; v7 ) { if ( v7 \u0026gt; 47 \u0026amp;\u0026amp; v7 \u0026lt;= 96 ) { v7 += 53; } else if ( v7 \u0026lt;= 46 ) { v7 += v7 % 11; } else { v7 -= v7 % 61; } fputc(v7, v5); } } fclose(v5); fclose(Stream); sprintf(Buffer, \u0026#34;del %s\u0026#34;, argv[1]); system(Buffer); sprintf(Buffer, \u0026#34;ren tmp %s\u0026#34;, argv[1]); system(Buffer); result = 0; } else { printf(\u0026amp;byte_40404B, argv[1]); result = -1; } return result; } 应该是一个非常简单的文件加密程序，看一下加密文件：\njeihjiiklwjnk{ljj{kflghhj{ilk{k{kij{ihlgkfkhkwhhjgly 加密后的字符串都是大于100的字符，可以根据代码：\nif ( v7 \u0026gt; 47 \u0026amp;\u0026amp; v7 \u0026lt;= 96 ) { v7 += 53; } 直接写个小程序进行破解：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string c = \u0026#34;jeihjiiklwjnk{ljj{kflghhj{ilk{k{kij{ihlgkfkhkwhhjgly\u0026#34;; for(auto s : c){ putchar(s-53); } return 0; } 编译并运行得到：\n504354467B596F755F6172335F476F6F645F437261636B33527D 然后对这段hex字符串进行解码：\nPCTF{You_ar3_Good_Crack3R} 0x11 Help!! # 出题人硬盘上找到一个神秘的压缩包，里面有个word文档，可是好像加密了呢~让我们一起分析一下吧！ 应该是一个MISC的题目，看看吧\n下载附件得到了一个zip加密的压缩文件，可能是伪加密的zip文件，使用 010 editor来进行修改下解伪加密就可以正常解压了\n得到一个word文件，下面就是丢到binwalk进行查看喽\n发现存在有两个图片文件，直接修改后缀名继续解压查看图片：\nflag就在图片里面\n0x12 Shellcode # 使用github上的工具：https://github.com/bdamele/shellcodeexec\n执行附件中的Shellcode就可以了\n成功拿到flag：\nPCTF{Begin_4_good_pwnn3r} 0x13 A Piece Of Cake # nit yqmg mqrqn bxw mtjtm nq rqni fiklvbxu mqrqnl xwg dvmnzxu lqjnyxmt xatwnl, rzn nit uxnntm xmt zlzxuuk mtjtmmtg nq xl rqnl. nitmt vl wq bqwltwlzl qw yivbi exbivwtl pzxuvjk xl mqrqnl rzn nitmt vl atwtmxu xamttetwn xeqwa tsftmnl, xwg nit fzruvb, nixn mqrqnl ntwg nq gq lqet qm xuu qj nit jquuqyvwa: xbbtfn tutbnmqwvb fmqamxeevwa, fmqbtll gxnx qm fiklvbxu ftmbtfnvqwl tutbnmqwvbxuuk, qftmxnt xznqwqeqzluk nq lqet gtamtt, eqdt xmqzwg, qftmxnt fiklvbxu fxmnl qj vnltuj qm fiklvbxu fmqbtlltl, ltwlt xwg exwvfzuxnt nitvm twdvmqwetwn, xwg tsivrvn vwntuuvatwn rtixdvqm - tlftbvxuuk rtixdvqm yivbi evevbl izexwl qm qnitm xwvexul. juxa vl lzrlnvnzntfxllvldtmktxlkkqzaqnvn. buqltuk mtuxntg nq nit bqwbtfn qj x mqrqn vl nit jvtug qj lkwnitnvb rvquqak, yivbi lnzgvtl twnvnvtl yiqlt wxnzmt vl eqmt bqefxmxrut nq rtvwal nixw nq exbivwtl. 直接丢到词频分析\nthe word robot can refer to both physical robots and virtual software agents, but the latter are usually referred to as bots. there is no consensus on which machines qualify as robots but there is general agreement among experts, and the public, that robots tend to do some or all of the following: accept electronic programming, process data or physical perceptions electronically, operate autonomously to some degree, move around, operate physical parts of itself or physical processes, sense and manipulate their environment, and exhibit intelligent behavior - especially behavior which mimics humans or other animals. flag is substitutepassisveryeasyyougotit. closely related to the concept of a robot is the field of synthetic biology, which studies entities whose nature is more comparable to beings than to machines. 直接看到flag：\nsubstitutepassisveryeasyyougotit 0x14 -.-字符串 # 请选手观察以下密文并转换成flag形式 ..-. .-.. .- --. ..... ..--- ..--- ----- .---- ---.. -.. -.... -.... ..... ...-- ---.. --... -.. .---- -.. .- ----. ...-- .---- ---.. .---- ..--- -... --... --... --... -.... ...-- ....- .---- ----- flag形式为32位大写md5 题目来源：CFF2016 直接进行Morse解码得到：\nFLAG522018D665387D1DA931812B77763410 这应该就是flag\n0x15 德军的密码 # 已知将一个flag以一种加密形式为使用密钥进行加密，使用密钥WELCOMETOCFF加密后密文为 000000000000000000000000000000000000000000000000000101110000110001000000101000000001 请分析出flag。Flag为12位大写字母 题目来源：CFF2016 二战中德国使用过的密码是费娜姆密码\n写个小程序进行异或操作就可：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { int data[] { 0b0000000,0b0000000,0b0000000,0b0000000,0b0000000,0b0000000,0b0000000,0b0010111, 0b0000110,0b0010000,0b0010100,0b0000001 }; char key[] = \u0026#34;WELCOMETOCFF\u0026#34;; for(size_t i;i\u0026lt;12;i++){ putchar(key[i]^data[i]); } return 0; } 编译并运行就可以得到flag：\nWELCOMECISRG 0x16 握手包 # 给你握手包，flag是Flag_is_here这个AP的密码，自己看着办吧。 提交格式：flag{WIFI密码} 把文件直接拖到kali里面，使用kali的工具进行破解\n用aircrack-ng命令进行破解\naircrack-ng wifi.cap -w /usr/share/wordlists/rockyou.txt 很快就可以破解出握手包的密码\n直接over了，flag即为：\nflag{11223344} ","date":"January 29, 2022","permalink":"/posts/jarvisoj-basic_writeup/","section":"Posts","summary":"Jarvisoj-Basic writeup # JarvisOJ是浙江大学系统安全实验室(USS Lab.)学生Jarvis所开发的一个CTF在线答题系统。题目形式与各大CTF比赛相同。目的主要是为自己整理历次比赛题目供以后查阅以及测试的作用，同时开放给广大爱好信息安全的朋友，可以在这里一起学习，一起进步。\n浙江大学的CTF刷题平台，使用起来还是比较不错的。界面简洁易用。\nBasic模块的题目都是非常简单的练手题，刷一刷，玩一玩。顺便学习一些奇淫技巧，😏\n0x00 base64? # GUYDIMZVGQ2DMN3CGRQTONJXGM3TINLGG42DGMZXGM3TINLGGY4DGNBXGYZTGNLGGY3DGNBWMU3WI=== 看样子像是Base32编码，直接解编码得到：\n504354467b4a7573745f743373745f683476335f66346e7d hex编码解编码得到：\nPCTF{Just_t3st_h4v3_f4n} 0x01 关于USS Lab # USS的英文全称是什么，请全部小写并使用下划线连接_，并在外面加上PCTF{}之后提交 USS Lab是Jarvis OJ的主要承办单位，在刷题平台就能找到相关的信息\nflag已经显而易见了，非常简单\nPCTF{UBIQUITOUS_SYSTEM_SECURITY} 0x02 veryeasy # 使用基本命令获取flag 直接使用cat命令查看附件内容，或者strings命令查看附件内容\n就能得到flag：\nPCTF{strings_i5_3asy_isnt_i7} 0x03 段子 # 程序猿圈子里有个非常著名的段子： 手持两把锟斤拷，口中疾呼烫烫烫。 请提交其中\u0026#34;锟斤拷\u0026#34;的十六进制编码。(大写) FLAG: PCTF{你的答案} 锟斤拷，是一串经常在搜索引擎页面和其他网站上看到的乱码字符。乱码源于GBK字符集和Unicode字符集之间的转换问题。\n可以直接在python解释器上进行调试得到：\n\u0026#34;锟斤拷\u0026#34;.encode(\u0026#39;gbk\u0026#39;).hex().upper() # \u0026#39;EFBFBDEFBFBD\u0026#39; 故flag：\nPCTF{EFBFBDEFBFBD} 0x04 手贱 # 某天A君的网站被日，管理员密码被改，死活登不上，去数据库一看，啥，这密码md5不是和原来一样吗？为啥登不上咧？ d78b6f302l25cdc811adfe8d4e7c9fd34 请提交PCTF{原来的管理员密码} 挺无聊的题目的，题目给出的md5的长度是33位，需要删去一位来进行爆破\n使用python脚本迭代出可能的md5数值：\n# coding:utf8 myMd5 = \u0026#34;\u0026#34; for i in range(len(myMd5)): for j in range(len(myMd5)): if i == j: pass else: print myMd5[j], print \u0026#34;\u0026#34; 然后依次在cmd5网站进行解密，直到解出flag","title":"Jarvisoj Basic_writeup"},{"content":"CTF整体规划 # CTF（Capture The Flag，夺旗赛）起源于 1996 年 DEFCON 全球黑客大会，是网络安全爱好者之间的竞技游戏。\nCTF 竞赛涉及众多领域，内容繁杂。与此同时，安全技术的发展速度越来越快，CTF 题目的难度越来越高，初学者面对的门槛越来越高。\n概述^1^ # CTF 的起源 # CTF 的前身是传统黑客之间的网络技术比拼游戏，起源于 1996 年第四届 DEFCON。\n早期 CTF 竞赛 # 第一个 CTF 比赛（1996 年 - 2001 年），没有明确的比赛规则，没有专业搭建的比赛平台与环境。由参数队伍各自准备比赛目标（自行准备与防守比赛目标，并要尝试攻破对方的比赛目标）。而组织者大都只是一些非专业的志愿者，接受参赛队伍手工计分的请求。\n没有后台自动系统支持和裁判技术能力认定，计分延迟和误差以及不可靠的网络和不当的配置，导致比赛带来了极大的争论与不满。\n「现代」CTF 竞赛 # 由专业队伍承担比赛平台、命题、赛事组织以及自动化积分系统。参赛队伍需提交参赛申请，由 DEFCON 会议组织者们进行评选。\n就 LegitBS 组织的三年 DEFCON CTF 比赛而言，有以下突出特点：\n比赛侧重于对计算机底层和系统安全的核心能力，Web 漏洞攻防技巧完全被忽略。 竞赛环境趋向多 CPU 指令架构集，多操作系统，多编程语言。 采用「零和」计分规则。 团队综合能力考验：逆向分析、漏洞挖掘、漏洞利用、漏洞修补加固、网络流量分析、系统安全运行维护以及安全方面的编程调试。 二级制安全规划 # Hacking 三部曲 # 理解系统（Understanding） 系统性地基础课程学习，深入理解计算机系统运作机制 破坏系统（Breaking） 学习与创造漏洞挖掘与利用技巧 重构系统（Reconstruction） 设计与构建系统防护 基础课程学习 # 核心基础课程 - 计算工作原理\n体系结构\nCPU的设计与实现 CMU 18-477\n机器指令与汇编语言 指令的解码、执行 内存管理 编译原理\n编译器的设计与实现 Stanford CS143\n自动机、词法分析、语法分析 运行时 程序静态分析 操作系统\n操作系统的设计与实现 MIT 6.828\n系统的加载与引导 用户态与内核态、系统调用、中断和驱动 进程与内存管理、文件系统 虚拟机 其他基础课程 - 系统软件开发基础\n编程语言 网络协议 算法与数据结构 漏洞挖掘与利用快速入门 - CTF # 蓝莲花战队CTF成长秘诀——坚持超过1年的以赛代练 CTF历史资料库：CTFs · GitHub Wargames https://pwnable.kr SmashTheStack Wargaming Network 漏洞挖掘与利用实战 # 如何从CTF赛棍转型 # CTF\n短时间 目标代码量小 漏洞容易发现 利用技巧千奇百怪 实战 - 长期做一道很难的CTF题\n长期 目标代码量大 漏洞难以发现 利用技术有套路可寻 目标 # 网络协议的实现 脚本引擎 内核 准备 # 学习历史漏洞 - CVEs 挖掘新漏洞 逆向分析 + 代码审计 快速逆向与理解 对漏洞的感觉 模糊测试 测试框架 样例生成想法 构建系统防护 # 漏洞自动挖掘技术\n静态程序分析 符号执行 机器学习 漏洞利用防护机制\nIntel SGX 控制流完整 拟态 WEB安全规划 # 漏洞类型 # 注入类\nSQL注入 XSS XEE 命令执行，命令注入 文件上传，文件下载 信息泄露\n源码泄露 敏感信息泄露 员工资料泄露 服务器信息泄露 逻辑类\n权限绕过 条件竞争 数据篡改 基础课程学习 # 核心基础课程 - 网站工作原理 # HTTP协议\nhttp-header构成\nhttp-body构成\nhttp方法\nWebserver\nWebserver分类 Webserver解析流程 Webserver基础安全 其他基础课程 - 软件开发基础 # 编程语言\n前端：html、js、css 后端、脚本语言：php、java、python 数据库原理\n关系型数据库 非关系型数据库 漏洞挖掘与利用 # 准备 # 信息收集工具\n端口 子域名 代码泄露 员工字典 数据包抓取修改重放工具\n顺手的浏览器以及插件\nVPS，漏洞验证\n挖掘 # 分析业务功能\n分析web架构\n针对性罗列可能的漏洞类型\n详细测试：不要放过任何一个数据包\n利用举例 # 单一利用\nGetshell 敏感信息接口 组合利用\nXss+csrf 相关资料 # CTF比赛详情\nCTFtime.org / All about CTF (Capture The Flag) CTF历史资料库\nCTFs · GitHub Wargames \u0026amp; Labs\nhttps://pwnable.kr SmashTheStack Wargaming Network Wargame.kr - 2.1 PentesterLab: Learn Web Penetration Testing: The Right Way OverTheWire: Wargames Homepage One - exploit-exercises.com 参考 # CTF 历史 - CTF Wiki (ctf-wiki.org) ","date":"January 29, 2022","permalink":"/posts/ctf%E6%95%B4%E4%BD%93%E8%A7%84%E5%88%92/","section":"Posts","summary":"CTF整体规划 # CTF（Capture The Flag，夺旗赛）起源于 1996 年 DEFCON 全球黑客大会，是网络安全爱好者之间的竞技游戏。\nCTF 竞赛涉及众多领域，内容繁杂。与此同时，安全技术的发展速度越来越快，CTF 题目的难度越来越高，初学者面对的门槛越来越高。\n概述^1^ # CTF 的起源 # CTF 的前身是传统黑客之间的网络技术比拼游戏，起源于 1996 年第四届 DEFCON。\n早期 CTF 竞赛 # 第一个 CTF 比赛（1996 年 - 2001 年），没有明确的比赛规则，没有专业搭建的比赛平台与环境。由参数队伍各自准备比赛目标（自行准备与防守比赛目标，并要尝试攻破对方的比赛目标）。而组织者大都只是一些非专业的志愿者，接受参赛队伍手工计分的请求。\n没有后台自动系统支持和裁判技术能力认定，计分延迟和误差以及不可靠的网络和不当的配置，导致比赛带来了极大的争论与不满。\n「现代」CTF 竞赛 # 由专业队伍承担比赛平台、命题、赛事组织以及自动化积分系统。参赛队伍需提交参赛申请，由 DEFCON 会议组织者们进行评选。\n就 LegitBS 组织的三年 DEFCON CTF 比赛而言，有以下突出特点：\n比赛侧重于对计算机底层和系统安全的核心能力，Web 漏洞攻防技巧完全被忽略。 竞赛环境趋向多 CPU 指令架构集，多操作系统，多编程语言。 采用「零和」计分规则。 团队综合能力考验：逆向分析、漏洞挖掘、漏洞利用、漏洞修补加固、网络流量分析、系统安全运行维护以及安全方面的编程调试。 二级制安全规划 # Hacking 三部曲 # 理解系统（Understanding） 系统性地基础课程学习，深入理解计算机系统运作机制 破坏系统（Breaking） 学习与创造漏洞挖掘与利用技巧 重构系统（Reconstruction） 设计与构建系统防护 基础课程学习 # 核心基础课程 - 计算工作原理\n体系结构","title":"CTF整体规划"},{"content":"","date":"January 29, 2022","permalink":"/categories/artcle/","section":"Categories","summary":"","title":"artcle"},{"content":"","date":"January 29, 2022","permalink":"/tags/think/","section":"Tags","summary":"","title":"Think"},{"content":"大学，未来 # 大学是一个知识分子的聚集地，是一个自由的学术殿堂。但是大学也有着很多限制和禁锢，大学生往往也在承受着社会的诸多压力。以上是我对于大学最基本的一种认识和一种观念上的思考。\n大学 # 什么是大学？我们为什么要上大学？\n我们年轻人往往存在着诸多迷茫和对于未来的种种困惑，我或许不能带来更多的思维上的超脱，但是我希望可以带来思维上的解放和独立\n大学是自由的学术空间，你可以在大学自由遨游，做任何自己想要做的事情，当然是在不违反大学规则的一种相对自由。大学的学术资源、知识资源和知识库存非常的丰富，在大学可以尽情的学习知识。在大学，你可以不受任何约束，去学习，去思考，去交谈，去恋爱等等。但是大学有不仅仅只是大学，大学有着诸多的现实性的因素和社会普遍观念的影响。因而，大学是一个人完全展现的自由空间，每个人都有着自己的自由世界和固有领域，相互交叉着，融合着形成了一种多元丰富的大学文化和大学空间。\n大学是一个个性发展的平台，同时大学也是一个思想碰撞和灵魂交错融合的空间。虽然现在社会上充斥着诸多的大学无用论和大学生的诸多问题。上大学究竟有没有用，或者说上大学的意义又是什么呢？寻找意义往往可能会是一种比较徒劳的过程，与其寻找意义倒不如去用自己的青春热血去创造意义，世界的未来必然是年轻人的天下和年轻人的一方天地。大学提升的往往不是一种知识层面上的增长，而更多的是一种精神层面和思维层面的增长，这些层次的增长会提升一个人的软实力和综合素质。这些能力的提升，必然会带来诸多方面的改变。因而，我们上大学有时不是为了改变我们自己，更多的是为了改变世界。\n学习 # 大学的主要组成成分是学习，但是又不仅仅是学习，但是更多的还是学习。 学习有广义和狭义之分，在大学之前的学习往往是一种狭义上的学习，在大学之后的学习往往是一种广义的学习。什么是狭义的学习？什么又是广义的学习？ 狭义的学习：指书本上知识内容或课堂内容的学习，这些学习到的知识往往都有着比较实质性的作用，比如应对考试、考证以及升学等诸多方面。 广义的学习：指更大范围的学习，一种终身学习的态度对待生活中的任何事情，知识的载体不仅限于书本和课堂，还有更多方面的载体，处处皆可学习，处处皆能学习。\n大学生之间的差异性往往在于学习的差异性，不同人对于学习的态度不同，对于学习的思考和思维方式不同，而带来了诸多方方面面的不同和差异性。我们大学生应该怎么进行学习？什么样的学习是有效的学习？\n很多大学生的学习方式往往都带有目的性，这个目的性往往指向期末考试和 GPA ，以及更多现实方面的意义。他们很多都是以 DDL 来鞭策自己，普遍具有拖延情况，而且很多大学生都缺乏正确的时间管理方法。于是，很多大学生就开始进行短期高效的学习。但是，这种学习往往都是不长久的学习。知识不能在大学生的思维深处内化，学习似乎变成了一种应付考试的短期用品，而不是一种长期的理念和生活方式。\n学习是大学生生活的一部分，更是要时时进行的一种思维训练和精神上的洗礼。学习可以给我们大学生带来一种视角和认知方式的改变，学习这个过程是苦乐交织的过程。通过学习知识，我们大学生可以更好地理解世界，更好地体会生命所带来的美好以及大学生活的意义。\n学习的方式有很多方面，学习本质是将信息转换为知识的过程。什么是信息?什么又是知识?信息就是我们日常生活所接触到的方方面面的可以影响决策的数据，知识就是根据一部分信息可以获取另一部分或者是推断出另一部分信息的模型或者是函数。要进行学习，首先需要获取信息，将信息整合成知识。或者将前人总结的知识进行模型化迁移进行内化和泛化处理。\n获取信息的途径有很多种，尤其在我们所处的信息时代中。我们可以通过互联网获得诸多信息，通过教学视频迁移前人或是他人的知识，通过阅读系统化地获取信息。对信息进行整合和转化的过程即是学习。\n信息获取的途径繁多，自然也带来了很多曾经没有的困境，即知识焦虑，信息迷茫问题。这些问题是伴随着信息时代所产生的一种问题，信息质量参差不齐，信息碎片化，信息数量大。这诸多情况，导致很多大学生不知道该对那些信息进行知识性转化。以及很多大学生不知道应该采取哪些渠道进行信息获取有效的知识并进行有效的学习。或许，也有很多人不知道该怎么去学习，或者他们根本并没有太多学习的欲望，把学习进行了泛化，进行着一种自我麻醉的学习。更可怕的是，他们却浑然不知，并且深深地沉浸在这种自我麻痹式的学习中。学习，也就是这样子了。\n信息的过滤和整合是学习过程中最美好的一个过程，也是最能体验到知识美好的一个过程，实现这个过程的方法很多，形式很多样化。每个人都有着自己的想法和自己的愿景，一般而言都会根据学习的原理进行个性化定制属于自己的那套学习方法。学习原理都是比较简单的内容，就是一种大脑思维的模型，大脑进行学习的工作原理，简而言之，学习就是获取知识的过程，学习原理也就是如何高效学习，即输入-计算-输出。构建这个知识模型，根据大脑的神经网络结构进行刻意练习，就是学习的本质也就是学习的原理。\n学习的方式因人而异，但是学习的原理一般都是具有普遍适应性的，具有非常好的兼容性。学习方法是根据学习原理来进行定制的，但是常见的学习方式一般有最近比较流行的思维导图，费曼学习法。其实，总的学习方法也是根据这两种学习方法进行个性化定制和改善的。还有一些学习方法是根据心理学上的一些原理和知识进行设计的，根据心理学的原理设计的方法很多都具有普遍性，由于这些方法都是针对人体本身的大脑思维原理的特点和优势进行开发和制作的。\n学习是个很大的话题，我所能介绍的不过也只是冰山一角，学习是大学生的任务，或者应该说是大学生的一种使命性的事情。我们大学生应该去面对学习这件事情，认真对待学习，在这个时代，知识就是力量。没有知识真的是寸步难行，特别是我们大学生。\n学习，从阅读一本书，做好每堂课程的笔记开始。\n知识 # 知识是具有普遍性通用性的特殊性的信息。在大学期间，我该去如何去考量知识呢？我们应该去选择哪些知识呢？\n现在社会焦虑开始不断扩大，各个层级开始不断出现内卷的现象，基于此。很多大学生也会受到社会或多或少的影响而去麻木地学习社会所需要的知识和内容。这些大学生进行这样的功利性学习是没有活力的学习，也不是说功利性学习不好，只是在我们这个相对和平安定的年代，我应该可以有选择知识的自由，遵从内心的想法，富有灵魂地学习一些自己所向往的知识领域。“爱你所爱，行你所行，听从你心，无问西东”，我们大学生应该有活力有激情地选择自己内心深处喜爱的知识，而不是仅仅被社会所束缚。知识，是灵动的，是富有生气的。\n知识和技能总会产生相应的联系。可以这么理解：\n知识是理论层面，就是大脑接收到的信息。 技能是实践层面，就是需要动手将信息有效利用。 现在计算机技术迭代迅速，计算机行业也是很多大学生争先恐后要去的方向。计算机行业是高薪行业，同时在这个浮躁且急功近利的社会中，大学生往往会更倾向于去选择这样的一个行业，因为未来就业可以相对比较容易，方向多，待遇方面相对较好。但是我们往往在追求功利的时候，我们可能往往变成了一个精致的利己主义者，这样真的是我们大学生学习知识和技能的意义吗？\n我们为什么学习知识？我们为什么学习技能？\n学习知识是为了更好的生活，更好的适应环境，毕竟物竞天择，适者生存嘛。但是我们大学应该拥有对于知识和技能更多的认识和见解，这些东西不应该只满足最低的生存需求，我们还有安全需求、归属寻求、自尊需求和自我实现需求。我们大学生，去学习那些知识应该尽可能去满足我们的自我实现需求，而生存需求、安全需求、归属需求等也就是在实现自我价值的过程中得到满足。\n知识，不仅仅只是书本上面的知识，还生活中的知识，知识就存在于我们身边，我们随处都可以学习。我们是否可以汲取到这些知识，取决于我们自己的内心，我们是否可以做到 “求知若渴，虚心若愚”。\n技能，不仅仅是枯燥无味的行动方针和工作方式，技能是富有灵魂和活动，是一种朝气蓬勃的动力和激情演绎出的具现化的知识。当我们使用技能的时候，我们应该是非常快乐而且非常愉悦的。\n我们应该保有我们自己所拥有的灵魂快乐与自我，去追求我们可以去追求的事情呀！\n“我为什么要那么努力， 因为我喜欢的东西都很贵， 我想去的地方都很远， 我爱的人超完美。”\n生活 # 生活总的来说，还是比生活艰难的，生活不止是学习，同时生活又在不断的和学习进行交融着，不确定我们究竟是在学习中生活还是在生活中学习。如果泛化学习的概念，学习可以说是无处不在的，到处都可以学习。泛化后的学习的形式不再仅仅局限于读书、记笔记而是展现于感官中的学习，即展现在听、说、读、写、思五个方面。这五个方面的学习可以融入到生活之中，进行相应的学习。那么生活是什么？\n生活是一个复杂集合体，每个人在生命过程中遇到的任何事情和任何发展以及想法都会扔到生活这个集合体中，但是我们每个人也在生活中，这些事情就会有生活再反馈给我们自身，在生活中遇到困难和烦恼，逃避是不能解决问题，有时候我们必须去面对生活中所产生的种种问题。生活中的问题其实都是由我们而生的，“人是一切社会关系的总和”，生活中的发生的事情，其实就是我们每一个人的社会关系所造成的一种效应。这种效应可能是显式的，也可能是隐式的，由于这种效应的存在。我们在生活中就好似被各种关系所连接的节点，与整个社会中的人群进行着交流和沟通，与他们产生羁绊和牵连。但是关系也只是生活的一个部分，还有一部分是自身因素所产生的，因而，总的来说，生活就是自身因素和自身的社会关系所产生的效应的集合体。\n我们应该怎样对待生活？自由的支配生活，还是被欲望所支配着看似自由的生活？大学生该如何生活才可以有一个光明的大学生活？这里产生很多问题和很多矛盾，很多大学生在纠结着该如何生活，很多大学生都很想奋进，很想努力去学习更多的知识，好好看看这个美丽的世界。但是，他们很多却被生活的压力和本能的反应所压制，而不知道该如何去正确的生活。正确往往存在于每个人的内心中，是否正确没有固定的标准和准则，准则存在于每个人的心中。\n很多时候，生活的意义一直在被很多人思考着、追寻着。我们可能并不了解生活究竟有什么样的意义和什么样的价值，仅仅只是将就着，被社会的理念和物质文化所牵动着，很多大学生的生活就被社会所物化，没有本真的活力和本真的激情。青年人，本应该是一种活力四射、激情盎然的样子，那气宇轩昂的志气。\n生活是年轻一代大学生自己所能做到的存在方式，这种存在方式取决于大学生自己的行为模式和思维模式，同时也影响着他们的模式。\n未来 # 未来，这是一个多么美好的词汇呀！\n但是，我们当代大学生或青年人的未来又会是什么样子呢？\n未来的大学生或青年人可以开心快乐，如果能够拥有足够强大的能力那就非常好了。\n为什么这样说呢？根据大学生近期情况的信息，不难察觉到当代大学生存在着很多不快乐的倾向，很多大学生都不是快乐的。这几年抑郁症的人群越来越大，而且患抑郁症的人群年龄在下调，人群分布似乎主要在年轻人的范围之内。很多年轻人都是不快乐的，为什么呢？原因可能是社会因素的影响，也可能是网络影响，总之诸多因素的影响下，年轻人面对着诸多的压力和焦虑情绪。而且，很多年轻人还没有完全适应信息时代高速发展所带来的冲击和不适，进而加剧了年轻人的焦虑情绪，而且网络上充斥着不少贩卖焦虑的文章和内容，更近一步加剧了年轻人的焦虑心理。这种心理不断演化、恶化。最终，抑郁症患者频出，抑郁症的患病率逐年升高。\n因而，开心快乐其实才是人生最美的时光，也是期许未来所能带来的最美好的回馈。\n最后 # 可能我的想法过于阴暗，过于偏激。可能我自己都不能搞清楚自己究竟是什么样子的恶魔，自己到底是什么样子的存在，也许，只是我看到太多比较阴暗的东西，我的观察角度往往只注意到了当代的大学生或年轻人的很多不足之处，只关注到了他们的阴暗面和阴暗的成分。\n我也只是一个大学生，我的想法可能也存在着很大的局限性，因为我还不能完全以局外人的身份去观测大学生这个群体。这些内容也仅仅只是我自己的个人见解罢了。\n我的经历是比较灰暗的，我能够观察到很多灰暗的细节性，虽然这有后期刻意练习观察力有关系吧。我的童年其实是非常静默的时光，我就像是一个隐匿的黑影，没有什么快乐的时光，仅仅只是呆呆地和父母一起生活，和自己生活。我曾经生活中确实是有一段时间，那段时间算是一段比较黄金的时光，那段时光里，我醉心于学习，沉迷于知识，没有太多物化的想法而内心满满只是一种仰望星空的蝶影。那段时间是在我的初中时期，我的高中时期是一个完全不一样的自我，一个从深渊中慢慢爬向另一个阴影中的自我，那时候我在不断不断地蜕变，看到了更多的光同时也看到了更多暗，也看到了完全不一样的世界风光。而进入大学时期，我也在不断地蜕变和改变着自己的生活方式，不断地学习各种个样的知识，去尽量抓住自己想要抓住的信息和知识，以及各种个样的机会。\n我也希望自己能够有一个比较好的规划，十年或是五年，自己也能有一个美好的梦想，去追逐，去努力实现。这篇文章本来就是写自己未来规划的文章，结果还是有点拖延呢，写着写着就写了很多很多乱七八糟的内容和想法吧。\n","date":"January 29, 2022","permalink":"/posts/%E5%A4%A7%E5%AD%A6%E6%9C%AA%E6%9D%A5/","section":"Posts","summary":"大学，未来 # 大学是一个知识分子的聚集地，是一个自由的学术殿堂。但是大学也有着很多限制和禁锢，大学生往往也在承受着社会的诸多压力。以上是我对于大学最基本的一种认识和一种观念上的思考。\n大学 # 什么是大学？我们为什么要上大学？\n我们年轻人往往存在着诸多迷茫和对于未来的种种困惑，我或许不能带来更多的思维上的超脱，但是我希望可以带来思维上的解放和独立\n大学是自由的学术空间，你可以在大学自由遨游，做任何自己想要做的事情，当然是在不违反大学规则的一种相对自由。大学的学术资源、知识资源和知识库存非常的丰富，在大学可以尽情的学习知识。在大学，你可以不受任何约束，去学习，去思考，去交谈，去恋爱等等。但是大学有不仅仅只是大学，大学有着诸多的现实性的因素和社会普遍观念的影响。因而，大学是一个人完全展现的自由空间，每个人都有着自己的自由世界和固有领域，相互交叉着，融合着形成了一种多元丰富的大学文化和大学空间。\n大学是一个个性发展的平台，同时大学也是一个思想碰撞和灵魂交错融合的空间。虽然现在社会上充斥着诸多的大学无用论和大学生的诸多问题。上大学究竟有没有用，或者说上大学的意义又是什么呢？寻找意义往往可能会是一种比较徒劳的过程，与其寻找意义倒不如去用自己的青春热血去创造意义，世界的未来必然是年轻人的天下和年轻人的一方天地。大学提升的往往不是一种知识层面上的增长，而更多的是一种精神层面和思维层面的增长，这些层次的增长会提升一个人的软实力和综合素质。这些能力的提升，必然会带来诸多方面的改变。因而，我们上大学有时不是为了改变我们自己，更多的是为了改变世界。\n学习 # 大学的主要组成成分是学习，但是又不仅仅是学习，但是更多的还是学习。 学习有广义和狭义之分，在大学之前的学习往往是一种狭义上的学习，在大学之后的学习往往是一种广义的学习。什么是狭义的学习？什么又是广义的学习？ 狭义的学习：指书本上知识内容或课堂内容的学习，这些学习到的知识往往都有着比较实质性的作用，比如应对考试、考证以及升学等诸多方面。 广义的学习：指更大范围的学习，一种终身学习的态度对待生活中的任何事情，知识的载体不仅限于书本和课堂，还有更多方面的载体，处处皆可学习，处处皆能学习。\n大学生之间的差异性往往在于学习的差异性，不同人对于学习的态度不同，对于学习的思考和思维方式不同，而带来了诸多方方面面的不同和差异性。我们大学生应该怎么进行学习？什么样的学习是有效的学习？\n很多大学生的学习方式往往都带有目的性，这个目的性往往指向期末考试和 GPA ，以及更多现实方面的意义。他们很多都是以 DDL 来鞭策自己，普遍具有拖延情况，而且很多大学生都缺乏正确的时间管理方法。于是，很多大学生就开始进行短期高效的学习。但是，这种学习往往都是不长久的学习。知识不能在大学生的思维深处内化，学习似乎变成了一种应付考试的短期用品，而不是一种长期的理念和生活方式。\n学习是大学生生活的一部分，更是要时时进行的一种思维训练和精神上的洗礼。学习可以给我们大学生带来一种视角和认知方式的改变，学习这个过程是苦乐交织的过程。通过学习知识，我们大学生可以更好地理解世界，更好地体会生命所带来的美好以及大学生活的意义。\n学习的方式有很多方面，学习本质是将信息转换为知识的过程。什么是信息?什么又是知识?信息就是我们日常生活所接触到的方方面面的可以影响决策的数据，知识就是根据一部分信息可以获取另一部分或者是推断出另一部分信息的模型或者是函数。要进行学习，首先需要获取信息，将信息整合成知识。或者将前人总结的知识进行模型化迁移进行内化和泛化处理。\n获取信息的途径有很多种，尤其在我们所处的信息时代中。我们可以通过互联网获得诸多信息，通过教学视频迁移前人或是他人的知识，通过阅读系统化地获取信息。对信息进行整合和转化的过程即是学习。\n信息获取的途径繁多，自然也带来了很多曾经没有的困境，即知识焦虑，信息迷茫问题。这些问题是伴随着信息时代所产生的一种问题，信息质量参差不齐，信息碎片化，信息数量大。这诸多情况，导致很多大学生不知道该对那些信息进行知识性转化。以及很多大学生不知道应该采取哪些渠道进行信息获取有效的知识并进行有效的学习。或许，也有很多人不知道该怎么去学习，或者他们根本并没有太多学习的欲望，把学习进行了泛化，进行着一种自我麻醉的学习。更可怕的是，他们却浑然不知，并且深深地沉浸在这种自我麻痹式的学习中。学习，也就是这样子了。\n信息的过滤和整合是学习过程中最美好的一个过程，也是最能体验到知识美好的一个过程，实现这个过程的方法很多，形式很多样化。每个人都有着自己的想法和自己的愿景，一般而言都会根据学习的原理进行个性化定制属于自己的那套学习方法。学习原理都是比较简单的内容，就是一种大脑思维的模型，大脑进行学习的工作原理，简而言之，学习就是获取知识的过程，学习原理也就是如何高效学习，即输入-计算-输出。构建这个知识模型，根据大脑的神经网络结构进行刻意练习，就是学习的本质也就是学习的原理。\n学习的方式因人而异，但是学习的原理一般都是具有普遍适应性的，具有非常好的兼容性。学习方法是根据学习原理来进行定制的，但是常见的学习方式一般有最近比较流行的思维导图，费曼学习法。其实，总的学习方法也是根据这两种学习方法进行个性化定制和改善的。还有一些学习方法是根据心理学上的一些原理和知识进行设计的，根据心理学的原理设计的方法很多都具有普遍性，由于这些方法都是针对人体本身的大脑思维原理的特点和优势进行开发和制作的。\n学习是个很大的话题，我所能介绍的不过也只是冰山一角，学习是大学生的任务，或者应该说是大学生的一种使命性的事情。我们大学生应该去面对学习这件事情，认真对待学习，在这个时代，知识就是力量。没有知识真的是寸步难行，特别是我们大学生。\n学习，从阅读一本书，做好每堂课程的笔记开始。\n知识 # 知识是具有普遍性通用性的特殊性的信息。在大学期间，我该去如何去考量知识呢？我们应该去选择哪些知识呢？\n现在社会焦虑开始不断扩大，各个层级开始不断出现内卷的现象，基于此。很多大学生也会受到社会或多或少的影响而去麻木地学习社会所需要的知识和内容。这些大学生进行这样的功利性学习是没有活力的学习，也不是说功利性学习不好，只是在我们这个相对和平安定的年代，我应该可以有选择知识的自由，遵从内心的想法，富有灵魂地学习一些自己所向往的知识领域。“爱你所爱，行你所行，听从你心，无问西东”，我们大学生应该有活力有激情地选择自己内心深处喜爱的知识，而不是仅仅被社会所束缚。知识，是灵动的，是富有生气的。\n知识和技能总会产生相应的联系。可以这么理解：\n知识是理论层面，就是大脑接收到的信息。 技能是实践层面，就是需要动手将信息有效利用。 现在计算机技术迭代迅速，计算机行业也是很多大学生争先恐后要去的方向。计算机行业是高薪行业，同时在这个浮躁且急功近利的社会中，大学生往往会更倾向于去选择这样的一个行业，因为未来就业可以相对比较容易，方向多，待遇方面相对较好。但是我们往往在追求功利的时候，我们可能往往变成了一个精致的利己主义者，这样真的是我们大学生学习知识和技能的意义吗？\n我们为什么学习知识？我们为什么学习技能？\n学习知识是为了更好的生活，更好的适应环境，毕竟物竞天择，适者生存嘛。但是我们大学应该拥有对于知识和技能更多的认识和见解，这些东西不应该只满足最低的生存需求，我们还有安全需求、归属寻求、自尊需求和自我实现需求。我们大学生，去学习那些知识应该尽可能去满足我们的自我实现需求，而生存需求、安全需求、归属需求等也就是在实现自我价值的过程中得到满足。\n知识，不仅仅只是书本上面的知识，还生活中的知识，知识就存在于我们身边，我们随处都可以学习。我们是否可以汲取到这些知识，取决于我们自己的内心，我们是否可以做到 “求知若渴，虚心若愚”。\n技能，不仅仅是枯燥无味的行动方针和工作方式，技能是富有灵魂和活动，是一种朝气蓬勃的动力和激情演绎出的具现化的知识。当我们使用技能的时候，我们应该是非常快乐而且非常愉悦的。\n我们应该保有我们自己所拥有的灵魂快乐与自我，去追求我们可以去追求的事情呀！\n“我为什么要那么努力， 因为我喜欢的东西都很贵， 我想去的地方都很远， 我爱的人超完美。”\n生活 # 生活总的来说，还是比生活艰难的，生活不止是学习，同时生活又在不断的和学习进行交融着，不确定我们究竟是在学习中生活还是在生活中学习。如果泛化学习的概念，学习可以说是无处不在的，到处都可以学习。泛化后的学习的形式不再仅仅局限于读书、记笔记而是展现于感官中的学习，即展现在听、说、读、写、思五个方面。这五个方面的学习可以融入到生活之中，进行相应的学习。那么生活是什么？\n生活是一个复杂集合体，每个人在生命过程中遇到的任何事情和任何发展以及想法都会扔到生活这个集合体中，但是我们每个人也在生活中，这些事情就会有生活再反馈给我们自身，在生活中遇到困难和烦恼，逃避是不能解决问题，有时候我们必须去面对生活中所产生的种种问题。生活中的问题其实都是由我们而生的，“人是一切社会关系的总和”，生活中的发生的事情，其实就是我们每一个人的社会关系所造成的一种效应。这种效应可能是显式的，也可能是隐式的，由于这种效应的存在。我们在生活中就好似被各种关系所连接的节点，与整个社会中的人群进行着交流和沟通，与他们产生羁绊和牵连。但是关系也只是生活的一个部分，还有一部分是自身因素所产生的，因而，总的来说，生活就是自身因素和自身的社会关系所产生的效应的集合体。\n我们应该怎样对待生活？自由的支配生活，还是被欲望所支配着看似自由的生活？大学生该如何生活才可以有一个光明的大学生活？这里产生很多问题和很多矛盾，很多大学生在纠结着该如何生活，很多大学生都很想奋进，很想努力去学习更多的知识，好好看看这个美丽的世界。但是，他们很多却被生活的压力和本能的反应所压制，而不知道该如何去正确的生活。正确往往存在于每个人的内心中，是否正确没有固定的标准和准则，准则存在于每个人的心中。\n很多时候，生活的意义一直在被很多人思考着、追寻着。我们可能并不了解生活究竟有什么样的意义和什么样的价值，仅仅只是将就着，被社会的理念和物质文化所牵动着，很多大学生的生活就被社会所物化，没有本真的活力和本真的激情。青年人，本应该是一种活力四射、激情盎然的样子，那气宇轩昂的志气。\n生活是年轻一代大学生自己所能做到的存在方式，这种存在方式取决于大学生自己的行为模式和思维模式，同时也影响着他们的模式。\n未来 # 未来，这是一个多么美好的词汇呀！\n但是，我们当代大学生或青年人的未来又会是什么样子呢？\n未来的大学生或青年人可以开心快乐，如果能够拥有足够强大的能力那就非常好了。\n为什么这样说呢？根据大学生近期情况的信息，不难察觉到当代大学生存在着很多不快乐的倾向，很多大学生都不是快乐的。这几年抑郁症的人群越来越大，而且患抑郁症的人群年龄在下调，人群分布似乎主要在年轻人的范围之内。很多年轻人都是不快乐的，为什么呢？原因可能是社会因素的影响，也可能是网络影响，总之诸多因素的影响下，年轻人面对着诸多的压力和焦虑情绪。而且，很多年轻人还没有完全适应信息时代高速发展所带来的冲击和不适，进而加剧了年轻人的焦虑情绪，而且网络上充斥着不少贩卖焦虑的文章和内容，更近一步加剧了年轻人的焦虑心理。这种心理不断演化、恶化。最终，抑郁症患者频出，抑郁症的患病率逐年升高。\n因而，开心快乐其实才是人生最美的时光，也是期许未来所能带来的最美好的回馈。\n最后 # 可能我的想法过于阴暗，过于偏激。可能我自己都不能搞清楚自己究竟是什么样子的恶魔，自己到底是什么样子的存在，也许，只是我看到太多比较阴暗的东西，我的观察角度往往只注意到了当代的大学生或年轻人的很多不足之处，只关注到了他们的阴暗面和阴暗的成分。\n我也只是一个大学生，我的想法可能也存在着很大的局限性，因为我还不能完全以局外人的身份去观测大学生这个群体。这些内容也仅仅只是我自己的个人见解罢了。\n我的经历是比较灰暗的，我能够观察到很多灰暗的细节性，虽然这有后期刻意练习观察力有关系吧。我的童年其实是非常静默的时光，我就像是一个隐匿的黑影，没有什么快乐的时光，仅仅只是呆呆地和父母一起生活，和自己生活。我曾经生活中确实是有一段时间，那段时间算是一段比较黄金的时光，那段时光里，我醉心于学习，沉迷于知识，没有太多物化的想法而内心满满只是一种仰望星空的蝶影。那段时间是在我的初中时期，我的高中时期是一个完全不一样的自我，一个从深渊中慢慢爬向另一个阴影中的自我，那时候我在不断不断地蜕变，看到了更多的光同时也看到了更多暗，也看到了完全不一样的世界风光。而进入大学时期，我也在不断地蜕变和改变着自己的生活方式，不断地学习各种个样的知识，去尽量抓住自己想要抓住的信息和知识，以及各种个样的机会。\n我也希望自己能够有一个比较好的规划，十年或是五年，自己也能有一个美好的梦想，去追逐，去努力实现。这篇文章本来就是写自己未来规划的文章，结果还是有点拖延呢，写着写着就写了很多很多乱七八糟的内容和想法吧。","title":"大学,未来"},{"content":"数学之美，程序之巧 # 计算机程序，简单来说，就是指令和数据的组合。程序可以通过算法组成相应的逻辑系统，逻辑系统可以根据编写者需求来完成各种各样的事情。\n计算机内部数据处理方式是什么样？\n这个问题可以从机器语言开始说起，如果要说到机器语言自然就要聊一聊编程语言喽：\n编程语言（英语：programming language），是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种能够让程序员准确地定义计算机所需要使用数据的计算机语言，并精确地定义在不同情况下所应当采取的行动。^1^\n机器语言是编程语言最初的一个代表，机器语言的表示方式通常是101010的二进制方式，这也是计算机运行最底层的内容和最底层的模块，在101010的运算模式是非常适合计算机进行计算的。编程就是数据和指令的集合，而计算机就是将101010的二进制数字进行运算，计算机的运算方式通常由逻辑运算和算术运算。但是这和数学有什么关系吗？计算机的运算是数学理论产生的产物，集成电路上闪动的光波，跳动的粒子都是多少数学家理论的产物呀！\n话说回来，机器语言现在几乎都不使用，都在使用高级编程语言。根据现在的情况，编程语言有大致三代。第一代编程语言是机器语言，编写非常复杂。第二代编程语言是汇编语言，编写相对机器语言简单了许多，但是仍然是比较复杂的语言。第三代编程语言是现在非常经常使用的高级编程语言，C语言，C++语言，Java语言等静态语言以及Python，PHP，Ruby，JavaScript等动态语言。发展到第三代编程语言，编程的难度大大降低。\n但是，编程和数学有什么关系呢？\n个人认为，编程本身是美的，数学亦是美的。编程的美是基于数学的逻辑，数学的理论和数学中的各种各样的奇妙变换。编程如果接触到了比较底层的内容，也就到了最核心的部分——数据结构和算法，而数据结构和算法很多的知识都是基于数学的思考。这里用算法里面的时间复杂度和数学中的微积分做一下对比：\n$$ O(n \\cdot \\ln:n) $$\n$$ f(x) = n \\cdot \\ln : n $$\n这两个公式是非常相像的，而时间复杂度的比较其实也是基于微积分中极限的概念进行比较的。\n如果要比较 (O(\\ln : n)) 和 (O(n))的时间复杂度，该怎么比较呢？\n这里可以使用微积分中的无穷小比较来进行比较的，同样是采用微积分中的极限的思想来进行比较的：\n$$ \\lim_{x \\to +\\infty} \\frac{\\ln : n}{n} = 0 $$\n这个式子在微积分中是非常常见的概念，通过数学的证明来证明这个结论。根据这个结论就可以非常容易的判断出时间复杂度之间的大小。这是数学在编程算法中的一个应用。通过这个应用可以说明计算机编程和数学之间的微妙关系。\n进行数学问题研究的人员往往是高深的数学家，而进行计算机编程的人员往往是秃头的程序员，程序员很少研究数学问题，但是程序员也了解一部分数学知识。而数学家和程序员之间又有什么关系呢？\n程序员是敲代码，负责对功能的实现，是应用方面的。而数学家是解决数学问题的，使用数学优美的证明和严谨的逻辑来证明数学问题，是理论方面的。看起来是没有什么必然的联系，其实进行连接的中介就是计算机科学家，他们负责对计算机理论的研究和算法的创新求解，他们会整合数学家的最新的研究成功并尝试融入到计算机理论中去。程序员可以从计算机理论中的很多相关内容中，进行代码和设计方面的功能实现，优化服务。\n现在的大时代趋势是万物互联，每个学科都不在是孤立存在的学科，学科之间彼此有着多重的交叉。随着时代的进步，学科交叉应该会越来越明显，而计算机和数学关系是非常密切的，应该会最先进行交叉研究，其实现在已经进行交叉研究了。\n我个人认为程序员应该是有一种对于数学的热爱，看到数学优美的证明会心生惊叹，面对数学问题会竭尽全力去攻克数学问题。其实这其实也是程序员对于程序和代码的一种态度，一种专业素养。程序员往往都会追求完美，希望程序可以不断优化不断进行完善，更少的BUG，更高的性能。这无非不是对于数学赞扬和感叹。\n数学之美，程序之巧，尽展心中，会现颅内。\n参考 # 编程语言-维基百科 闲聊到此为止，来喝杯茶可好？\n","date":"January 29, 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E7%A8%8B%E5%BA%8F%E4%B9%8B%E5%B7%A7/","section":"Posts","summary":"数学之美，程序之巧 # 计算机程序，简单来说，就是指令和数据的组合。程序可以通过算法组成相应的逻辑系统，逻辑系统可以根据编写者需求来完成各种各样的事情。\n计算机内部数据处理方式是什么样？\n这个问题可以从机器语言开始说起，如果要说到机器语言自然就要聊一聊编程语言喽：\n编程语言（英语：programming language），是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种能够让程序员准确地定义计算机所需要使用数据的计算机语言，并精确地定义在不同情况下所应当采取的行动。^1^\n机器语言是编程语言最初的一个代表，机器语言的表示方式通常是101010的二进制方式，这也是计算机运行最底层的内容和最底层的模块，在101010的运算模式是非常适合计算机进行计算的。编程就是数据和指令的集合，而计算机就是将101010的二进制数字进行运算，计算机的运算方式通常由逻辑运算和算术运算。但是这和数学有什么关系吗？计算机的运算是数学理论产生的产物，集成电路上闪动的光波，跳动的粒子都是多少数学家理论的产物呀！\n话说回来，机器语言现在几乎都不使用，都在使用高级编程语言。根据现在的情况，编程语言有大致三代。第一代编程语言是机器语言，编写非常复杂。第二代编程语言是汇编语言，编写相对机器语言简单了许多，但是仍然是比较复杂的语言。第三代编程语言是现在非常经常使用的高级编程语言，C语言，C++语言，Java语言等静态语言以及Python，PHP，Ruby，JavaScript等动态语言。发展到第三代编程语言，编程的难度大大降低。\n但是，编程和数学有什么关系呢？\n个人认为，编程本身是美的，数学亦是美的。编程的美是基于数学的逻辑，数学的理论和数学中的各种各样的奇妙变换。编程如果接触到了比较底层的内容，也就到了最核心的部分——数据结构和算法，而数据结构和算法很多的知识都是基于数学的思考。这里用算法里面的时间复杂度和数学中的微积分做一下对比：\n$$ O(n \\cdot \\ln:n) $$\n$$ f(x) = n \\cdot \\ln : n $$\n这两个公式是非常相像的，而时间复杂度的比较其实也是基于微积分中极限的概念进行比较的。\n如果要比较 (O(\\ln : n)) 和 (O(n))的时间复杂度，该怎么比较呢？\n这里可以使用微积分中的无穷小比较来进行比较的，同样是采用微积分中的极限的思想来进行比较的：\n$$ \\lim_{x \\to +\\infty} \\frac{\\ln : n}{n} = 0 $$\n这个式子在微积分中是非常常见的概念，通过数学的证明来证明这个结论。根据这个结论就可以非常容易的判断出时间复杂度之间的大小。这是数学在编程算法中的一个应用。通过这个应用可以说明计算机编程和数学之间的微妙关系。\n进行数学问题研究的人员往往是高深的数学家，而进行计算机编程的人员往往是秃头的程序员，程序员很少研究数学问题，但是程序员也了解一部分数学知识。而数学家和程序员之间又有什么关系呢？\n程序员是敲代码，负责对功能的实现，是应用方面的。而数学家是解决数学问题的，使用数学优美的证明和严谨的逻辑来证明数学问题，是理论方面的。看起来是没有什么必然的联系，其实进行连接的中介就是计算机科学家，他们负责对计算机理论的研究和算法的创新求解，他们会整合数学家的最新的研究成功并尝试融入到计算机理论中去。程序员可以从计算机理论中的很多相关内容中，进行代码和设计方面的功能实现，优化服务。\n现在的大时代趋势是万物互联，每个学科都不在是孤立存在的学科，学科之间彼此有着多重的交叉。随着时代的进步，学科交叉应该会越来越明显，而计算机和数学关系是非常密切的，应该会最先进行交叉研究，其实现在已经进行交叉研究了。\n我个人认为程序员应该是有一种对于数学的热爱，看到数学优美的证明会心生惊叹，面对数学问题会竭尽全力去攻克数学问题。其实这其实也是程序员对于程序和代码的一种态度，一种专业素养。程序员往往都会追求完美，希望程序可以不断优化不断进行完善，更少的BUG，更高的性能。这无非不是对于数学赞扬和感叹。\n数学之美，程序之巧，尽展心中，会现颅内。\n参考 # 编程语言-维基百科 闲聊到此为止，来喝杯茶可好？","title":"数学之美,程序之巧"},{"content":"浅谈椭圆曲线加密算法（ECC） # 椭圆曲线加密算法是近十年提出的一个非对称加密算法，这个加密算法非常复杂，加密的数据具有良好的保密性。加密效果比RSA加密算法都高。这次不可能全部将ECC加密算法讲完，只能简单聊聊ECC加密算法的基本概念和ECC加密算法的数学基础了。\n什么是ECC加密算法？\n椭圆曲线密码学（英语：Elliptic Curve Cryptography，缩写：ECC）是一种基于椭圆曲线数学的公开密钥加密算法。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz（英语：Neal Koblitz）和Victor Miller（英语：Victor Miller）分别独立提出的。\nECC的主要优势是它相比RSA加密算法使用较小的密钥长度并提供相当等级的安全性[1]。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。^1^\n椭圆曲线加密算法，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全，RSA加密算法也是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密（有待考证）。^2^\nECC加密算法需要的数学理论基础相对来说是比较高的层次方面，远比RSA的数学难度高。看来，数学上层理论的基础是对密码学产生了比较大的影响。下面，来简单聊聊数学基础吧。\n数学基础 # 阿贝尔群 # 刚看到这个的时候，我的第一反应是：这是什么东西？（一脸懵逼）\n阿贝尔群其实就是针对椭圆曲线的概念抽象的一个群，简单来说就是针对椭圆曲线的加减乘除规则。概念的变换，就像刚开始学习微积分的加减乘除规则转换到矩阵的加减乘除规律一样。群其实就是一种推广的矩阵。那么，阿贝尔群定义了些什么有趣的东西呢？\n封闭性：如果$ a $和$ b $ 都是阿贝尔群的成员，那么 $ a + b $ 也是阿贝尔群的成员 结合律：$ (a+b)+c=a+(b+c) $ 单位元：如果$ a+0=0+a=a $，则 $ 0 $就是单位元 逆元：对于任意值$ a $必定存在$ b $，使得$ a+b=0 $ 交换律：$ a + b = b + a $ 根据这个定义整数集是个阿贝尔群。\n椭圆曲线的数学性质 # 加法 # 过曲线上的两点$ A $、$ B $画一条直线，找到直线与椭圆曲线的交点，交点关于$ x $轴对称位置的点，定义为$ A+B $，即为加法。\n二倍运算 # 上述方法无法解释$ A + A $，即两点重合的情况，因此在这种情况下，将椭圆曲线在$ A $点的切线，与椭圆曲线的交点，交点关于$ x $轴对称位置的点，定义为$ A + A $，即$ 2A $，即为二倍运算。\n同余运算 # 同余就是有相同的余数，两个整数 a、 b，若它们除以正整数 m所得的余数相等，则称$ a $，$ b $对于模m同余。\n$$ a\\equiv b(mod;m) $$\n乘法逆元 # 这是比较简单的一个概念，在RSA加密算法里面也进行了阐述，这里就举个例子说明吧：\n在模7乘法中：\n1的逆元为1 $ (1 \\times 1) \\mod ; 7=1 $ 2的逆元为4 $ (2 \\times 4) \\mod ; 7=1 $ 3的逆元为5 $ (3 \\times 5) \\mod ; 7=1 $ 4的逆元为2 $ (4 \\times 2) \\mod ; 7=1 $ 5的逆元为3 $ (5 \\times 3) \\mod ; 7=1 $ 6的逆元为6 $ (6 \\times 6) \\mod ; 7=1 $ 这些大致就是ECC所需要的大致的数学理论，可能也只是很少的一部分数学理论，毕竟ECC加密算法的安全性是非常高的，因此可以考虑在ECC算法的基础进行改进和拓展出更多的ECC变体的加密算法，ECC的数学理论主要是建立在抽象代数相关理论中，可以补抽象代数的相关内容来进行ECC加密算法的深入了解。\n参考： # 椭圆曲线密码学-维基百科 椭圆曲线加密算法(ECC)-知乎 闲聊到此为止，来喝杯茶可好？\n","date":"January 29, 2022","permalink":"/posts/%E6%B5%85%E8%B0%88%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95ecc/","section":"Posts","summary":"浅谈椭圆曲线加密算法（ECC） # 椭圆曲线加密算法是近十年提出的一个非对称加密算法，这个加密算法非常复杂，加密的数据具有良好的保密性。加密效果比RSA加密算法都高。这次不可能全部将ECC加密算法讲完，只能简单聊聊ECC加密算法的基本概念和ECC加密算法的数学基础了。\n什么是ECC加密算法？\n椭圆曲线密码学（英语：Elliptic Curve Cryptography，缩写：ECC）是一种基于椭圆曲线数学的公开密钥加密算法。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz（英语：Neal Koblitz）和Victor Miller（英语：Victor Miller）分别独立提出的。\nECC的主要优势是它相比RSA加密算法使用较小的密钥长度并提供相当等级的安全性[1]。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。^1^\n椭圆曲线加密算法，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全，RSA加密算法也是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密（有待考证）。^2^\nECC加密算法需要的数学理论基础相对来说是比较高的层次方面，远比RSA的数学难度高。看来，数学上层理论的基础是对密码学产生了比较大的影响。下面，来简单聊聊数学基础吧。\n数学基础 # 阿贝尔群 # 刚看到这个的时候，我的第一反应是：这是什么东西？（一脸懵逼）\n阿贝尔群其实就是针对椭圆曲线的概念抽象的一个群，简单来说就是针对椭圆曲线的加减乘除规则。概念的变换，就像刚开始学习微积分的加减乘除规则转换到矩阵的加减乘除规律一样。群其实就是一种推广的矩阵。那么，阿贝尔群定义了些什么有趣的东西呢？\n封闭性：如果$ a $和$ b $ 都是阿贝尔群的成员，那么 $ a + b $ 也是阿贝尔群的成员 结合律：$ (a+b)+c=a+(b+c) $ 单位元：如果$ a+0=0+a=a $，则 $ 0 $就是单位元 逆元：对于任意值$ a $必定存在$ b $，使得$ a+b=0 $ 交换律：$ a + b = b + a $ 根据这个定义整数集是个阿贝尔群。\n椭圆曲线的数学性质 # 加法 # 过曲线上的两点$ A $、$ B $画一条直线，找到直线与椭圆曲线的交点，交点关于$ x $轴对称位置的点，定义为$ A+B $，即为加法。","title":"浅谈椭圆曲线加密算法(ECC)"},{"content":"","date":"January 29, 2022","permalink":"/tags/system/","section":"Tags","summary":"","title":"system"},{"content":"进程与线程的理解 # 个人对于进程和线程概念的理解，可能会有些偏差\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。^1^\n线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。^2^\n百度百科上面的解释是一种比较抽象的解释，看了不是非常容易理解。\n可以进程的概念和线程的概念联系到一起进行理解\n首先明确一下进程的概念：\n“进程是数据集合的运行运动”，这句话简单来说就是将数据进行整合的封装成一个又个文件，而这些文件就是模块。\n“线程是操作系统能够进行运算调度的最小单位”，这句话简单来说就是线程把各种文件模块跑起来的单位。\n这就需要了解一下一个程序是如何跑起来的了？ # 一个程序要运行起来需要创建进程，**所有的进程都是别的进程创建的（第一个进程是由操作系统内核创建的）**都是由explorer.exe这个进程创建的。\nExplorer是怎么创建进程的？\n它调用了一个函数：CreateProcess()，把我们的程序变成了进程\nCreateProcess怎么把一个程序变成进程的？\n映射exe文件\n创建内核对象EPROCESS\n映射系统DLL(ntdll.dll)\n创建线程内核对象ETHREAD\n系统启动线程\n5.1 映射DLL(ntdll.LdrlnitializeThunk)\n5.2 线程开始执行\n进程提供代码、资源、数据等，使用这些东西的都是线程，不然它就是一个死的\n那么该怎么去理解进程和线程 # 我个人找到了几个理解线程和进程的角度：\n生物学的角度 # 参考有丝分裂的过程来进行进程与线程的理解\n根据高中生物学的基础知识来理解，我们都知道生物的有丝分裂的过程是一个高中生物学非常基本的分裂过程。有丝分裂主要分为两个重要的时期，分裂间期和分裂期。根据最基本的高中生物知识可以很容易地知道，分裂间期需要准备资源的过程，也就是蛋白质和DNA复制的过程。分裂期也就是利用资源进行分裂的过程。\n我们可以这样理解进程和线程，进程提供代码、资源、数据。线程进行程序的运算。仔细观察线程和进程是不是和生物学中的有丝分裂的分裂间期和分裂期。\n我们可以把有丝分裂的分裂间期来看作进程的过程，把有丝分裂的分裂期来看作线程的过程。\n这样进行类比，对于进程和线程的理解就非常清晰了。\n面向对象的角度 # 面向对象的思想是现代编程的一个重要思想，通过面向对象的概念可以比较清晰地理解进程和线程的关系。\n面向对象是一种抽象的思维过程，有几个比较关键的概念，类，构造函数，析构函数，实例化。在编程过程中，会经常使用到面向对象的思想。\n#include \u0026lt;iostream\u0026gt; class MyObj { int var = 0; public: MyObj() { var = 10; } int run() { std::cout \u0026lt;\u0026lt; \u0026#34;the program running!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ~MyObj() { var = 0; } }; int main(){ MyObj* obj = new MyObj(); obj-\u0026gt;run(); return 0; } 这是C++中简单的对象格式。\n创建对象实例时，实例会进行初始化。对象实例进行初始化的过程中，会初始化对象实例所需的资源代码。\n对象实例调用成员方法时，对象就会使用初始化的一些资源进行成员函数的调用。\n根据我个人的理解，面向对象的编程过程，其实就和进程与线程的原理相似。可以把进程的准备过程理解成初始化，线程作为成员函数的调用。只不过，进程和线程是一个完全连续的过程，没有线程进程就是死的。\n以上是我对于进程和线程的理解，可能略有不足。\n参考 # 进程（一段程序的执行过程）_百度百科 (baidu.com) 线程（计算机术语）_百度百科 (baidu.com) ","date":"January 29, 2022","permalink":"/posts/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","section":"Posts","summary":"进程与线程的理解 # 个人对于进程和线程概念的理解，可能会有些偏差\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。^1^\n线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。^2^\n百度百科上面的解释是一种比较抽象的解释，看了不是非常容易理解。\n可以进程的概念和线程的概念联系到一起进行理解\n首先明确一下进程的概念：\n“进程是数据集合的运行运动”，这句话简单来说就是将数据进行整合的封装成一个又个文件，而这些文件就是模块。\n“线程是操作系统能够进行运算调度的最小单位”，这句话简单来说就是线程把各种文件模块跑起来的单位。\n这就需要了解一下一个程序是如何跑起来的了？ # 一个程序要运行起来需要创建进程，**所有的进程都是别的进程创建的（第一个进程是由操作系统内核创建的）**都是由explorer.exe这个进程创建的。\nExplorer是怎么创建进程的？\n它调用了一个函数：CreateProcess()，把我们的程序变成了进程\nCreateProcess怎么把一个程序变成进程的？\n映射exe文件\n创建内核对象EPROCESS\n映射系统DLL(ntdll.dll)\n创建线程内核对象ETHREAD\n系统启动线程\n5.1 映射DLL(ntdll.LdrlnitializeThunk)\n5.2 线程开始执行\n进程提供代码、资源、数据等，使用这些东西的都是线程，不然它就是一个死的\n那么该怎么去理解进程和线程 # 我个人找到了几个理解线程和进程的角度：\n生物学的角度 # 参考有丝分裂的过程来进行进程与线程的理解\n根据高中生物学的基础知识来理解，我们都知道生物的有丝分裂的过程是一个高中生物学非常基本的分裂过程。有丝分裂主要分为两个重要的时期，分裂间期和分裂期。根据最基本的高中生物知识可以很容易地知道，分裂间期需要准备资源的过程，也就是蛋白质和DNA复制的过程。分裂期也就是利用资源进行分裂的过程。\n我们可以这样理解进程和线程，进程提供代码、资源、数据。线程进行程序的运算。仔细观察线程和进程是不是和生物学中的有丝分裂的分裂间期和分裂期。\n我们可以把有丝分裂的分裂间期来看作进程的过程，把有丝分裂的分裂期来看作线程的过程。\n这样进行类比，对于进程和线程的理解就非常清晰了。\n面向对象的角度 # 面向对象的思想是现代编程的一个重要思想，通过面向对象的概念可以比较清晰地理解进程和线程的关系。\n面向对象是一种抽象的思维过程，有几个比较关键的概念，类，构造函数，析构函数，实例化。在编程过程中，会经常使用到面向对象的思想。\n#include \u0026lt;iostream\u0026gt; class MyObj { int var = 0; public: MyObj() { var = 10; } int run() { std::cout \u0026lt;\u0026lt; \u0026#34;the program running!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ~MyObj() { var = 0; } }; int main(){ MyObj* obj = new MyObj(); obj-\u0026gt;run(); return 0; } 这是C++中简单的对象格式。","title":"进程与线程"},{"content":"杯茗藏香，君闻几何 # “浅谈密码学” # 密文寥寥，清茶袅袅。\n杯杯入境，字字明心。\n密码学是主要研究密码编码和解码的一种学科，主要目标是提供在不安全的信道上的安全通信机制^1^\n根据OWASP上面的定义来开启我们的闲聊。“密码学是主要研究密码编码和解码的一种学科”，这里有两个比较关键的词汇。密码编码和解码，密码比较好理解。平时我们注册一个账户的时候通常就需要一个密码来进行登入，密码和账户构成了网络账户的基本符号。那么，编码和解码又该怎么理解呢？\n编码是信息从一种形式或格式转换为另一种形式的过程，也称为计算机编程语言的代码简称编码。^2^\n编码，简单来说就是对内容进行编制，来确保内容不会影响到互联网整体的传输过程。在互联网中，数据传输通常是采用http，ftp，https等协议进行传输的。这些协议中也会有些特殊的字符有特殊的功能性作用，如果不进行编码，可能会出现预期之外的事故。当然编码也有一些安全性的作用，可以确保数据传输过程中数据不是特别明显的暴露，有较大的截获风险。\n编码是互联网中不可或缺的一种数据处理方式。\n解码是一种用特定方法，把数码还原成它所代表的内容或将电脉冲信号、光信号、无线电波等转换成它所代表的信息、数据等的过程。解码是受传者将接受到的符号或代码还原为信息的过程，与编码过程相对应。^3^\n解码，就是将编码的内容进行还原的过程。意思很明了，在互联网中一般会将解码后的信息展示给用户，在数据传输的过程中，将数据进行编码传输。为什么这样做？一方面是为了用户的使用体验，另一方面是为了数据传输的正常进行和安全性保障。\nOWASP的密码学定义相对来说是比较狭义的，只对互联网中的简单过程进行了定义，将密码学研究的范围缩小了。\n那么，密码学是什么呢？\n密码学，就是将OWASP对于密码学的定义进行推广和扩充。编码不仅仅限制于互联网、计算机领域中，解码也不仅仅仅限于互联网、计算机领域方面。编码就变成了加密的一个子集，解码就变成了解密的一个子集。加密前的数据就有了一个比较完整的概念，即明文。加密后的数据也有了一个名字叫密文。进行加密的工具叫做密钥。这些是密码学的基础性的概念。这些概念和体系形成了密码学的大集体。\n下面是百度百科给出的对于密码学的具体定义和描述。\n密码学（在西欧语文中，源于希腊语kryptós“隐藏的”，和gráphein“书写”）是研究如何隐密地传递信息的学科。在现代特别指对信息以及其传输的数学性研究，常被认为是数学和计算机科学的分支，和信息论也密切相关。著名的密码学者Ron Rivest解释道：“密码学是关于如何在敌人存在的环境中通讯”，自工程学的角度，这相当于密码学与纯数学的异同。密码学是信息安全等相关议题，如认证、访问控制的核心。密码学的首要目的是隐藏信息的涵义，并不是隐藏信息的存在。密码学也促进了计算机科学，特别是在于电脑与网络安全所使用的技术，如访问控制与信息的机密性。密码学已被应用在日常生活：包括自动柜员机的芯片卡、电脑使用者存取密码、电子商务等等。^4^\n密码学不仅仅只是计算机领域的内容，也是一种比较多元化的体系，但是主要应用于计算机领域。密码学会涉及到很多与数学相关联的知识体系，从微积分到线性代数、概率论以及离散数学，再从线性代数到抽象代数，再从抽象代数到数论。几乎数学方面比较难的模块都涉及到了密码学中，仿佛富有丰富的能量和特别的活力。\n这回只是对密码学的初步探索和学习，有时候知识都是相通的，都是彼此有联系的存在。密码学何尝不是呢？喝杯茶其实也是种生活种的密码学。\n密码学有密文和明文，茶叶中有遗传密码和表现型，有香气分子和味觉感受。密码学应该是和生物学一样，是非常beautiful的学科，一定非常好玩！\n请君先闻龙井香，道出多少古时芳。\n参考： # http://www.owasp.org.cn/ https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092 https://baike.baidu.com/item/%E8%A7%A3%E7%A0%81 https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E5%AD%A6 闲聊到此为止，来喝杯茶可好？\n","date":"January 29, 2022","permalink":"/posts/%E6%9D%AF%E8%8C%97%E8%97%8F%E9%A6%99%E5%90%9B%E9%97%BB%E5%87%A0%E4%BD%95/","section":"Posts","summary":"杯茗藏香，君闻几何 # “浅谈密码学” # 密文寥寥，清茶袅袅。\n杯杯入境，字字明心。\n密码学是主要研究密码编码和解码的一种学科，主要目标是提供在不安全的信道上的安全通信机制^1^\n根据OWASP上面的定义来开启我们的闲聊。“密码学是主要研究密码编码和解码的一种学科”，这里有两个比较关键的词汇。密码编码和解码，密码比较好理解。平时我们注册一个账户的时候通常就需要一个密码来进行登入，密码和账户构成了网络账户的基本符号。那么，编码和解码又该怎么理解呢？\n编码是信息从一种形式或格式转换为另一种形式的过程，也称为计算机编程语言的代码简称编码。^2^\n编码，简单来说就是对内容进行编制，来确保内容不会影响到互联网整体的传输过程。在互联网中，数据传输通常是采用http，ftp，https等协议进行传输的。这些协议中也会有些特殊的字符有特殊的功能性作用，如果不进行编码，可能会出现预期之外的事故。当然编码也有一些安全性的作用，可以确保数据传输过程中数据不是特别明显的暴露，有较大的截获风险。\n编码是互联网中不可或缺的一种数据处理方式。\n解码是一种用特定方法，把数码还原成它所代表的内容或将电脉冲信号、光信号、无线电波等转换成它所代表的信息、数据等的过程。解码是受传者将接受到的符号或代码还原为信息的过程，与编码过程相对应。^3^\n解码，就是将编码的内容进行还原的过程。意思很明了，在互联网中一般会将解码后的信息展示给用户，在数据传输的过程中，将数据进行编码传输。为什么这样做？一方面是为了用户的使用体验，另一方面是为了数据传输的正常进行和安全性保障。\nOWASP的密码学定义相对来说是比较狭义的，只对互联网中的简单过程进行了定义，将密码学研究的范围缩小了。\n那么，密码学是什么呢？\n密码学，就是将OWASP对于密码学的定义进行推广和扩充。编码不仅仅限制于互联网、计算机领域中，解码也不仅仅仅限于互联网、计算机领域方面。编码就变成了加密的一个子集，解码就变成了解密的一个子集。加密前的数据就有了一个比较完整的概念，即明文。加密后的数据也有了一个名字叫密文。进行加密的工具叫做密钥。这些是密码学的基础性的概念。这些概念和体系形成了密码学的大集体。\n下面是百度百科给出的对于密码学的具体定义和描述。\n密码学（在西欧语文中，源于希腊语kryptós“隐藏的”，和gráphein“书写”）是研究如何隐密地传递信息的学科。在现代特别指对信息以及其传输的数学性研究，常被认为是数学和计算机科学的分支，和信息论也密切相关。著名的密码学者Ron Rivest解释道：“密码学是关于如何在敌人存在的环境中通讯”，自工程学的角度，这相当于密码学与纯数学的异同。密码学是信息安全等相关议题，如认证、访问控制的核心。密码学的首要目的是隐藏信息的涵义，并不是隐藏信息的存在。密码学也促进了计算机科学，特别是在于电脑与网络安全所使用的技术，如访问控制与信息的机密性。密码学已被应用在日常生活：包括自动柜员机的芯片卡、电脑使用者存取密码、电子商务等等。^4^\n密码学不仅仅只是计算机领域的内容，也是一种比较多元化的体系，但是主要应用于计算机领域。密码学会涉及到很多与数学相关联的知识体系，从微积分到线性代数、概率论以及离散数学，再从线性代数到抽象代数，再从抽象代数到数论。几乎数学方面比较难的模块都涉及到了密码学中，仿佛富有丰富的能量和特别的活力。\n这回只是对密码学的初步探索和学习，有时候知识都是相通的，都是彼此有联系的存在。密码学何尝不是呢？喝杯茶其实也是种生活种的密码学。\n密码学有密文和明文，茶叶中有遗传密码和表现型，有香气分子和味觉感受。密码学应该是和生物学一样，是非常beautiful的学科，一定非常好玩！\n请君先闻龙井香，道出多少古时芳。\n参考： # http://www.owasp.org.cn/ https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092 https://baike.baidu.com/item/%E8%A7%A3%E7%A0%81 https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E5%AD%A6 闲聊到此为止，来喝杯茶可好？","title":"杯茗藏香，君闻几何"},{"content":"一花一世界，一码一千秋 # ”逆向工程初步“ # 逆向工程应该是一门优雅的艺术，而不是一些低层次者手中的粗陋工具；\n逆向工程的目的是学习与再利用；\n逆向工程的精神是“自由”。\n《加密与解密》\n什么是逆向工程？ # 逆向工程（Reverse engineering），又称反向工程，是一种技术过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能性能规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是，在无法轻易获得必要的生产信息下，直接从成品的分析，推导产品的设计原理。^1^\n通俗来讲，逆向工程就是将机器才能够懂的机器代码（0101二进制代码）翻译成人能够读懂的代码（汇编、smali代码）。 但实际情况往往是，我们只寻找关键的代码去翻译或仅了解其业务逻辑，因为要将所有的机器代码翻译出来，工作量是极其巨大的且繁琐的。^2^\n逆向技术在实际业务中一般应用于以下几个方面：二进制漏洞挖掘、软件破解、恶意代码分析、竞品分析等。\n逆向工程涉及的知识面非常广，从计算机基础原理到计算机架构，再到各种编程语言的编译原理。逆向工程往往需要对算法进行逆向，对操作系统架构进行逆向，这就要求逆向工程师有不错的算法水平，而且对计算机相关的原理深入理解。\n一个逆向工程大师，也许具有如下特征。\n永远保持好奇心，崇尚自由——既能促使探索，也能抵抗商业利益和欲望的侵袭。有了它，枯燥的代码世界才有了生气。 勤奋与毅力。在一篇关于逆向的文章中有这样的语句：“让我们搞清楚作为一名逆向工作者需要具备的基本条件，其实那并不是扎实的汇编功底和编程基础——可以完全不懂这些，秘诀就是勤奋加上执着！记住并做到这两点，你一样可以变得优秀。” 精通至少一门编程语言——不仅仅是代码，更重要的是编程思想。 扎实的汇编功底和系统编程知识。 基础知识 # 汇编语言 C语言 一门脚本语言(Python) Windows核心编程 PE文件格式 程序加载流程 基础工具 # 查壳工具（DIE、PEID、EXEINFO、LordPE、ResourceHacker等） 常用脱壳工具或脱壳脚本（专属壳的脱壳器例如upx等、各种壳的脱壳脚本） 十六进制编辑器（010Editor、winhex等） 反汇编工具（IDA、Hopper） 调试器（Ollydbg、gdb、windbg等） 这些都是比较常用的逆向工具。其中特别要熟练使用IDA与Ollydbg，IDA一般用来做静态分析，其中的F5功能更是强大到没朋友，新手必备。Ollydbg简称OD一般用来做动态调试使用，两者结合使用堪比倚天剑和屠龙刀，可谓是神挡杀神佛挡杀佛。^3^\n逆向的分类 # 解释型语言的逆向 编译型语言的逆向 分析手段 # 静态分析 动态分析 网络流量分析 猜 静态分析 # 将机器代码反汇编成方便人类理解的代码，如smali代码（Java）、汇编代码或汇编代码翻译的C语言伪代码等等，通过分析这些比较低级的编程语言的代码，找到程序的业务流程或设计逻辑。\n动态分析 # 通过断点调试手段，让程序单步执行进行分析。动态分析往往是在静态分析出一定的结果的基础上进行，找到合适的地方给代码打断点，即时地读取当前变量的值，来进一步分析程序的逻辑、获取程序关系数据。\n网络流量分析 # 通过代理方式或者其他方式，截取程序与服务器通信的数据流量（抓包），来分析客户端和服务端的通信协议。网络流量分析比较有局限性，若客户端使用Http这种明文传输的协议，会比较容易分析；但如果客户端使用SSL、Https等加密传输协议与服务端进行通信，那么抓包的前提是需要拿到服务端下发给客户端的证书才能进一步解密分析，这种情况下就比较棘手。网上有方案通过安装插件拿到Chrome或者Firefox浏览器的本地证书，但只适用于客户端是网页的情况。若其他大佬有好的宝贵经验，还望能指点迷津。\n猜 # 猜测的前提是，你需要有一定的编程经验，能够在逆向分析出一些代码后，对其上下的代码进行合理的推测，推测不出来的代码再通过以上手段分析。可以这么说，你的推测能力决定了你的逆向分析效率，而编程经验则是你猜测能力的基石。\n逆向工程的学习是一条漫长的道路，每一个逆向工程师都是一个优秀的开发者，只不过他们选择去挑战更有深度，更有趣味的事情。加密与解密，解开每一段代码的意味，看到软件背后潜藏的世界，正所谓，一花一世界，一码一千秋嘛。\n参考 # 逆向工程-维基百科 逆向工程入门概述-知乎 CTF逆向选手入坑指南-FreeBuf 闲聊到此为止，来喝杯茶可好？\n","date":"January 29, 2022","permalink":"/posts/%E4%B8%80%E8%8A%B1%E4%B8%80%E4%B8%96%E7%95%8C%E4%B8%80%E7%A0%81%E4%B8%80%E5%8D%83%E7%A7%8B/","section":"Posts","summary":"一花一世界，一码一千秋 # ”逆向工程初步“ # 逆向工程应该是一门优雅的艺术，而不是一些低层次者手中的粗陋工具；\n逆向工程的目的是学习与再利用；\n逆向工程的精神是“自由”。\n《加密与解密》\n什么是逆向工程？ # 逆向工程（Reverse engineering），又称反向工程，是一种技术过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能性能规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是，在无法轻易获得必要的生产信息下，直接从成品的分析，推导产品的设计原理。^1^\n通俗来讲，逆向工程就是将机器才能够懂的机器代码（0101二进制代码）翻译成人能够读懂的代码（汇编、smali代码）。 但实际情况往往是，我们只寻找关键的代码去翻译或仅了解其业务逻辑，因为要将所有的机器代码翻译出来，工作量是极其巨大的且繁琐的。^2^\n逆向技术在实际业务中一般应用于以下几个方面：二进制漏洞挖掘、软件破解、恶意代码分析、竞品分析等。\n逆向工程涉及的知识面非常广，从计算机基础原理到计算机架构，再到各种编程语言的编译原理。逆向工程往往需要对算法进行逆向，对操作系统架构进行逆向，这就要求逆向工程师有不错的算法水平，而且对计算机相关的原理深入理解。\n一个逆向工程大师，也许具有如下特征。\n永远保持好奇心，崇尚自由——既能促使探索，也能抵抗商业利益和欲望的侵袭。有了它，枯燥的代码世界才有了生气。 勤奋与毅力。在一篇关于逆向的文章中有这样的语句：“让我们搞清楚作为一名逆向工作者需要具备的基本条件，其实那并不是扎实的汇编功底和编程基础——可以完全不懂这些，秘诀就是勤奋加上执着！记住并做到这两点，你一样可以变得优秀。” 精通至少一门编程语言——不仅仅是代码，更重要的是编程思想。 扎实的汇编功底和系统编程知识。 基础知识 # 汇编语言 C语言 一门脚本语言(Python) Windows核心编程 PE文件格式 程序加载流程 基础工具 # 查壳工具（DIE、PEID、EXEINFO、LordPE、ResourceHacker等） 常用脱壳工具或脱壳脚本（专属壳的脱壳器例如upx等、各种壳的脱壳脚本） 十六进制编辑器（010Editor、winhex等） 反汇编工具（IDA、Hopper） 调试器（Ollydbg、gdb、windbg等） 这些都是比较常用的逆向工具。其中特别要熟练使用IDA与Ollydbg，IDA一般用来做静态分析，其中的F5功能更是强大到没朋友，新手必备。Ollydbg简称OD一般用来做动态调试使用，两者结合使用堪比倚天剑和屠龙刀，可谓是神挡杀神佛挡杀佛。^3^\n逆向的分类 # 解释型语言的逆向 编译型语言的逆向 分析手段 # 静态分析 动态分析 网络流量分析 猜 静态分析 # 将机器代码反汇编成方便人类理解的代码，如smali代码（Java）、汇编代码或汇编代码翻译的C语言伪代码等等，通过分析这些比较低级的编程语言的代码，找到程序的业务流程或设计逻辑。\n动态分析 # 通过断点调试手段，让程序单步执行进行分析。动态分析往往是在静态分析出一定的结果的基础上进行，找到合适的地方给代码打断点，即时地读取当前变量的值，来进一步分析程序的逻辑、获取程序关系数据。\n网络流量分析 # 通过代理方式或者其他方式，截取程序与服务器通信的数据流量（抓包），来分析客户端和服务端的通信协议。网络流量分析比较有局限性，若客户端使用Http这种明文传输的协议，会比较容易分析；但如果客户端使用SSL、Https等加密传输协议与服务端进行通信，那么抓包的前提是需要拿到服务端下发给客户端的证书才能进一步解密分析，这种情况下就比较棘手。网上有方案通过安装插件拿到Chrome或者Firefox浏览器的本地证书，但只适用于客户端是网页的情况。若其他大佬有好的宝贵经验，还望能指点迷津。\n猜 # 猜测的前提是，你需要有一定的编程经验，能够在逆向分析出一些代码后，对其上下的代码进行合理的推测，推测不出来的代码再通过以上手段分析。可以这么说，你的推测能力决定了你的逆向分析效率，而编程经验则是你猜测能力的基石。\n逆向工程的学习是一条漫长的道路，每一个逆向工程师都是一个优秀的开发者，只不过他们选择去挑战更有深度，更有趣味的事情。加密与解密，解开每一段代码的意味，看到软件背后潜藏的世界，正所谓，一花一世界，一码一千秋嘛。\n参考 # 逆向工程-维基百科 逆向工程入门概述-知乎 CTF逆向选手入坑指南-FreeBuf 闲聊到此为止，来喝杯茶可好？","title":"一花一世界，一码一千秋"},{"content":"一个废柴学习者，尝试去探索密码学的国度和逆向工程的世界，盼望着可以去遨游在病毒的世界，用心去透析计算机底层的奥秘与神奇。\n这里就是我这个废柴的记录空间，欢迎到访。\n","date":"January 29, 2022","permalink":"/about/","section":"OPdbg","summary":"一个废柴学习者，尝试去探索密码学的国度和逆向工程的世界，盼望着可以去遨游在病毒的世界，用心去透析计算机底层的奥秘与神奇。\n这里就是我这个废柴的记录空间，欢迎到访。","title":"About"},{"content":"XCTF-REVERSE-高手区-3 writeup # 继续玩一玩逆向的题目，感觉还是蛮有意思的。\n0x0 srm-50 # 使用DIE进行探测：\n32位PE程序，无壳。可以尝试运行一下：\n应该是一个邮箱破解的程序，终于有点稍微有意思的题目了\n首先进行静态分析看代码：\n根据WIN32的编程基础，关键函数应该是在DialogFunc中，登录的细节应该是在DialogFunc中。\n跟进DialogFunc函数，来寻找更多的细节\nINT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4) { HMODULE v5; // eax HICON v6; // eax HMODULE v7; // eax HWND v8; // eax HCURSOR v9; // [esp-4h] [ebp-34Ch] CHAR String[256]; // [esp+8h] [ebp-340h] BYREF CHAR v11[256]; // [esp+108h] [ebp-240h] BYREF CHAR Text[256]; // [esp+208h] [ebp-140h] BYREF char Source[60]; // [esp+308h] [ebp-40h] BYREF if ( a2 == 16 ) { EndDialog(hDlg, 0); return 0; } if ( a2 == 272 ) { v5 = GetModuleHandleW(0); v6 = LoadIconW(v5, (LPCWSTR)0x67); SetClassLongA(hDlg, -14, (LONG)v6); v7 = GetModuleHandleW(0); v9 = LoadCursorW(v7, (LPCWSTR)0x66); v8 = GetDlgItem(hDlg, 1); SetClassLongA(v8, -12, (LONG)v9); return 1; } if ( a2 != 273 || (unsigned __int16)a3 != 1 ) return 0; memset(String, (unsigned __int16)a3 - 1, sizeof(String)); memset(v11, 0, sizeof(v11)); memset(Text, 0, sizeof(Text)); GetDlgItemTextA(hDlg, 1001, String, 256); GetDlgItemTextA(hDlg, 1002, v11, 256); if ( strstr(String, \u0026#34;@\u0026#34;) \u0026amp;\u0026amp; strstr(String, \u0026#34;.\u0026#34;) \u0026amp;\u0026amp; strstr(String, \u0026#34;.\u0026#34;)[1] \u0026amp;\u0026amp; strstr(String, \u0026#34;@\u0026#34;)[1] != 46 ) { strcpy(\u0026amp;Source[36], \u0026#34;Registration failure.\u0026#34;); strcpy(Source, \u0026#34;Registration Success!\\nYour flag is:\u0026#34;); if ( strlen(v11) == 16 \u0026amp;\u0026amp; v11[0] == 67 \u0026amp;\u0026amp; v11[15] == 88 \u0026amp;\u0026amp; v11[1] == 90 \u0026amp;\u0026amp; v11[14] == 65 \u0026amp;\u0026amp; v11[2] == 57 \u0026amp;\u0026amp; v11[13] == 98 \u0026amp;\u0026amp; v11[3] == 100 \u0026amp;\u0026amp; v11[12] == 55 \u0026amp;\u0026amp; v11[4] == 109 \u0026amp;\u0026amp; v11[11] == 71 \u0026amp;\u0026amp; v11[5] == 113 \u0026amp;\u0026amp; v11[10] == 57 \u0026amp;\u0026amp; v11[6] == 52 \u0026amp;\u0026amp; v11[9] == 103 \u0026amp;\u0026amp; v11[7] == 99 \u0026amp;\u0026amp; v11[8] == 56 ) { strcpy_s(Text, 0x100u, Source); strcat_s(Text, 0x100u, v11); } else { strcpy_s(Text, 0x100u, \u0026amp;Source[36]); } } else { strcpy_s(Text, 0x100u, \u0026#34;Your E-mail address in not valid.\u0026#34;); } MessageBoxA(hDlg, Text, \u0026#34;Registeration\u0026#34;, 0x40u); return 1; } flag直接展示的非常清晰了：\nif ( strstr(String, \u0026#34;@\u0026#34;) \u0026amp;\u0026amp; strstr(String, \u0026#34;.\u0026#34;) \u0026amp;\u0026amp; strstr(String, \u0026#34;.\u0026#34;)[1] \u0026amp;\u0026amp; strstr(String, \u0026#34;@\u0026#34;)[1] != 46 ) { strcpy(\u0026amp;Source[36], \u0026#34;Registration failure.\u0026#34;); strcpy(Source, \u0026#34;Registration Success!\\nYour flag is:\u0026#34;); if ( strlen(v11) == 16 \u0026amp;\u0026amp; v11[0] == 67 \u0026amp;\u0026amp; v11[15] == 88 \u0026amp;\u0026amp; v11[1] == 90 \u0026amp;\u0026amp; v11[14] == 65 \u0026amp;\u0026amp; v11[2] == 57 \u0026amp;\u0026amp; v11[13] == 98 \u0026amp;\u0026amp; v11[3] == 100 \u0026amp;\u0026amp; v11[12] == 55 \u0026amp;\u0026amp; v11[4] == 109 \u0026amp;\u0026amp; v11[11] == 71 \u0026amp;\u0026amp; v11[5] == 113 \u0026amp;\u0026amp; v11[10] == 57 \u0026amp;\u0026amp; v11[6] == 52 \u0026amp;\u0026amp; v11[9] == 103 \u0026amp;\u0026amp; v11[7] == 99 \u0026amp;\u0026amp; v11[8] == 56 ) { strcpy_s(Text, 0x100u, Source); strcat_s(Text, 0x100u, v11); } else { strcpy_s(Text, 0x100u, \u0026amp;Source[36]); } } 对v11数组进行运算就可以得到，非常简单，可以非常容易地得到：\nCZ9dmq4c8g9G7bAX 故本题的flag：\nCZ9dmq4c8g9G7bAX 0x1 simple-check-100 # 先使用DIE姐姐进行探测一下，呐呐~\nPE32程序，没有加壳。直接静态分析看一波：\nint __cdecl main(int argc, const char **argv, const char **envp) { void *v3; // esp void *v4; // esp char v6; // [esp+8h] [ebp-40h] BYREF char v7; // [esp+1Bh] [ebp-2Dh] BYREF char *v8; // [esp+1Ch] [ebp-2Ch] int v9; // [esp+20h] [ebp-28h] char v10; // [esp+25h] [ebp-23h] char v11; // [esp+26h] [ebp-22h] char v12; // [esp+27h] [ebp-21h] char v13; // [esp+28h] [ebp-20h] char v14; // [esp+29h] [ebp-1Fh] char v15; // [esp+2Ah] [ebp-1Eh] char v16; // [esp+2Bh] [ebp-1Dh] char v17; // [esp+2Ch] [ebp-1Ch] char v18; // [esp+2Dh] [ebp-1Bh] char v19; // [esp+2Eh] [ebp-1Ah] char v20; // [esp+2Fh] [ebp-19h] char v21; // [esp+30h] [ebp-18h] char v22; // [esp+31h] [ebp-17h] char v23; // [esp+32h] [ebp-16h] char v24; // [esp+33h] [ebp-15h] char v25; // [esp+34h] [ebp-14h] char v26; // [esp+35h] [ebp-13h] char v27; // [esp+36h] [ebp-12h] char v28; // [esp+37h] [ebp-11h] char v29; // [esp+38h] [ebp-10h] char v30; // [esp+39h] [ebp-Fh] char v31; // [esp+3Ah] [ebp-Eh] char v32; // [esp+3Bh] [ebp-Dh] char v33; // [esp+3Ch] [ebp-Ch] char v34; // [esp+3Dh] [ebp-Bh] char v35; // [esp+3Eh] [ebp-Ah] char v36; // [esp+3Fh] [ebp-9h] int *v37; // [esp+40h] [ebp-8h] v37 = \u0026amp;argc; __main(); v7 = 84; v36 = -56; v35 = 126; v34 = -29; v33 = 100; v32 = -57; v31 = 22; v30 = -102; v29 = -51; v28 = 17; v27 = 101; v26 = 50; v25 = 45; v24 = -29; v23 = -45; v22 = 67; v21 = -110; v20 = -87; v19 = -99; v18 = -46; v17 = -26; v16 = 109; v15 = 44; v14 = -45; v13 = -74; v12 = -67; v11 = -2; v10 = 106; v9 = 19; v3 = alloca(32); v4 = alloca(32); v8 = \u0026amp;v6; printf(\u0026#34;Key: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, v8); if ( check_key((int)v8) ) interesting_function((int)\u0026amp;v7); else puts(\u0026#34;Wrong\u0026#34;); return 0; } 关键函数是check_key函数，只要对check_key函数进行绕过应该就可以拿到flag\n使用Ollydbg进行动态调试：\n发现Ollydbg总是会输出乱码。不能够正确地将flag输出出来，可能是由于WINDOW编码的问题，也可能是由于题目的WINDOWS程序没有写好。需要再进行对Linux程序进行分析，但是考虑到Linux程序的代码应该是和Windows的代码结构大致一致\n把程序拖到Kali Linux中，使用GDB进行调试：\n成功调试出了flag：\nflag_is_you_know_cracking!!! 0x2 Mysterious # 先使用DIE探测一下：\n32位PE程序，无壳\n尝试运行一下这个程序：\n密码破解的程序，先进行静态分析确定位置：\n经典的WIN32程序，继续跟进\n跟进DialogFunc函数，这个函数主要就是WIN32的窗口创建函数，代码逻辑应该就在WIN32中。\n继续跟进，胜利就在前方！\n找到主要的逻辑函数，在下面寻找逻辑判断语句\n这个loc_401183应该是关键函数，这个函数的地址是0x401183，使用Ollydbg进行同时调试来绕过这个判断条件直接出flag\n使用Ollydbg，使用快捷键CTRL+G快速跳转到0x401183的地址，同时也要根据代码静态分析的逻辑来进行判断，发现需要进行输入的代码段是122，这个可以作为Key进行输入：\n在Ollydbg中修改汇编，修改跳转条件，然后输入122\n就可以拿到flag了\nflag为：\nflag{123_Buff3r_0v3rf|0w} 本题还有一种更简单的解法，就是直接静态分析来读取密码直接输入来拿到flag\n本菜鸡只是希望可以学习到更多的技能点，于是使用另一种思路进行求解。\n0x3 re1-100 # 先进行一下探测：\n64位的ELF文件，直接静态分析：\n代码中有反调试函数，这道题目使用动态调试会有些麻烦，应该是使用静态调试进行求解\n查看静态调试代码\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp) { __pid_t v3; // eax size_t v4; // rax ssize_t v5; // rbx bool v6; // al bool bCheckPtrace; // [rsp+13h] [rbp-1BDh] ssize_t numRead; // [rsp+18h] [rbp-1B8h] ssize_t numReada; // [rsp+18h] [rbp-1B8h] char bufWrite[200]; // [rsp+20h] [rbp-1B0h] BYREF char bufParentRead[200]; // [rsp+F0h] [rbp-E0h] BYREF unsigned __int64 v12; // [rsp+1B8h] [rbp-18h] v12 = __readfsqword(0x28u); bCheckPtrace = detectDebugging(); if ( pipe(pParentWrite) == -1 ) exit(1); if ( pipe(pParentRead) == -1 ) exit(1); v3 = fork(); if ( v3 != -1 ) { if ( v3 ) { close(pParentWrite[0]); close(pParentRead[1]); while ( 1 ) { printf(\u0026#34;Input key : \u0026#34;); memset(bufWrite, 0, sizeof(bufWrite)); gets(bufWrite); v4 = strlen(bufWrite); v5 = write(pParentWrite[1], bufWrite, v4); if ( v5 != strlen(bufWrite) ) printf(\u0026#34;parent - partial/failed write\u0026#34;); do { memset(bufParentRead, 0, sizeof(bufParentRead)); numReada = read(pParentRead[0], bufParentRead, 0xC8uLL); v6 = bCheckPtrace || checkDebuggerProcessRunning(); if ( !v6 \u0026amp;\u0026amp; checkStringIsNumber(bufParentRead) \u0026amp;\u0026amp; atoi(bufParentRead) ) { puts(\u0026#34;True\u0026#34;); if ( close(pParentWrite[1]) == -1 ) exit(1); exit(0); } puts(\u0026#34;Wrong !!!\\n\u0026#34;); } while ( numReada == -1 ); } } close(pParentWrite[1]); close(pParentRead[0]); while ( 1 ) { memset(bufParentRead, 0, sizeof(bufParentRead)); numRead = read(pParentWrite[0], bufParentRead, 0xC8uLL); if ( numRead == -1 ) break; if ( numRead ) { if ( !childCheckDebugResult() \u0026amp;\u0026amp; bufParentRead[0] == 123 \u0026amp;\u0026amp; strlen(bufParentRead) == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; !strncmp(\u0026amp;bufParentRead[1], \u0026#34;53fc275d81\u0026#34;, 0xAuLL) \u0026amp;\u0026amp; bufParentRead[strlen(bufParentRead) - 1] == 125 \u0026amp;\u0026amp; !strncmp(\u0026amp;bufParentRead[31], \u0026#34;4938ae4efd\u0026#34;, 0xAuLL) \u0026amp;\u0026amp; confuseKey(bufParentRead, 42) \u0026amp;\u0026amp; !strncmp(bufParentRead, \u0026#34;{daf29f59034938ae4efd53fc275d81053ed5be8c}\u0026#34;, 0x2AuLL) ) { responseTrue(); } else { responseFalse(); } } } exit(1); } exit(1); } 发现存在有一个可疑的字符串：\n{daf29f59034938ae4efd53fc275d81053ed5be8c} 这个字符串可能是flag，但是感觉似乎有些不太对劲\n往上观察，发现存在有一个进行变换的函数confusekey\n进入这个函数：\nbool __cdecl confuseKey(char *szKey, int iKeyLength) { char szPart1[15]; // [rsp+10h] [rbp-50h] BYREF char szPart2[15]; // [rsp+20h] [rbp-40h] BYREF char szPart3[15]; // [rsp+30h] [rbp-30h] BYREF char szPart4[15]; // [rsp+40h] [rbp-20h] BYREF unsigned __int64 v7; // [rsp+58h] [rbp-8h] v7 = __readfsqword(0x28u); *(_QWORD *)szPart1 = 0LL; *(_DWORD *)\u0026amp;szPart1[8] = 0; *(_WORD *)\u0026amp;szPart1[12] = 0; szPart1[14] = 0; *(_QWORD *)szPart2 = 0LL; *(_DWORD *)\u0026amp;szPart2[8] = 0; *(_WORD *)\u0026amp;szPart2[12] = 0; szPart2[14] = 0; *(_QWORD *)szPart3 = 0LL; *(_DWORD *)\u0026amp;szPart3[8] = 0; *(_WORD *)\u0026amp;szPart3[12] = 0; szPart3[14] = 0; *(_QWORD *)szPart4 = 0LL; *(_DWORD *)\u0026amp;szPart4[8] = 0; *(_WORD *)\u0026amp;szPart4[12] = 0; szPart4[14] = 0; if ( iKeyLength != 42 ) return 0; if ( !szKey ) return 0; if ( strlen(szKey) != 42 ) return 0; if ( *szKey != 123 ) return 0; strncpy(szPart1, szKey + 1, 0xAuLL); strncpy(szPart2, szKey + 11, 0xAuLL); strncpy(szPart3, szKey + 21, 0xAuLL); strncpy(szPart4, szKey + 31, 0xAuLL); memset(szKey, 0, 0x2AuLL); *szKey = 123; strcat(szKey, szPart3); strcat(szKey, szPart4); strcat(szKey, szPart1); strcat(szKey, szPart2); szKey[41] = 125; return 1; } 发现字符串发生了位置的变化，将位置变化还原应该就是flag\n看代码可以直接对字符进行变换处理：\n53fc275d81053ed5be8cdaf29f59034938ae4efd 本题的flag为：\n53fc275d81053ed5be8cdaf29f59034938ae4efd 0x4 crazy # 探测探测，看看是什么样的程序：\n64位的ELF程序，无壳。直接上静态分析看一看：\nint __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rax __int64 v4; // rax __int64 v5; // rax __int64 v6; // rax __int64 v7; // rax __int64 v8; // rax __int64 v9; // rax __int64 v10; // rax __int64 v11; // rax __int64 v12; // rax __int64 v13; // rax __int64 v14; // rax __int64 v15; // rax __int64 v16; // rax char v18[32]; // [rsp+10h] [rbp-130h] BYREF char v19[32]; // [rsp+30h] [rbp-110h] BYREF char v20[32]; // [rsp+50h] [rbp-F0h] BYREF char v21[32]; // [rsp+70h] [rbp-D0h] BYREF char v22[32]; // [rsp+90h] [rbp-B0h] BYREF char v23[120]; // [rsp+B0h] [rbp-90h] BYREF unsigned __int64 v24; // [rsp+128h] [rbp-18h] v24 = __readfsqword(0x28u); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v18, argv, envp); std::operator\u0026gt;\u0026gt;\u0026lt;char\u0026gt;(\u0026amp;std::cin, v18); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;-------------------------------------------\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v3, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Quote from people\u0026#39;s champ\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v4, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v5 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;-------------------------------------------\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v6 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;( \u0026amp;std::cout, \u0026#34;*My goal was never to be the loudest or the craziest. It was to be the most entertaining.\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v6, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v7 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;*Wrestling was like stand-up comedy for me.\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v7, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v8 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;( \u0026amp;std::cout, \u0026#34;*I like to use the hard times in the past to motivate me today.\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v8, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v9 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;-------------------------------------------\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v9, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); HighTemplar::HighTemplar((DarkTemplar *)v23, (__int64)v18); v10 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Checking....\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v10, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v19, v18); func1(v20, v19); func2(v21, v20); func3(v21, 0LL); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v21); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v20); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v19); HighTemplar::calculate((HighTemplar *)v23); if ( !(unsigned int)HighTemplar::getSerial((HighTemplar *)v23) ) { v11 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;/////////////////////////////////\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v11, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v12 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Do not be angry. Happy Hacking :)\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v12, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v13 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;/////////////////////////////////\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v13, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); HighTemplar::getFlag[abi:cxx11](v22, v23); v14 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;flag{\u0026#34;); v15 = std::operator\u0026lt;\u0026lt;\u0026lt;char\u0026gt;(v14, v22); v16 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(v15, \u0026#34;}\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v16, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v22); } HighTemplar::~HighTemplar((HighTemplar *)v23); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v18); return 0; } 这道题目的难点应该是C++反汇编反编译代码的阅读，需要寻找关键函数：\nHighTemplar::HighTemplar((DarkTemplar *)v23, (__int64)v18); // 数据：\u0026#34;327a6c4304ad5938eaf0efb6cc3e53dc\u0026#34; HighTemplar::calculate((HighTemplar *)v23); // 加密 HighTemplar::getSerial((HighTemplar *)v23); // 验证 现在通过审计获得了三个关键函数，现在就可以逐一分析了\n先看看加密：\nbool __fastcall HighTemplar::calculate(HighTemplar *this) { __int64 v1; // rax _BYTE *v2; // rbx bool result; // al _BYTE *v4; // rbx int i; // [rsp+18h] [rbp-18h] int j; // [rsp+1Ch] [rbp-14h] if ( std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length((char *)this + 16) != 32 ) { v1 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Too short or too long\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v1, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); exit(-1); } for ( i = 0; i \u0026lt;= (unsigned __int64)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length((char *)this + 16); ++i ) { v2 = (_BYTE *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( (char *)this + 16, i); *v2 = (*(_BYTE *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( (char *)this + 16, i) ^ 0x50) + 23; } for ( j = 0; ; ++j ) { result = j \u0026lt;= (unsigned __int64)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length((char *)this + 16); if ( !result ) break; v4 = (_BYTE *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( (char *)this + 16, j); *v4 = (*(_BYTE *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( (char *)this + 16, j) ^ 0x13) + 11; } return result; } 对加密代码简要分析就是：\nc = (((m ^ 0x50) + 23) ^ 0x13) + 11 然后查看一下验证函数\n__int64 __fastcall HighTemplar::getSerial(HighTemplar *this) { char v1; // bl __int64 v2; // rax __int64 v3; // rax __int64 v4; // rax __int64 v5; // rax unsigned int i; // [rsp+1Ch] [rbp-14h] for ( i = 0; (int)i \u0026lt; (unsigned __int64)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length((char *)this + 16); ++i ) { v1 = *(_BYTE *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( (char *)this + 80, (int)i); if ( v1 != *(_BYTE *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( (char *)this + 16, (int)i) ) { v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;You did not pass \u0026#34;); v5 = std::ostream::operator\u0026lt;\u0026lt;(v4, i); std::ostream::operator\u0026lt;\u0026lt;(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); *((_DWORD *)this + 3) = 1; return *((unsigned int *)this + 3); } v2 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Pass \u0026#34;); v3 = std::ostream::operator\u0026lt;\u0026lt;(v2, i); std::ostream::operator\u0026lt;\u0026lt;(v3, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } return *((unsigned int *)this + 3); } 也是对于字符327a6c4304ad5938eaf0efb6cc3e53dc的验证\n于是这道题目就非常简单了，直接对于异或操作进行逆向求解，写个python即可求解：\ndata=\u0026#39;327a6c4304ad5938eaf0efb6cc3e53dc\u0026#39; flag=\u0026#39;\u0026#39; for i in range(len(data)): n=ord(data[i]) flag+=chr((((n-11)^0x13)-23)^0x50) print(\u0026#39;flag{\u0026#39;+flag+\u0026#39;}\u0026#39;) 运行就能得到flag\nflag{tMx~qdstOs~crvtwb~aOba}qddtbrtcd} 0x5 Windows Reverse1 # 探测程序：\n程序是32位PE程序，使用了UPX的压缩壳，需要进行程序脱壳\n使用 upx -d命令进行脱壳\n脱壳后再次检查：\n脱壳之后然后进行静态分析：\nint __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp+4h] [ebp-804h] BYREF char v5[1023]; // [esp+5h] [ebp-803h] BYREF char v6; // [esp+404h] [ebp-404h] BYREF char v7[1023]; // [esp+405h] [ebp-403h] BYREF v6 = 0; memset(v7, 0, sizeof(v7)); v4 = 0; memset(v5, 0, sizeof(v5)); printf(\u0026#34;please input code:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;v6); sub_401000(\u0026amp;v6); if ( !strcmp(\u0026amp;v4, \u0026#34;DDCTF{reverseME}\u0026#34;) ) printf(\u0026#34;You\u0026#39;ve got it!!%s\\n\u0026#34;, \u0026amp;v4); else printf(\u0026#34;Try again later.\\n\u0026#34;); return 0; } 进行静态分析发现，存在一个关键函数在进行处理，即sub_401000函数在进行处理\n跟进这个函数\nunsigned int __cdecl sub_401000(const char *a1) { _BYTE *v1; // ecx unsigned int v2; // edi unsigned int result; // eax int v4; // ebx v2 = 0; result = strlen(a1); if ( result ) { v4 = a1 - v1; do { *v1 = byte_402FF8[(char)v1[v4]]; ++v2; ++v1; result = strlen(a1); } while ( v2 \u0026lt; result ); } return result; } 发现这个函数的具体实现算法相对而言是比较难以理解，当然也是本垃圾太菜了，对这个算法的逻辑搞不太清楚。\n看看这个代码的汇编语句：\n对汇编代码的阅读，就可以理解关键语句\n*v1 = byte_402FF8[(char)v1[v4]]; 这个代码就可以转换为\n*v1 = byte_402FF8[(char)(v1+v4)]; 同时，由于：\nv4 = a1 - v1; 因此：\n*v1 = byte_402FF8[(char)a1]; 这样子就很好分析了，就是将a1进行遍历，将数据存储在v1里面。下面就是寻找byte_402FF8\n由于本题是在进行很多地址的运算，数组也大概率被存储在更高位的地址，依着逻辑去寻找可以找到byte_402FF8\n应该就是下面那一坨字符，进行提取就可以了。\n现在逻辑已经大致梳理清楚了，可以写个程序进行求解了：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { char data[]{ 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 0 }; char c[]{\u0026#34;DDCTF{reverseME}\u0026#34;}; std::cout \u0026lt;\u0026lt; \u0026#34;flag{\u0026#34;; for(size_t i{ 0 };i \u0026lt; strlen(c);i++) { for(size_t j{ 0 };j \u0026lt; strlen(data); j++) { if(c[i] == data[j]) putchar(32+j); } } std::cout \u0026lt;\u0026lt; \u0026#34;}\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 编译并运行，就能拿到flag啦：\nflag{ZZ[JX#,9(9,+9QY!} 这道题目坑好多，而且考察的点是相对比较偏的。\n","date":"January 28, 2022","permalink":"/posts/xctf-reverse-expert-3_writeup/","section":"Posts","summary":"XCTF-REVERSE-高手区-3 writeup # 继续玩一玩逆向的题目，感觉还是蛮有意思的。\n0x0 srm-50 # 使用DIE进行探测：\n32位PE程序，无壳。可以尝试运行一下：\n应该是一个邮箱破解的程序，终于有点稍微有意思的题目了\n首先进行静态分析看代码：\n根据WIN32的编程基础，关键函数应该是在DialogFunc中，登录的细节应该是在DialogFunc中。\n跟进DialogFunc函数，来寻找更多的细节\nINT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4) { HMODULE v5; // eax HICON v6; // eax HMODULE v7; // eax HWND v8; // eax HCURSOR v9; // [esp-4h] [ebp-34Ch] CHAR String[256]; // [esp+8h] [ebp-340h] BYREF CHAR v11[256]; // [esp+108h] [ebp-240h] BYREF CHAR Text[256]; // [esp+208h] [ebp-140h] BYREF char Source[60]; // [esp+308h] [ebp-40h] BYREF if ( a2 == 16 ) { EndDialog(hDlg, 0); return 0; } if ( a2 == 272 ) { v5 = GetModuleHandleW(0); v6 = LoadIconW(v5, (LPCWSTR)0x67); SetClassLongA(hDlg, -14, (LONG)v6); v7 = GetModuleHandleW(0); v9 = LoadCursorW(v7, (LPCWSTR)0x66); v8 = GetDlgItem(hDlg, 1); SetClassLongA(v8, -12, (LONG)v9); return 1; } if ( a2 !","title":"XCTF REVERSE Expert (3) Writeup"},{"content":"XCTF-REVERSE-高手区-2 writeup # 感觉攻防世界的逆向题目还是蛮有意思的，刷着玩玩，就当作闯关游戏一样！\n0x0 EasyRE # 使用DIE查看一下程序信息：\n无壳32位程序，直接静态分析走起！\nint __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // kr00_4 int v4; // edx char *v5; // esi char v6; // al unsigned int i; // edx int v8; // eax char Arglist[16]; // [esp+2h] [ebp-24h] BYREF __int64 v11; // [esp+12h] [ebp-14h] BYREF int v12; // [esp+1Ah] [ebp-Ch] __int16 v13; // [esp+1Eh] [ebp-8h] sub_401020(Format, Arglist[0]); v12 = 0; v13 = 0; *(_OWORD *)Arglist = 0i64; v11 = 0i64; sub_401050(\u0026#34;%s\u0026#34;, (char)Arglist); v3 = strlen(Arglist); if ( v3 \u0026gt;= 0x10 \u0026amp;\u0026amp; v3 == 24 ) { v4 = 0; v5 = (char *)\u0026amp;v11 + 7; do { v6 = *v5--; byte_40336C[v4++] = v6; } while ( v4 \u0026lt; 24 ); for ( i = 0; i \u0026lt; 0x18; ++i ) byte_40336C[i] = (byte_40336C[i] + 1) ^ 6; v8 = strcmp(byte_40336C, aXircjR2twsv3pt); if ( v8 ) v8 = v8 \u0026lt; 0 ? -1 : 1; if ( !v8 ) { sub_401020(\u0026#34;right\\n\u0026#34;, Arglist[0]); system(\u0026#34;pause\u0026#34;); } } return 0; } 看代码，应该是比较简单的。但是需要对代码进行相对比较仔细的审计，来确保代码审计的成功\n首先程序先对数组进行了倒序处理\nv4 = 0; v5 = (char *)\u0026amp;v11 + 7; do { v6 = *v5--; byte_40336C[v4++] = v6; } while ( v4 \u0026lt; 24 ); 然后是对数据进行处理\nfor ( i = 0; i \u0026lt; 0x18; ++i ) byte_40336C[i] = (byte_40336C[i] + 1) ^ 6; 而我们的目标是得到原始匹配的输入数据来获取到flag\n编写一个小程序来获得flag\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { int data[]{ 0x78, 0x49, 0x72, 0x43, 0x6A, 0x7E, 0x3C, 0x72, 0x7C, 0x32, 0x74, 0x57, 0x73, 0x76, 0x33, 0x50, 0x74, 0x49, 0x7F, 0x7A, 0x6E, 0x64, 0x6B, 0x61 }; for(int i{ 0 };i\u0026lt;24;i++) { data[i] = (data[i]^6)-1; } for(int j{23};j\u0026gt;=0;j--) { putchar(data[j]); } return 0; } 编译并运行程序得到：\nflag{xNqU4otPq3ys9wkDsN} 0x1 Shuffle # 丢到DIE探测一波：\n没有壳，32位的Ubuntu编译的程序，直接静态分析\nint __cdecl main(int argc, const char **argv, const char **envp) { time_t v3; // ebx __pid_t v4; // eax int i; // [esp+14h] [ebp-44h] unsigned int v7; // [esp+18h] [ebp-40h] unsigned int v8; // [esp+1Ch] [ebp-3Ch] char v9; // [esp+20h] [ebp-38h] char s[40]; // [esp+24h] [ebp-34h] BYREF unsigned int v11; // [esp+4Ch] [ebp-Ch] v11 = __readgsdword(0x14u); strcpy(s, \u0026#34;SECCON{Welcome to the SECCON 2014 CTF!}\u0026#34;); v3 = time(0); v4 = getpid(); srand(v3 + v4); for ( i = 0; i \u0026lt;= 99; ++i ) { v7 = rand() % 0x28u; v8 = rand() % 0x28u; v9 = s[v7]; s[v7] = s[v8]; s[v8] = v9; } puts(s); return 0; } 由于题目描述：\n找到字符串在随机化之前 故flag为：\nSECCON{Welcome to the SECCON 2014 CTF!} 0x2 re-for-50-plz-50 # 使用DIE查看程序信息：\n没有壳32位程序，直接静态分析：\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int i; // [sp+18h] [+18h] for ( i = 0; i \u0026lt; 31; ++i ) { if ( meow[i] != (char)(argv[1][i] ^ 0x37) ) { print(\u0026#34;NOOOOOOOOOOOOOOOOOO\\n\u0026#34;); exit_funct(); } } puts(\u0026#34;C0ngr4ssulations!! U did it.\u0026#34;, argv, envp); exit_funct(); } 代码非常简单，就是对程序静态字符串进行按位异或操作，编写一个程序来求解：\n#include \u0026lt;iostream\u0026gt; int main() { int meow[]{ 0x63, 0x62, 0x74, 0x63, 0x71, 0x4C, 0x55, 0x42, 0x43, 0x68, 0x45, 0x52, 0x56, 0x5B, 0x5B, 0x4E, 0x68, 0x40, 0x5F, 0x58, 0x5E, 0x44, 0x5D, 0x58, 0x5F, 0x59, 0x50, 0x56, 0x5B, 0x43, 0x4A }; int f{0x37}; for(int i{0};i\u0026lt;31;i++) { putchar(meow[i]^f); } return 0; } 编译并运行得到：\nTUCTF{but_really_whoisjohngalt} 0x3 dmd-50 # 使用DIE来进行探测：\n64位ELF程序，静态分析一探究竟：\n看样子应该是C++编写的程序，可以发现汇编代码有个md5的函数，应该是使用了md5加密\n后面的汇编语句进行了一系列的比较操作：\n0x00400f36 cmp al, 0x37 ; 55 0x00400f38 jne 0x40129b 0x00400f3e mov rax, qword [var_58h] 0x00400f42 add rax, 1 0x00400f46 movzx eax, byte [rax] 0x00400f49 cmp al, 0x38 ; 56 0x00400f4b jne 0x40129b 0x00400f51 mov rax, qword [var_58h] 0x00400f55 add rax, 2 0x00400f59 movzx eax, byte [rax] 0x00400f5c cmp al, 0x30 ; 48 0x00400f5e jne 0x40129b 0x00400f64 mov rax, qword [var_58h] 0x00400f68 add rax, 3 0x00400f6c movzx eax, byte [rax] 0x00400f6f cmp al, 0x34 ; 52 0x00400f71 jne 0x40129b 0x00400f77 mov rax, qword [var_58h] 0x00400f7b add rax, 4 0x00400f7f movzx eax, byte [rax] 0x00400f82 cmp al, 0x33 ; 51 0x00400f84 jne 0x40129b 0x00400f8a mov rax, qword [var_58h] 0x00400f8e add rax, 5 0x00400f92 movzx eax, byte [rax] 0x00400f95 cmp al, 0x38 ; 56 0x00400f97 jne 0x40129b 0x00400f9d mov rax, qword [var_58h] 0x00400fa1 add rax, 6 0x00400fa5 movzx eax, byte [rax] 0x00400fa8 cmp al, 0x64 ; 100 0x00400faa jne 0x40129b 0x00400fb0 mov rax, qword [var_58h] 0x00400fb4 add rax, 7 0x00400fb8 movzx eax, byte [rax] 0x00400fbb cmp al, 0x35 ; 53 0x00400fbd jne 0x40129b 0x00400fc3 mov rax, qword [var_58h] 0x00400fc7 add rax, 8 0x00400fcb movzx eax, byte [rax] 0x00400fce cmp al, 0x62 ; 98 0x00400fd0 jne 0x40129b 0x00400fd6 mov rax, qword [var_58h] 0x00400fda add rax, 9 0x00400fde movzx eax, byte [rax] 0x00400fe1 cmp al, 0x36 ; 54 0x00400fe3 jne 0x40129b 0x00400fe9 mov rax, qword [var_58h] 0x00400fed add rax, 0xa 0x00400ff1 movzx eax, byte [rax] 0x00400ff4 cmp al, 0x65 ; 101 0x00400ff6 jne 0x40129b 0x00400ffc mov rax, qword [var_58h] 0x00401000 add rax, 0xb ; 11 0x00401004 movzx eax, byte [rax] 0x00401007 cmp al, 0x32 ; 50 0x00401009 jne 0x40129b 0x0040100f mov rax, qword [var_58h] 0x00401013 add rax, 0xc ; 12 0x00401017 movzx eax, byte [rax] 0x0040101a cmp al, 0x39 ; 57 0x0040101c jne 0x40129b 0x00401022 mov rax, qword [var_58h] 0x00401026 add rax, 0xd ; 13 0x0040102a movzx eax, byte [rax] 0x0040102d cmp al, 0x64 ; 100 0x0040102f jne 0x40129b 0x00401035 mov rax, qword [var_58h] 0x00401039 add rax, 0xe ; 14 0x0040103d movzx eax, byte [rax] 0x00401040 cmp al, 0x62 ; 98 0x00401042 jne 0x40129b 0x00401048 mov rax, qword [var_58h] 0x0040104c add rax, 0xf ; 15 0x00401050 movzx eax, byte [rax] 0x00401053 cmp al, 0x30 ; 48 0x00401055 jne 0x40129b 0x0040105b mov rax, qword [var_58h] 0x0040105f add rax, 0x10 ; 16 0x00401063 movzx eax, byte [rax] 0x00401066 cmp al, 0x38 ; 56 0x00401068 jne 0x40129b 0x0040106e mov rax, qword [var_58h] 0x00401072 add rax, 0x11 ; 17 0x00401076 movzx eax, byte [rax] 0x00401079 cmp al, 0x39 ; 57 0x0040107b jne 0x40129b 0x00401081 mov rax, qword [var_58h] 0x00401085 add rax, 0x12 ; 18 0x00401089 movzx eax, byte [rax] 0x0040108c cmp al, 0x38 ; 56 0x0040108e jne 0x40129b 0x00401094 mov rax, qword [var_58h] 0x00401098 add rax, 0x13 ; 19 0x0040109c movzx eax, byte [rax] 0x0040109f cmp al, 0x62 ; 98 0x004010a1 jne 0x40129b 0x004010a7 mov rax, qword [var_58h] 0x004010ab add rax, 0x14 ; 20 0x004010af movzx eax, byte [rax] 0x004010b2 cmp al, 0x63 ; 99 0x004010b4 jne 0x40129b 0x004010ba mov rax, qword [var_58h] 0x004010be add rax, 0x15 ; 21 0x004010c2 movzx eax, byte [rax] 0x004010c5 cmp al, 0x34 ; 52 0x004010c7 jne 0x40129b 0x004010cd mov rax, qword [var_58h] 0x004010d1 add rax, 0x16 ; 22 0x004010d5 movzx eax, byte [rax] 0x004010d8 cmp al, 0x66 ; 102 0x004010da jne 0x40129b 0x004010e0 mov rax, qword [var_58h] 0x004010e4 add rax, 0x17 ; 23 0x004010e8 movzx eax, byte [rax] 0x004010eb cmp al, 0x30 ; 48 0x004010ed jne 0x40129b 0x004010f3 mov rax, qword [var_58h] 0x004010f7 add rax, 0x18 ; 24 0x004010fb movzx eax, byte [rax] 0x004010fe cmp al, 0x32 ; 50 0x00401100 jne 0x40129b 0x00401106 mov rax, qword [var_58h] 0x0040110a add rax, 0x19 ; 25 0x0040110e movzx eax, byte [rax] 0x00401111 cmp al, 0x32 ; 50 0x00401113 jne 0x40129b 0x00401119 mov rax, qword [var_58h] 0x0040111d add rax, 0x1a ; 26 0x00401121 movzx eax, byte [rax] 0x00401124 cmp al, 0x35 ; 53 0x00401126 jne 0x40129b 0x0040112c mov rax, qword [var_58h] 0x00401130 add rax, 0x1b ; 27 0x00401134 movzx eax, byte [rax] 0x00401137 cmp al, 0x39 ; 57 0x00401139 jne 0x40129b 0x0040113f mov rax, qword [var_58h] 0x00401143 add rax, 0x1c ; 28 0x00401147 movzx eax, byte [rax] 0x0040114a cmp al, 0x33 ; 51 0x0040114c jne 0x40129b 0x00401152 mov rax, qword [var_58h] 0x00401156 add rax, 0x1d ; 29 0x0040115a movzx eax, byte [rax] 0x0040115d cmp al, 0x35 ; 53 0x0040115f jne 0x40129b 0x00401165 mov rax, qword [var_58h] 0x00401169 add rax, 0x1e ; 30 0x0040116d movzx eax, byte [rax] 0x00401170 cmp al, 0x63 ; 99 0x00401172 jne 0x40129b 0x00401178 mov rax, qword [var_58h] 0x0040117c add rax, 0x1f ; 31 0x00401180 movzx eax, byte [rax] 0x00401183 cmp al, 0x30 ; 48 0x00401185 jne 0x40129b 根据汇编语句可以得到md5的字符应该是：\n780438d5b6e29db0898bc4f0225935c0 试试使用一些md5破解的工具进行破解：\nb781cbb29054db12f88f08c6e161c199 这个应该就是flag了，题目思路也就很简单。可能感到困难的是C++的反汇编。\n本题flag：\nb781cbb29054db12f88f08c6e161c199 0x4 parallel-comparator-200 # 题目直接给到了C的源代码\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #define FLAG_LEN 20 void * checking(void *arg) { char *result = malloc(sizeof(char)); char *argument = (char *)arg; *result = (argument[0]+argument[1]) ^ argument[2]; return result; } int highly_optimized_parallel_comparsion(char *user_string) { int initialization_number; int i; char generated_string[FLAG_LEN + 1]; generated_string[FLAG_LEN] = \u0026#39;\\0\u0026#39;; while ((initialization_number = random()) \u0026gt;= 64); int first_letter; first_letter = (initialization_number % 26) + 97; pthread_t thread[FLAG_LEN]; char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7}; char *arguments[20]; for (i = 0; i \u0026lt; FLAG_LEN; i++) { arguments[i] = (char *)malloc(3*sizeof(char)); arguments[i][0] = first_letter; arguments[i][1] = differences[i]; arguments[i][2] = user_string[i]; pthread_create((pthread_t*)(thread+i), NULL, checking, arguments[i]); } void *result; int just_a_string[FLAG_LEN] = {115, 116, 114, 97, 110, 103, 101, 95, 115, 116, 114, 105, 110, 103, 95, 105, 116, 95, 105, 115}; for (i = 0; i \u0026lt; FLAG_LEN; i++) { pthread_join(*(thread+i), \u0026amp;result); generated_string[i] = *(char *)result + just_a_string[i]; free(result); free(arguments[i]); } int is_ok = 1; for (i = 0; i \u0026lt; FLAG_LEN; i++) { if (generated_string[i] != just_a_string[i]) return 0; } return 1; } int main() { char *user_string = (char *)calloc(FLAG_LEN+1, sizeof(char)); fgets(user_string, FLAG_LEN+1, stdin); int is_ok = highly_optimized_parallel_comparsion(user_string); if (is_ok) printf(\u0026#34;You win!\\n\u0026#34;); else printf(\u0026#34;Wrong!\\n\u0026#34;); return 0; } 应该是一个代码审计的题目，对C语言源码进行审计\n找到关键函数代码：\npthread_t thread[FLAG_LEN]; char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7}; char *arguments[20]; for (i = 0; i \u0026lt; FLAG_LEN; i++) { arguments[i] = (char *)malloc(3*sizeof(char)); arguments[i][0] = first_letter; arguments[i][1] = differences[i]; arguments[i][2] = user_string[i]; pthread_create((pthread_t*)(thread+i), NULL, checking, arguments[i]); } 关键应该是pthread_create函数和checking函数\nvoid * checking(void *arg) { char *result = malloc(sizeof(char)); char *argument = (char *)arg; *result = (argument[0]+argument[1]) ^ argument[2]; return result; } 通过对函数pthread_create的查阅并根据checking的返回值可以得到：\nresult == 0 ，也就是可以得到一个等式关系来进行求解：\n(argument[0]+argument[1]) == argument[2]; 故现在只需要得到argument[0]的数值就可以进行求解了：\nint first_letter; first_letter = (initialization_number % 26) + 97; 现在可以知道argument[0]的取值范围在 0 ~ 25根据这个范围进行爆破。\n根据上述分析，写一个python脚本求解：\ndifferences = [0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7] for i in range(97,97+26): flag =\u0026#34;\u0026#34; for k in differences: flag += chr(k+i) print(flag) 运行代码在输出结果中可以找到：\n故本题的flag:\nlucky_hacker_you_are 0x5 secret-galaxy-300 # 使用DIE来对程序进行探测：\n没有壳，静态分析看下代码：\nint __cdecl main(int argc, const char **argv, const char **envp) { __main(); fill_starbase(\u0026amp;starbase); print_starbase(\u0026amp;starbase); return 0; } 分别跟进两个函数来查看\nfill_starbase：\nvoid __cdecl fill_starbase(int a1) { int i; // [esp+8h] [ebp-10h] int v2; // [esp+Ch] [ebp-Ch] v2 = 0; for ( i = 0; i \u0026lt;= 4; ++i ) { *(_DWORD *)(a1 + 24 * i) = galaxy_name[i]; *(_DWORD *)(24 * i + a1 + 4) = rand(); *(_DWORD *)(24 * i + a1 + 8) = 0; *(_DWORD *)(24 * i + a1 + 12) = 0; *(_DWORD *)(24 * i + a1 + 16) = 24 * (i + 1) + a1; *(_DWORD *)(a1 + 24 * i + 20) = v2; v2 = 24 * i + a1; } print_starbase：\nint __cdecl print_starbase(int a1) { int result; // eax const char *v2; // edx int i; // [esp+1Ch] [ebp-Ch] puts(\u0026#34;--------------GALAXY DATABASE-------------\u0026#34;); printf(\u0026#34;%10s | %s | %s\\n\u0026#34;, \u0026#34;Galaxy name\u0026#34;, \u0026#34;Existence of life\u0026#34;, \u0026#34;Distance from Earth\u0026#34;); result = puts(\u0026#34;-------------------------------------------\u0026#34;); for ( i = 0; i \u0026lt;= 4; ++i ) { if ( *(_DWORD *)(24 * i + a1 + 8) == 1 ) v2 = \u0026#34;INHABITED\u0026#34;; else v2 = \u0026#34;IS NOT INHABITED\u0026#34;; result = printf(\u0026#34;%11s | %17s | %d\\n\u0026#34;, *(const char **)(24 * i + a1), v2, *(_DWORD *)(24 * i + a1 + 4)); } return result; } 实在是看不出什么线索，查看一下字符串输出\n发现有个字符串没有进行输出，有点可疑，跟进去一探究竟\n果然有些端倪，继续追踪\n再接再励，真相就在眼前\n这个字符串的地址是0x4013E0，拿到了地址就可以做很多事情了，可以使用Ollydbg跟踪到这个地址来进行动态分析，如果没有问题的话，flag应该就在动态调试的内存中。先来尝试一下调试调试：\n步入到断点0x4013E0，不断进行F8单步运行，运行到函数结尾位置，查看一下内存：\n发现可疑字符，这段字符应该就是可能的flag\n这道题目的flag是\naliens_are_around_us ","date":"January 28, 2022","permalink":"/posts/xctf-reverse-expert-2_writeup/","section":"Posts","summary":"XCTF-REVERSE-高手区-2 writeup # 感觉攻防世界的逆向题目还是蛮有意思的，刷着玩玩，就当作闯关游戏一样！\n0x0 EasyRE # 使用DIE查看一下程序信息：\n无壳32位程序，直接静态分析走起！\nint __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // kr00_4 int v4; // edx char *v5; // esi char v6; // al unsigned int i; // edx int v8; // eax char Arglist[16]; // [esp+2h] [ebp-24h] BYREF __int64 v11; // [esp+12h] [ebp-14h] BYREF int v12; // [esp+1Ah] [ebp-Ch] __int16 v13; // [esp+1Eh] [ebp-8h] sub_401020(Format, Arglist[0]); v12 = 0; v13 = 0; *(_OWORD *)Arglist = 0i64; v11 = 0i64; sub_401050(\u0026#34;%s\u0026#34;, (char)Arglist); v3 = strlen(Arglist); if ( v3 \u0026gt;= 0x10 \u0026amp;\u0026amp; v3 == 24 ) { v4 = 0; v5 = (char *)\u0026amp;v11 + 7; do { v6 = *v5--; byte_40336C[v4++] = v6; } while ( v4 \u0026lt; 24 ); for ( i = 0; i \u0026lt; 0x18; ++i ) byte_40336C[i] = (byte_40336C[i] + 1) ^ 6; v8 = strcmp(byte_40336C, aXircjR2twsv3pt); if ( v8 ) v8 = v8 \u0026lt; 0 ?","title":"XCTF REVERSE Expert (2) Writeup"},{"content":"XCTF-REVERSE-高手区-1 writeup # 有段时间没有刷题了，刷刷题找找手感\n0x0 answer_to_everything # 使用DIE查看程序信息\n程序没有壳，而且是64位。然后看看文件长什么样，静态分析的时刻来临：\n发现关键函数，跟进这个函数\n__int64 __fastcall not_the_flag(int a1) { if ( a1 == 42 ) puts(\u0026#34;Cipher from Bill \\nSubmit without any tags\\n#kdudpeh\u0026#34;); else puts(\u0026#34;YOUSUCK\u0026#34;); return 0LL; } 根据题目要求，应该是要对一个字段进行sha1加密，仔细观察逆向程序，发现应该是对kdudpeh进行sha1加密\n使用python进行sha1加密得：\n80ee2a3fe31da904c596d993f7f1de4827c1450a 故本题flag为\nflag{80ee2a3fe31da904c596d993f7f1de4827c1450a} 0x1 elrond32 # 使用DIE查询一下文件信息\n32位的exec文件，使用IDA pro打开\n定位到main函数的位置\nint __cdecl main(int a1, char **a2) { if ( a1 \u0026gt; 1 \u0026amp;\u0026amp; sub_8048414(a2[1], 0) ) { puts(\u0026#34;Access granted\u0026#34;); sub_8048538(a2[1]); } else { puts(\u0026#34;Access denied\u0026#34;); } return 0; } 关键函数应该是在sub_8048538(a2[1])函数里面\n跟进到sub_8048538(a2[1])函数\nint __cdecl sub_8048538(int a1) { int v2[33]; // [esp+18h] [ebp-A0h] BYREF int i; // [esp+9Ch] [ebp-1Ch] qmemcpy(v2, \u0026amp;unk_8048760, sizeof(v2)); for ( i = 0; i \u0026lt;= 32; ++i ) putchar(v2[i] ^ *(char *)(a1 + i % 8)); return putchar(10); } 发现和参数a2有关联，需要寻找a2的相关线索\n发现if判断那个位置的函数有对a2数据进行处理，跟进那个函数：\nint __cdecl sub_8048414(_BYTE *a1, int a2) { int result; // eax switch ( a2 ) { case 0: if ( *a1 == 105 ) goto LABEL_19; result = 0; break; case 1: if ( *a1 == 101 ) goto LABEL_19; result = 0; break; case 3: if ( *a1 == 110 ) goto LABEL_19; result = 0; break; case 4: if ( *a1 == 100 ) goto LABEL_19; result = 0; break; case 5: if ( *a1 == 97 ) goto LABEL_19; result = 0; break; case 6: if ( *a1 == 103 ) goto LABEL_19; result = 0; break; case 7: if ( *a1 == 115 ) goto LABEL_19; result = 0; break; case 9: if ( *a1 == 114 ) LABEL_19: result = sub_8048414(a1 + 1, 7 * (a2 + 1) % 11); else result = 0; break; default: result = 1; break; } return result; } 对于a2进行递归变化，结合对于a2处理的函数，可以编写个小程序来生成flag\n#include \u0026lt;iostream\u0026gt; int main() { int v2[] { 0x0F, 0x1F, 0x04, 0x09, 0x1C, 0x12, 0x42, 0x09, 0x0C, 0x44, 0x0D, 0x07, 0x09, 0x06, 0x2D, 0x37, 0x59, 0x1E, 0x00, 0x59, 0x0F, 0x08, 0x1C, 0x23, 0x36, 0x07, 0x55, 0x02, 0x0C, 0x08, 0x41, 0x0A, 0x14 }; int key[] { 105,115,101,110,103,97,114,100 }; for(int i = 0;i\u0026lt;33;i++) { putchar(v2[i]^key[i%8]); } return 0; } 编译并运行，就能得到flag\nflag{s0me7hing_S0me7hinG_t0lki3n} 0x2 666 # 使用DIE查询一下程序信息：\n64位程序，使用GCC进行编译的无壳程序\n使用IDA x64 pro 对程序进行静态分析：\nint __cdecl main(int argc, const char **argv, const char **envp) { char s[240]; // [rsp+0h] [rbp-1E0h] BYREF char v5[240]; // [rsp+F0h] [rbp-F0h] BYREF memset(s, 0, 30uLL); printf(\u0026#34;Please Input Key: \u0026#34;); __isoc99_scanf(\u0026#34;%s\u0026#34;, v5); encode(v5, (__int64)s); if ( strlen(v5) == key ) { if ( !strcmp(s, enflag) ) puts(\u0026#34;You are Right\u0026#34;); else puts(\u0026#34;flag{This_1s_f4cker_flag}\u0026#34;); } return 0; } 关键函数应该是在encode里面，这个程序的基本逻辑就是将输入进行encode函数处理，然后与指定的字符串进行比对来进行验证。\n而输入的字符串就是flag数据。\n因此，这道题目也就可以非常简单进行处理，也就是对encode函数进行逆向处理就可\n首先，还是查看一下encode的内部实现情况：\nint __fastcall encode(const char *a1, __int64 a2) { char v3[104]; // [rsp+10h] [rbp-70h] int v4; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] i = 0; v4 = 0; if ( strlen(a1) != key ) return puts(\u0026#34;Your Length is Wrong\u0026#34;); for ( i = 0; i \u0026lt; key; i += 3 ) { v3[i + 64] = key ^ (a1[i] + 6); v3[i + 33] = (a1[i + 1] - 6) ^ key; v3[i + 2] = a1[i + 2] ^ 6 ^ key; *(_BYTE *)(a2 + i) = v3[i + 64]; *(_BYTE *)(a2 + i + 1LL) = v3[i + 33]; *(_BYTE *)(a2 + i + 2LL) = v3[i + 2]; } return a2; } 进行跟踪发现key = 18\n可以得知我们输入的内容长度为18\n根据编码函数编写一个解密器进行程序破解\n#include \u0026lt;iostream\u0026gt; int main() { int enflag[] = { 0x69, 0x7A, 0x77, 0x68, 0x72, 0x6F, 0x7A, 0x22, 0x22, 0x77, 0x22, 0x76, 0x2E, 0x4B, 0x22, 0x2E, 0x4E, 0x69, 0x00 }; int key = 0x12; int i = 0; for(i;i\u0026lt;key;i+=3) { putchar((key^enflag[i])-6); putchar((enflag[i+1]^key)+6); putchar((enflag[i+2]^key^6)); } return 0; } 编译并运行程序就能拿到flag：\nunctf{b66_6b6_66b} 0x3 IgniteMe # 首先是使用DIE进行程序信息的查看：\n32位的PE程序，PE程序可以使用的工具就有很多了，首先还是静态分析：\nint __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax size_t i; // [esp+4Ch] [ebp-8Ch] char v5[8]; // [esp+50h] [ebp-88h] BYREF char Str[128]; // [esp+58h] [ebp-80h] BYREF sub_402B30(\u0026amp;unk_446360, \u0026#34;Give me your flag:\u0026#34;); sub_4013F0(sub_403670); sub_401440(Str, 127); if ( strlen(Str) \u0026lt; 0x1E \u0026amp;\u0026amp; strlen(Str) \u0026gt; 4 ) { strcpy(v5, \u0026#34;EIS{\u0026#34;); for ( i = 0; i \u0026lt; strlen(v5); ++i ) { if ( Str[i] != v5[i] ) goto LABEL_7; } if ( Str[28] != 125 ) { LABEL_7: sub_402B30(\u0026amp;unk_446360, \u0026#34;Sorry, keep trying! \u0026#34;); sub_4013F0(sub_403670); return 0; } if ( (unsigned __int8)sub_4011C0(Str) ) sub_402B30(\u0026amp;unk_446360, \u0026#34;Congratulations! \u0026#34;); else sub_402B30(\u0026amp;unk_446360, \u0026#34;Sorry, keep trying! \u0026#34;); sub_4013F0(sub_403670); result = 0; } else { sub_402B30(\u0026amp;unk_446360, \u0026#34;Sorry, keep trying!\u0026#34;); sub_4013F0(sub_403670); result = 0; } return result; } 找到关键加密的位置进行分析\n即对函数sub_4011c0(str)进行分析\nbool __cdecl sub_4011C0(char *Str) { size_t v2; // eax int v3; // [esp+50h] [ebp-B0h] char Str2[32]; // [esp+54h] [ebp-ACh] BYREF int v5; // [esp+74h] [ebp-8Ch] int v6; // [esp+78h] [ebp-88h] size_t i; // [esp+7Ch] [ebp-84h] char v8[128]; // [esp+80h] [ebp-80h] BYREF if ( strlen(Str) \u0026lt;= 4 ) return 0; i = 4; v6 = 0; while ( i \u0026lt; strlen(Str) - 1 ) v8[v6++] = Str[i++]; v8[v6] = 0; v5 = 0; v3 = 0; memset(Str2, 0, sizeof(Str2)); for ( i = 0; ; ++i ) { v2 = strlen(v8); if ( i \u0026gt;= v2 ) break; if ( v8[i] \u0026gt;= 97 \u0026amp;\u0026amp; v8[i] \u0026lt;= 122 ) { v8[i] -= 32; v3 = 1; } if ( !v3 \u0026amp;\u0026amp; v8[i] \u0026gt;= 65 \u0026amp;\u0026amp; v8[i] \u0026lt;= 90 ) v8[i] += 32; Str2[i] = byte_4420B0[i] ^ sub_4013C0(v8[i]); v3 = 0; } return strcmp(\u0026#34;GONDPHyGjPEKruv{{pj]X@rF\u0026#34;, Str2) == 0; } 直接就是一个加密算法，直接进行手撸一个解密算法即可：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { char flag[128]{ 0 }; char s[]{ 0x0D, 0x13, 0x17, 0x11, 0x02, 0x01, 0x20, 0x1D, 0x0C, 0x02, 0x19, 0x2F, 0x17, 0x2B, 0x24, 0x1F, 0x1E, 0x16, 0x09, 0x0F, 0x15, 0x27, 0x13, 0x26, 0x0A, 0x2F, 0x1E, 0x1A, 0x2D, 0x0C, 0x22, 0x04 }; char Str[]{ \u0026#34;GONDPHyGjPEKruv{{pj]X@rF\u0026#34; }; for(int i{ 0 };i\u0026lt;strlen(Str);i++) { flag[i] = ((Str[i]^s[i])-72)^0x55; if(flag[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; flag[i] \u0026lt;= \u0026#39;z\u0026#39;) { flag[i] -= 32; } else if(flag[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; flag[i] \u0026lt;= \u0026#39;Z\u0026#39;) { flag[i] += 32; } } std::cout \u0026lt;\u0026lt; \u0026#34;EIS{\u0026#34; \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; \u0026#34;}\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 编译并运行，就可以得到flag\nEIS{wadx_tdgk_aihc_ihkn_pjlm} 0x4 debug # 使用DIE进行正常的程序信息查询：\n.Net编译的程序，看样子不太友好。面对从未见到过的程序，该怎么做呢？这种情况下，就要使用强大的搜索引擎来寻找答案，经过搜索引擎的帮助，我这边找到了一个工具可以进行.Net程序的逆向——dnSpy\n使用dnSpy来进行.Net程序的开心逆向吧！\ndnSpy程序载入页面，dnSpy是一个非常好用的.Net程序和C#程序逆向工具，而且dnSpy的操作方式与Visual Studio非常相似，可以根据Visual Studio的操作模式进行debug。\n首先，需要寻找到关键函数和关键代码位置\n经过一番寻找，发现在02000003的位置有存在关键代码，根据关键代码跟进关键函数发现：\nflag就存在在这里，使用断点断在入口函数这里来进行调试，得到：\n得到flag：\nflag{967DDDFBCD32C1F53527C221D9E40A0B} 0x5 Guess-the-Number # 题目直接给了一个jar程序文件，应该是一个java逆向题目，java逆向和Android逆向类似，故可以使用相似的工具进行反编译：\npackage defpackage; import java.math.BigInteger; /* renamed from: guess reason: default package */ public class guess { static String XOR(String _str_one, String _str_two) { return new BigInteger(_str_one, 16).xor(new BigInteger(_str_two, 16)).toString(16); } public static void main(String[] args) { if (args.length \u0026gt; 0) { try { if (309137378 == Integer.parseInt(args[0])) { int my_num = 349763335 + 345736730; System.out.println(\u0026#34;your flag is: \u0026#34; + XOR(\u0026#34;4b64ca12ace755516c178f72d05d7061\u0026#34;, \u0026#34;ecd44646cfe5994ebeb35bf922e25dba\u0026#34;)); return; } System.err.println(\u0026#34;wrong guess!\u0026#34;); System.exit(1); } catch (NumberFormatException e) { System.err.println(\u0026#34;please enter an integer \\nexample: java -jar guess 12\u0026#34;); System.exit(1); } } else { System.err.println(\u0026#34;wrong guess!\u0026#34;); int num = 1000000 + 1; System.exit(1); } } } 可以直接拖到idea进行参数调试来得到flag🐱（偷懒小技巧）\n成功得到flag：\na7b08c546302cc1fd2a4d48bf2bf2ddb ","date":"January 28, 2022","permalink":"/posts/xctf-reverse-expert-1_writeup/","section":"Posts","summary":"XCTF-REVERSE-高手区-1 writeup # 有段时间没有刷题了，刷刷题找找手感\n0x0 answer_to_everything # 使用DIE查看程序信息\n程序没有壳，而且是64位。然后看看文件长什么样，静态分析的时刻来临：\n发现关键函数，跟进这个函数\n__int64 __fastcall not_the_flag(int a1) { if ( a1 == 42 ) puts(\u0026#34;Cipher from Bill \\nSubmit without any tags\\n#kdudpeh\u0026#34;); else puts(\u0026#34;YOUSUCK\u0026#34;); return 0LL; } 根据题目要求，应该是要对一个字段进行sha1加密，仔细观察逆向程序，发现应该是对kdudpeh进行sha1加密\n使用python进行sha1加密得：\n80ee2a3fe31da904c596d993f7f1de4827c1450a 故本题flag为\nflag{80ee2a3fe31da904c596d993f7f1de4827c1450a} 0x1 elrond32 # 使用DIE查询一下文件信息\n32位的exec文件，使用IDA pro打开\n定位到main函数的位置\nint __cdecl main(int a1, char **a2) { if ( a1 \u0026gt; 1 \u0026amp;\u0026amp; sub_8048414(a2[1], 0) ) { puts(\u0026#34;Access granted\u0026#34;); sub_8048538(a2[1]); } else { puts(\u0026#34;Access denied\u0026#34;); } return 0; } 关键函数应该是在sub_8048538(a2[1])函数里面","title":"XCTF REVERSE Expert (1) Writeup"},{"content":"BUUCTF-REVERSE-3 writeup # 8道练手的逆向题目，可以尝试做一做\n0x0 [GWCTF 2019] pyre # 应该是python逆向的题目\n果然是一个pyc文件，使用pyc的逆向工具进行处理得到python的代码\n# uncompyle6 version 3.7.4 # Python bytecode 2.7 (62211) # Decompiled from: Python 3.8.8 (default, Apr 13 2021, 15:08:03) [MSC v.1916 64 bit (AMD64)] # Embedded file name: encode.py # Compiled at: 2019-08-19 21:01:57 print \u0026#39;Welcome to Re World!\u0026#39; print \u0026#39;Your input1 is your flag~\u0026#39; l = len(input1) for i in range(l): num = ((input1[i] + i) % 128 + 128) % 128 code += num for i in range(l - 1): code[i] = code[i] ^ code[(i + 1)] print code code = [\u0026#39;\\x1f\u0026#39;, \u0026#39;\\x12\u0026#39;, \u0026#39;\\x1d\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;\\x01\u0026#39;, \u0026#39;\\x06\u0026#39;, \u0026#39;\\x14\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;\\x1b\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;:\u0026#39;, \u0026#39;\\x01\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;%\u0026#39;, \u0026#39;\\x13\u0026#39;] # okay decompiling .\\attachment.pyc 对代码进行审计，发现input1的数值没有给到，感觉应该是在input1里面。根据代码进行逆推\ncode = [\u0026#39;\\x1f\u0026#39;, \u0026#39;\\x12\u0026#39;, \u0026#39;\\x1d\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;\\x01\u0026#39;, \u0026#39;\\x06\u0026#39;, \u0026#39;\\x14\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;\\x1b\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;:\u0026#39;, \u0026#39;\\x01\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;%\u0026#39;, \u0026#39;\\x13\u0026#39;] l = len(code) for i in range(l-2,-1,-1): code[i] = chr(ord(code[i])^ord(code[i+1])) flag = \u0026#34;\u0026#34; for i in range(l): flag += chr((ord(code[i]) - i)%128) print(flag) 运行脚本，得到flag\nGWHT{Just_Re_1s_Ha66y!} 0x1 rsa # rsa还能出逆向题目：D！Crypto手狂喜\n两个文件，一个enc文件和一个key文件，标准的RSA文件\n可以使用python脚本来获取n的数值和e的数据\nfrom Crypto.PublicKey import RSA with open(\u0026#34;pub.key\u0026#34;,\u0026#39;r\u0026#39;) as f: public_key = RSA.import_key(f.read()) e = public_key.e n = public_key.n print(n) 得到n的数值\n86934482296048119190666062003494800588905656017203025617216654058378322103517 然后使用yafu工具进行大数分解，得到p和q\nP = 304008741604601924494328155975272418463 Q = 285960468890451637935629440372639283459 然后根据后续得到是数据写脚本求解\nfrom Crypto.PublicKey import RSA from Crypto.Util.number import long_to_bytes,bytes_to_long from libnum import invmod with open(\u0026#34;pub.key\u0026#34;,\u0026#39;r\u0026#39;) as f: public_key = RSA.import_key(f.read()) e = public_key.e n = public_key.n # print(n) with open(\u0026#34;flag.enc\u0026#34;,\u0026#34;rb\u0026#34;) as f: c = bytes_to_long(f.read()) p = 304008741604601924494328155975272418463 q = 285960468890451637935629440372639283459 phi = (p-1)*(q-1) d = invmod(e,phi) m = pow(c,d,n) flag = long_to_bytes(m) print(flag) 运行脚本得到flag\nb\u0026#39;\\x02\\x9d {zR\\x1e\\x08\\xe4\\xe6\\x18\\x06\\x00flag{decrypt_256}\\n\u0026#39; flag即为\nflag{decrypt_256} 0x2 [ACTF新生赛] easyre # 走下流程，查下壳\n发现有壳，需要进行脱壳\n使用UPX进行脱壳处理\n然后再次查看信息\n32位程序，已经成功脱壳，可以丢进ida pro里面玩耍了\nint __cdecl main(int argc, const char **argv, const char **envp) { _BYTE v4[12]; // [esp+12h] [ebp-2Eh] BYREF _DWORD v5[3]; // [esp+1Eh] [ebp-22h] _BYTE v6[5]; // [esp+2Ah] [ebp-16h] BYREF int v7; // [esp+2Fh] [ebp-11h] int v8; // [esp+33h] [ebp-Dh] int v9; // [esp+37h] [ebp-9h] char v10; // [esp+3Bh] [ebp-5h] int i; // [esp+3Ch] [ebp-4h] __main(); qmemcpy(v4, \u0026#34;*F\u0026#39;\\\u0026#34;N,\\\u0026#34;(I?+@\u0026#34;, sizeof(v4)); printf(\u0026#34;Please input:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, v6); if ( v6[0] != 65 || v6[1] != 67 || v6[2] != 84 || v6[3] != 70 || v6[4] != 123 || v10 != 125 ) return 0; v5[0] = v7; v5[1] = v8; v5[2] = v9; for ( i = 0; i \u0026lt;= 11; ++i ) { if ( v4[i] != _data_start__[*((char *)v5 + i) - 1] ) return 0; } printf(\u0026#34;You are correct!\u0026#34;); return 0; } 就是非常简单的算法了，进行简单的逆向算法就可以求解，写一个python脚本进行求解\ndata_list = [42,70,39,34,78,44,34,40,73,63,43,64] data = r\u0026#34;}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?\u0026gt;=\u0026lt;;:9876543210/.-,+*)(\u0026#34; + chr(0x27) + r\u0026#39;\u0026amp;%$# !\u0026#34;\u0026#39; flag_list = [] for i in data_list: flag_list.append(data.find(chr(i))+1) s = [chr(x + 1) for x in pos] flag = \u0026#39;\u0026#39;.join(s) print (\u0026#39;flag{\u0026#39;+flag+\u0026#39;}\u0026#39;) 运行脚本就可以得到flag：\nflag{U9X_1S_W6@T?} 0x3 CrackRTF # 先查一下壳\n32位无壳的pe文件，使用ida pro打开文件\nint __cdecl main_0(int argc, const char **argv, const char **envp) { DWORD v3; // eax DWORD v4; // eax char Str[260]; // [esp+4Ch] [ebp-310h] BYREF int v7; // [esp+150h] [ebp-20Ch] char String1[260]; // [esp+154h] [ebp-208h] BYREF char Destination[260]; // [esp+258h] [ebp-104h] BYREF memset(Destination, 0, sizeof(Destination)); memset(String1, 0, sizeof(String1)); v7 = 0; printf(\u0026#34;pls input the first passwd(1): \u0026#34;); scanf(\u0026#34;%s\u0026#34;, Destination); if ( strlen(Destination) != 6 ) { printf(\u0026#34;Must be 6 characters!\\n\u0026#34;); ExitProcess(0); } v7 = atoi(Destination); if ( v7 \u0026lt; 100000 ) ExitProcess(0); strcat(Destination, \u0026#34;@DBApp\u0026#34;); v3 = strlen(Destination); sub_40100A((BYTE *)Destination, v3, String1); if ( !_strcmpi(String1, \u0026#34;6E32D0943418C2C33385BC35A1470250DD8923A9\u0026#34;) ) { printf(\u0026#34;continue...\\n\\n\u0026#34;); printf(\u0026#34;pls input the first passwd(2): \u0026#34;); memset(Str, 0, sizeof(Str)); scanf(\u0026#34;%s\u0026#34;, Str); if ( strlen(Str) != 6 ) { printf(\u0026#34;Must be 6 characters!\\n\u0026#34;); ExitProcess(0); } strcat(Str, Destination); memset(String1, 0, sizeof(String1)); v4 = strlen(Str); sub_401019((BYTE *)Str, v4, String1); if ( !_strcmpi(\u0026#34;27019e688a4e62a649fd99cadaafdb4e\u0026#34;, String1) ) { if ( !(unsigned __int8)sub_40100F(Str) ) { printf(\u0026#34;Error!!\\n\u0026#34;); ExitProcess(0); } printf(\u0026#34;bye ~~\\n\u0026#34;); } } return 0; } 对代码进行审计分析，发现我们需要输入两次密码\n首先看下第一次密码输入需要满足什么样的要求：\n第一次输入需要进行链接然后使用md5加密然后获取的数值与某些数值相等，也就是:\nMD5(xxxxxx@DBAPP) == 6E32D0943418C2C33385BC35A1470250DD8923A9 sub_40100A函数代码：\nint __cdecl sub_401230(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1) { int result; // eax DWORD i; // [esp+4Ch] [ebp-28h] CHAR String2[4]; // [esp+50h] [ebp-24h] BYREF BYTE v6[20]; // [esp+54h] [ebp-20h] BYREF DWORD pdwDataLen; // [esp+68h] [ebp-Ch] BYREF HCRYPTHASH phHash; // [esp+6Ch] [ebp-8h] BYREF HCRYPTPROV phProv; // [esp+70h] [ebp-4h] BYREF if ( !CryptAcquireContextA(\u0026amp;phProv, 0, 0, 1u, 0xF0000000) ) return 0; if ( CryptCreateHash(phProv, 0x8004u, 0, 0, \u0026amp;phHash) ) { if ( CryptHashData(phHash, pbData, dwDataLen, 0) ) { CryptGetHashParam(phHash, 2u, v6, \u0026amp;pdwDataLen, 0); *lpString1 = 0; for ( i = 0; i \u0026lt; pdwDataLen; ++i ) { wsprintfA(String2, \u0026#34;%02X\u0026#34;, v6[i]); lstrcatA(lpString1, String2); } CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); result = 1; } else { CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); result = 0; } } else { CryptReleaseContext(phProv, 0); result = 0; } return result; } 程序直接调用WIN32的API函数进行调用来进行MD5的加密\n使用在线的MD5工具进行解密获得：\n123321@DBApp 下面解决一下第二次加密的问题，第二次加密显然也是一个MD5的比较问题，即：\nMD5(xxxxxx123321@DBApp@DBAPP) == 27019e688a4e62a649fd99cadaafdb4e 同样使用上面那个MD5的工具进行求解就可以得到数据：\n~!3a@0123321@DBApp 现在得到了所有的密码，是不是可以运行一下程序来得到结果：\n运行程序得到了一个rtf文件，打开rtf文件就能得到flag啦：\nFlag{N0_M0re_Free_Bugs} 0x4 [2019红帽杯] easyRE # 得到一个ELF文件，可以确定是Linux系统的文件，虽然Linux系统的大多数文件是不带壳的，但是为了以防万一还是查下程序信息：\n64位程序，果然是没有壳的程序。使用x64 IDA pro打开一下程序，看看程序内部\n// positive sp value has been detected, the output may be wrong! void __fastcall __noreturn start(__int64 a1, __int64 a2, int a3) { __int64 v3; // rax int v4; // esi __int64 v5; // [rsp-8h] [rbp-8h] BYREF void *retaddr; // [rsp+0h] [rbp+0h] BYREF v4 = v5; v5 = v3; sub_401BC0( (unsigned int)sub_4009C6, v4, (unsigned int)\u0026amp;retaddr, (unsigned int)sub_402080, (unsigned int)sub_402110, a3, (__int64)\u0026amp;v5); } 好像是找不到什么具体的内容，使用字符串检索定位到关键函数的位置\n__int64 sub_4009C6() { __int64 result; // rax int i; // [rsp+Ch] [rbp-114h] __int64 v2; // [rsp+10h] [rbp-110h] __int64 v3; // [rsp+18h] [rbp-108h] __int64 v4; // [rsp+20h] [rbp-100h] __int64 v5; // [rsp+28h] [rbp-F8h] __int64 v6; // [rsp+30h] [rbp-F0h] __int64 v7; // [rsp+38h] [rbp-E8h] __int64 v8; // [rsp+40h] [rbp-E0h] __int64 v9; // [rsp+48h] [rbp-D8h] __int64 v10; // [rsp+50h] [rbp-D0h] __int64 v11; // [rsp+58h] [rbp-C8h] char v12[13]; // [rsp+60h] [rbp-C0h] BYREF char v13[4]; // [rsp+6Dh] [rbp-B3h] BYREF char v14[19]; // [rsp+71h] [rbp-AFh] BYREF char v15[32]; // [rsp+90h] [rbp-90h] BYREF int v16; // [rsp+B0h] [rbp-70h] char v17; // [rsp+B4h] [rbp-6Ch] char v18[72]; // [rsp+C0h] [rbp-60h] BYREF unsigned __int64 v19; // [rsp+108h] [rbp-18h] v19 = __readfsqword(0x28u); qmemcpy(v12, \u0026#34;Iodl\u0026gt;Qnb(ocy\u0026#34;, 12); v12[12] = 127; qmemcpy(v13, \u0026#34;y.i\u0026#34;, 3); v13[3] = 127; qmemcpy(v14, \u0026#34;d`3w}wek9{iy=~yL@EC\u0026#34;, sizeof(v14)); memset(v15, 0, sizeof(v15)); v16 = 0; v17 = 0; sub_4406E0(0LL, v15, 37LL); v17 = 0; if ( sub_424BA0(v15) == 36 ) { for ( i = 0; i \u0026lt; (unsigned __int64)sub_424BA0(v15); ++i ) { if ( (unsigned __int8)(v15[i] ^ i) != v12[i] ) { result = 4294967294LL; goto LABEL_13; } } sub_410CC0(\u0026#34;continue!\u0026#34;); memset(v18, 0, 0x40uLL); v18[64] = 0; sub_4406E0(0LL, v18, 64LL); v18[39] = 0; if ( sub_424BA0(v18) == 39 ) { v2 = sub_400E44(v18); v3 = sub_400E44(v2); v4 = sub_400E44(v3); v5 = sub_400E44(v4); v6 = sub_400E44(v5); v7 = sub_400E44(v6); v8 = sub_400E44(v7); v9 = sub_400E44(v8); v10 = sub_400E44(v9); v11 = sub_400E44(v10); if ( !(unsigned int)sub_400360(v11, off_6CC090) ) { sub_410CC0(\u0026#34;You found me!!!\u0026#34;); sub_410CC0(\u0026#34;bye bye~\u0026#34;); } result = 0LL; } else { result = 4294967293LL; } } else { result = 0xFFFFFFFFLL; } LABEL_13: if ( __readfsqword(0x28u) != v19 ) sub_444020(); return result; } 找到关键函数，下面就是对关键函数进行分析来寻找线索\n简单对代码进行审计，可以发现有很多混淆来防止我们进行正确的逆向分析操作\n来，让我们跳进第一个坑：\nv19 = __readfsqword(0x28u); qmemcpy(v12, \u0026#34;Iodl\u0026gt;Qnb(ocy\u0026#34;, 12); v12[12] = 127; qmemcpy(v13, \u0026#34;y.i\u0026#34;, 3); v13[3] = 127; qmemcpy(v14, \u0026#34;d`3w}wek9{iy=~yL@EC\u0026#34;, sizeof(v14)); memset(v15, 0, sizeof(v15)); v16 = 0; v17 = 0; sub_4406E0(0LL, v15, 37LL); v17 = 0; if ( sub_424BA0(v15) == 36 ) { for ( i = 0; i \u0026lt; (unsigned __int64)sub_424BA0(v15); ++i ) { if ( (unsigned __int8)(v15[i] ^ i) != v12[i] ) { result = 4294967294LL; goto LABEL_13; } } sub_410CC0(\u0026#34;continue!\u0026#34;); 写一个python脚本迭代出假flag：\ndata = [] v12 = \u0026#34;Iodl\u0026gt;Qnb(ocy\u0026#34; insert_v = 127; v13 = \u0026#34;y.i\u0026#34; v14 = \u0026#34;d`3w}wek9{iy=~yL@EC\u0026#34; flag = \u0026#34;\u0026#34; for i in v12: data.append(ord(i)) data.append(insert_v) for i in v13: data.append(ord(i)) data.append(insert_v) for i in v14: data.append(ord(i)) for i in range(36): flag +=chr(data[i]^i) print(flag) 运行脚本得到fake flag：\nInfo:The first four chars are `flag` 然后走进下面一个坑：\n（”吾愿称之为base64之坑“ XD ）\n提取数据：\nVm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ== 进行十次base64解密得到一个博客地址：https://bbs.pediy.com/thread-254172.htm\n点开博客看一下，可以看到这段话：\n所谓“让对手不要走正确的破解之路” 讲人话 就是“把对手往沟里带” 但对手并不傻 很多时候攻击方比防守方更聪明 要想带对手进沟 防守方必须首先透彻了解攻击方 特别是其人性弱点（知道为什么是马克思主义学院了吧） Good, 现在知道自己掉坑里面了， 两个坑都掉了一遍所以flag在哪呢？\n我们去找下主函数\n发现周围存在一个奇奇怪怪的函数，会不会就是这个函数呢\n点开看看：\nunsigned __int64 sub_400D35() { unsigned __int64 result; // rax unsigned int v1; // [rsp+Ch] [rbp-24h] int i; // [rsp+10h] [rbp-20h] int j; // [rsp+14h] [rbp-1Ch] unsigned int v4; // [rsp+24h] [rbp-Ch] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v1 = sub_43FD20(0LL) - qword_6CEE38; for ( i = 0; i \u0026lt;= 1233; ++i ) { sub_40F790(v1); sub_40FE60(); sub_40FE60(); v1 = sub_40FE60() ^ 0x98765432; } v4 = v1; if ( ((unsigned __int8)v1 ^ byte_6CC0A0[0]) == 102 \u0026amp;\u0026amp; (HIBYTE(v4) ^ (unsigned __int8)byte_6CC0A3) == 103 ) { for ( j = 0; j \u0026lt;= 24; ++j ) sub_410E90((unsigned __int8)(byte_6CC0A0[j] ^ *((_BYTE *)\u0026amp;v4 + j % 4))); } result = __readfsqword(0x28u) ^ v5; if ( result ) sub_444020(); return result; } 应该就是简单的异或操作了，需要提取数据来进行异或来得到flag\n提取数据并写一个异或脚本就就可以得到flag\ndata = [ 0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B ] s = \u0026#34;flag\u0026#34; key = \u0026#39;\u0026#39; flag = \u0026#39;\u0026#39; for i in range(4): key += chr(ord(s[i])^data[i]) for i in range(len(data)): flag += chr(data[i]^ord(key[i%4])) print(flag) 运行脚本就能得到flag，终于是over了\nflag{Act1ve_Defen5e_Test} 0x5 [ACTF新生赛2020] rome # 首先，查一下文件的信息\n32位程序，没有壳，丢进IDA prio里面看看：\nint func() { int result; // eax int v1[4]; // [esp+14h] [ebp-44h] unsigned __int8 v2; // [esp+24h] [ebp-34h] BYREF unsigned __int8 v3; // [esp+25h] [ebp-33h] unsigned __int8 v4; // [esp+26h] [ebp-32h] unsigned __int8 v5; // [esp+27h] [ebp-31h] unsigned __int8 v6; // [esp+28h] [ebp-30h] int v7; // [esp+29h] [ebp-2Fh] int v8; // [esp+2Dh] [ebp-2Bh] int v9; // [esp+31h] [ebp-27h] int v10; // [esp+35h] [ebp-23h] unsigned __int8 v11; // [esp+39h] [ebp-1Fh] char v12[29]; // [esp+3Bh] [ebp-1Dh] BYREF strcpy(v12, \u0026#34;Qsw3sj_lz4_Ujw@l\u0026#34;); printf(\u0026#34;Please input:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;v2); result = v2; if ( v2 == 65 ) { result = v3; if ( v3 == 67 ) { result = v4; if ( v4 == 84 ) { result = v5; if ( v5 == 70 ) { result = v6; if ( v6 == 123 ) { result = v11; if ( v11 == 125 ) { v1[0] = v7; v1[1] = v8; v1[2] = v9; v1[3] = v10; *(_DWORD *)\u0026amp;v12[17] = 0; while ( *(int *)\u0026amp;v12[17] \u0026lt;= 15 ) { if ( *((char *)v1 + *(_DWORD *)\u0026amp;v12[17]) \u0026gt; 64 \u0026amp;\u0026amp; *((char *)v1 + *(_DWORD *)\u0026amp;v12[17]) \u0026lt;= 90 ) *((_BYTE *)v1 + *(_DWORD *)\u0026amp;v12[17]) = (*((char *)v1 + *(_DWORD *)\u0026amp;v12[17]) - 51) % 26 + 65; if ( *((char *)v1 + *(_DWORD *)\u0026amp;v12[17]) \u0026gt; 96 \u0026amp;\u0026amp; *((char *)v1 + *(_DWORD *)\u0026amp;v12[17]) \u0026lt;= 122 ) *((_BYTE *)v1 + *(_DWORD *)\u0026amp;v12[17]) = (*((char *)v1 + *(_DWORD *)\u0026amp;v12[17]) - 79) % 26 + 97; ++*(_DWORD *)\u0026amp;v12[17]; } *(_DWORD *)\u0026amp;v12[17] = 0; while ( *(int *)\u0026amp;v12[17] \u0026lt;= 15 ) { result = (unsigned __int8)v12[*(_DWORD *)\u0026amp;v12[17]]; if ( *((_BYTE *)v1 + *(_DWORD *)\u0026amp;v12[17]) != (_BYTE)result ) return result; ++*(_DWORD *)\u0026amp;v12[17]; } result = printf(\u0026#34;You are correct!\u0026#34;); } } } } } } return result; } 对代码进行简单的审计，可以发现，程序的加密算法是类似与凯撒加密的位移方式，可以根据程序的这一特点写个Python脚本进行求解来得到flag的数据：\nimport string data = [81,115,119,51,115,106,95,108,122,52,95,85,106,119,64,108] Lower = string.ascii_lowercase Upper = string.ascii_uppercase flag = \u0026#34;\u0026#34; for i in data: if i \u0026gt; 64 and i \u0026lt;= 90: flag += Upper[i-14-65] elif i \u0026gt; 96 and i \u0026lt;= 122: flag += Lower[i-18-97] else: flag += chr(i) print (\u0026#39;flag{\u0026#39;+flag+\u0026#39;}\u0026#39;) 运行脚本，得到flag：\nflag{Cae3ar_th4_Gre@t} 0x6 [FlareOn4] login # 发现文件是一个html文件，应该是需要进行源码阅读的题目，然后逆向算法\n\u0026lt;!DOCTYPE Html /\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;FLARE On 2017\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;flag\u0026#34; id=\u0026#34;flag\u0026#34; value=\u0026#34;Enter the flag\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;prompt\u0026#34; value=\u0026#34;Click to check the flag\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.getElementById(\u0026#34;prompt\u0026#34;).onclick = function () { var flag = document.getElementById(\u0026#34;flag\u0026#34;).value; var rotFlag = flag.replace(/[a-zA-Z]/g, function (c) { return String.fromCharCode((c \u0026lt;= \u0026#34;Z\u0026#34; ? 90 : 122) \u0026gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26); }); if (\u0026#34;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz\u0026#34; == rotFlag) { alert(\u0026#34;Correct flag!\u0026#34;); } else { alert(\u0026#34;Incorrect flag, rot again\u0026#34;); } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 源码的核心逻辑是在JavaScript的代码中，看来题目要求我们可以能够对算法进行逆向分析，来得到flag数据\n代码进行的操作无非就是±13的操作。\n代码会区分大小写分别进行相应的操作来得到flag，如果字母+13小于字母表最后一位字母，字母最终就+13，否则字母最终就-13。逻辑非常简单，写个简单的逆向算法就能进行求解：\ncipher = \u0026#34;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz\u0026#34; m = \u0026#34;\u0026#34; for i in cipher: if ord(i) \u0026gt;= 65 and ord(i) \u0026lt;= 90: if ord(i)-13 \u0026lt; 65: m += chr(ord(i)+13) else: m += chr(ord(i)-13) elif ord(i) \u0026gt;= 97 and ord(i) \u0026lt;= 122: if ord(i)-13 \u0026lt; 97: m += chr(ord(i)+13) else: m += chr(ord(i)-13) else: m += i print(m) 运行脚本，就能得到flag：\nClientSideLoginsAreEasy@flare-on.com 唔~题目好像还有个hint可以看一下：\nHint:本题解出相应字符串后请用flag{}包裹，形如：flag{123456@flare-on.com} 所以，这道题目的flag应该就是：\nflag{ClientSideLoginsAreEasy@flare-on.com} 0x7 [GUET-CTF2019] re # 拿到程序，先看看程序的信息：\n发现程序有壳，而且是一个64位的ELF程序\n需要进行脱壳处理，程序使用的是最基本的UPX的壳，可以使用UPX进行简单脱壳：\nupx -d re 脱壳后，然后使用Exeinfo再次进行查看\n壳已经被脱掉，然后使用x64 IDA pro进行查看程序\n// positive sp value has been detected, the output may be wrong! void __fastcall __noreturn start(__int64 a1, __int64 a2, int a3) { __int64 v3; // rax int v4; // esi __int64 v5; // [rsp-8h] [rbp-8h] BYREF void *retaddr; // [rsp+0h] [rbp+0h] BYREF v4 = v5; v5 = v3; sub_4016C0( (unsigned int)sub_400E28, v4, (unsigned int)\u0026amp;retaddr, (unsigned int)sub_401B80, (unsigned int)sub_401C10, a3, (__int64)\u0026amp;v5); } 发现程序入口并找不到什么东西，应该是将入口函数进行混淆和隐藏了\n使用字符串检索来获取相应的信息，来定位到主函数：\n__int64 __fastcall sub_400E28(__int64 a1, int a2, int a3, int a4, int a5, int a6) { int v6; // edx int v7; // ecx int v8; // er8 int v9; // er9 __int64 result; // rax __int64 v11; // [rsp+0h] [rbp-30h] BYREF unsigned __int64 v12; // [rsp+28h] [rbp-8h] v12 = __readfsqword(0x28u); sub_40F950((unsigned int)\u0026#34;input your flag:\u0026#34;, a2, a3, a4, a5, a6, 0LL, 0LL, 0LL, 0LL); sub_40FA80((unsigned int)\u0026#34;%s\u0026#34;, (unsigned int)\u0026amp;v11, v6, v7, v8, v9, v11); if ( (unsigned int)sub_4009AE(\u0026amp;v11) ) sub_410350(\u0026#34;Correct!\u0026#34;); else sub_410350(\u0026#34;Wrong!\u0026#34;); result = 0LL; if ( __readfsqword(0x28u) != v12 ) sub_443550(); return result; } 主函数中的一些关键性的函数都被进行了混淆操作，代码进行审计分析\nv11是关键输入函数，然后sub_40FA80是关键性的函数，对sub_40FA80分析：\n_BOOL8 __fastcall sub_4009AE(char *a1) { if ( 1629056 * *a1 != 166163712 ) return 0LL; if ( 6771600 * a1[1] != 731332800 ) return 0LL; if ( 3682944 * a1[2] != 357245568 ) return 0LL; if ( 10431000 * a1[3] != 1074393000 ) return 0LL; if ( 3977328 * a1[4] != 489211344 ) return 0LL; if ( 5138336 * a1[5] != 518971936 ) return 0LL; if ( 7532250 * a1[7] != 406741500 ) return 0LL; if ( 5551632 * a1[8] != 294236496 ) return 0LL; if ( 3409728 * a1[9] != 177305856 ) return 0LL; if ( 13013670 * a1[10] != 650683500 ) return 0LL; if ( 6088797 * a1[11] != 298351053 ) return 0LL; if ( 7884663 * a1[12] != 386348487 ) return 0LL; if ( 8944053 * a1[13] != 438258597 ) return 0LL; if ( 5198490 * a1[14] != 249527520 ) return 0LL; if ( 4544518 * a1[15] != 445362764 ) return 0LL; if ( 3645600 * a1[17] != 174988800 ) return 0LL; if ( 10115280 * a1[16] != 981182160 ) return 0LL; if ( 9667504 * a1[18] != 493042704 ) return 0LL; if ( 5364450 * a1[19] != 257493600 ) return 0LL; if ( 13464540 * a1[20] != 767478780 ) return 0LL; if ( 5488432 * a1[21] != 312840624 ) return 0LL; if ( 14479500 * a1[22] != 1404511500 ) return 0LL; if ( 6451830 * a1[23] != 316139670 ) return 0LL; if ( 6252576 * a1[24] != 619005024 ) return 0LL; if ( 7763364 * a1[25] != 372641472 ) return 0LL; if ( 7327320 * a1[26] != 373693320 ) return 0LL; if ( 8741520 * a1[27] != 498266640 ) return 0LL; if ( 8871876 * a1[28] != 452465676 ) return 0LL; if ( 4086720 * a1[29] != 208422720 ) return 0LL; if ( 9374400 * a1[30] == 515592000 ) return 5759124 * a1[31] == 719890500; return 0LL; } 写个C语言的flag生成器来生成flag\n#include \u0026lt;stdio.h\u0026gt; int main() { char a1[30] = {0}; *a1 = 166163712 / 1629056; a1[1] = 731332800 / 6771600; a1[2] = 357245568 / 3682944; a1[3] = 1074393000 / 10431000; a1[4] = 489211344 / 3977328; a1[5] = 518971936 / 5138336; a1[7] = 406741500 / 7532250; a1[8] = 294236496 / 5551632; a1[9] = 177305856 / 3409728; a1[10] = 650683500 / 13013670; a1[11] = 298351053 / 6088797; a1[12] = 386348487 / 7884663; a1[13] = 438258597 / 8944053; a1[14] = 249527520 / 5198490; a1[15] = 445362764 / 4544518; a1[17] = 174988800 / 3645600; a1[16] = 981182160 / 10115280; a1[18] = 493042704 / 9667504; a1[19] = 257493600 / 5364450; a1[20] = 767478780 / 13464540; a1[21] = 312840624 / 5488432; a1[22] = 1404511500 / 14479500; a1[23] = 316139670 / 6451830; a1[24] = 619005024 / 6252576; a1[25] = 372641472 / 7763364; a1[26] = 373693320 / 7327320; a1[27] = 498266640 / 8741520; a1[28] = 452465676 / 8871876; a1[29] = 208422720 / 4086720; a1[30] = 515592000 / 9374400; a1[31] = 719890500 / 5759124; for(int i=0;i\u0026lt;32;++i) { if(a1[i] == 0) printf(\u0026#34;*\u0026#34;); else printf(\u0026#34;%c\u0026#34;,a1[i]); } printf(\u0026#34;\\n\u0026#34;); } 编译并运行来得到flag：\nflag{e*65421110ba03099a1c039337} 由于有一位的字符未知，需要进行爆破来得到flag:\nflag{e165421110ba03099a1c039337} ","date":"January 28, 2022","permalink":"/posts/buuctf-reverse-3_writeup/","section":"Posts","summary":"BUUCTF-REVERSE-3 writeup # 8道练手的逆向题目，可以尝试做一做\n0x0 [GWCTF 2019] pyre # 应该是python逆向的题目\n果然是一个pyc文件，使用pyc的逆向工具进行处理得到python的代码\n# uncompyle6 version 3.7.4 # Python bytecode 2.7 (62211) # Decompiled from: Python 3.8.8 (default, Apr 13 2021, 15:08:03) [MSC v.1916 64 bit (AMD64)] # Embedded file name: encode.py # Compiled at: 2019-08-19 21:01:57 print \u0026#39;Welcome to Re World!\u0026#39; print \u0026#39;Your input1 is your flag~\u0026#39; l = len(input1) for i in range(l): num = ((input1[i] + i) % 128 + 128) % 128 code += num for i in range(l - 1): code[i] = code[i] ^ code[(i + 1)] print code code = [\u0026#39;\\x1f\u0026#39;, \u0026#39;\\x12\u0026#39;, \u0026#39;\\x1d\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;\\x01\u0026#39;, \u0026#39;\\x06\u0026#39;, \u0026#39;\\x14\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;\\x1b\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;?","title":"BUUCTF REVERSE [17~24]_Writeup"},{"content":"BUUCTF-REVERSE-2 writeup # 8道逆向工程的小题目，re真是越来越有意思了\n0x0 不一样的flag # 简单看看题目描述\n是不是做习惯了常规的逆向题目？试试这道题，看你在能不能在程序中找到真正的flag！注意：flag并非是flag{XXX}形式，就是一个’字符串‘，考验眼力的时候到了！ 注意：得到的 flag 请包上 flag{} 提交 应该会是一道非常有趣的题目，非常有意思的题目。\n首先还是先查询一下程序信息\n没有壳，是一个32位的PE程序，丢进Cutter里面看个究竟吧\n#include \u0026lt;stdint.h\u0026gt; int32_t dbg_main (void) { int32_t var_4h; char[5][5] a; int[2] location; int32_t var_34h; int32_t choice; int32_t i; int32_t var_40h; /* int main(); */ _main (ebx, esi, edi); location = 0; var_34h = 0; edx = \u0026amp;a; ebx = \u0026#34;*11110100001010000101111#\u0026#34;; eax = 0x19; edi = edx; esi = ebx; ecx = eax; do { *(es:edi) = *(esi); ecx--; esi++; es:edi++; } while (ecx != 0); goto label_1; label_0: label_1: _puts (\u0026#34;you can choose one action to execute\u0026#34;); _puts (\u0026#34;1 up\u0026#34;); _puts (\u0026#34;2 down\u0026#34;); _puts (\u0026#34;3 left\u0026#34;); _printf (\u0026#34;4 right\\n:\u0026#34;); eax = \u0026amp;choice; _scanf (0x403066, eax); eax = choice; if (eax != 2) { if (eax \u0026lt;= 2) { if (eax != 1) { } else { if (eax != 3) { if (eax == 4) { goto label_2; } eax = location; eax--; location = eax; } else { } else { eax = location; eax++; location = eax; goto label_3; } } eax = var_34h; eax--; var_34h = eax; goto label_3; label_2: eax = var_34h; eax++; var_34h = eax; goto label_3; } _exit (1); } label_3: i = 0; while (i \u0026lt;= 1) { eax = i; eax = *((esp + eax*4 + 0x30)); if (eax \u0026gt;= 0) { eax = i; eax = *((esp + eax*4 + 0x30)); if (eax \u0026lt;= 4) { goto label_4; } } _exit (1); label_4: i++; } edx = location; ecx = var_34h; eax = edx; eax \u0026lt;\u0026lt;= 2; eax += edx; edx = \u0026amp;var_40h; eax += edx; eax += ecx; eax -= 0x29; al = *(eax); if (al == 0x31) { _exit (1); } edx = location; ecx = var_34h; eax = edx; eax \u0026lt;\u0026lt;= 2; eax += edx; esi = \u0026amp;var_40h; eax += esi; eax += ecx; eax -= 0x29; al = *(eax); if (al != 0x23) { goto label_0; } _puts (\u0026#34;\\nok, the order you enter is the flag!\u0026#34;); _exit (0); } 根据反编译的代码，可以发现这道题目是一个走迷宫的题目，总体而言，还是挺有意思的，找到迷宫数据然后走出迷宫。\n根据迷宫的特性，需要寻找一下一些关键性的信息，来完成迷宫的\n首先是迷宫的信息，可以从反编译的关键代码找到迷宫信息\nebx = \u0026#34;*11110100001010000101111#\u0026#34;; 将数据整合一下便得到如下内容：\n*1111 01000 01010 00010 1111# 对于这个数据可以非常清晰看出迷宫的形式，*是起点，#是终点，1不能通行，0可以通行。\n然后是寻找操作指令，自然也可以从反编译代码中找到\n_puts (\u0026#34;you can choose one action to execute\u0026#34;); _puts (\u0026#34;1 up\u0026#34;); _puts (\u0026#34;2 down\u0026#34;); _puts (\u0026#34;3 left\u0026#34;); _printf (\u0026#34;4 right\\n:\u0026#34;); 根据迷宫和操作数，就可以得到flag\nflag{222441144222} 0x1 SimpleRev # 首先查一下程序信息，看看程序具体是个什么\n是一个Linux程序，使用x64 IDA pro进行打开\n找到main函数位置，查看反编译代码\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // eax char v4; // [rsp+Fh] [rbp-1h] while ( 1 ) { while ( 1 ) { printf(\u0026#34;Welcome to CTF game!\\nPlease input d/D to start or input q/Q to quit this program: \u0026#34;); v4 = getchar(); if ( v4 != 100 \u0026amp;\u0026amp; v4 != 68 ) break; Decry(\u0026#34;Welcome to CTF game!\\nPlease input d/D to start or input q/Q to quit this program: \u0026#34;, argv); } if ( v4 == 113 || v4 == 81 ) Exit(\u0026#34;Welcome to CTF game!\\nPlease input d/D to start or input q/Q to quit this program: \u0026#34;, argv); puts(\u0026#34;Input fault format!\u0026#34;); v3 = getchar(); putchar(v3); } } 对反编译的代码进行简单的审计，发现Decry函数是关键函数，可以看看这个函数的具体实现细节\nunsigned __int64 Decry() { char v1; // [rsp+Fh] [rbp-51h] int v2; // [rsp+10h] [rbp-50h] int v3; // [rsp+14h] [rbp-4Ch] int i; // [rsp+18h] [rbp-48h] int v5; // [rsp+1Ch] [rbp-44h] char src[8]; // [rsp+20h] [rbp-40h] BYREF __int64 v7; // [rsp+28h] [rbp-38h] int v8; // [rsp+30h] [rbp-30h] __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF int v10; // [rsp+50h] [rbp-10h] unsigned __int64 v11; // [rsp+58h] [rbp-8h] v11 = __readfsqword(0x28u); *(_QWORD *)src = 0x534C43444ELL; v7 = 0LL; v8 = 0; v9[0] = 0x776F646168LL; v9[1] = 0LL; v10 = 0; text = (char *)join(key3, v9); strcpy(key, key1); strcat(key, src); v2 = 0; v3 = 0; getchar(); v5 = strlen(key); for ( i = 0; i \u0026lt; v5; ++i ) { if ( key[v3 % v5] \u0026gt; 64 \u0026amp;\u0026amp; key[v3 % v5] \u0026lt;= 90 ) key[i] = key[v3 % v5] + 32; ++v3; } printf(\u0026#34;Please input your flag:\u0026#34;); while ( 1 ) { v1 = getchar(); if ( v1 == 10 ) break; if ( v1 == 32 ) { ++v2; } else { if ( v1 \u0026lt;= 96 || v1 \u0026gt; 122 ) { if ( v1 \u0026gt; 64 \u0026amp;\u0026amp; v1 \u0026lt;= 90 ) { str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97; ++v3; } } else { str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97; ++v3; } if ( !(v3 % v5) ) putchar(32); ++v2; } } if ( !strcmp(text, str2) ) puts(\u0026#34;Congratulation!\\n\u0026#34;); else puts(\u0026#34;Try again!\\n\u0026#34;); return __readfsqword(0x28u) ^ v11; } 根据函数的核心代码可以知道，最开始的数据是\nIntel CPU/AMD CPU 计算机内部的数据存储的方式是以小端序存储的方式，因此部分数据是以颠倒方式进行存储的\ntext = \u0026#39;killshadow\u0026#39; key = \u0026#39;ADSFKNDCLS\u0026#39; 现在有原始数据就可以进一步对算法进行分析\nwhile ( 1 ) { v1 = getchar(); if ( v1 == 10 ) break; if ( v1 == 32 ) { ++v2; } else { if ( v1 \u0026lt;= 96 || v1 \u0026gt; 122 ) { if ( v1 \u0026gt; 64 \u0026amp;\u0026amp; v1 \u0026lt;= 90 ) { str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97; ++v3; } } else { str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97; ++v3; } if ( !(v3 % v5) ) putchar(32); ++v2; } } if ( !strcmp(text, str2) ) puts(\u0026#34;Congratulation!\\n\u0026#34;); else puts(\u0026#34;Try again!\\n\u0026#34;); 对代码观察可以发现，最终的逻辑判断是text的数据和str2的数据相等\n根据对于程序的逻辑判断，编写逆向算法\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int i, j, n = 0, v2 = 0, v3 = 0;; char v1; string text = \u0026#34;killshadow\u0026#34;; string key = \u0026#34;ADSFKNDCLS\u0026#34;; char flag[11] = { 0 }; char str2[104] = { 0 };\tint v5 = key.length(); for(int i=0; i\u0026lt;v5; ++i) { if ( key[v3 % v5] \u0026gt; 64 \u0026amp;\u0026amp; key[v3 % v5] \u0026lt;= 90 ) key[i] = key[v3 % v5] + 32; ++v3; } for (j = 0; j \u0026lt; 10; ++j) { for (v2 = 0; v2 \u0026lt; 10; ++v2) { v1 = text[v2] - 97 + 26 * j - 97 + key[v3++ % v5] + 39; if ((v1 \u0026gt;= 65 \u0026amp;\u0026amp; v1 \u0026lt;= 90) || (v1 \u0026gt;= 97 \u0026amp;\u0026amp; v1 \u0026lt;= 122)) { flag[v2] = v1; if (++n == 10) { cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; system(\u0026#34;PAUSE\u0026#34;); return 0; } } } } system(\u0026#34;PAUSE\u0026#34;); return 0; } 运行得到flag\nKLDQCUDFZO 0x2 Java逆向解密 # Java逆向的题目，本质上和安卓逆向有着异曲同工之处，可以使用安卓逆向工具进行打开，这里使用Jadx打开\npackage defpackage; import java.util.ArrayList; import java.util.Scanner; /* renamed from: Reverse reason: default package */ public class Reverse { public static void main(String[] args) { Scanner s = new Scanner(System.in); System.out.println(\u0026#34;Please input the flag ：\u0026#34;); String str = s.next(); System.out.println(\u0026#34;Your input is ：\u0026#34;); System.out.println(str); Encrypt(str.toCharArray()); } public static void Encrypt(char[] arr) { int[] KEY; ArrayList\u0026lt;Integer\u0026gt; Resultlist = new ArrayList\u0026lt;\u0026gt;(); for (char c : arr) { Resultlist.add(Integer.valueOf((c + \u0026#39;@\u0026#39;) ^ 32)); } ArrayList\u0026lt;Integer\u0026gt; KEYList = new ArrayList\u0026lt;\u0026gt;(); for (int i : new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65}) { KEYList.add(Integer.valueOf(i)); } System.out.println(\u0026#34;Result:\u0026#34;); if (Resultlist.equals(KEYList)) { System.out.println(\u0026#34;Congratulations！\u0026#34;); } else { System.err.println(\u0026#34;Error！\u0026#34;); } } } 应该就是最基本的代码审计\n关键代码其实就在Encrypt函数里面\npublic static void Encrypt(char[] arr) { int[] KEY; ArrayList\u0026lt;Integer\u0026gt; Resultlist = new ArrayList\u0026lt;\u0026gt;(); for (char c : arr) { Resultlist.add(Integer.valueOf((c + \u0026#39;@\u0026#39;) ^ 32)); } ArrayList\u0026lt;Integer\u0026gt; KEYList = new ArrayList\u0026lt;\u0026gt;(); for (int i : new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65}) { KEYList.add(Integer.valueOf(i)); } System.out.println(\u0026#34;Result:\u0026#34;); if (Resultlist.equals(KEYList)) { System.out.println(\u0026#34;Congratulations！\u0026#34;); } else { System.err.println(\u0026#34;Error！\u0026#34;); } } 应该是一个注册码校验程序，写一个java程序逆过去应该就可以得到flag\npackage re; import java.util.ArrayList; public class JavaRe { public static void main(String[] args) { ArrayList\u0026lt;Integer\u0026gt; KEYList = new ArrayList\u0026lt;\u0026gt;(); for (int i : new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65}) { KEYList.add(Integer.valueOf(i)); } ArrayList\u0026lt;Character\u0026gt; Resultlist = new ArrayList\u0026lt;\u0026gt;(); for (int c : KEYList) { Resultlist.add(((char)((c^ 32)-\u0026#39;@\u0026#39;))); } String flag = new String(); for(char c:Resultlist) { flag += c; } System.out.println(flag); } } 运行Java程序就可以得到flag\nThis_is_the_flag_! 0x3 刮开有奖 # 看下题目：\n这是一个赌博程序，快去赚钱吧！！！！！！！！！！！！！！！！！！！！！！！！！！！(在编辑框中的输入值，即为flag，提交即可) 注意：得到的 flag 请包上 flag{} 提交 先查一下壳：\n没壳，32位的程序，使用IDA pro打开\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { DialogBoxParamA(hInstance, (LPCSTR)0x67, 0, DialogFunc, 0); return 0; } 看样子是调用了一个WIN32的API函数，关键的代码应该是在DialogFunc函数代码中\nINT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4) { const char *v4; // esi const char *v5; // edi int v7[2]; // [esp+8h] [ebp-20030h] BYREF int v8; // [esp+10h] [ebp-20028h] int v9; // [esp+14h] [ebp-20024h] int v10; // [esp+18h] [ebp-20020h] int v11; // [esp+1Ch] [ebp-2001Ch] int v12; // [esp+20h] [ebp-20018h] int v13; // [esp+24h] [ebp-20014h] int v14; // [esp+28h] [ebp-20010h] int v15; // [esp+2Ch] [ebp-2000Ch] int v16; // [esp+30h] [ebp-20008h] CHAR String[65536]; // [esp+34h] [ebp-20004h] BYREF char v18[65536]; // [esp+10034h] [ebp-10004h] BYREF if ( a2 == 272 ) return 1; if ( a2 != 273 ) return 0; if ( (_WORD)a3 == 1001 ) { memset(String, 0, 0xFFFFu); GetDlgItemTextA(hDlg, 1000, String, 0xFFFF); if ( strlen(String) == 8 ) { v7[0] = 90; v7[1] = 74; v8 = 83; v9 = 69; v10 = 67; v11 = 97; v12 = 78; v13 = 72; v14 = 51; v15 = 110; v16 = 103; sub_4010F0(v7, 0, 10); memset(v18, 0, 0xFFFFu); v18[0] = String[5]; v18[2] = String[7]; v18[1] = String[6]; v4 = (const char *)sub_401000(v18, strlen(v18)); memset(v18, 0, 0xFFFFu); v18[1] = String[3]; v18[0] = String[2]; v18[2] = String[4]; v5 = (const char *)sub_401000(v18, strlen(v18)); if ( String[0] == v7[0] + 34 \u0026amp;\u0026amp; String[1] == v10 \u0026amp;\u0026amp; 4 * String[2] - 141 == 3 * v8 \u0026amp;\u0026amp; String[3] / 4 == 2 * (v13 / 9) \u0026amp;\u0026amp; !strcmp(v4, \u0026#34;ak1w\u0026#34;) \u0026amp;\u0026amp; !strcmp(v5, \u0026#34;V1Ax\u0026#34;) ) { MessageBoxA(hDlg, \u0026#34;U g3t 1T!\u0026#34;, \u0026#34;@_@\u0026#34;, 0); } } return 0; } if ( (_WORD)a3 != 1 \u0026amp;\u0026amp; (_WORD)a3 != 2 ) return 0; EndDialog(hDlg, (unsigned __int16)a3); return 1; } 也是调用了几个WIN32的API，对代码进行分析\n可以知道：\nGetDlgItemTextA 函数是获取输入的字符串\n这段代码对字符串进行了处理，主要是有两个处理函数sub_4010F0 和 sub_401000\n这个函数应该是处理这个程序字符串的关键函数\n先来看看sub_4010F0函数：\nint __cdecl sub_4010F0(int a1, int a2, int a3) { int result; // eax int i; // esi int v5; // ecx int v6; // edx result = a3; for ( i = a2; i \u0026lt;= a3; a2 = i ) { v5 = 4 * i; v6 = *(_DWORD *)(4 * i + a1); if ( a2 \u0026lt; result \u0026amp;\u0026amp; i \u0026lt; result ) { do { if ( v6 \u0026gt; *(_DWORD *)(a1 + 4 * result) ) { if ( i \u0026gt;= result ) break; ++i; *(_DWORD *)(v5 + a1) = *(_DWORD *)(a1 + 4 * result); if ( i \u0026gt;= result ) break; while ( *(_DWORD *)(a1 + 4 * i) \u0026lt;= v6 ) { if ( ++i \u0026gt;= result ) goto LABEL_13; } if ( i \u0026gt;= result ) break; v5 = 4 * i; *(_DWORD *)(a1 + 4 * result) = *(_DWORD *)(4 * i + a1); } --result; } while ( i \u0026lt; result ); } LABEL_13: *(_DWORD *)(a1 + 4 * result) = v6; sub_4010F0(a1, a2, i - 1); result = a3; ++i; } return result; } 代码的功能暂时不太清楚，毕竟对C语言的审计功底还是不是很到位，根据代码进行转换为相应的Cpp代码运行一下：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; using namespace std; int __cdecl sub_4010F0(char *a1, int a2, int a3) { int result; // eax int i; // esi int v5; // ecx int v6; // edx result = a3; for (i = a2; i \u0026lt;= a3; a2 = i) { v5 = i; v6 = a1[i]; if (a2 \u0026lt; result \u0026amp;\u0026amp; i \u0026lt; result) { do { if (v6 \u0026gt;a1[result]) { if (i \u0026gt;= result) break; ++i; a1[v5] = a1[result]; if (i \u0026gt;= result) break; while (a1[i] \u0026lt;= v6) { if (++i \u0026gt;= result) goto LABEL_13; } if (i \u0026gt;= result) break; v5 = i; a1[result] = a1[i]; } --result; } while (i \u0026lt; result); } LABEL_13: a1[result] = v6; sub_4010F0(a1, a2, i - 1); result = a3; ++i; } return result; } int main() { char v7[11]; v7[0] = 90; v7[1] = 74; v7[2] = 83; v7[3] = 69; v7[4] = 67; v7[5] = 97; v7[6] = 78; v7[7] = 72; v7[8] = 51; v7[9] = 110; v7[10] = 103; cout \u0026lt;\u0026lt; v7 \u0026lt;\u0026lt; endl; sub_4010F0(v7, 0, 10); for(int i = 0;i\u0026lt; 11;++i){ cout \u0026lt;\u0026lt; (int)v7[i] \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34;; } cout \u0026lt;\u0026lt; endl; system(\u0026#34;PAUSE\u0026#34;); return 0; } 运行代码，得到\nZJSECaNH3ng 51 67 69 72 74 78 83 90 97 103 110 看来应该是一个排序算法，按升序进行排序的\n下面分析另一个函数具体是个什么东西：\n_BYTE *__cdecl sub_401000(int a1, int a2) { int v2; // eax int v3; // esi size_t v4; // ebx _BYTE *v5; // eax _BYTE *v6; // edi int v7; // eax _BYTE *v8; // ebx int v9; // edi int v10; // edx int v11; // edi int v12; // eax int i; // esi _BYTE *result; // eax _BYTE *v15; // [esp+Ch] [ebp-10h] _BYTE *v16; // [esp+10h] [ebp-Ch] int v17; // [esp+14h] [ebp-8h] int v18; // [esp+18h] [ebp-4h] v2 = a2 / 3; v3 = 0; if ( a2 % 3 \u0026gt; 0 ) ++v2; v4 = 4 * v2 + 1; v5 = malloc(v4); v6 = v5; v15 = v5; if ( !v5 ) exit(0); memset(v5, 0, v4); v7 = a2; v8 = v6; v16 = v6; if ( a2 \u0026gt; 0 ) { while ( 1 ) { v9 = 0; v10 = 0; v18 = 0; do { if ( v3 \u0026gt;= v7 ) break; ++v10; v9 = *(unsigned __int8 *)(v3 + a1) | (v9 \u0026lt;\u0026lt; 8); ++v3; } while ( v10 \u0026lt; 3 ); v11 = v9 \u0026lt;\u0026lt; (8 * (3 - v10)); v12 = 0; v17 = v3; for ( i = 18; i \u0026gt; -6; i -= 6 ) { if ( v10 \u0026gt;= v12 ) { *((_BYTE *)\u0026amp;v18 + v12) = (v11 \u0026gt;\u0026gt; i) \u0026amp; 0x3F; v8 = v16; } else { *((_BYTE *)\u0026amp;v18 + v12) = 64; } *v8++ = byte_407830[*((char *)\u0026amp;v18 + v12++)]; v16 = v8; } v3 = v17; if ( v17 \u0026gt;= a2 ) break; v7 = a2; } v6 = v15; } result = v6; *v8 = 0; return result; } 看代码，发现有3和8移位的特征初步推测是base64编码，看到有一个byte_407830的数组，跟进点开查看数据内容\n看到这数据应该就可以断定是base64编码了。\n现在知道了两个函数的功能作用，可以直接进行求解，直接定位到判断条件的位置：\nif ( String[0] == v7[0] + 34 \u0026amp;\u0026amp; String[1] == v10 \u0026amp;\u0026amp; 4 * String[2] - 141 == 3 * v8 \u0026amp;\u0026amp; String[3] / 4 == 2 * (v13 / 9) \u0026amp;\u0026amp; !strcmp(v4, \u0026#34;ak1w\u0026#34;) \u0026amp;\u0026amp; !strcmp(v5, \u0026#34;V1Ax\u0026#34;) ) { MessageBoxA(hDlg, \u0026#34;U g3t 1T!\u0026#34;, \u0026#34;@_@\u0026#34;, 0); } 进行简单的推断可以得出\nString[0] == 85; // 51+34 = 85 String[1] == 74; String[2] == 87; //(3 x 69 +141)/4 = 87 String[3] == 80;// 2 x (90 / 9) x4 == 80 下面进行base64解码来得到后面四个字符的数据\nb\u0026#39;jMp\u0026#39; b\u0026#39;WP1\u0026#39; 根据推断出来的信息可以求解得到flag\nUJWP1jMp 也可以使用Python脚本快速求解\nimport base64 data = [51, 67, 69, 72, 74, 78, 83, 90, 97, 103, 110] String = \u0026#34;\u0026#34; String += chr(data[0]+34) String += chr(data[4]) String += base64.b64decode(\u0026#34;V1Ax\u0026#34;).decode() String += base64.b64decode(\u0026#34;ak1w\u0026#34;).decode() flag = \u0026#34;flag{\u0026#34;+String+\u0026#34;}\u0026#34; print(flag) 运行脚本就可以得到flag\nflag{UJWP1jMp} 0x4 [GXYCTF2019]luck_guy # 文件没有拓展名，感觉是一个ELF格式的文件\n先走一下逆向的流程，首先查下壳\n果然是一个ELF文件，64位的文件，用x64 IDA pro打开文件，查看主程序\nint __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v4; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); welcome(argc, argv, envp); puts(\u0026#34;_________________\u0026#34;); puts(\u0026#34;try to patch me and find flag\u0026#34;); v4 = 0; puts(\u0026#34;please input a lucky number\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); patch_me(v4); puts(\u0026#34;OK,see you again\u0026#34;); return 0; } 程序挺简单的，需要寻找一下核心代码\n看样子核心代码应该是在patch_me(v4)函数里面，进入函数内部\nint __fastcall patch_me(int a1) { int result; // eax if ( a1 % 2 == 1 ) result = puts(\u0026#34;just finished\u0026#34;); else result = get_flag(); return result; } 继续跟进到get_flag()函数里面\nunsigned __int64 get_flag() { unsigned int v0; // eax int i; // [rsp+4h] [rbp-3Ch] int j; // [rsp+8h] [rbp-38h] __int64 s; // [rsp+10h] [rbp-30h] BYREF char v5; // [rsp+18h] [rbp-28h] unsigned __int64 v6; // [rsp+38h] [rbp-8h] v6 = __readfsqword(0x28u); v0 = time(0LL); srand(v0); for ( i = 0; i \u0026lt;= 4; ++i ) { switch ( rand() % 200 ) { case 1: puts(\u0026#34;OK, it\u0026#39;s flag:\u0026#34;); memset(\u0026amp;s, 0, 0x28uLL); strcat((char *)\u0026amp;s, f1); strcat((char *)\u0026amp;s, \u0026amp;f2); printf(\u0026#34;%s\u0026#34;, (const char *)\u0026amp;s); break; case 2: printf(\u0026#34;Solar not like you\u0026#34;); break; case 3: printf(\u0026#34;Solar want a girlfriend\u0026#34;); break; case 4: s = 0x7F666F6067756369LL; v5 = 0; strcat(\u0026amp;f2, (const char *)\u0026amp;s); break; case 5: for ( j = 0; j \u0026lt;= 7; ++j ) { if ( j % 2 == 1 ) *(\u0026amp;f2 + j) -= 2; else --*(\u0026amp;f2 + j); } break; default: puts(\u0026#34;emmm,you can\u0026#39;t find flag 23333\u0026#34;); break; } } return __readfsqword(0x28u) ^ v6; } 看来flag应该就在这个函数里面，本来觉得可以使用gdb调试出来，无奈自己太菜了，不知道到gdb怎么修改汇编代码进行跳转，只能进行静态分析调试\n进行分析发现，switch 条件的顺序应该是 4 –\u0026gt; 5 —\u0026gt;1的顺序依次输出flag\n写一个脚本将flag数据输出\nflag = \u0026#39;GXY{do_not_\u0026#39; f2 = [0x7F, 0x66, 0x6F, 0x60, 0x67, 0x75, 0x63, 0x69][::-1] s = \u0026#39;\u0026#39; for i in range(8): if i % 2 == 1: s = chr(f2[i] - 2) else: s = chr(f2[i] - 1) flag += s print(flag) 运行脚本，得到flag\nGXY{do_not_hate_me} 0x5 findit # 看下题目哈\n不知不觉，小明长大了，变成了一个程序员，虽然很苦逼，但是偶尔编写个小东西坑害公司新人还是蛮好玩的。新人小萌一天问小明wifi账号密码，一分钟后，小萌收到了一个文件。小萌想了好久都没得到密码，怎么办，女朋友要买东西，流量告罄，没wifi上不了网，不买就分手，是时候该展现月老的实力了兄弟们！代表月亮惩罚小明！得出答案。 注意：得到的 flag 请包上 flag{} 提交 感觉像是一道APK的题目，下载附件发现果然是一个APK的题目，使用APK逆向工具jadx进行逆向\npackage com.example.findit; import android.os.Bundle; import android.support.v7.app.ActionBarActivity; import android.view.MenuItem; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; public class MainActivity extends ActionBarActivity { /* access modifiers changed from: protected */ @Override // android.support.v7.app.ActionBarActivity, android.support.v4.app.FragmentActivity public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final EditText edit = (EditText) findViewById(R.id.widget2); final TextView text = (TextView) findViewById(R.id.widget1); final char[] a = {\u0026#39;T\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;}; final char[] b = {\u0026#39;p\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;}\u0026#39;}; ((Button) findViewById(R.id.widget3)).setOnClickListener(new View.OnClickListener() { /* class com.example.findit.MainActivity.AnonymousClass1 */ public void onClick(View v) { char[] x = new char[17]; char[] y = new char[38]; for (int i = 0; i \u0026lt; 17; i++) { if ((a[i] \u0026lt; \u0026#39;I\u0026#39; \u0026amp;\u0026amp; a[i] \u0026gt;= \u0026#39;A\u0026#39;) || (a[i] \u0026lt; \u0026#39;i\u0026#39; \u0026amp;\u0026amp; a[i] \u0026gt;= \u0026#39;a\u0026#39;)) { x[i] = (char) (a[i] + 18); } else if ((a[i] \u0026lt; \u0026#39;A\u0026#39; || a[i] \u0026gt; \u0026#39;Z\u0026#39;) \u0026amp;\u0026amp; (a[i] \u0026lt; \u0026#39;a\u0026#39; || a[i] \u0026gt; \u0026#39;z\u0026#39;)) { x[i] = a[i]; } else { x[i] = (char) (a[i] - \u0026#39;\\b\u0026#39;); } } if (String.valueOf(x).equals(edit.getText().toString())) { for (int i2 = 0; i2 \u0026lt; 38; i2++) { if ((b[i2] \u0026lt; \u0026#39;A\u0026#39; || b[i2] \u0026gt; \u0026#39;Z\u0026#39;) \u0026amp;\u0026amp; (b[i2] \u0026lt; \u0026#39;a\u0026#39; || b[i2] \u0026gt; \u0026#39;z\u0026#39;)) { y[i2] = b[i2]; } else { y[i2] = (char) (b[i2] + 16); if ((y[i2] \u0026gt; \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; y[i2] \u0026lt; \u0026#39;a\u0026#39;) || y[i2] \u0026gt;= \u0026#39;z\u0026#39;) { y[i2] = (char) (y[i2] - 26); } } } text.setText(String.valueOf(y)); return; } text.setText(\u0026#34;答案错了肿么办。。。不给你又不好意思。。。哎呀好纠结啊~~~\u0026#34;); } }); } public boolean onOptionsItemSelected(MenuItem item) { if (item.getItemId() == R.id.action_settings) { return true; } return super.onOptionsItemSelected(item); } } 看样子好像是一个简单的加密程序，可以进行简单的分析\n发现主要的flag代码：\nfor (int i2 = 0; i2 \u0026lt; 38; i2++) { if ((b[i2] \u0026lt; \u0026#39;A\u0026#39; || b[i2] \u0026gt; \u0026#39;Z\u0026#39;) \u0026amp;\u0026amp; (b[i2] \u0026lt; \u0026#39;a\u0026#39; || b[i2] \u0026gt; \u0026#39;z\u0026#39;)) { y[i2] = b[i2]; } else { y[i2] = (char) (b[i2] + 16); if ((y[i2] \u0026gt; \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; y[i2] \u0026lt; \u0026#39;a\u0026#39;) || y[i2] \u0026gt;= \u0026#39;z\u0026#39;) { y[i2] = (char) (y[i2] - 26); } } } text.setText(String.valueOf(y)); return; 这行代码稍加修改一下运行就可以直接俄得到flag了，写个Java的flag生成器，来生成flag吧！\npackage re; public class Findit { final static char[] b = {\u0026#39;p\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;}\u0026#39;}; public static void main(String[] args) { char[] y = new char[38]; for (int i2 = 0; i2 \u0026lt; 38; i2++) { if ((b[i2] \u0026lt; \u0026#39;A\u0026#39; || b[i2] \u0026gt; \u0026#39;Z\u0026#39;) \u0026amp;\u0026amp; (b[i2] \u0026lt; \u0026#39;a\u0026#39; || b[i2] \u0026gt; \u0026#39;z\u0026#39;)) { y[i2] = b[i2]; } else { y[i2] = (char) (b[i2] + 16); if ((y[i2] \u0026gt; \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; y[i2] \u0026lt; \u0026#39;a\u0026#39;) || y[i2] \u0026gt;= \u0026#39;z\u0026#39;) { y[i2] = (char) (y[i2] - 26); } } } System.out.println(String.valueOf(y)); }\t} 运行一下这个java程序就能生成flag啦！\nflag{c164675262033b4c49bdf7f9cda28a75} 0x6 简单的注册器 # 看下题目\n生活中难免会有需要使用一些付费的程序，但是没有绿色版怎么办？只能自己逆向看看注册程序的代码是什么逻辑了。 注意：得到的 flag 请包上 flag{} 提交 下载附件，发现是一个apk文件，使用apk逆向工具jadx查看apk的伪代码\npackage com.example.flag; import android.os.Bundle; import android.support.v4.app.Fragment; import android.support.v7.app.ActionBarActivity; import android.view.LayoutInflater; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.view.ViewGroup; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; public class MainActivity extends ActionBarActivity { /* access modifiers changed from: protected */ @Override // android.support.v7.app.ActionBarActivity, android.support.v4.app.FragmentActivity public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState == null) { getSupportFragmentManager().beginTransaction().add(R.id.container, new PlaceholderFragment()).commit(); } final TextView textview = (TextView) findViewById(R.id.textView1); final EditText editview = (EditText) findViewById(R.id.editText1); ((Button) findViewById(R.id.button1)).setOnClickListener(new View.OnClickListener() { /* class com.example.flag.MainActivity.AnonymousClass1 */ public void onClick(View v) { int flag = 1; String xx = editview.getText().toString(); if (!(xx.length() == 32 \u0026amp;\u0026amp; xx.charAt(31) == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; xx.charAt(1) == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; (xx.charAt(0) + xx.charAt(2)) - 48 == 56)) { flag = 0; } if (flag == 1) { char[] x = \u0026#34;dd2940c04462b4dd7c450528835cca15\u0026#34;.toCharArray(); x[2] = (char) ((x[2] + x[3]) - 50); x[4] = (char) ((x[2] + x[5]) - 48); x[30] = (char) ((x[31] + x[9]) - 48); x[14] = (char) ((x[27] + x[28]) - 97); for (int i = 0; i \u0026lt; 16; i++) { char a = x[31 - i]; x[31 - i] = x[i]; x[i] = a; } textview.setText(\u0026#34;flag{\u0026#34; + String.valueOf(x) + \u0026#34;}\u0026#34;); return; } textview.setText(\u0026#34;输入注册码错误\u0026#34;); } }); } public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return true; } public boolean onOptionsItemSelected(MenuItem item) { if (item.getItemId() == R.id.action_settings) { return true; } return super.onOptionsItemSelected(item); } public static class PlaceholderFragment extends Fragment { @Override // android.support.v4.app.Fragment public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_main, container, false); } } } 进行简单的代码审计，可以确定核心代码：\nif (flag == 1) { char[] x = \u0026#34;dd2940c04462b4dd7c450528835cca15\u0026#34;.toCharArray(); x[2] = (char) ((x[2] + x[3]) - 50); x[4] = (char) ((x[2] + x[5]) - 48); x[30] = (char) ((x[31] + x[9]) - 48); x[14] = (char) ((x[27] + x[28]) - 97); for (int i = 0; i \u0026lt; 16; i++) { char a = x[31 - i]; x[31 - i] = x[i]; x[i] = a; } textview.setText(\u0026#34;flag{\u0026#34; + String.valueOf(x) + \u0026#34;}\u0026#34;); return; } 写一个Java注册器，把flag注册出来\npackage re; public class Register { public static void main(String[] args) { char[] x = \u0026#34;dd2940c04462b4dd7c450528835cca15\u0026#34;.toCharArray(); x[2] = (char) ((x[2] + x[3]) - 50); x[4] = (char) ((x[2] + x[5]) - 48); x[30] = (char) ((x[31] + x[9]) - 48); x[14] = (char) ((x[27] + x[28]) - 97); for (int i = 0; i \u0026lt; 16; i++) { char a = x[31 - i]; x[31 - i] = x[i]; x[i] = a; } System.out.println(\u0026#34;flag{\u0026#34; + String.valueOf(x) + \u0026#34;}\u0026#34;); } } 运行注册器来注册一个flag\nflag{59acc538825054c7de4b26440c0999dd} 0x7 [BJDCTF2020]JustRE # 下载下来是一个挺有意思的exe程序\n走下流程，首先是查询文件\n32位的PE程序，使用IDA pro反汇编通过检索BJD的字符串来定位到核心代码\nINT_PTR __stdcall DialogFunc(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4) { CHAR String[100]; // [esp+0h] [ebp-64h] BYREF if ( a2 != 272 ) { if ( a2 != 273 ) return 0; if ( (_WORD)a3 != 1 \u0026amp;\u0026amp; (_WORD)a3 != 2 ) { sprintf(String, Format, ++dword_4099F0); if ( dword_4099F0 == 19999 ) { sprintf(String, \u0026#34; BJD{%d%d2069a45792d233ac}\u0026#34;, 19999, 0); SetWindowTextA(hWnd, String); return 0; } SetWindowTextA(hWnd, String); return 0; } EndDialog(hWnd, (unsigned __int16)a3); } return 1; } 发现核心代码中隐藏着flag的信息，得到flag\nBJD{1999902069a45792d233ac} ","date":"January 28, 2022","permalink":"/posts/buuctf-reverse-2_writeup/","section":"Posts","summary":"BUUCTF-REVERSE-2 writeup # 8道逆向工程的小题目，re真是越来越有意思了\n0x0 不一样的flag # 简单看看题目描述\n是不是做习惯了常规的逆向题目？试试这道题，看你在能不能在程序中找到真正的flag！注意：flag并非是flag{XXX}形式，就是一个’字符串‘，考验眼力的时候到了！ 注意：得到的 flag 请包上 flag{} 提交 应该会是一道非常有趣的题目，非常有意思的题目。\n首先还是先查询一下程序信息\n没有壳，是一个32位的PE程序，丢进Cutter里面看个究竟吧\n#include \u0026lt;stdint.h\u0026gt; int32_t dbg_main (void) { int32_t var_4h; char[5][5] a; int[2] location; int32_t var_34h; int32_t choice; int32_t i; int32_t var_40h; /* int main(); */ _main (ebx, esi, edi); location = 0; var_34h = 0; edx = \u0026amp;a; ebx = \u0026#34;*11110100001010000101111#\u0026#34;; eax = 0x19; edi = edx; esi = ebx; ecx = eax; do { *(es:edi) = *(esi); ecx--; esi++; es:edi++; } while (ecx !","title":"BUUCTF REVERSE [9~16]_Writeup"},{"content":"XCTF-REVERSE-新手区 writeup # 来XCTF平台，做做Re练练手\nXCTF平台有十道题目：\n十道题目应该是涵盖了逆向方向的主要内容，带着好奇心去探索逆向的世界吧\n0x0 insanity # 往往第一道题目都不是很难，下载附件，看看是个什么东西。\n文件没有扩展名，可能是个ELF文件，走个流程\n首先查一下壳\n果然是ELF格式的文件，不过不是x64格式的ELF文件\n使用IDA pro打开文件，查看主函数的反编译代码\nint __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax unsigned int v4; // eax puts(\u0026#34;Reticulating splines, please wait..\u0026#34;); sleep(5u); v3 = time(0); srand(v3); v4 = rand(); puts((\u0026amp;strs)[v4 % 0xA]); return 0; } 跟进strs的数据\n继续跟进strs的数据\nget到了flag\n9447{This_is_a_flag} 0x1 python-trade # 看题目应该是一个Python的逆向题目\n文件是一个pyc文件应该是Python的逆向文件，可以使用Python的反编译工具进行反编译\n可以使用 uncompyle 进行反编译：\n# uncompyle6 version 3.7.4 # Python bytecode 2.7 (62211) # Decompiled from: Python 3.8.8 (default, Apr 13 2021, 15:08:03) [MSC v.1916 64 bit (AMD64)] # Embedded file name: 1.py # Compiled at: 2017-06-03 10:20:43 import base64 def encode(message): s = \u0026#39;\u0026#39; for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s) correct = \u0026#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt\u0026#39; flag = \u0026#39;\u0026#39; print \u0026#39;Input flag:\u0026#39; flag = raw_input() if encode(flag) == correct: print \u0026#39;correct\u0026#39; else: print \u0026#39;wrong\u0026#39; # okay decompiling .\\test.pyc 应该是需要逆这个加密算法的进行求解，密码手的老本行了，写个求解脚本:\nimport base64 def Redecode(cipher): message = \u0026#39;\u0026#39; cipher = base64.b64decode(cipher).decode() for i in cipher: x = ord(i) - 16 x = x ^ 32 message += chr(x) return message cipher = \u0026#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt\u0026#39; flag = Redecode(cipher) print(flag) 在python2环境下运行脚本，就能得到flag了：\nnctf{d3c0mpil1n9_PyC} 0x2 re1 # 附件有报毒，麻了\n走一下流程，先查文件信息\n32位的可执行程序，程序没有壳，丢进IDA pro进行静态分析\nint __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax __m128i v5; // [esp+0h] [ebp-44h] BYREF char v6[8]; // [esp+10h] [ebp-34h] BYREF int v7; // [esp+18h] [ebp-2Ch] __int16 v8; // [esp+1Ch] [ebp-28h] char v9[32]; // [esp+20h] [ebp-24h] BYREF v5 = _mm_loadu_si128((const __m128i *)\u0026#34;DUTCTF{We1c0met0DUTCTF}\u0026#34;); v7 = 0; strcpy(v6, \u0026#34;DUTCTF}\u0026#34;); v8 = 0; printf(\u0026#34;欢迎来到DUTCTF呦\\n\u0026#34;); printf(\u0026#34;这是一道很可爱很简单的逆向题呦\\n\u0026#34;); printf(\u0026#34;输入flag吧:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, v9); v3 = strcmp(v5.m128i_i8, v9); if ( v3 ) v3 = v3 \u0026lt; 0 ? -1 : 1; if ( v3 ) printf(aFlag_0); else printf(aFlagGet); system(\u0026#34;pause\u0026#34;); return 0; } 首先，我们需要知道具体的逻辑判断形式，逻辑判断是以什么形式进行判断的，找到逻辑判断语句\nif ( v3 ) v3 = v3 \u0026lt; 0 ? -1 : 1; if ( v3 ) printf(aFlag_0); else printf(aFlagGet); v3 数值不为0的情况下会先执行第一个 if 语句，将不正确的v3值进行转换\n然后再进行一个if - else 的逻辑语句，判断v3的数值，如果v3的数值是等于0的，那么我们输入的flag就是正确的\n那么，v3 是什么东西？\nv3 = strcmp(v5.m128i_i8, v9); 是一个比较数值，如果 v5.m128i_i8 与 v9 相等，那么v3 的数值就等于0了，逻辑现在搞通了，下面跟进数据：\n这段数据应该就是 v5 的数据了，将数据转换成字符串\n成功得到flag：\nDUTCTF{We1c0met0DUTCTF} 0x3 game # 应该是个游戏，感觉还是挺有意思的\n果然是一个游戏，还蛮有意思的，不过，还是要走下流程查一下信息\n32位程序，没有壳，先丢进IDA pro康一康\nint __cdecl main_0(int argc, const char **argv, const char **envp) { int i; // [esp+DCh] [ebp-20h] int v5; // [esp+F4h] [ebp-8h] BYREF sub_45A7BE(\u0026amp;unk_50B110); sub_45A7BE(\u0026amp;unk_50B158); sub_45A7BE(\u0026amp;unk_50B1A0); sub_45A7BE(\u0026amp;unk_50B1E8); sub_45A7BE(\u0026amp;unk_50B230); sub_45A7BE(\u0026amp;unk_50B278); sub_45A7BE(\u0026amp;unk_50B2C0); sub_45A7BE(\u0026amp;unk_50B308); sub_45A7BE(\u0026#34;二 |\\n\u0026#34;); sub_45A7BE(\u0026#34;| by 0x61 |\\n\u0026#34;); sub_45A7BE(\u0026#34;| |\\n\u0026#34;); sub_45A7BE(\u0026#34;|------------------------------------------------------|\\n\u0026#34;); sub_45A7BE( \u0026#34;Play a game\\n\u0026#34; \u0026#34;The n is the serial number of the lamp,and m is the state of the lamp\\n\u0026#34; \u0026#34;If m of the Nth lamp is 1,it\u0026#39;s on ,if not it\u0026#39;s off\\n\u0026#34; \u0026#34;At first all the lights were closed\\n\u0026#34;); sub_45A7BE(\u0026#34;Now you can input n to change its state\\n\u0026#34;); sub_45A7BE( \u0026#34;But you should pay attention to one thing,if you change the state of the Nth lamp,the state of (N-1)th and (N+1)th w\u0026#34; \u0026#34;ill be changed too\\n\u0026#34;); sub_45A7BE(\u0026#34;When all lamps are on,flag will appear\\n\u0026#34;); sub_45A7BE(\u0026#34;Now,input n \\n\u0026#34;); while ( 1 ) { while ( 1 ) { sub_45A7BE(\u0026#34;input n,n(1-8)\\n\u0026#34;); sub_459418(); sub_45A7BE(\u0026#34;n=\u0026#34;); sub_4596D4(\u0026#34;%d\u0026#34;, \u0026amp;v5); sub_45A7BE(\u0026#34;\\n\u0026#34;); if ( v5 \u0026gt;= 0 \u0026amp;\u0026amp; v5 \u0026lt;= 8 ) break; sub_45A7BE(\u0026#34;sorry,n error,try again\\n\u0026#34;); } if ( v5 ) { sub_4576D6(v5 - 1); } else { for ( i = 0; i \u0026lt; 8; ++i ) { if ( (unsigned int)i \u0026gt;= 9 ) sub_458919(); byte_532E28[i] = 0; } } sub_4581B7(\u0026#34;CLS\u0026#34;); sub_458054(); if ( byte_532E28[0] == 1 \u0026amp;\u0026amp; byte_532E28[1] == 1 \u0026amp;\u0026amp; byte_532E28[2] == 1 \u0026amp;\u0026amp; byte_532E28[3] == 1 \u0026amp;\u0026amp; byte_532E28[4] == 1 \u0026amp;\u0026amp; byte_532E28[5] == 1 \u0026amp;\u0026amp; byte_532E28[6] == 1 \u0026amp;\u0026amp; byte_532E28[7] == 1 ) { sub_457AB4(); } } } 寻找到核心代码：\nif ( byte_532E28[0] == 1 \u0026amp;\u0026amp; byte_532E28[1] == 1 \u0026amp;\u0026amp; byte_532E28[2] == 1 \u0026amp;\u0026amp; byte_532E28[3] == 1 \u0026amp;\u0026amp; byte_532E28[4] == 1 \u0026amp;\u0026amp; byte_532E28[5] == 1 \u0026amp;\u0026amp; byte_532E28[6] == 1 \u0026amp;\u0026amp; byte_532E28[7] == 1 ) { sub_457AB4(); } 可以知道，可以确定是 sub_457AB4(); 函数：\nint sub_45E940() { char v1; // [esp+0h] [ebp-164h] int i; // [esp+D0h] [ebp-94h] char v3[22]; // [esp+DCh] [ebp-88h] BYREF char v4[32]; // [esp+F2h] [ebp-72h] BYREF char v5[4]; // [esp+112h] [ebp-52h] BYREF char v6[64]; // [esp+120h] [ebp-44h] sub_45A7BE((int)\u0026#34;done!!! the flag is \u0026#34;, v1); v6[0] = 18; v6[1] = 64; v6[2] = 98; v6[3] = 5; v6[4] = 2; v6[5] = 4; v6[6] = 6; v6[7] = 3; v6[8] = 6; v6[9] = 48; v6[10] = 49; v6[11] = 65; v6[12] = 32; v6[13] = 12; v6[14] = 48; v6[15] = 65; v6[16] = 31; v6[17] = 78; v6[18] = 62; v6[19] = 32; v6[20] = 49; v6[21] = 32; v6[22] = 1; v6[23] = 57; v6[24] = 96; v6[25] = 3; v6[26] = 21; v6[27] = 9; v6[28] = 4; v6[29] = 62; v6[30] = 3; v6[31] = 5; v6[32] = 4; v6[33] = 1; v6[34] = 2; v6[35] = 3; v6[36] = 44; v6[37] = 65; v6[38] = 78; v6[39] = 32; v6[40] = 16; v6[41] = 97; v6[42] = 54; v6[43] = 16; v6[44] = 44; v6[45] = 52; v6[46] = 32; v6[47] = 64; v6[48] = 89; v6[49] = 45; v6[50] = 32; v6[51] = 65; v6[52] = 15; v6[53] = 34; v6[54] = 18; v6[55] = 16; v6[56] = 0; v3[0] = 123; v3[1] = 32; v3[2] = 18; v3[3] = 98; v3[4] = 119; v3[5] = 108; v3[6] = 65; v3[7] = 41; v3[8] = 124; v3[9] = 80; v3[10] = 125; v3[11] = 38; v3[12] = 124; v3[13] = 111; v3[14] = 74; v3[15] = 49; v3[16] = 83; v3[17] = 108; v3[18] = 94; v3[19] = 108; v3[20] = 84; v3[21] = 6; qmemcpy(v4, \u0026#34;`S,yhn _uec{\u0026#34;, 12); v4[12] = 127; v4[13] = 119; v4[14] = 96; v4[15] = 48; v4[16] = 107; v4[17] = 71; v4[18] = 92; v4[19] = 29; v4[20] = 81; v4[21] = 107; v4[22] = 90; v4[23] = 85; v4[24] = 64; v4[25] = 12; v4[26] = 43; v4[27] = 76; v4[28] = 86; v4[29] = 13; v4[30] = 114; v4[31] = 1; strcpy(v5, \u0026#34;u~\u0026#34;); for ( i = 0; i \u0026lt; 56; ++i ) { v3[i] ^= v6[i]; v3[i] ^= 0x13u; } return sub_45A7BE((int)\u0026#34;%s\\n\u0026#34;, (char)v3); } 基本上可以确定在这里输出flag，基本逻辑应该可以清晰的知道\n下面使用Ollydbg进行动态调试，调试出来flag\n先使用F8进行单步调试，确定关键函数位置\nF7进入函数的具体执行过程，进行字符串检索\n找到输入的关键位置，然后移动到关键位置\n根据已知的逻辑循环，修改逻辑循环\n修改这个关键性的跳转代码进行跳转修改，将跳转修改为call那个位置\n修改为：\njnz short 00D2F66C 然后运行修改过汇编的程序\n尝试输入几个参数就能获取到flag了\n得到flag\nzsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t} 0x4 Hello, CTF # 首先查一下程序信息\n32位没有壳的程序\n使用IDA pro的看一下程序\nint __cdecl main(int argc, const char **argv, const char **envp) { int i; // ebx char v4; // al int result; // eax int v6; // [esp+0h] [ebp-70h] int v7; // [esp+0h] [ebp-70h] char Buffer[2]; // [esp+12h] [ebp-5Eh] BYREF char v9[20]; // [esp+14h] [ebp-5Ch] BYREF char v10[32]; // [esp+28h] [ebp-48h] BYREF __int16 v11; // [esp+48h] [ebp-28h] char v12; // [esp+4Ah] [ebp-26h] char v13[36]; // [esp+4Ch] [ebp-24h] BYREF strcpy(v13, \u0026#34;437261636b4d654a757374466f7246756e\u0026#34;); while ( 1 ) { memset(v10, 0, sizeof(v10)); v11 = 0; v12 = 0; sub_40134B(aPleaseInputYou, v6); scanf(\u0026#34;%s\u0026#34;, v9); if ( strlen(v9) \u0026gt; 0x11 ) break; for ( i = 0; i \u0026lt; 17; ++i ) { v4 = v9[i]; if ( !v4 ) break; sprintf(Buffer, \u0026#34;%x\u0026#34;, v4); strcat(v10, Buffer); } if ( !strcmp(v10, v13) ) sub_40134B(aSuccess, v7); else sub_40134B(aWrong, v7); } sub_40134B(aWrong, v7); result = --Stream._cnt; if ( Stream._cnt \u0026lt; 0 ) return _filbuf(\u0026amp;Stream); ++Stream._ptr; return result; } 代码非常清晰，应该可以明确v13的值和flag应该是一致的\nv13应该是Hex编码的字符串，进行解码就得到flag了\nCrackMeJustForFun 0x5 open-source # 下载附件，源代码审计，看看源代码内容\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { if (argc != 4) { printf(\u0026#34;what?\\n\u0026#34;); exit(1); } unsigned int first = atoi(argv[1]); if (first != 0xcafe) { printf(\u0026#34;you are wrong, sorry.\\n\u0026#34;); exit(2); } unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) { printf(\u0026#34;ha, you won\u0026#39;t get it!\\n\u0026#34;); exit(3); } if (strcmp(\u0026#34;h4cky0u\u0026#34;, argv[3])) { printf(\u0026#34;so close, dude!\\n\u0026#34;); exit(4); } printf(\u0026#34;Brr wrrr grr\\n\u0026#34;); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\u0026#34;Get your key: \u0026#34;); printf(\u0026#34;%x\\n\u0026#34;, hash); return 0; } 根据源码进行求解，其实也就是解个方程\n可以写个C程序直接求解\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { unsigned int first = 0xcafe; unsigned int second = 25; char * Third = \u0026#34;h4cky0u\u0026#34;; unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(Third) - 1615810207; printf(\u0026#34;Get your key: \u0026#34;); printf(\u0026#34;%x\\n\u0026#34;, hash); return 0; } 编译并运行程序就能得到flag：\nGet your key: c0ffee 0x6 simple-unpack # 看题目，应该是一个有壳的程序\n就正常走一下流程首先先要看看程序的信息\n加壳的64位的程序，首先使用upx脱一下壳，然后使用x64 IDA pro查看\n直接就能看到flag信息数据\nflag{Upx_1s_n0t_a_d3liv3r_c0mp4ny} 0x7 logmein # 查一下程序信息\n没有壳，64位的Linux程序\n直接进行x64 ida pro静态调试\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3) { size_t v3; // rsi int i; // [rsp+3Ch] [rbp-54h] char s[36]; // [rsp+40h] [rbp-50h] BYREF int v6; // [rsp+64h] [rbp-2Ch] __int64 v7; // [rsp+68h] [rbp-28h] char v8[28]; // [rsp+70h] [rbp-20h] BYREF int v9; // [rsp+8Ch] [rbp-4h] v9 = 0; strcpy(v8, \u0026#34;:\\\u0026#34;AL_RT^L*.?+6/46\u0026#34;); v7 = 0x65626D61726168LL; v6 = 7; printf(\u0026#34;Welcome to the RC3 secure password guesser.\\n\u0026#34;); printf(\u0026#34;To continue, you must enter the correct password.\\n\u0026#34;); printf(\u0026#34;Enter your guess: \u0026#34;); __isoc99_scanf(\u0026#34;%32s\u0026#34;, s); v3 = strlen(s); if ( v3 \u0026lt; strlen(v8) ) sub_4007C0(); for ( i = 0; i \u0026lt; strlen(s); ++i ) { if ( i \u0026gt;= strlen(v8) ) sub_4007C0(); if ( s[i] != (char)(*((_BYTE *)\u0026amp;v7 + i % v6) ^ v8[i]) ) sub_4007C0(); } sub_4007F0(); } 应该是对算法进行逆向来得到相应的flag\n关键的数据是v7和v8，针对这两个数据写个C程序进行逆向算法\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char v8[28]; strcpy(v8, \u0026#34;:\\\u0026#34;AL_RT^L*.?+6/46\u0026#34;); char *v7 = \u0026#34;harambe\u0026#34;; int v6 = 7; char s[strlen(v8)]; for (int i = 0; i \u0026lt; strlen(v8); ++i ) { s[i] = *(v7+i % v6) ^ v8[i]; } printf(\u0026#34;%s\\n\u0026#34;,s); } 编译并运行得到flag\nRC3-2016-XORISGUD 0x8 no-string-attached # 查一下文件的信息\n32位文件，没有壳，丢进到IDA pro查看\nint __cdecl main(int argc, const char **argv, const char **envp) { setlocale(6, \u0026amp;locale); banner(); prompt_authentication(); authenticate(); return 0; } 进行分析，确定flag应该是在 authenticate()函数中\n跟进到 authenticate()函数\nvoid authenticate() { wchar_t ws[8192]; // [esp+1Ch] [ebp-800Ch] BYREF wchar_t *s2; // [esp+801Ch] [ebp-Ch] s2 = (wchar_t *)decrypt((wchar_t *)\u0026amp;s, (wchar_t *)\u0026amp;dword_8048A90); if ( fgetws(ws, 0x2000, stdin) ) { ws[wcslen(ws) - 1] = 0; if ( !wcscmp(ws, s2) ) wprintf(\u0026amp;unk_8048B44); else wprintf(\u0026amp;unk_8048BA4); } free(s2); } 关键数据应该是在s2中，调用了decrypt函数，看一下这个函数的汇编代码\nws= dword ptr -800Ch s2= dword ptr -0Ch ; __unwind { push ebp mov ebp, esp sub esp, 8028h mov dword ptr [esp+4], offset dword_8048A90 ; wchar_t * mov dword ptr [esp], offset s ; s call decrypt mov [ebp+s2], eax mov eax, ds:stdin@@GLIBC_2_0 mov [esp+8], eax ; stream mov dword ptr [esp+4], 2000h ; n lea eax, [ebp+ws] mov [esp], eax ; ws call _fgetws test eax, eax jz short loc_804879C 根据汇编代码，应该可以清晰的知道，flag数据应该是存储在eax寄存器中了\n使用gdb动态调试程序\ngdb Re_demo 然后设置断点，根据刚刚了解到的信息，flag的数据应该是在decrypt函数中，设置断点\nb decrypt 然后运行程序到断点\nr 然后单步执行\nn 查看寄存器\ni r 然后查看eax寄存器存储的数据\nx/sw $eax 成功拿到flag数据\n9447{you_are_an_international_mystery} 0x9 getit # 基本流程，查看程序信息\n64位无壳的ELF可执行程序\n先丢进x64 IDA pro看一看\nint __cdecl main(int argc, const char **argv, const char **envp) { char v3; // al int i; // [rsp+0h] [rbp-40h] int j; // [rsp+4h] [rbp-3Ch] FILE *stream; // [rsp+8h] [rbp-38h] char filename[24]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v9; // [rsp+28h] [rbp-18h] v9 = __readfsqword(0x28u); for ( i = 0; i \u0026lt; strlen(s); ++i ) { if ( (i \u0026amp; 1) != 0 ) v3 = 1; else v3 = -1; *(\u0026amp;t + i + 10) = s[i] + v3; } strcpy(filename, \u0026#34;/tmp/flag.txt\u0026#34;); stream = fopen(filename, \u0026#34;w\u0026#34;); fprintf(stream, \u0026#34;%s\\n\u0026#34;, u); for ( j = 0; j \u0026lt; strlen(\u0026amp;t); ++j ) { fseek(stream, p[j], 0); fputc(*(\u0026amp;t + p[j]), stream); fseek(stream, 0LL, 0); fprintf(stream, \u0026#34;%s\\n\u0026#34;, u); } fclose(stream); remove(filename); return 0; } 应该是一个文件写入的程序，打开一个文件并进行写入\n对程序进行分析应该可以看出三个部分\n初始化变量 生成flag数据 写入flag数据 查看一下静态数据：\n根据静态数据和对代码分析的结果，写一个flag生成器：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char t[] =\u0026#34; harifCTF{????????????????????????????????}\u0026#34;; char s[] = \u0026#34;c61b68366edeb7bdce3c6820314b7498\u0026#34;; t[0] = 0x53; int i, v3; for ( i = 0; i \u0026lt; strlen(s); ++i ) { if ( (i \u0026amp; 1) != 0 ) v3 = 1; else v3 = -1; *(t+i+10) = s[i]+v3; } printf(\u0026#34;%s\\n\u0026#34;,t); return 0; } 编译并运行flag生成器就可以生成flag啦！\nSharifCTF{b70c59275fcfa8aebf2d5911223c6589} 0xA csaw2013reversing2 # 杀软会报毒的程序，首先查一下壳\n32位无壳程序，使用IDA pro查看详细信息\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // ecx CHAR *lpMem; // [esp+8h] [ebp-Ch] HANDLE hHeap; // [esp+10h] [ebp-4h] hHeap = HeapCreate(0x40000u, 0, 0); lpMem = (CHAR *)HeapAlloc(hHeap, 8u, SourceSize + 1); memcpy_s(lpMem, SourceSize, \u0026amp;unk_409B10, SourceSize); if ( !sub_40102A() \u0026amp;\u0026amp; !IsDebuggerPresent() ) { MessageBoxA(0, lpMem + 1, \u0026#34;Flag\u0026#34;, 2u); HeapFree(hHeap, 0, lpMem); HeapDestroy(hHeap); ExitProcess(0); } __debugbreak(); sub_401000(v3 + 4, lpMem); ExitProcess(0xFFFFFFFF); } 都是WIN32api的调用，尝试运行一下程序：\n应该是有些关键的语句没有执行\n可以查看下IDA pro的汇编语句\n显然是有一个Flag没有进行相应的跳转，显然有着较大的嫌疑，可以尝试去搞一搞让其跳转\n使用OD进行调试修改汇编让其进行跳转，首先定位到Flag\n000D1092 . 85C0 test eax, eax 000D1094 74 23 je short 000D10B9 000D1096 \u0026gt; 41 inc ecx 000D1097 . 41 inc ecx 000D1098 . 41 inc ecx 000D1099 . 41 inc ecx 000D109A CC int3 000D109B . 8B55 F4 mov edx, dword ptr [ebp-C] 000D109E . E8 5DFFFFFF call 000D1000 000D10A3 EB 4A jmp short 000D10EF 000D10A5 . 6A 02 push 2 ; /Style = MB_ABORTRETRYIGNORE|MB_APPLMODAL 000D10A7 . 68 20780D00 push 000D7820 ; |Title = \u0026#34;Flag\u0026#34; 000D10AC . FF75 F4 push dword ptr [ebp-C] ; |Text 000D10AF . 6A 00 push 0 ; |hOwner = NULL 000D10B1 . FF15 E4600D00 call dword ptr [\u0026lt;\u0026amp;USER32.MessageBoxA\u0026gt;\u0026gt;; \\MessageBoxA 000D10B7 . EB 14 jmp short 000D10CD 000D10B9 \u0026gt; 6A 02 push 2 ; /Style = MB_ABORTRETRYIGNORE|MB_APPLMODAL 000D10BB . 68 20780D00 push 000D7820 ; |Title = \u0026#34;Flag\u0026#34; 000D10C0 . 8B45 F4 mov eax, dword ptr [ebp-C] ; | 000D10C3 . 40 inc eax ; | 000D10C4 . 50 push eax ; |Text 000D10C5 . 6A 00 push 0 ; |hOwner = NULL 000D10C7 . FF15 E4600D00 call dword ptr [\u0026lt;\u0026amp;USER32.MessageBoxA\u0026gt;\u0026gt;; \\MessageBoxA 然后定位到if语句对应的汇编语句\n000D1083 . E8 A2FFFFFF call 000D102A 000D1088 . 85C0 test eax, eax 000D108A . 75 0A jnz short 000D1096 000D108C . FF15 14600D00 call dword ptr [\u0026lt;\u0026amp;KERNEL32.IsDebugger\u0026gt;; [IsDebuggerPresent 000D1092 . 85C0 test eax, eax 000D1094 74 23 je short 000D10B9 000D1096 \u0026gt; 41 inc ecx 000D1097 . 41 inc ecx 000D1098 . 41 inc ecx 000D1099 . 41 inc ecx 000D109A CC int3 000D109B . 8B55 F4 mov edx, dword ptr [ebp-C] 000D109E . E8 5DFFFFFF call 000D1000 000D10A3 EB 4A jmp short 000D10EF 关键就是对这些汇编语句进行修改来获得flag数据，运行过程中有一个int3断点应该是让程序进行终止的，然后就是je跳转语句和jmp跳转语句了。对je跳转语句进行修改和jmp跳转语句进行修改，设置断点进行调试应该就可以获得flag\n修改过的汇编语句\n000D1083 . E8 A2FFFFFF call 000D102A 000D1088 . 85C0 test eax, eax 000D108A . 75 0A jnz short 000D1096 000D108C . FF15 14600D00 call dword ptr [\u0026lt;\u0026amp;KERNEL32.IsDebugger\u0026gt;; [IsDebuggerPresent 000D1092 . 85C0 test eax, eax 000D1094 90 nop 000D1095 90 nop 000D1096 \u0026gt; 41 inc ecx 000D1097 . 41 inc ecx 000D1098 . 41 inc ecx 000D1099 . 41 inc ecx 000D109A 90 nop 000D109B . 8B55 F4 mov edx, dword ptr [ebp-C] 000D109E . E8 5DFFFFFF call 000D1000 000D10A3 EB 14 jmp short 000D10B9 然后设置断点进行调试，来获得flag\n成功得到flag\nflag{reversing_is_not_that_hard!} 0xB maze # 走迷宫的题目，逆向题目中多少有些趣味的题目，来一起走迷宫吧\n首先查看一下程序信息\n64位的程序，使用x64 IDA pro查看一下\n__int64 __fastcall main(int a1, char **a2, char **a3) { __int64 v3; // rbx int v4; // eax char v5; // bp char v6; // al const char *v7; // rdi unsigned int v9; // [rsp+0h] [rbp-28h] BYREF int v10[9]; // [rsp+4h] [rbp-24h] BYREF v10[0] = 0; v9 = 0; puts(\u0026#34;Input flag:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;s1); if ( strlen(\u0026amp;s1) != 24 || strncmp(\u0026amp;s1, \u0026#34;nctf{\u0026#34;, 5uLL) || *(\u0026amp;byte_6010BF + 24) != 125 ) { LABEL_22: puts(\u0026#34;Wrong flag!\u0026#34;); exit(-1); } v3 = 5LL; if ( strlen(\u0026amp;s1) - 1 \u0026gt; 5 ) { while ( 1 ) { v4 = *(\u0026amp;s1 + v3); v5 = 0; if ( v4 \u0026gt; 78 ) { if ( (unsigned __int8)v4 == 79 ) { v6 = sub_400650(v10); goto LABEL_14; } if ( (unsigned __int8)v4 == 111 ) { v6 = sub_400660(v10); goto LABEL_14; } } else { if ( (unsigned __int8)v4 == 46 ) { v6 = sub_400670(\u0026amp;v9); goto LABEL_14; } if ( (unsigned __int8)v4 == 48 ) { v6 = sub_400680(\u0026amp;v9); LABEL_14: v5 = v6; goto LABEL_15; } } LABEL_15: if ( !(unsigned __int8)sub_400690(asc_601060, (unsigned int)v10[0], v9) ) goto LABEL_22; if ( ++v3 \u0026gt;= strlen(\u0026amp;s1) - 1 ) { if ( v5 ) break; LABEL_20: v7 = \u0026#34;Wrong flag!\u0026#34;; goto LABEL_21; } } } if ( asc_601060[8 * v9 + v10[0]] != 35 ) goto LABEL_20; v7 = \u0026#34;Congratulations!\u0026#34;; LABEL_21: puts(v7); return 0LL; } 函数的主要逻辑应该是根据输入的值来进行走迷宫的，走出迷宫即得到flag。程序中肯定存在的有迷宫的地图作为静态数据存储。所以可以尝试查看静态数据：\n果然有一个类似迷宫的数据，查看迷宫数据\n******* * **** * **** * *** *# *** *** *** ********* 需要对代码进行分析来进一步得到迷宫的大致样子\nif ( strlen(\u0026amp;s1) != 24 || strncmp(\u0026amp;s1, \u0026#34;nctf{\u0026#34;, 5uLL) || *(\u0026amp;byte_6010BF + 24) != 125 ) { LABEL_22: puts(\u0026#34;Wrong flag!\u0026#34;); exit(-1); } 根据这段代码可以判断出走出迷宫需要18个操作数\nwhile ( 1 ) { v4 = *(\u0026amp;s1 + v3); v5 = 0; if ( v4 \u0026gt; 78 ) { if ( (unsigned __int8)v4 == \u0026#39;O\u0026#39; ) { v6 = sub_400650(v10); goto LABEL_14; } if ( (unsigned __int8)v4 == \u0026#39;o\u0026#39; ) { v6 = sub_400660(v10); goto LABEL_14; } } else { if ( (unsigned __int8)v4 == \u0026#39;.\u0026#39; ) { v6 = sub_400670(\u0026amp;v9); goto LABEL_14; } if ( (unsigned __int8)v4 == \u0026#39;0\u0026#39; ) { v6 = sub_400680(\u0026amp;v9); 这些是对迷宫操作的判断，根据这些判断可以确定我们如何进行迷宫的操作\n首先根据反汇编的代码进行分析，可以发现有两个关键数据有着比较重要的作用就是v10就v9的数据，根据跟进分析，发现v10 是进行横向操作，发现v9 是纵向操作。然后根据函数内部的加或减来确定 上下左右 的方向。\n对代码进行进一步分析应该就知道对应操作：\n\u0026#39;O\u0026#39; ← \u0026#39;o\u0026#39; → \u0026#39;.\u0026#39; ↑ \u0026#39;0\u0026#39; ↓ 根据代码的分析，迷宫应该是8x8的迷宫，可以排列出迷宫的样子\n00****** *000*00* ***0*0** **00*0** *00*#00* **0***0* **00000* ******** 根据目前的分析的结果就可以开心地走迷宫了：\no0oo00O000oooo..OO 迷宫路线即为flag，因此本题的flag为：\nnctf{o0oo00O000oooo..OO} ","date":"October 14, 2021","permalink":"/posts/xctf-reverse-novice_writeup/","section":"Posts","summary":"XCTF-REVERSE-新手区 writeup # 来XCTF平台，做做Re练练手\nXCTF平台有十道题目：\n十道题目应该是涵盖了逆向方向的主要内容，带着好奇心去探索逆向的世界吧\n0x0 insanity # 往往第一道题目都不是很难，下载附件，看看是个什么东西。\n文件没有扩展名，可能是个ELF文件，走个流程\n首先查一下壳\n果然是ELF格式的文件，不过不是x64格式的ELF文件\n使用IDA pro打开文件，查看主函数的反编译代码\nint __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax unsigned int v4; // eax puts(\u0026#34;Reticulating splines, please wait..\u0026#34;); sleep(5u); v3 = time(0); srand(v3); v4 = rand(); puts((\u0026amp;strs)[v4 % 0xA]); return 0; } 跟进strs的数据\n继续跟进strs的数据\nget到了flag\n9447{This_is_a_flag} 0x1 python-trade # 看题目应该是一个Python的逆向题目\n文件是一个pyc文件应该是Python的逆向文件，可以使用Python的反编译工具进行反编译\n可以使用 uncompyle 进行反编译：\n# uncompyle6 version 3.7.4 # Python bytecode 2.","title":"XCTF REVERSE novice_writeup"},{"content":"BUUCTF-REVERSE-1 writeup # 逆向工程让密码学更加灵动，让密码学不再抽象。初步试水逆向工程题目，嘤嘤嘤！\n0x0 easyre # 非常简单的逆向题目，这道题目解决方法很多，基本思路就使用静态调试工具进行反汇编，然后检索字符串得到flag。这里使用一个开源的工具Cutter来逆向玩玩。\n直接点击下面的Strings\n使用过滤器，快速检索flag就能得到flag\n得到flag\nflag{this_Is_a_EaSyRe} 0x1 reverse1 # 先丢进IDA pro里面看看，会有什么神奇的反应和效果！\n然后我们需要定位到主函数，定位到主函数的方法有很多，目前，我大致有两种，首先是检索字符串，其次就 是检索函数来快速定位主函数。\n通过检索字符串来定位主函数，直接检索flag\n然后通过检索结果定位到主函数\n使用F5看到反编译的代码\n代码非常清晰，找到关键的代码\nfor ( j = 0; ; ++j ) { v8 = j; v2 = j_strlen(Str2); if ( v8 \u0026gt; v2 ) break; if ( Str2[j] == 111 ) Str2[j] = 48; } sub_1400111D1(\u0026#34;input the flag:\u0026#34;); sub_14001128F(\u0026#34;%20s\u0026#34;, Str1); v3 = j_strlen(Str2); if ( !strncmp(Str1, Str2, v3) ) sub_1400111D1(\u0026#34;this is the right flag!\\n\u0026#34;); else sub_1400111D1(\u0026#34;wrong flag\\n\u0026#34;); sub_14001113B(v5, \u0026amp;unk_140019D00); return 0i64; } 进行简单地代码审计可以明确地发现\nflag就藏在Str2数据中，顺着这条线找下去可以看到Str2的数据\n现在可以看到了flag\n{hello_world} 不过，这道题目还没完，还是有个对于数据的变换，变换后的数据才是flag\nfor ( j = 0; ; ++j ) { v8 = j; v2 = j_strlen(Str2); if ( v8 \u0026gt; v2 ) break; if ( Str2[j] == 111 ) Str2[j] = 48; } 这段代码简单来说就是将原始数据中的o变成0，进行变换后就得到flag\nflag{hell0_w0rld} 0x2 reverse2 # 也是一道简单的逆向题目，稍微走向流程。\n查看文件格式信息，由于文件没有扩展名，推测很有可能ELF格式的Linux可执行文件而不是PE文件\n使用Exeinfo PE工具查一下信息\n发现是64位的ELF文件，使用Cutter进行反编译并进入到主函数，也就是main函数\n可以找到反编译器中的关键代码\nwhile (rbx \u0026lt;= rax) { eax = var_38h; rax = (int64_t) eax; eax = *((rax + flag)); if (al != 0x69) { eax = var_38h; rax = (int64_t) eax; eax = *((rax + flag)); if (al != 0x72) { goto label_1; } } eax = var_38h; rax = (int64_t) eax; *((rax + flag)) = 0x31; label_1: var_38h++; eax = var_38h; rbx = (int64_t) eax; edi = \u0026#34;{hacking_for_fun}\u0026#34;; rax = strlen (); } goto label_2; label_0: rcx = \u0026amp;wstatus; eax = pid; edx = 0; rsi = rcx; edi = eax; eax = 0; waitpid (); label_2: eax = 0; printf (\u0026#34;input the flag:\u0026#34;); rax = \u0026amp;s2; rsi = rax; edi = \u0026#34;%20s\u0026#34;; eax = 0; isoc99_scanf (); rax = \u0026amp;s2; eax = strcmp (\u0026#34;{hacking_for_fun}\u0026#34;, rax); if (eax != 0) { puts (\u0026#34;wrong flag!\u0026#34;); } else { puts (\u0026#34;this is the right flag!\u0026#34;); } rdx = canary; rdx ^= *(fs:0x28); if (eax != 0) { stack_chk_fail (); } 对关键代码进行审计，发现原始数据是\n{hacking_for_fun} 而且flag是对原始数据进行数据上的变换的，根据代码应该是将原始数据中的r和i进行替换，替换成了1\n因此，最终的flag就是\nflag{hack1ng_fo1_fun} 0x3 内涵的软件 # 日常逆向走个流程，查一下软件信息\n没有壳，32位程序\n丢进Cutter简单看一下，可以发现flag应该就是在反编译的文件中\n结合题目的名字，应该就可以推断出来flag就是那段看起来像是flag的字段，即\nflag{49d3c93df25caad81232130f3d2ebfad} 0x4 新年快乐 # 走下流程，先看看文件信息\n发现文件被UPX进行了加壳处理\n进行UPX脱壳后然后丢进Cutter就能看到flag\n审计代码后可以看到flag就是\nflag{HappyNewYear!} 0x5 xor # 看样子像是ELF文件，使用linux的命令查询一下文件信息\nfile xor 可以得到以下信息\nxor: Mach-O 64-bit x86_64 executable, flags:\u0026lt;NOUNDEFS|DYLDLINK|TWOLEVEL|PIE\u0026gt; 可以知道应该是一个Mac OS的可执行文件，而且是一个64位的程序，丢进IDA pro里面进行逆向得到\nint __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+2Ch] [rbp-124h] char __b[264]; // [rsp+40h] [rbp-110h] BYREF memset(__b, 0, 0x100uLL); printf(\u0026#34;Input your flag:\\n\u0026#34;); get_line(__b, 256LL); if ( strlen(__b) != 33 ) goto LABEL_7; for ( i = 1; i \u0026lt; 33; ++i ) __b[i] ^= __b[i - 1]; if ( !strncmp(__b, global, 0x21uLL) ) printf(\u0026#34;Success\u0026#34;); else LABEL_7: printf(\u0026#34;Failed\u0026#34;); return 0; } 关键函数应该是在global数组中，下面关键就是找到这个数组里面的数据\n然后顺着这个global往上找，可以找aFKWOXZUPFVMDGH这个变量，数据应该存储在这个变量中，追踪这个变量可以找到内部的数据信息\n然后提取数据得到\nunsigned char aFKWOXZUPFVMDGH[] = { 102, 10, 107, 12, 119, 38, 79, 46, 64, 17, 120, 13, 90, 59, 85, 17, 112, 25, 70, 31, 118, 34, 77, 35, 68, 14, 103, 6, 104, 15, 71, 50, 79, 0 }; 现在拿到数据了，下面就是对数据进行异或操作\n由于异或操作是一个非常有趣的操作，就好像是在进行变魔术，非常有意思。因此可以根据异或运算的性质和特点来获取flag\n写一个非常简单的异或脚本应该就能出flag了\nflag=\u0026#34;\u0026#34; xor=[102, 10, 107, 12, 119, 38, 79, 46, 64, 17, 120, 13, 90, 59, 85, 17, 112, 25, 70, 31, 118, 34, 77, 35, 68, 14, 103, 6, 104, 15, 71, 50, 79, 0] for i in range(0,33): flag += chr(xor[i]^xor[i-1]) print(flag) 运行脚本就能得到flag\nflag{QianQiuWanDai_YiTongJiangHu} 0x6 helloworld # 一个APK文件，丢到jadx反编译看看吧\n如果是第一次接触apk程序的逆向工程可能对apk程序的结构不是非常熟悉，不知道怎么定位的主函数。一般而言，apk文件的主函数，也就是入口函数一般都是com.example.xxxx的包里面的MainActivity函数。因此找到这个函数，点开\nflag就摆出来了\nflag{7631a988259a00816deda84afb29430a} 0x7 reverse3 # 查一下程序信息\n是一个32位的程序，丢进Cutter里面看看主程序\n找到主程序的反编译代码\n#include \u0026lt;stdint.h\u0026gt; int32_t main (void) { int32_t var_17ch; int32_t var_178h; int32_t var_ach; int32_t var_a0h; char * dest; int32_t var_28h; int32_t var_ch; int32_t var_4h; edi = \u0026amp;var_17ch; ecx = 0x5f; eax = 0xcccccccc; memset (edi, eax, ecx); eax = *(0x41a004); eax ^= ebp; var_4h = eax; var_a0h = 0; while (1) { eax = var_a0h; eax++; var_a0h = eax; if (var_a0h \u0026gt;= 0x64) { goto label_0; } eax = var_a0h; var_178h = var_a0h; if (var_178h \u0026lt; 0x64) { } else { fcn_00411154 (); } ecx = var_178h; *((ebp + ecx - 0x94)) = 0; } label_0: fcn_0041132f (\u0026#34;please enter the flag:\u0026#34;); fcn_00411375 (\u0026#34;%20s\u0026#34;, var_28h); esi = esp; eax = \u0026amp;var_ch; ecx = \u0026amp;var_28h; eax = fcn_004110c8 (); eax = fcn_004110be (var_28h, eax); uint32_t (*strncpy)(void, void) (dest, eax); fcn_00411127 (); eax = \u0026amp;dest; eax = fcn_004110c8 (); var_a0h = eax; var_ach = 0; while (1) { eax = var_ach; eax++; var_ach = eax; if (eax \u0026gt;= var_a0h) { goto label_1; } eax = var_ach; ecx = *((ebp + eax - 0x94)); ecx += var_ach; edx = var_ach; *((ebp + edx - 0x94)) = cl; } label_1: eax = \u0026amp;dest; eax = fcn_004110c8 (); esi = esp; uint32_t (*strncmp)(void, char*, void) (dest, \u0026#34;e3nifIH9b_C@n@dH\u0026#34;, eax); eax = fcn_00411127 (); if (eax != 0) { fcn_0041132f (\u0026#34;wrong flag!\\n\u0026#34;); } else { eax = fcn_0041132f (\u0026#34;rigth flag!\\n\u0026#34;); } eax = 0; ecx = ebp; edx = 0x415890; fcn_0041126c (eax); ecx = var_4h; ecx ^= ebp; fcn_00411280 (); fcn_00411127 (); } 主函数也有个关键函数 fcn_004110be ，定位到这个函数，看看这个函数的执行过程\n#include \u0026lt;stdint.h\u0026gt; int32_t fcn_004110be (uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h) { int32_t var_100h; int32_t var_38h; int32_t var_2ch; size_t size; uint32_t var_14h; int32_t var_8h; edi = \u0026amp;var_100h; ecx = 0x40; eax = 0xcccccccc; memset (edi, eax, ecx); var_8h = 0; var_14h = 0; size = 0; if (arg_8h != 0) { if (arg_ch != 0) { goto label_1; } } eax = 0; goto label_2; label_1: eax = arg_ch; edx = 0; ecx = 3; eax = edx:eax / ecx; edx = edx:eax % ecx; size = eax; edx:eax = (int64_t) eax; ecx = 3; eax = edx:eax / ecx; edx = edx:eax % ecx; if (edx != 0) { eax = size; eax++; } eax \u0026lt;\u0026lt;= 2; eax = arg_10h; ecx = size; *(eax) = ecx; eax = size; eax++; esi = esp; uint32_t (*malloc)(void, void, void) (eax, eax, eax); eax = fcn_00411127 (); var_14h = eax; if (var_14h == 0) { eax = 0; goto label_2; } eax = size; eax++; ecx = var_14h; fcn_004110b9 (); eax = arg_8h; var_8h = arg_8h; eax = arg_ch; size = arg_ch; var_2ch = 0; var_38h = 0; label_0: if (size \u0026lt;= 0) { goto label_3; } eax = 1; eax \u0026lt;\u0026lt;= 1; *((eax + 0x41a144)) = 0; ecx = 1; ecx \u0026lt;\u0026lt;= 0; *((ecx + 0x41a144)) = 0; edx = 1; eax = edx * 0; *((eax + 0x41a144)) = 0; var_2ch = 0; while (1) { eax = var_2ch; eax++; var_2ch = eax; if (var_2ch \u0026gt;= 3) { goto label_4; } if (size \u0026lt; 1) { } else { eax = var_2ch; ecx = var_8h; dl = *(ecx); *((eax + 0x41a144)) = dl; eax = size; eax--; size = eax; eax = var_8h; eax++; var_8h = eax; } } label_4: if (var_2ch == 0) { } else { eax = var_2ch; var_100h = var_2ch; if (var_100h != 1) { if (var_100h != 2) { if (var_100h != 3) { } else { eax = 1; ecx = eax * 0; edx = *((ecx + 0x41a144)); edx \u0026gt;\u0026gt;= 2; eax = var_14h; eax += var_38h; cl = *((edx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(eax) = cl; edx = var_38h; edx++; var_38h = edx; eax = 1; ecx = eax * 0; edx = *((ecx + 0x41a144)); edx \u0026amp;= 3; edx \u0026lt;\u0026lt;= 4; eax = 1; eax \u0026lt;\u0026lt;= 0; ecx = *((eax + 0x41a144)); ecx \u0026amp;= 0xf0; ecx \u0026gt;\u0026gt;= 4; edx |= ecx; eax = var_14h; eax += var_38h; cl = *((edx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(eax) = cl; edx = var_38h; edx++; var_38h = edx; eax = 1; eax \u0026lt;\u0026lt;= 6; ecx = var_14h; ecx += var_38h; dl = *((eax + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(ecx) = dl; eax = var_38h; eax++; var_38h = eax; eax = 1; eax \u0026lt;\u0026lt;= 6; ecx = var_14h; ecx += var_38h; dl = *((eax + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(ecx) = dl; eax = var_38h; eax++; var_38h = eax; } else { eax = 1; } ecx = eax * 0; edx = *((ecx + 0x41a144)); edx \u0026gt;\u0026gt;= 2; eax = var_14h; eax += var_38h; cl = *((edx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(eax) = cl; edx = var_38h; edx++; var_38h = edx; eax = 1; ecx = eax * 0; edx = *((ecx + 0x41a144)); edx \u0026amp;= 3; edx \u0026lt;\u0026lt;= 4; eax = 1; eax \u0026lt;\u0026lt;= 0; ecx = *((eax + 0x41a144)); ecx \u0026amp;= 0xf0; ecx \u0026gt;\u0026gt;= 4; edx |= ecx; eax = var_14h; eax += var_38h; cl = *((edx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(eax) = cl; edx = var_38h; edx++; var_38h = edx; eax = 1; eax \u0026lt;\u0026lt;= 0; ecx = *((eax + 0x41a144)); ecx \u0026amp;= 0xf; ecx \u0026lt;\u0026lt;= 2; edx = 1; edx \u0026lt;\u0026lt;= 1; eax = *((edx + 0x41a144)); eax \u0026amp;= 0xc0; eax \u0026gt;\u0026gt;= 6; ecx |= eax; edx = var_14h; edx += var_38h; al = *((ecx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(edx) = al; ecx = var_38h; ecx++; var_38h = ecx; eax = 1; eax \u0026lt;\u0026lt;= 6; ecx = var_14h; ecx += var_38h; dl = *((eax + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(ecx) = dl; eax = var_38h; eax++; var_38h = eax; } else { eax = 1; } ecx = eax * 0; edx = *((ecx + 0x41a144)); edx \u0026gt;\u0026gt;= 2; eax = var_14h; eax += var_38h; cl = *((edx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(eax) = cl; edx = var_38h; edx++; var_38h = edx; eax = 1; ecx = eax * 0; edx = *((ecx + 0x41a144)); edx \u0026amp;= 3; edx \u0026lt;\u0026lt;= 4; eax = 1; eax \u0026lt;\u0026lt;= 0; ecx = *((eax + 0x41a144)); ecx \u0026amp;= 0xf0; ecx \u0026gt;\u0026gt;= 4; edx |= ecx; eax = var_14h; eax += var_38h; cl = *((edx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(eax) = cl; edx = var_38h; edx++; var_38h = edx; eax = 1; eax \u0026lt;\u0026lt;= 0; ecx = *((eax + 0x41a144)); ecx \u0026amp;= 0xf; ecx \u0026lt;\u0026lt;= 2; edx = 1; edx \u0026lt;\u0026lt;= 1; eax = *((edx + 0x41a144)); eax \u0026amp;= 0xc0; eax \u0026gt;\u0026gt;= 6; ecx |= eax; edx = var_14h; edx += var_38h; al = *((ecx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(edx) = al; ecx = var_38h; ecx++; var_38h = ecx; eax = 1; eax \u0026lt;\u0026lt;= 1; ecx = *((eax + 0x41a144)); ecx \u0026amp;= 0x3f; edx = var_14h; edx += var_38h; al = *((ecx + str.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789)); *(edx) = al; ecx = var_38h; ecx++; var_38h = ecx; } goto label_0; } label_3: eax = var_14h; eax += var_38h; *(eax) = 0; eax = var_14h; label_2: fcn_00411127 (); return eax; } 看函数实现过程的细节像是base64的实现过程，实现之后主程序还有一个移位密码的变换\nwhile (1) { eax = var_ach; eax++; var_ach = eax; if (eax \u0026gt;= var_a0h) { goto label_1; } eax = var_ach; ecx = *((ebp + eax - 0x94)); ecx += var_ach; edx = var_ach; *((ebp + edx - 0x94)) = cl; } 变换后肯定有一个校验的过程，找到校验的数据\ne3nifIH9b_C@n@dH 最后根据目前收集到的数据和信息编写个python脚本\n（感觉挺像密码学的）\nimport base64 c = \u0026#34;e3nifIH9b_C@n@dH\u0026#34; m = \u0026#34;\u0026#34; for i in range(len(c)): m +=chr(ord(c[i])-i) flag = \u0026#34;flag\u0026#34;+base64.b64decode(m).decode() print(flag) 运行脚本就得到flag了\nflag{i_l0ve_you} ","date":"October 14, 2021","permalink":"/posts/buuctf-reverse-1_writeup/","section":"Posts","summary":"BUUCTF-REVERSE-1 writeup # 逆向工程让密码学更加灵动，让密码学不再抽象。初步试水逆向工程题目，嘤嘤嘤！\n0x0 easyre # 非常简单的逆向题目，这道题目解决方法很多，基本思路就使用静态调试工具进行反汇编，然后检索字符串得到flag。这里使用一个开源的工具Cutter来逆向玩玩。\n直接点击下面的Strings\n使用过滤器，快速检索flag就能得到flag\n得到flag\nflag{this_Is_a_EaSyRe} 0x1 reverse1 # 先丢进IDA pro里面看看，会有什么神奇的反应和效果！\n然后我们需要定位到主函数，定位到主函数的方法有很多，目前，我大致有两种，首先是检索字符串，其次就 是检索函数来快速定位主函数。\n通过检索字符串来定位主函数，直接检索flag\n然后通过检索结果定位到主函数\n使用F5看到反编译的代码\n代码非常清晰，找到关键的代码\nfor ( j = 0; ; ++j ) { v8 = j; v2 = j_strlen(Str2); if ( v8 \u0026gt; v2 ) break; if ( Str2[j] == 111 ) Str2[j] = 48; } sub_1400111D1(\u0026#34;input the flag:\u0026#34;); sub_14001128F(\u0026#34;%20s\u0026#34;, Str1); v3 = j_strlen(Str2); if ( !strncmp(Str1, Str2, v3) ) sub_1400111D1(\u0026#34;this is the right flag!","title":"BUUCTF REVERSE [1~8]_writeup"},{"content":"百题计划，冲呀！冲呀！冲呀！\n本次16道题目，难度开始逐渐上升，越来越有挑战性喽！\n0x0 RSA \u0026amp; what # 开场就是一道RSA题目，真是不错！\n附件有四个文件，一个README.txt文件，一个rsa.py算法文件，一个HUB1输出文件和一个HUB2输出文件。看看这些文件都是些什么内容吧！\nREADME.txt：\n素数生成算法太麻烦了，有没有取巧的方法呢？ 诶，这里好像有个不错的想法哟。 看起来节约了不少时间呢，嘿嘿嘿…… 顺便问问，应该大家都知道base64吧，用来编码还是很方便的呢！ rsa.py：\nfrom Crypto.Util.number import bytes_to_long, getPrime from random import randint from gmpy2 import powmod p = getPrime(2048) q = getPrime(2048) N = p*q Phi = (p-1)*(q-1) def get_enc_key(N,Phi): e = getPrime(N) if Phi % e == 0: return get_enc_key(N, Phi) else: return e e1 = get_enc_key(randint(10, 12), Phi) e2 = get_enc_key(randint(10, 12), Phi) fr = open(r\u0026#34;./base64\u0026#34;, \u0026#34;rb\u0026#34;)#flag is in this file f1 = open(r\u0026#34;./HUB1\u0026#34;, \u0026#34;wb\u0026#34;) f2 = open(r\u0026#34;./HUB2\u0026#34;, \u0026#34;wb\u0026#34;) base64 = fr.read(255) f1.write(\u0026#34;%d\\n%d\\n\u0026#34; % (N, e1)) f2.write(\u0026#34;%d\\n%d\\n\u0026#34; % (N, e2)) while len(base64)\u0026gt;0: pt = bytes_to_long(base64) ct1 = powmod(pt, e1, N) ct2 = powmod(pt, e2, N) f1.write(\u0026#34;\\n%d\u0026#34; % ct1) f2.write(\u0026#34;\\n%d\u0026#34; % ct2) base64 = fr.read(255) fr.close() f1.close() f2.close() HUB1：\n785095419718268286866508214304816985447077293766819398728046411166917810820484759314291028976498223661229395009474063173705162627037610993539617751905443039278227583504604808251931083818909467613277587874545761074364427549966555519371913859875313577282243053150056274667798049694695703660313532933165449312949725581708965417273055582216295994587600975970124811496270080896977076946000102701030260990598181466447208054713391526313700681341093922240317428173599031624125155188216489476825606191521182034969120343287691181300399683515414809262700457525876691808180257730351707673660380698973884642306898810000633684878715402823143549139850732982897459698089649561190746850698130299458080255582312696873149210028240898137822888492559957665067936573356367589784593119016624072433872744537432005911668494455733330689385141214653091888017782049043434862620306783436169856564175929871100669913438980899219579329897753233450934770193915434791427728636586218049874617231705308003720066269312729135764175698611068808404054125581540114956463603240222497919384691718744014002554201602395969312999994159599536026359879060218056496345745457493919771337601177449899066579857630036350871090452649830775029695488575574985078428560054253180863725364147 1697 412629526163150748619328091306742267675740578011800062477174189782151273970783531227579758540364970485350157944321579108232221072397135934034064481497887079641131808838242743811511451355024436983050572020925065644355566434625618133203024215941534926113892937988520918939061441606915556516246057349589921494351383160036280826024605351878408056180907759973804117263002554923041750587548819746346813966673034182913325507826219961923932100526305289894965216608254252188398580139545189681875824089456195044984585824938384521905334289906422454152976834867304693292466676355760173232407753256256317546190171995276258924613533179898467683358934751999655196790168438343198229183747091108262988777659858609744709324571850262293294975336628234767258858873839342596887193772615000676401522431518310648303975593582965021189182246986957349253156736526071639973844039068996404290548474640668851856078201093335425412842295604919065487301340901573809617549185106072798799159726375235125260509158832996701927878713084753334549129580912412168594170659605421750204835970231909591063407612779337478065175988365401590396247576709343727196106058477166945670117868989025903023998142850338956985816131805349549059377047477131270847579095628384569645636821650 494644347943710545224678831941589086572700792465459558770782213550069709458568349686998660541810166872034041584767487150140111151788221460027897193248273461607411027815984883969396220626358625041781558277804930212654296704055890683796941327712758797770820006623289146990000114915293539639766846910274034245607746230740851938158390562286057002223177609606376329007676845450142537930798148258428701466415483232670659815791064681384406494388237742330786225557303988025468036820082959712050733095860546860468575857084616069132051094882919253745234762029759124776348047587755897123575123506976140900565238840752841856713613368250071926171873213897914794115466890719123299469964019450899291410760762179836946570945555295288184698184555018368687708432612286248476073758067175481771199066581572870175460016017100414479346437034291784837132240891321931601494414908927713208448927221095745802380014441841139882391378410438764884597938773868771896252329517440068673532468372840830510218585255432000690265226016573313570977945083879214961394087065558376158826938257664840570952233832852869328785568175434516247720356520242602299510374317488182738732700078879665745909603766482100138001417023680647717824323143388857817595766172152883484274718248 152942283599728307168144137370127212672611894072038732126041098102628831053000986759260271210671922070555948023688596575415822984026159010574404359474670428678518262175033880513984372909748992727828381694416776740981021730545374002974037896534944567124543272737618380646771071804878796585983783360553761828325817820260204820004421979881871027255562690952334900616675606524933557440263648233514757200263521499508373975003431306847453046714027687108396945719803444444954079308404947126216395526551292104722047878178373207886033071857277857997932255251315982837892164421298202073945919187779856785892717251746704537315003771369737854896595170485152591013676942418134278534037654467840633528916812275267230155352077736583130992587670941654695382287023971261529987384520843829695778029311786431227409189019205818351911572757145556993606643464336196802350204616056286497246016800105003143046120608673496196758720552776772796609670537056331996894322779267635281472481559819839042424017171718303214059720568484939239370144038161541354254182769979771948759413102933987773401644506930205164891773826513161783736386604783484446345744957119469799231796368324927570694496679453313927562345656690240414624431304646248599226046524702364131095964335 79717988936247951265489157583697956031893477858854186991051529161879478488281744062318600470906120960002282886511477294555606503083169449335174864424180701080203993329996226566203834693869525797695969610065991941396723959032680019082506816443041598300477625793433080664346470586416385854692124426348587211026568667694805849554780794033764714016521711467557284846737236374990121316809833819996821592832639024026411520407330206281265390130763948165694574512140518775603040182029818771866749548761938870605590174330887949847420877829240131490902432602005681085180807294176837646062568094875766945890382971790015490163385088144673549085079635083262975154206269679142412897438231719704933258660779310737302680265445437771977749959110744959368586293082016067927548564967400845992380076107522755566531760628823374519718763740378295585535591752887339222947397184116326706799921515431185636740825707782742373783475781052674257292910213843986132987466810027275052416774693363446184518901899202502828670309452622347532932678874990809930682575738653876289384151496807194146308614368821006660626870989784697045160231069428458961107751207771093777394616856305293335603892178327520756554333365975114235981173451368131680404850832773147333013716920 123111353650401158556639983459870663057297871992927053886971224773529636525110628183715748795987525113177540092814119928708272290370336537110381023134637759740716140969662183269370676630325583385284994943164692397459103195434968057377474610500216801375394703781249039351368816958227409657934091741509357152328382960684515093945552479461382281913961956745154260686029997827565075768703774895750561575155143606297116391666385705899138085693913246313778033627210312268959737394553510894720099165193981333775907531107232556909478156441457899797515694348816961762796703443502856101079430585547997496001098926600499728389113862894833789669213630332988693669889340482430613291490613803204484751470676686041002772556117213612152322606737150858116122936539131795111263513114569794532805886643087299918196635113037777138666914296986040549274559835214505300618256105508764026461518876579387159881983544667258537064954616097750399839661065797883103731694314852301848272092388637114950059216922969842082648527035538090054093890365647676119748995243416337805666557501345234056968476142608491830438065401219751688687373709390057521910942736632126729711606256158399963682990881473178216060827021373776598901281958527655543318413664277921492723185984 36869806815936046911848195817405817350259890871483063184373728397968909458432625046025376290214729914038387534731762237978339011724858818860181178811639468996206294711495853807311240013786226884265118119546377272154555615363105236192878292703331473547623021744317034819416624562896226194523639793573028006666236271812390759036235867495803255905843636447252225413871038762657801345647584493917576263471587347202664391908570140389126903204602391093990827188675090199750617303773574821926387194478875191828814971296674530519321530805302667925998711835019806761133078403281404889374663875077339168901297819436499920958268483684335998301056068380228873524800383911402490807139268964095165069610454677558808756444381542173782815227920906224931028457073652453777424387873533280455944646592996920617956675786286711447540353883400282402551158169958389450168079568459656526911857835375748015814860506707921852997096156275804955989964215077733621769938075413007804223217091604613132253046399456747595300404564172224333936405545921819654435437072133387523533568472443532200069133022979195685683508297337961701169394794966256415112246587706103819620428258245999539040721929317130088874161577093962579487428358736401687123174207198251449851429295 HUB2：\n785095419718268286866508214304816985447077293766819398728046411166917810820484759314291028976498223661229395009474063173705162627037610993539617751905443039278227583504604808251931083818909467613277587874545761074364427549966555519371913859875313577282243053150056274667798049694695703660313532933165449312949725581708965417273055582216295994587600975970124811496270080896977076946000102701030260990598181466447208054713391526313700681341093922240317428173599031624125155188216489476825606191521182034969120343287691181300399683515414809262700457525876691808180257730351707673660380698973884642306898810000633684878715402823143549139850732982897459698089649561190746850698130299458080255582312696873149210028240898137822888492559957665067936573356367589784593119016624072433872744537432005911668494455733330689385141214653091888017782049043434862620306783436169856564175929871100669913438980899219579329897753233450934770193915434791427728636586218049874617231705308003720066269312729135764175698611068808404054125581540114956463603240222497919384691718744014002554201602395969312999994159599536026359879060218056496345745457493919771337601177449899066579857630036350871090452649830775029695488575574985078428560054253180863725364147 599 592169079372093727306100216011395857825646323934289480976073629037543922902098120901138454462177159996376654176248238979132528728327590301098966139983157980612320563496546128644967731000716697705104079039156276714872147463350811303393260622707024952543509891692246246277965823414460326811240048060543656588688604452353899779068825120910282167004715339763187734797180326976132213325054697165320479166356562518029805927741656605174809726397565772271562066078076105491745903986597877400370206718954975288721072048333678609055008135809089304229015364348490924974097403734627265297637171818849461766523691595241613878709865506436588268999163342945070495338153600520537498539457396582804692959296612715752573140296135784933206146091436617979599749774330699946637591406356289409716084034451049094715202196203486088368791744107629271647320273259836915312794297246589501008666299165717722507702866033454215783240025504356157664454861755286285777763585177751796252655008206383024707883077513745863312079349790275094080707502392866946325796914450602264462588722052297430827681750827349094323968337670311272933785838850649376115667223821665435911506351891489985627506615492005617098615432522564204152887767244129985681083657783356557756654335186 373940646416832740878733255707567753033716583448402000789202767511920210382830343955553654111486728333980557319799362514960627879016797491389812007768832730979916230647641872759001906846747977631675704310179448857128160385701185892914523053669366534408863734305635222625590986006420486092550427301086984563126480814987024980594613542978310129247678826691418335300577577527951623696426435497835228167084738007750914270251001921329521479047662848650808989996085600197309361410863238526802127877523767262921515150984998560136647154865791163316503073285223966216441025637452229043510097323724381056976302288136843260163922706692913035222445496716008888946581535004546355744211680390731257309941902587303353139951102244865270295414474488798335404630458489706639805186573874814586736746232358849677477533671968344154242963289415569487579895910660999043578737461300406937828924818002658292769882181668784501439254131996848948120781562158861495883827848139425862249576454689133681009549361314460818658995959098228995702202268649635363105549975932395335076521137604288520082040121286614922986554652700056148966514178935952363036963217619879899671383604638416567950421350546204434902113156720006282720889591288850271076074941927715678306057176 527630926460622936571385649841758214453416849039412401087443444317101857090904711485538107058823056085840539073345920792871368232355475394571098380596835468509997340505604333730547799560998822989747473780307779717715522787724471724766494090783971030594671013168209717686720448579582618378459567979027822271918653169622428153856198907810040224340270362413432495029672123261375400927159831537760709974778708160583252613784358234858583174544777979242887938827573604837766801998381379999076416444683891078093889686055482709838668356120916040352123019019255084513769603803814947774554028717814638951416291274696771515474086351482107953150253616922787262398450376249126999644026382478413080973933173079111305142716133389111399235545279259017424722601848670061556859163943895466553927946412523750166582734005733378328468250568944945912238495877929717101722314678120172228493787964904072583905721074766711732215815561012960394537195757832959268603775112932862105945720853959285187521763557915356428113876893276879775603217718981852114599706699524551973934242045743122744146361596971245034059345915315495232135483464496114770357536576200511490922413208178149869347802988786513451486411409887164516065062084917556120712465074206435831498113605 8786437178698940322877889807009957616777351844979869726962356553244050911283984280960665761649310895230455072977431415102053987735969326553978994853162483051544656873294555116009995592043183070208706258164840540599577072097104139505857517663273929851202628854185356185647194933800084230503413037858893307713037149307477830536758283681093517617820169181420796105338681582230788318108428132051793761014952837330456262272828627355701464740578197966332613127307037255647286823496355917642353327912440019621838870388091824748629637425759125214639885130163183752378908729773517053259212525494555880921052679512582051516604297098204363525081039382358483926727008679327719083138865969291911863630382097160230960738043575559330264018212774424527719153248563876760067931499029384228993253862501939337758514377472011933279273181144830381169849387893799390755052093069179605579485710343655570028592595882436632426527654452895431758715126580164902410286422637215098476316042367916779431052267545769495994723721129943616294879642305545894912914632980455031755879087401575310699765408473606166727137934224515998416625122213056208800095077933103150699272650116151674702438463062734472714004926103668378506804002740045547964716693536349447660850580 205314962204511500352858372254132533167549960825498949618514841570703199264867431580754674275990554478140637041427842111391746883257447120035947621456863890934062044010795443059281736346976175772415034838334682726635263432655537852942177334888025283748611576171534251461847349566505628290587224150869640386437623371249743165260396675220683302142805646368906930575140628610003919131999295855501215111393294818218799982703289304596989070475000081175510085432290264502023736899104746316830742226946395027029820825791831870857382647221322734605026210073093918331247494307555600335550942340526536281372036612138713881098866303169425501998978400008829873080965592009371176208668290074288903681417933657472279670688597862835627506340169978450918788539270346340385928840299573889292189531738082166408734046381423516467694328971385421907314814283489322619386570046183556572383980777277173349209330683424343658179781015072259378576130442222984963071166207642585589822061597282467850868050737957726423713761694231879497037175627546427449730638216214828463003483408928375620315193290871300316930139260521382533279767663839278693750409419493280753368451508802658272220767624766390639285308433607255253282702383762149755935518922075584637512494819 271453634732502613378948161256470991260052778799128789839624515809143527363206813219580098196957510291648493698144497567392065251244844074992734669490296293997386198359280316655904691639367482203210051809125904410431506925238374843856343243276508280641059690938930957474434518308646618959004216831130099873532714372402117796666560677624822509159287675432413016478948594640872091688482149004426363946048517480052906306290126242866034249478040406351940088231081456109195799442996799641647167552689564613346415247906852055588498305665928450828756152103096629274760601528737639415361467941349982213641454967962723875032638267311935042334584913897338553953961877439389588793074211502597238465542889335363559052368180212013206172712561221352833891640659020253527584706465205486408990762759230842192028381048563437724528409174790022752557512795782713125166158329880702730769957185428522011430144840232256419113631679343171680631630775266488738173707357123139368825087043785842169049943237537188129367275730984789479909103397937113837824575137021012333461552176687570010445744268373840742899299977372834041925102853718964831225250407279578465008537542659673685686242773379131904890865110699190451534445434533919127658976874721029586168106207 这道题目的关键应该就是加密算法的那个python文件和提示文件，需要看懂并了解rsa.py里面具体的加密算法，是以什么样的方式进行加密的。\n审计一下加密算法，发现N使用了两次，可以断定这题是共模攻击的题目，先丢进共模攻击的脚本里面瞧一瞧：\nimport libnum import gmpy2 def common_modulus(n,c1,c2,e1,e2): assert(libnum.gcd(e1, e2)) _, s1, s2 = gmpy2.gcdext(e1, e2) if s1 \u0026lt; 0: s1 = -s1 c1 = gmpy2.invert(c1,n) if s2 \u0026lt; 0: s2 = -s2 c2 = gmpy2.invert(c2,n) return pow(c1,s1,n) * pow(c2,s2,n) % n n = 785095419718268286866508214304816985447077293766819398728046411166917810820484759314291028976498223661229395009474063173705162627037610993539617751905443039278227583504604808251931083818909467613277587874545761074364427549966555519371913859875313577282243053150056274667798049694695703660313532933165449312949725581708965417273055582216295994587600975970124811496270080896977076946000102701030260990598181466447208054713391526313700681341093922240317428173599031624125155188216489476825606191521182034969120343287691181300399683515414809262700457525876691808180257730351707673660380698973884642306898810000633684878715402823143549139850732982897459698089649561190746850698130299458080255582312696873149210028240898137822888492559957665067936573356367589784593119016624072433872744537432005911668494455733330689385141214653091888017782049043434862620306783436169856564175929871100669913438980899219579329897753233450934770193915434791427728636586218049874617231705308003720066269312729135764175698611068808404054125581540114956463603240222497919384691718744014002554201602395969312999994159599536026359879060218056496345745457493919771337601177449899066579857630036350871090452649830775029695488575574985078428560054253180863725364147 e1 = 1697 e2 = 599 c1 = 0 c2 = 0 hub1 = [ 412629526163150748619328091306742267675740578011800062477174189782151273970783531227579758540364970485350157944321579108232221072397135934034064481497887079641131808838242743811511451355024436983050572020925065644355566434625618133203024215941534926113892937988520918939061441606915556516246057349589921494351383160036280826024605351878408056180907759973804117263002554923041750587548819746346813966673034182913325507826219961923932100526305289894965216608254252188398580139545189681875824089456195044984585824938384521905334289906422454152976834867304693292466676355760173232407753256256317546190171995276258924613533179898467683358934751999655196790168438343198229183747091108262988777659858609744709324571850262293294975336628234767258858873839342596887193772615000676401522431518310648303975593582965021189182246986957349253156736526071639973844039068996404290548474640668851856078201093335425412842295604919065487301340901573809617549185106072798799159726375235125260509158832996701927878713084753334549129580912412168594170659605421750204835970231909591063407612779337478065175988365401590396247576709343727196106058477166945670117868989025903023998142850338956985816131805349549059377047477131270847579095628384569645636821650, 494644347943710545224678831941589086572700792465459558770782213550069709458568349686998660541810166872034041584767487150140111151788221460027897193248273461607411027815984883969396220626358625041781558277804930212654296704055890683796941327712758797770820006623289146990000114915293539639766846910274034245607746230740851938158390562286057002223177609606376329007676845450142537930798148258428701466415483232670659815791064681384406494388237742330786225557303988025468036820082959712050733095860546860468575857084616069132051094882919253745234762029759124776348047587755897123575123506976140900565238840752841856713613368250071926171873213897914794115466890719123299469964019450899291410760762179836946570945555295288184698184555018368687708432612286248476073758067175481771199066581572870175460016017100414479346437034291784837132240891321931601494414908927713208448927221095745802380014441841139882391378410438764884597938773868771896252329517440068673532468372840830510218585255432000690265226016573313570977945083879214961394087065558376158826938257664840570952233832852869328785568175434516247720356520242602299510374317488182738732700078879665745909603766482100138001417023680647717824323143388857817595766172152883484274718248, 152942283599728307168144137370127212672611894072038732126041098102628831053000986759260271210671922070555948023688596575415822984026159010574404359474670428678518262175033880513984372909748992727828381694416776740981021730545374002974037896534944567124543272737618380646771071804878796585983783360553761828325817820260204820004421979881871027255562690952334900616675606524933557440263648233514757200263521499508373975003431306847453046714027687108396945719803444444954079308404947126216395526551292104722047878178373207886033071857277857997932255251315982837892164421298202073945919187779856785892717251746704537315003771369737854896595170485152591013676942418134278534037654467840633528916812275267230155352077736583130992587670941654695382287023971261529987384520843829695778029311786431227409189019205818351911572757145556993606643464336196802350204616056286497246016800105003143046120608673496196758720552776772796609670537056331996894322779267635281472481559819839042424017171718303214059720568484939239370144038161541354254182769979771948759413102933987773401644506930205164891773826513161783736386604783484446345744957119469799231796368324927570694496679453313927562345656690240414624431304646248599226046524702364131095964335, 79717988936247951265489157583697956031893477858854186991051529161879478488281744062318600470906120960002282886511477294555606503083169449335174864424180701080203993329996226566203834693869525797695969610065991941396723959032680019082506816443041598300477625793433080664346470586416385854692124426348587211026568667694805849554780794033764714016521711467557284846737236374990121316809833819996821592832639024026411520407330206281265390130763948165694574512140518775603040182029818771866749548761938870605590174330887949847420877829240131490902432602005681085180807294176837646062568094875766945890382971790015490163385088144673549085079635083262975154206269679142412897438231719704933258660779310737302680265445437771977749959110744959368586293082016067927548564967400845992380076107522755566531760628823374519718763740378295585535591752887339222947397184116326706799921515431185636740825707782742373783475781052674257292910213843986132987466810027275052416774693363446184518901899202502828670309452622347532932678874990809930682575738653876289384151496807194146308614368821006660626870989784697045160231069428458961107751207771093777394616856305293335603892178327520756554333365975114235981173451368131680404850832773147333013716920, 123111353650401158556639983459870663057297871992927053886971224773529636525110628183715748795987525113177540092814119928708272290370336537110381023134637759740716140969662183269370676630325583385284994943164692397459103195434968057377474610500216801375394703781249039351368816958227409657934091741509357152328382960684515093945552479461382281913961956745154260686029997827565075768703774895750561575155143606297116391666385705899138085693913246313778033627210312268959737394553510894720099165193981333775907531107232556909478156441457899797515694348816961762796703443502856101079430585547997496001098926600499728389113862894833789669213630332988693669889340482430613291490613803204484751470676686041002772556117213612152322606737150858116122936539131795111263513114569794532805886643087299918196635113037777138666914296986040549274559835214505300618256105508764026461518876579387159881983544667258537064954616097750399839661065797883103731694314852301848272092388637114950059216922969842082648527035538090054093890365647676119748995243416337805666557501345234056968476142608491830438065401219751688687373709390057521910942736632126729711606256158399963682990881473178216060827021373776598901281958527655543318413664277921492723185984, 36869806815936046911848195817405817350259890871483063184373728397968909458432625046025376290214729914038387534731762237978339011724858818860181178811639468996206294711495853807311240013786226884265118119546377272154555615363105236192878292703331473547623021744317034819416624562896226194523639793573028006666236271812390759036235867495803255905843636447252225413871038762657801345647584493917576263471587347202664391908570140389126903204602391093990827188675090199750617303773574821926387194478875191828814971296674530519321530805302667925998711835019806761133078403281404889374663875077339168901297819436499920958268483684335998301056068380228873524800383911402490807139268964095165069610454677558808756444381542173782815227920906224931028457073652453777424387873533280455944646592996920617956675786286711447540353883400282402551158169958389450168079568459656526911857835375748015814860506707921852997096156275804955989964215077733621769938075413007804223217091604613132253046399456747595300404564172224333936405545921819654435437072133387523533568472443532200069133022979195685683508297337961701169394794966256415112246587706103819620428258245999539040721929317130088874161577093962579487428358736401687123174207198251449851429295 ] hub2 = [ 592169079372093727306100216011395857825646323934289480976073629037543922902098120901138454462177159996376654176248238979132528728327590301098966139983157980612320563496546128644967731000716697705104079039156276714872147463350811303393260622707024952543509891692246246277965823414460326811240048060543656588688604452353899779068825120910282167004715339763187734797180326976132213325054697165320479166356562518029805927741656605174809726397565772271562066078076105491745903986597877400370206718954975288721072048333678609055008135809089304229015364348490924974097403734627265297637171818849461766523691595241613878709865506436588268999163342945070495338153600520537498539457396582804692959296612715752573140296135784933206146091436617979599749774330699946637591406356289409716084034451049094715202196203486088368791744107629271647320273259836915312794297246589501008666299165717722507702866033454215783240025504356157664454861755286285777763585177751796252655008206383024707883077513745863312079349790275094080707502392866946325796914450602264462588722052297430827681750827349094323968337670311272933785838850649376115667223821665435911506351891489985627506615492005617098615432522564204152887767244129985681083657783356557756654335186, 373940646416832740878733255707567753033716583448402000789202767511920210382830343955553654111486728333980557319799362514960627879016797491389812007768832730979916230647641872759001906846747977631675704310179448857128160385701185892914523053669366534408863734305635222625590986006420486092550427301086984563126480814987024980594613542978310129247678826691418335300577577527951623696426435497835228167084738007750914270251001921329521479047662848650808989996085600197309361410863238526802127877523767262921515150984998560136647154865791163316503073285223966216441025637452229043510097323724381056976302288136843260163922706692913035222445496716008888946581535004546355744211680390731257309941902587303353139951102244865270295414474488798335404630458489706639805186573874814586736746232358849677477533671968344154242963289415569487579895910660999043578737461300406937828924818002658292769882181668784501439254131996848948120781562158861495883827848139425862249576454689133681009549361314460818658995959098228995702202268649635363105549975932395335076521137604288520082040121286614922986554652700056148966514178935952363036963217619879899671383604638416567950421350546204434902113156720006282720889591288850271076074941927715678306057176, 527630926460622936571385649841758214453416849039412401087443444317101857090904711485538107058823056085840539073345920792871368232355475394571098380596835468509997340505604333730547799560998822989747473780307779717715522787724471724766494090783971030594671013168209717686720448579582618378459567979027822271918653169622428153856198907810040224340270362413432495029672123261375400927159831537760709974778708160583252613784358234858583174544777979242887938827573604837766801998381379999076416444683891078093889686055482709838668356120916040352123019019255084513769603803814947774554028717814638951416291274696771515474086351482107953150253616922787262398450376249126999644026382478413080973933173079111305142716133389111399235545279259017424722601848670061556859163943895466553927946412523750166582734005733378328468250568944945912238495877929717101722314678120172228493787964904072583905721074766711732215815561012960394537195757832959268603775112932862105945720853959285187521763557915356428113876893276879775603217718981852114599706699524551973934242045743122744146361596971245034059345915315495232135483464496114770357536576200511490922413208178149869347802988786513451486411409887164516065062084917556120712465074206435831498113605, 8786437178698940322877889807009957616777351844979869726962356553244050911283984280960665761649310895230455072977431415102053987735969326553978994853162483051544656873294555116009995592043183070208706258164840540599577072097104139505857517663273929851202628854185356185647194933800084230503413037858893307713037149307477830536758283681093517617820169181420796105338681582230788318108428132051793761014952837330456262272828627355701464740578197966332613127307037255647286823496355917642353327912440019621838870388091824748629637425759125214639885130163183752378908729773517053259212525494555880921052679512582051516604297098204363525081039382358483926727008679327719083138865969291911863630382097160230960738043575559330264018212774424527719153248563876760067931499029384228993253862501939337758514377472011933279273181144830381169849387893799390755052093069179605579485710343655570028592595882436632426527654452895431758715126580164902410286422637215098476316042367916779431052267545769495994723721129943616294879642305545894912914632980455031755879087401575310699765408473606166727137934224515998416625122213056208800095077933103150699272650116151674702438463062734472714004926103668378506804002740045547964716693536349447660850580, 205314962204511500352858372254132533167549960825498949618514841570703199264867431580754674275990554478140637041427842111391746883257447120035947621456863890934062044010795443059281736346976175772415034838334682726635263432655537852942177334888025283748611576171534251461847349566505628290587224150869640386437623371249743165260396675220683302142805646368906930575140628610003919131999295855501215111393294818218799982703289304596989070475000081175510085432290264502023736899104746316830742226946395027029820825791831870857382647221322734605026210073093918331247494307555600335550942340526536281372036612138713881098866303169425501998978400008829873080965592009371176208668290074288903681417933657472279670688597862835627506340169978450918788539270346340385928840299573889292189531738082166408734046381423516467694328971385421907314814283489322619386570046183556572383980777277173349209330683424343658179781015072259378576130442222984963071166207642585589822061597282467850868050737957726423713761694231879497037175627546427449730638216214828463003483408928375620315193290871300316930139260521382533279767663839278693750409419493280753368451508802658272220767624766390639285308433607255253282702383762149755935518922075584637512494819, 271453634732502613378948161256470991260052778799128789839624515809143527363206813219580098196957510291648493698144497567392065251244844074992734669490296293997386198359280316655904691639367482203210051809125904410431506925238374843856343243276508280641059690938930957474434518308646618959004216831130099873532714372402117796666560677624822509159287675432413016478948594640872091688482149004426363946048517480052906306290126242866034249478040406351940088231081456109195799442996799641647167552689564613346415247906852055588498305665928450828756152103096629274760601528737639415361467941349982213641454967962723875032638267311935042334584913897338553953961877439389588793074211502597238465542889335363559052368180212013206172712561221352833891640659020253527584706465205486408990762759230842192028381048563437724528409174790022752557512795782713125166158329880702730769957185428522011430144840232256419113631679343171680631630775266488738173707357123139368825087043785842169049943237537188129367275730984789479909103397937113837824575137021012333461552176687570010445744268373840742899299977372834041925102853718964831225250407279578465008537542659673685686242773379131904890865110699190451534445434533919127658976874721029586168106207 ] assert len(hub1) == len(hub2) length = len(hub2) baseCipher = \u0026#34;\u0026#34; for i in range(length): c1 = hub1[i] c2 = hub2[i] m = common_modulus(n,c1,c2,e1,e2) baseCipher += libnum.n2s(m) print baseCipher 运行脚本后，输出的是一堆base64：\nVEhJUz== RkxBR3== SVN= SElEREVOLo== Q0FO WU9V RklORM== SVT= T1VUP4== RE8= WU9V S05PV9== QkFTRTY0P5== WW91bmdD VEhJTku= WU9V QVJF Tk9U VEhBVE== RkFNSUxJQVI= V0lUSO== QkFTRTY0Lh== QmFzZTY0 aXO= YW== Z3JvdXA= b2b= c2ltaWxhcn== YmluYXJ5LXRvLXRleHR= ZW5jb2Rpbme= c2NoZW1lc0== dGhhdD== cmVwcmVzZW50 YmluYXJ5 ZGF0YW== aW5= YW6= QVNDSUl= c3RyaW5n Zm9ybWF0 Ynk= dHJhbnNsYXRpbmd= aXS= aW50b1== YT== cmFkaXgtNjQ= cmVwcmVzZW50YXRpb24u VGhl dGVybc== QmFzZTY0 b3JpZ2luYXRlc8== ZnJvbd== YY== c3BlY2lmaWN= TUlNRT== Y29udGVudI== dHJhbnNmZXI= ZW5jb2Rpbmcu VGhl cGFydGljdWxhct== c2V0 b2b= NjR= Y2hhcmFjdGVyc5== Y2hvc2Vu dG+= cmVwcmVzZW50 dGhl NjQ= cGxhY2UtdmFsdWVz Zm9y dGhl YmFzZd== dmFyaWVz YmV0d2Vlbt== aW1wbGVtZW50YXRpb25zLp== VGhl Z2VuZXJhbI== c3RyYXRlZ3n= aXO= dG9= Y2hvb3Nl NjR= Y2hhcmFjdGVyc5== dGhhdA== YXJl Ym90aN== bWVtYmVyc5== b2a= YS== c3Vic2V0 Y29tbW9u dG8= bW9zdM== ZW5jb2RpbmdzLA== YW5k YWxzb8== cHJpbnRhYmxlLg== VGhpc9== Y29tYmluYXRpb25= bGVhdmVz dGhl ZGF0YW== dW5saWtlbHk= dG/= YmV= bW9kaWZpZWS= aW5= dHJhbnNpdE== dGhyb3VnaN== aW5mb3JtYXRpb26= c3lzdGVtcyw= c3VjaN== YXM= RS1tYWlsLD== dGhhdA== d2VyZQ== dHJhZGl0aW9uYWxseQ== bm90 OC1iaXQ= Y2xlYW4uWzFd Rm9y ZXhhbXBsZSw= TUlNRSdz QmFzZTY0 aW1wbGVtZW50YXRpb24= dXNlcw== QahDWiw= YahDeiw= YW5k MKhDOQ== Zm9y dGhl Zmlyc3Q= NjI= dmFsdWVzLg== T3RoZXI= dmFyaWF0aW9ucw== c2hhcmU= dGhpcw== cHJvcGVydHk= YnV0 ZGlmZmVy aW4= dGhl c3ltYm9scw== Y2hvc2Vu Zm9y dGhl bGFzdA== dHdv dmFsdWVzOw== YW4= ZXhhbXBsZQ== aXM= VVRGLTcu 看样子像是base64隐写，可以将内容写入一个txt文件，然后借一个base64隐写的脚本处理一下：\ndef get_base64_diff_value(s1, s2): base64chars = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return res def solve_stego(): with open(\u0026#39;cipher.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: file_lines = f.readlines() bin_str = \u0026#39;\u0026#39; for line in file_lines: steg_line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) norm_line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;).decode(\u0026#39;base64\u0026#39;).encode(\u0026#39;base64\u0026#39;).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count(\u0026#39;=\u0026#39;) if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += \u0026#39;0\u0026#39; * pads_num * 2 print goflag(bin_str) def goflag(bin_str): res_str = \u0026#39;\u0026#39; for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_str if __name__ == \u0026#39;__main__\u0026#39;: solve_stego() 运行一个这个脚本，flag就有了：\n7c86d8f7d6de33a87f7f9d6b005ce640 完整EXP：\nimport libnum import gmpy2 def common_modulus(n,c1,c2,e1,e2): assert(libnum.gcd(e1, e2)) _, s1, s2 = gmpy2.gcdext(e1, e2) if s1 \u0026lt; 0: s1 = -s1 c1 = gmpy2.invert(c1,n) if s2 \u0026lt; 0: s2 = -s2 c2 = gmpy2.invert(c2,n) return pow(c1,s1,n) * pow(c2,s2,n) % n n = 785095419718268286866508214304816985447077293766819398728046411166917810820484759314291028976498223661229395009474063173705162627037610993539617751905443039278227583504604808251931083818909467613277587874545761074364427549966555519371913859875313577282243053150056274667798049694695703660313532933165449312949725581708965417273055582216295994587600975970124811496270080896977076946000102701030260990598181466447208054713391526313700681341093922240317428173599031624125155188216489476825606191521182034969120343287691181300399683515414809262700457525876691808180257730351707673660380698973884642306898810000633684878715402823143549139850732982897459698089649561190746850698130299458080255582312696873149210028240898137822888492559957665067936573356367589784593119016624072433872744537432005911668494455733330689385141214653091888017782049043434862620306783436169856564175929871100669913438980899219579329897753233450934770193915434791427728636586218049874617231705308003720066269312729135764175698611068808404054125581540114956463603240222497919384691718744014002554201602395969312999994159599536026359879060218056496345745457493919771337601177449899066579857630036350871090452649830775029695488575574985078428560054253180863725364147 e1 = 1697 e2 = 599 c1 = 0 c2 = 0 hub1 = [ 412629526163150748619328091306742267675740578011800062477174189782151273970783531227579758540364970485350157944321579108232221072397135934034064481497887079641131808838242743811511451355024436983050572020925065644355566434625618133203024215941534926113892937988520918939061441606915556516246057349589921494351383160036280826024605351878408056180907759973804117263002554923041750587548819746346813966673034182913325507826219961923932100526305289894965216608254252188398580139545189681875824089456195044984585824938384521905334289906422454152976834867304693292466676355760173232407753256256317546190171995276258924613533179898467683358934751999655196790168438343198229183747091108262988777659858609744709324571850262293294975336628234767258858873839342596887193772615000676401522431518310648303975593582965021189182246986957349253156736526071639973844039068996404290548474640668851856078201093335425412842295604919065487301340901573809617549185106072798799159726375235125260509158832996701927878713084753334549129580912412168594170659605421750204835970231909591063407612779337478065175988365401590396247576709343727196106058477166945670117868989025903023998142850338956985816131805349549059377047477131270847579095628384569645636821650, 494644347943710545224678831941589086572700792465459558770782213550069709458568349686998660541810166872034041584767487150140111151788221460027897193248273461607411027815984883969396220626358625041781558277804930212654296704055890683796941327712758797770820006623289146990000114915293539639766846910274034245607746230740851938158390562286057002223177609606376329007676845450142537930798148258428701466415483232670659815791064681384406494388237742330786225557303988025468036820082959712050733095860546860468575857084616069132051094882919253745234762029759124776348047587755897123575123506976140900565238840752841856713613368250071926171873213897914794115466890719123299469964019450899291410760762179836946570945555295288184698184555018368687708432612286248476073758067175481771199066581572870175460016017100414479346437034291784837132240891321931601494414908927713208448927221095745802380014441841139882391378410438764884597938773868771896252329517440068673532468372840830510218585255432000690265226016573313570977945083879214961394087065558376158826938257664840570952233832852869328785568175434516247720356520242602299510374317488182738732700078879665745909603766482100138001417023680647717824323143388857817595766172152883484274718248, 152942283599728307168144137370127212672611894072038732126041098102628831053000986759260271210671922070555948023688596575415822984026159010574404359474670428678518262175033880513984372909748992727828381694416776740981021730545374002974037896534944567124543272737618380646771071804878796585983783360553761828325817820260204820004421979881871027255562690952334900616675606524933557440263648233514757200263521499508373975003431306847453046714027687108396945719803444444954079308404947126216395526551292104722047878178373207886033071857277857997932255251315982837892164421298202073945919187779856785892717251746704537315003771369737854896595170485152591013676942418134278534037654467840633528916812275267230155352077736583130992587670941654695382287023971261529987384520843829695778029311786431227409189019205818351911572757145556993606643464336196802350204616056286497246016800105003143046120608673496196758720552776772796609670537056331996894322779267635281472481559819839042424017171718303214059720568484939239370144038161541354254182769979771948759413102933987773401644506930205164891773826513161783736386604783484446345744957119469799231796368324927570694496679453313927562345656690240414624431304646248599226046524702364131095964335, 79717988936247951265489157583697956031893477858854186991051529161879478488281744062318600470906120960002282886511477294555606503083169449335174864424180701080203993329996226566203834693869525797695969610065991941396723959032680019082506816443041598300477625793433080664346470586416385854692124426348587211026568667694805849554780794033764714016521711467557284846737236374990121316809833819996821592832639024026411520407330206281265390130763948165694574512140518775603040182029818771866749548761938870605590174330887949847420877829240131490902432602005681085180807294176837646062568094875766945890382971790015490163385088144673549085079635083262975154206269679142412897438231719704933258660779310737302680265445437771977749959110744959368586293082016067927548564967400845992380076107522755566531760628823374519718763740378295585535591752887339222947397184116326706799921515431185636740825707782742373783475781052674257292910213843986132987466810027275052416774693363446184518901899202502828670309452622347532932678874990809930682575738653876289384151496807194146308614368821006660626870989784697045160231069428458961107751207771093777394616856305293335603892178327520756554333365975114235981173451368131680404850832773147333013716920, 123111353650401158556639983459870663057297871992927053886971224773529636525110628183715748795987525113177540092814119928708272290370336537110381023134637759740716140969662183269370676630325583385284994943164692397459103195434968057377474610500216801375394703781249039351368816958227409657934091741509357152328382960684515093945552479461382281913961956745154260686029997827565075768703774895750561575155143606297116391666385705899138085693913246313778033627210312268959737394553510894720099165193981333775907531107232556909478156441457899797515694348816961762796703443502856101079430585547997496001098926600499728389113862894833789669213630332988693669889340482430613291490613803204484751470676686041002772556117213612152322606737150858116122936539131795111263513114569794532805886643087299918196635113037777138666914296986040549274559835214505300618256105508764026461518876579387159881983544667258537064954616097750399839661065797883103731694314852301848272092388637114950059216922969842082648527035538090054093890365647676119748995243416337805666557501345234056968476142608491830438065401219751688687373709390057521910942736632126729711606256158399963682990881473178216060827021373776598901281958527655543318413664277921492723185984, 36869806815936046911848195817405817350259890871483063184373728397968909458432625046025376290214729914038387534731762237978339011724858818860181178811639468996206294711495853807311240013786226884265118119546377272154555615363105236192878292703331473547623021744317034819416624562896226194523639793573028006666236271812390759036235867495803255905843636447252225413871038762657801345647584493917576263471587347202664391908570140389126903204602391093990827188675090199750617303773574821926387194478875191828814971296674530519321530805302667925998711835019806761133078403281404889374663875077339168901297819436499920958268483684335998301056068380228873524800383911402490807139268964095165069610454677558808756444381542173782815227920906224931028457073652453777424387873533280455944646592996920617956675786286711447540353883400282402551158169958389450168079568459656526911857835375748015814860506707921852997096156275804955989964215077733621769938075413007804223217091604613132253046399456747595300404564172224333936405545921819654435437072133387523533568472443532200069133022979195685683508297337961701169394794966256415112246587706103819620428258245999539040721929317130088874161577093962579487428358736401687123174207198251449851429295 ] hub2 = [ 592169079372093727306100216011395857825646323934289480976073629037543922902098120901138454462177159996376654176248238979132528728327590301098966139983157980612320563496546128644967731000716697705104079039156276714872147463350811303393260622707024952543509891692246246277965823414460326811240048060543656588688604452353899779068825120910282167004715339763187734797180326976132213325054697165320479166356562518029805927741656605174809726397565772271562066078076105491745903986597877400370206718954975288721072048333678609055008135809089304229015364348490924974097403734627265297637171818849461766523691595241613878709865506436588268999163342945070495338153600520537498539457396582804692959296612715752573140296135784933206146091436617979599749774330699946637591406356289409716084034451049094715202196203486088368791744107629271647320273259836915312794297246589501008666299165717722507702866033454215783240025504356157664454861755286285777763585177751796252655008206383024707883077513745863312079349790275094080707502392866946325796914450602264462588722052297430827681750827349094323968337670311272933785838850649376115667223821665435911506351891489985627506615492005617098615432522564204152887767244129985681083657783356557756654335186, 373940646416832740878733255707567753033716583448402000789202767511920210382830343955553654111486728333980557319799362514960627879016797491389812007768832730979916230647641872759001906846747977631675704310179448857128160385701185892914523053669366534408863734305635222625590986006420486092550427301086984563126480814987024980594613542978310129247678826691418335300577577527951623696426435497835228167084738007750914270251001921329521479047662848650808989996085600197309361410863238526802127877523767262921515150984998560136647154865791163316503073285223966216441025637452229043510097323724381056976302288136843260163922706692913035222445496716008888946581535004546355744211680390731257309941902587303353139951102244865270295414474488798335404630458489706639805186573874814586736746232358849677477533671968344154242963289415569487579895910660999043578737461300406937828924818002658292769882181668784501439254131996848948120781562158861495883827848139425862249576454689133681009549361314460818658995959098228995702202268649635363105549975932395335076521137604288520082040121286614922986554652700056148966514178935952363036963217619879899671383604638416567950421350546204434902113156720006282720889591288850271076074941927715678306057176, 527630926460622936571385649841758214453416849039412401087443444317101857090904711485538107058823056085840539073345920792871368232355475394571098380596835468509997340505604333730547799560998822989747473780307779717715522787724471724766494090783971030594671013168209717686720448579582618378459567979027822271918653169622428153856198907810040224340270362413432495029672123261375400927159831537760709974778708160583252613784358234858583174544777979242887938827573604837766801998381379999076416444683891078093889686055482709838668356120916040352123019019255084513769603803814947774554028717814638951416291274696771515474086351482107953150253616922787262398450376249126999644026382478413080973933173079111305142716133389111399235545279259017424722601848670061556859163943895466553927946412523750166582734005733378328468250568944945912238495877929717101722314678120172228493787964904072583905721074766711732215815561012960394537195757832959268603775112932862105945720853959285187521763557915356428113876893276879775603217718981852114599706699524551973934242045743122744146361596971245034059345915315495232135483464496114770357536576200511490922413208178149869347802988786513451486411409887164516065062084917556120712465074206435831498113605, 8786437178698940322877889807009957616777351844979869726962356553244050911283984280960665761649310895230455072977431415102053987735969326553978994853162483051544656873294555116009995592043183070208706258164840540599577072097104139505857517663273929851202628854185356185647194933800084230503413037858893307713037149307477830536758283681093517617820169181420796105338681582230788318108428132051793761014952837330456262272828627355701464740578197966332613127307037255647286823496355917642353327912440019621838870388091824748629637425759125214639885130163183752378908729773517053259212525494555880921052679512582051516604297098204363525081039382358483926727008679327719083138865969291911863630382097160230960738043575559330264018212774424527719153248563876760067931499029384228993253862501939337758514377472011933279273181144830381169849387893799390755052093069179605579485710343655570028592595882436632426527654452895431758715126580164902410286422637215098476316042367916779431052267545769495994723721129943616294879642305545894912914632980455031755879087401575310699765408473606166727137934224515998416625122213056208800095077933103150699272650116151674702438463062734472714004926103668378506804002740045547964716693536349447660850580, 205314962204511500352858372254132533167549960825498949618514841570703199264867431580754674275990554478140637041427842111391746883257447120035947621456863890934062044010795443059281736346976175772415034838334682726635263432655537852942177334888025283748611576171534251461847349566505628290587224150869640386437623371249743165260396675220683302142805646368906930575140628610003919131999295855501215111393294818218799982703289304596989070475000081175510085432290264502023736899104746316830742226946395027029820825791831870857382647221322734605026210073093918331247494307555600335550942340526536281372036612138713881098866303169425501998978400008829873080965592009371176208668290074288903681417933657472279670688597862835627506340169978450918788539270346340385928840299573889292189531738082166408734046381423516467694328971385421907314814283489322619386570046183556572383980777277173349209330683424343658179781015072259378576130442222984963071166207642585589822061597282467850868050737957726423713761694231879497037175627546427449730638216214828463003483408928375620315193290871300316930139260521382533279767663839278693750409419493280753368451508802658272220767624766390639285308433607255253282702383762149755935518922075584637512494819, 271453634732502613378948161256470991260052778799128789839624515809143527363206813219580098196957510291648493698144497567392065251244844074992734669490296293997386198359280316655904691639367482203210051809125904410431506925238374843856343243276508280641059690938930957474434518308646618959004216831130099873532714372402117796666560677624822509159287675432413016478948594640872091688482149004426363946048517480052906306290126242866034249478040406351940088231081456109195799442996799641647167552689564613346415247906852055588498305665928450828756152103096629274760601528737639415361467941349982213641454967962723875032638267311935042334584913897338553953961877439389588793074211502597238465542889335363559052368180212013206172712561221352833891640659020253527584706465205486408990762759230842192028381048563437724528409174790022752557512795782713125166158329880702730769957185428522011430144840232256419113631679343171680631630775266488738173707357123139368825087043785842169049943237537188129367275730984789479909103397937113837824575137021012333461552176687570010445744268373840742899299977372834041925102853718964831225250407279578465008537542659673685686242773379131904890865110699190451534445434533919127658976874721029586168106207 ] assert len(hub1) == len(hub2) length = len(hub2) baseCipher = \u0026#34;\u0026#34; for i in range(length): c1 = hub1[i] c2 = hub2[i] m = common_modulus(n,c1,c2,e1,e2) baseCipher += libnum.n2s(m) with open(\u0026#34;cipher.txt\u0026#34;,\u0026#34;wb\u0026#34;) as f: f.write(baseCipher) def get_base64_diff_value(s1, s2): base64chars = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return res def solve_stego(): with open(\u0026#39;cipher.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: file_lines = f.readlines() bin_str = \u0026#39;\u0026#39; for line in file_lines: steg_line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) norm_line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;).decode(\u0026#39;base64\u0026#39;).encode(\u0026#39;base64\u0026#39;).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count(\u0026#39;=\u0026#39;) if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += \u0026#39;0\u0026#39; * pads_num * 2 print goflag(bin_str) def goflag(bin_str): res_str = \u0026#39;\u0026#39; for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_str if __name__ == \u0026#39;__main__\u0026#39;: solve_stego() base64隐写其实是利用base64编码原理的一个漏洞进行隐写来进行隐藏数据的一种隐写数据的方式。具体隐写原理和解密脚本，可以参照这篇博客：MISC | base64隐写_Lemon\u0026rsquo;s blog-CSDN博客 讲的很清楚，base64隐写其实也就那回事了。\n0x1 [WUSTCTF2020]大数计算 # 大数计算，应该是数学题目吧，看看吧：\nflag等于 wctf2020{Part1-Part2-Part3-Part4} 每一Part都为数的十六进制形式（不需要0x)，并用 \u0026#39;-\u0026#39; 连接 Part1 = 2020*2019*2018* ... *3*2*1 的前8位 Part2 = 520^1314 + 2333^666 的前8位 Part3 = 宇宙终极问题的答案 x,y,z绝对值和的前8位 Part4 = 见图片附件，计算结果乘上1314 感觉也不过如此嘛，解决思路还是比较简单的，采用数学计算加搜索引擎应该就解决了\n不过还是根据题目写个完整的exp吧，采用sage脚本（由于涉及到的数学计算比较多，选择sagemath编写脚本会简单许多）：\npart1 =int(str(factorial(2020))[:8]) part2 =int(str((520**1314) + (2333**666))[:8]) x_ = -80538738812075974 y_ = 80435758145817515 z_ = 12602123297335631 part3 =int(str(abs(x_)+abs(y_)+abs(z_))[:8]) x = var(x) f(x) = 2*x result = integral(f,x,0,22) part4 = (result+36)*1314 flag = \u0026#34;wctf2020{\u0026#34;+hex(part1)[2:]+ \u0026#34;-\u0026#34;+hex(part2)[2:] + \u0026#34;-\u0026#34;+ hex(part3)[2:]+\u0026#34;-\u0026#34;+hex(part4)[2:] + \u0026#34;}\u0026#34; print(flag) 使用sage运行一下，flag就有了：(中间的x,y,z是宇宙终极问题的解)\nwctf2020{24d231f-403cfd3-108db5e-a6d10} 0x2 坏蛋是雷宾 # 看题目还是挺有意思的，看看题目具体是什么吧：\n老牌刺客之王混进了女王的住所。一天，女王得到了一个匿名举报，说她的侍卫里有一个刺客，叫做Rabin，而他的信息就在一份文件里，文件中有附带一个Pk，是523798549，密文是162853095，校验码二进制值是110001，根据说明是放在明文后一起加密的，明文与密文长度相同。加密算法和这位老牌刺客同名。快拯救女王，答案是求得的明文，进行32位md5小写哈希字符串，提交即可。 注意：得到的 flag 请包上 flag{} 提交 看到Rabin这个词汇，应该是比较敏感的，因为Rabin算法是一个非常有名的RSA扩展算法，这道题目应该考察的也是Rabin算法进行求解的。应该是使用一个Rabin算法，Rabin算法有很多轮子，可以直接搬来用，或者稍微修改修改也就能得到相应的结果。\n题目中Pk就是n， 密文就是c，校验码二进制值是Rabin算法得出四个结果，四个结果的二进制值最后六位数字就是校验码二进制值。只有校验码二进制值与题目给出的校验码二进制值相符合的结果，才是本题的flag\n而且题目中的n值非常小，可以直接进行分解。\n这里给出一个小脚本求解：\nimport gmpy2 import hashlib c = 162853095 p = 49123 q = 10663 n = p*q r = pow(c,(p+1)/4,p) s = pow(c,(q+1)/4,q) a = gmpy2.invert(p,q) b = gmpy2.invert(q,p) x =(a*p*s+b*q*r)%n y =(a*p*s-b*q*r)%n m1 = x%n m2 = (-x)%n m3 = y%n m4 = (-y)%n yz = \u0026#39;110001\u0026#39; result = [m1,m2,m3,m4] for i in result: bin_i = bin(i)[2:] if bin_i[-6:] == yz: m = str(int(bin_i[:-6],2)) flag = hashlib.md5(m).hexdigest() print flag 运行脚本，就能拿到flag\nca5cec442b2734735406d78c88e90f35 0x3 [HDCTF2019]together # 看题目together，第一时间相到的应该是RSA题目的共模攻击，看看我的猜测对不对：\n题目给出四个文件，两个公钥文件，两个明文文件。非常明显的是RSA共模攻击的题目，下面就是看看RSA公钥的modulus是否相同，就可以进一步确定是否是RSA共模攻击。\n经过读取文件进行测试，发现两个公钥文件的modulus数值是一样的。\n下面直接丢脚本求解吧：\nfrom Crypto.PublicKey import RSA import gmpy2 import base64 import libnum def get_key(key_file): with open(key_file,\u0026#34;rb\u0026#34;) as f: data = f.read() key = RSA.importKey(data) return key def get_c(flag_file): with open(flag_file) as f: data = f.read() c = libnum.s2n(base64.b64decode(data)) return c def common_modulus(n,c1,c2,e1,e2): assert(libnum.gcd(e1, e2)) _, s1, s2 = gmpy2.gcdext(e1, e2) if s1 \u0026lt; 0: s1 = -s1 c1 = gmpy2.invert(c1,n) if s2 \u0026lt; 0: s2 = -s2 c2 = gmpy2.invert(c2,n) return pow(c1,s1,n) * pow(c2,s2,n) % n key1 = get_key(\u0026#34;pubkey1.pem\u0026#34;) key2 = get_key(\u0026#34;pubkey2.pem\u0026#34;) assert(key1.n == key2.n) n = key1.n e1 = key1.e e2 = key2.e c1 = get_c(\u0026#34;myflag1\u0026#34;) c2 = get_c(\u0026#34;myflag2\u0026#34;) m = common_modulus(n,c1,c2,e1,e2) flag = libnum.n2s(m) print flag 运行脚本，就能得到flag：\nflag{23re_SDxF_y78hu_5rFgS} 0x4 [MRCTF2020]babyRSA # RSA题目，应该会有点意思，看看题目具体是什么：\nimport sympy import random from gmpy2 import gcd, invert from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes from z3 import * flag = b\u0026#34;MRCTF{xxxx}\u0026#34; base = 65537 def GCD(A): B = 1 for i in range(1, len(A)): B = gcd(A[i-1], A[i]) return B def gen_p(): P = [0 for i in range(17)] P[0] = getPrime(128) for i in range(1, 17): P[i] = sympy.nextprime(P[i-1]) print(\u0026#34;P_p :\u0026#34;, P[9]) n = 1 for i in range(17): n *= P[i] p = getPrime(1024) factor = pow(p, base, n) print(\u0026#34;P_factor :\u0026#34;, factor) return sympy.nextprime(p) def gen_q(): sub_Q = getPrime(1024) Q_1 = getPrime(1024) Q_2 = getPrime(1024) Q = sub_Q ** Q_2 % Q_1 print(\u0026#34;Q_1: \u0026#34;, Q_1) print(\u0026#34;Q_2: \u0026#34;, Q_2) print(\u0026#34;sub_Q: \u0026#34;, sub_Q) return sympy.nextprime(Q) if __name__ == \u0026#34;__main__\u0026#34;: _E = base _P = gen_p() _Q = gen_q() assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1) _M = bytes_to_long(flag) _C = pow(_M, _E, _P * _Q) print(\u0026#34;Ciphertext = \u0026#34;, _C) \u0026#39;\u0026#39;\u0026#39; P_p : 206027926847308612719677572554991143421 P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839 Q_1: 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521 Q_2: 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743 sub_Q: 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651 Ciphertext = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832 \u0026#39;\u0026#39;\u0026#39; 一个python文件，应该是这道题目的求解关键，考察的应该就是对于加密算法的审计和算法的逆向运算咯，开始搞吧！\n核心代码应该就是这个：\nif __name__ == \u0026#34;__main__\u0026#34;: _E = base _P = gen_p() _Q = gen_q() assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1) _M = bytes_to_long(flag) _C = pow(_M, _E, _P * _Q) print(\u0026#34;Ciphertext = \u0026#34;, _C) 根据核心代码，可以找到：\nbase\nbase = 65537 gen_p()\ndef gen_p(): P = [0 for i in range(17)] P[0] = getPrime(128) for i in range(1, 17): P[i] = sympy.nextprime(P[i-1]) print(\u0026#34;P_p :\u0026#34;, P[9]) n = 1 for i in range(17): n *= P[i] p = getPrime(1024) factor = pow(p, base, n) print(\u0026#34;P_factor :\u0026#34;, factor) return sympy.nextprime(p) gen_q()\ndef gen_q(): sub_Q = getPrime(1024) Q_1 = getPrime(1024) Q_2 = getPrime(1024) Q = sub_Q ** Q_2 % Q_1 print(\u0026#34;Q_1: \u0026#34;, Q_1) print(\u0026#34;Q_2: \u0026#34;, Q_2) print(\u0026#34;sub_Q: \u0026#34;, sub_Q) return sympy.nextprime(Q) 核心代码就是这些，然后看看具体的输出结果：\n\u0026#39;\u0026#39;\u0026#39; P_p : 206027926847308612719677572554991143421 P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839 Q_1: 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521 Q_2: 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743 sub_Q: 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651 Ciphertext = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832 \u0026#39;\u0026#39;\u0026#39; 分析核心代码后，可以大致推导出来： $$ P = \\text{nextprime}(p^{base} \\text{mod}n) $$\n$$ Q = sub_Q ^ {Q_2} \\text{mod}Q_1 $$\n$$ C = M^E \\text{mod}(P\\times Q) $$\n根据算法泄露出来的数据，进行还原数据P和Q ，然后根据p和Q的数值进行正常的RSA解密运算，这道题目就over了。\n下面给出完整的EXP：\nimport sympy import gmpy2 import libnum P_p = 206027926847308612719677572554991143421 P_factor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839 Q_1 = 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521 Q_2 = 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743 sub_Q = 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651 Ciphertext = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832 base = 65537 _Q =sympy.nextprime(pow(sub_Q,Q_2,Q_1)) P = [None]*17 P[9] = P_p for i in range(0,9): P[9-(i+1)] = sympy.prevprime(P[9-i]) for i in range(9,16): P[i+1] = sympy.nextprime(P[i]) P_phi = 1 P_n = 1 for i in P: P_n *= i P_phi *= (i-1) assert(libnum.gcd(base,P_phi)==1) P_d = libnum.invmod(base,P_phi) p = pow(P_factor, P_d, P_n) _P = sympy.nextprime(p) phi = (_Q-1) * (_P-1) n = _Q * _P _E = base _D = libnum.invmod(_E,phi) _M = pow(Ciphertext, _D, n) flag = libnum.n2s(_M) print flag 运行一下脚本，flag就出来了：\nMRCTF{sti11_@_b@by_qu3st10n} 0x5 [网鼎杯 2020 青龙组]you_raise_me_up # 题目目前看不出什么提示来，直接看题目吧：\n#!/usr/bin/env python # -*- coding: utf-8 -*- from Crypto.Util.number import * import random n = 2 ** 512 m = random.randint(2, n-1) | 1 c = pow(m, bytes_to_long(flag), n) print \u0026#39;m = \u0026#39; + str(m) print \u0026#39;c = \u0026#39; + str(c) # m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075 # c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499 非常简单的一个小脚本，但是脚本过程中的加密过程有些特别，麻雀虽小五脏俱全。真可谓浓缩的都是精华，看看大致的加密过程吧： $$ n = 2^{512} $$\n$$ c = m^{\\text{bytes_to_long(flag)}}\\text{mod}n $$\n一时半会儿看不出怎么进行求解，求助了下大佬的博客，发现这道题目考察的是一个离散对数问题，即： $$ \\text{bytes_to_long(flag)} = log_{(m\\ \\text{mod}\\ n)} (c\\ \\text{mod}\\ n) $$ 对于这种离散对数的问题，可以使用sage求解，这里使用sage脚本进行求解：\nimport libnum n = 2 ** 512 m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075 c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499 flag = libnum.n2s(int(discrete_log(c,mod(m,n)))) print(flag) 非常简单的脚本，运行一下flag就有了：\nflag{5f95ca93-1594-762d-ed0b-a9139692cb4a} 0x6 [BJDCTF2020]Polybius # 看题目应该是Polybius密码，一种古典密码。看一下题目：\n密文：ouauuuoooeeaaiaeauieuooeeiea hint：VGhlIGxlbmd0aCBvZiB0aGlzIHBsYWludGV4dDogMTQ= flag:解出明文后，请加上BJD{} 波利比奥斯方阵密码，也叫ADFGX密码，一种棋盘密码，解密方式也相对比较简单。因为是一种棋盘密码，也就是根据方阵进行加密。\n对hint进行解密，得到：\nThe length of this plaintext: 14 密文长度是14x2位，更是说明了这是Polybius方阵密码。不过观察密文内容，发现是aeiou五个字母的重复出现而不是adfgx五个字母的反复出现，因此暂时找不到良好的对应关系，只得进行爆破求解，然后从解出的结果中找到flag。借网上的一个脚本稍微修改一下：\nimport itertools ciper = \u0026#39;ouauuuoooeeaaiaeauieuooeeiea\u0026#39; head = \u0026#39;aeoiu\u0026#39; headlist = [] num_headlist = [] x = itertools.permutations(head,5) for i in x: temp = \u0026#34;\u0026#34;.join(i) headlist.append(temp) for i in headlist: temp = \u0026#39;\u0026#39; for j in ciper: temp += str(i.index(j) + 1) num_headlist.append(temp) for i in num_headlist: temp = \u0026#39;\u0026#39; for j in range(0,len(i),2): xx = (int(i[j]) - 1)*5 + int(i[j+1]) + 96 if xx\u0026gt;ord(\u0026#39;i\u0026#39;): xx+=1 temp += chr(xx) if \u0026#39;flag\u0026#39; in temp: print temp 运行一下脚本，flag就有了：\nflagispolybius flagkxoplubkyx 0x7 [WUSTCTF2020]情书 # 看样子好像挺有意思的样子，看看题目吧：\nPremise: Enumerate the alphabet by 0、1、2、..... 、25 Using the RSA system Encryption:0156 0821 1616 0041 0140 2130 1616 0793 Public Key:2537 and 13 Private Key:2537 and 937 flag: wctf2020{Decryption} 看样子是一个小rsa题目，题目公钥和私钥都告知了，密文也有，应该是比较简单的题目。\n题目文件第一行提示了是得到的数字是根据字母表的顺序排列，0-25的样子，应该是每段加密的文段进行解密后都是一个数字，数字映射到字母表中就是相应的密码了。\n写个简单的脚本就可以处理了：\nimport string letters = string.lowercase c = \u0026#34;0156 0821 1616 0041 0140 2130 1616 0793\u0026#34; c_list = c.split(\u0026#34; \u0026#34;) N = 2537 e = 13 d = 937 m = \u0026#34;\u0026#34;.join(letters[pow(int(i),d,N)] for i in c_list) print m 运行脚本，即可得到flag：\niloveyou 0x8 [BJDCTF2020]编码与调制 # 看题目，这道题目应该是通信的题目。\n看看题目内容吧：\n两个文件，一个题目求解内容和一个提示图片\n题目内容：\n密文：2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6 提示图片：\n![I\u0026rsquo;m hint!!!](/images/BUUCTF-CRYPTO-6_writeup/I\u0026rsquo;m hint!!!.png)\n大致看一下图片，应该是曼彻斯特编码进行编码的调制。但是题目有两种可能的结果，一种是曼彻斯特编码，另一种就是差分曼彻斯特编码。由于不知道这道题目要求求解的那种编码，只能分别解码。\n写个脚本进行测试：\nimport libnum c = 0x2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6 c_bin = bin(c)[2:] m = \u0026#34;\u0026#34; for i in range(0,len(c_bin),2): test = c_bin[i:i+2] if test == \u0026#34;10\u0026#34;: m += \u0026#34;1\u0026#34; elif test == \u0026#34;01\u0026#34;: m += \u0026#34;0\u0026#34; print libnum.n2s(int(m,2)) Dif_m = \u0026#34;1\u0026#34; for i in range(1,len(c_bin),3): test = c_bin[i:i+2] if (test == \u0026#34;00\u0026#34; or test == \u0026#34;11\u0026#34;): Dif_m += \u0026#34;1\u0026#34; elif (test == \u0026#34;10\u0026#34; or test == \u0026#34;01\u0026#34;): Dif_m += \u0026#34;0\u0026#34; print libnum.n2s(int(Dif_m,2)) 运行发现，编码是Manchester编码，而不是差分Manchester编码。得到flag：\nBJD{DifManchestercode} 0x9 [ACTF新生赛]crypto-classic1 # 看样子是古典密码学题目没错了，看看都有些什么东西吧：\n两个文件，一个提示文件，一个加密的压缩文件。提示文件应该是用来解密压缩文件的。\nhint.txt\n哇，这里有压缩包的密码哦，于是我低下了头，看向了我的双手，试图从中找到某些规律 xdfv ujko98 edft54 xdfv pok,.; wsdr43 仔细观察一下，发现是非常有规律的，就是键盘密码，观察一下键盘就可以得到结果：\ncircle 这应该就是压缩文件的密码，进行解密得到：\nSRLU{OWSI_S_RDPKHARSA_NXYTFTJT} 由于压缩文件名是vigenere.zip, 应该是维吉尼亚密码，根据题目的特点进行观察发现SRLU是对应着ACTF，密钥应该是就是sp。求解得到flag：\nACTF{WHAT_A_CLASSICAL_VIGENERE} buu的题目好像是错误，buu给到的 SRLU{LZPL_S_UASHKXUPD_NXYTFTJT}\n正确的的数据是 SRLU{OWSI_S_RDPKHARSA_NXYTFTJT}\n0xA [UTCTF2020]basic-crypto # 看样子应该是一道古典密码学的题目，应该是层层套娃的。\n看看题目：\n01010101 01101000 00101101 01101111 01101000 00101100 00100000 01101100 01101111 01101111 01101011 01110011 00100000 01101100 01101001 01101011 01100101 00100000 01110111 01100101 00100000 01101000 01100001 01110110 01100101 00100000 01100001 01101110 01101111 01110100 01101000 01100101 01110010 00100000 01100010 01101100 01101111 01100011 01101011 00100000 01101111 01100110 00100000 01110100 01100101 01111000 01110100 00101100 00100000 01110111 01101001 01110100 01101000 00100000 01110011 01101111 01101101 01100101 00100000 01110011 01101111 01110010 01110100 00100000 01101111 01100110 00100000 01110011 01110000 01100101 01100011 01101001 01100001 01101100 00100000 01100101 01101110 01100011 01101111 01100100 01101001 01101110 01100111 00101110 00100000 01000011 01100001 01101110 00100000 01111001 01101111 01110101 00100000 01100110 01101001 01100111 01110101 01110010 01100101 00100000 01101111 01110101 01110100 00100000 01110111 01101000 01100001 01110100 00100000 01110100 01101000 01101001 01110011 00100000 01100101 01101110 01100011 01101111 01100100 01101001 01101110 01100111 00100000 01101001 01110011 00111111 00100000 00101000 01101000 01101001 01101110 01110100 00111010 00100000 01101001 01100110 00100000 01111001 01101111 01110101 00100000 01101100 01101111 01101111 01101011 00100000 01100011 01100001 01110010 01100101 01100110 01110101 01101100 01101100 01111001 00101100 00100000 01111001 01101111 01110101 00100111 01101100 01101100 00100000 01101110 01101111 01110100 01101001 01100011 01100101 00100000 01110100 01101000 01100001 01110100 00100000 01110100 01101000 01100101 01110010 01100101 00100000 01101111 01101110 01101100 01111001 00100000 01100011 01101000 01100001 01110010 01100001 01100011 01110100 01100101 01110010 01110011 00100000 01110000 01110010 01100101 01110011 01100101 01101110 01110100 00100000 01100001 01110010 01100101 00100000 01000001 00101101 01011010 00101100 00100000 01100001 00101101 01111010 00101100 00100000 00110000 00101101 00111001 00101100 00100000 01100001 01101110 01100100 00100000 01110011 01101111 01101101 01100101 01110100 01101001 01101101 01100101 01110011 00100000 00101111 00100000 01100001 01101110 01100100 00100000 00101011 00101110 00100000 01010011 01100101 01100101 00100000 01101001 01100110 00100000 01111001 01101111 01110101 00100000 01100011 01100001 01101110 00100000 01100110 01101001 01101110 01100100 00100000 01100001 01101110 00100000 01100101 01101110 01100011 01101111 01100100 01101001 01101110 01100111 00100000 01110100 01101000 01100001 01110100 00100000 01101100 01101111 01101111 01101011 01110011 00100000 01101100 01101001 01101011 01100101 00100000 01110100 01101000 01101001 01110011 00100000 01101111 01101110 01100101 00101110 00101001 00001010 01010100 01101101 01010110 00110011 01001001 01000111 01001110 01101111 01011001 01010111 01111000 01110011 01011010 01010111 00110101 01101110 01011010 01010011 01000101 01100111 01010001 00110010 01000110 01110101 01001001 01001000 01101100 01110110 01100100 01010011 01000010 01101101 01100001 01010111 01100100 00110001 01100011 01101101 01010101 01100111 01100010 00110011 01010110 00110000 01001001 01001000 01100100 01101111 01011001 01011000 01010001 01101110 01100011 01111001 01000010 01101110 01100010 00110010 01101100 01110101 01011010 01111001 01000010 01110110 01100010 01101001 01000010 01101111 01011010 01011000 01001010 01101100 01010000 01111001 01000010 01001010 01100100 01000011 01000010 01110011 01100010 00110010 00111001 01110010 01100011 01111001 01000010 01110011 01100001 01010111 01110100 01101100 01001001 01001000 01010010 01101111 01011010 01010011 01000010 01110011 01011010 01011000 01010010 00110000 01011010 01011000 01001010 01111010 01001001 01000111 01000110 01111001 01011010 01010011 01000010 01111010 01100001 01000111 01101100 01101101 01100100 01000111 01010110 01101011 01001001 01000111 01001010 00110101 01001001 01001000 01001110 01110110 01100010 01010111 01010101 01100111 01011001 00110010 00111001 01110101 01100011 00110011 01010010 01101000 01100010 01101110 01010001 01110101 01001001 01000011 01101000 01101111 01100001 01010111 00110101 00110000 01001111 01101001 01000010 00110101 01100010 00110011 01010101 01100111 01100010 01010111 01101100 01101110 01100001 01001000 01010001 01100111 01100100 00110010 01000110 01110101 01100100 01000011 01000010 00110000 01100010 01111001 01000010 01111010 01100100 01000111 01000110 01111001 01100100 01000011 01000010 01110011 01100010 00110010 00111001 01110010 01100001 01010111 00110101 01101110 01001001 01001000 01010110 01110111 01001001 01000110 01001010 01110110 01100010 01010111 01000110 01110101 01001001 01001000 01000010 01101100 01100010 00110011 01000010 01110011 01011010 01010011 01101011 01110101 01000011 01101101 01110100 00110010 01011001 01101110 01001110 01111000 01100011 01101101 01010001 01110011 01001001 01000111 01101100 00110101 01011010 01010011 01100100 01101001 01100010 01111001 01000010 01110010 01100100 01101110 01100100 00110101 01011001 00110010 01010001 01100111 01011010 01001000 01001010 01110110 01011001 01101101 00111000 01101000 01001001 01000110 01101000 00110101 01011010 01111001 01000010 01110111 01100101 01010111 01001001 01100111 01011010 01001000 01001010 01110110 01001001 01001000 01000010 01111010 01100101 01000111 01110100 00110010 01001001 01000011 01101000 01110010 01100101 01000111 00110100 01100111 01100100 00110010 01110100 01110000 01100010 01000111 00111000 01100111 01011010 01001000 01001010 01110110 01001001 01001000 01001010 01110010 01011001 01101101 00110101 01110110 01011001 00110010 01010001 01110101 01001100 01101001 00110100 01110000 01001001 01001000 01110000 01110010 01011001 01101101 01010001 00110110 01001001 01000111 01110011 01100111 01011001 00110010 01010110 01110011 01011001 00110010 01010010 01111010 01011010 01000111 01010110 01101011 01100011 00110011 01101100 00110100 01001001 01000111 00110001 01111010 01100101 01101110 01001010 01110110 01011001 01101001 00110100 01100111 01010101 00110011 01100111 01100111 01011010 01001000 01001010 01110110 01001001 01001000 01000010 00110101 01100100 01101110 01011010 00110101 01011010 00110011 01001110 00110100 01100011 01010011 01000010 01101011 01100010 00110010 01101000 01101011 01001100 01000011 01000010 01010100 01001010 00110010 01011010 01110110 01001001 01000111 01010010 01110010 01100100 01010111 00111001 00110100 01001001 01001000 01100100 01110000 01001001 01001000 01100100 01110110 01011001 00110010 01001110 01110010 01100011 01010111 00111000 01100111 01100001 00110011 01101000 01110101 01001001 01000111 01001010 01110110 01100101 01101110 01011010 01110010 01100010 01010111 00111001 01110101 01001001 01000111 00111001 01101101 01100010 00110010 01001010 01110000 01001001 01000111 01110100 00110010 01100101 01101110 01001010 01110010 01100010 01000111 00111001 01101011 01100011 00110010 00110000 01100111 01100010 01011000 01001010 01110010 01011001 01101101 01110100 01110100 01011010 01000111 00111001 01101001 01001001 01000111 01100100 01111010 01011010 01001000 01001001 01100111 01100001 01111001 01000010 01110100 01100101 01010111 01001010 01101001 01100010 00110010 01001110 00110110 01100101 01011000 01101000 01110101 01100010 00110011 01101000 01110100 01100010 01111001 01000010 01101011 01100101 01010011 01000010 01110010 01001001 01000111 00110101 01111010 01100011 01001000 01000010 01110110 01011001 01101101 00111001 00110100 01011010 01000011 01000010 01110100 01100011 01101101 01110100 01101001 01100001 00110010 00110001 01101011 01100010 00110010 01001001 01100111 01001100 01010011 01000010 00110001 01100101 01001000 01101100 01101110 01100101 01000011 01000010 01110010 01011001 01111001 01000010 01110010 01001001 01000111 01001110 01101100 01100010 01000111 01001110 01101011 01100011 00110010 01010010 01101100 01011010 01001000 01001110 00110101 01100101 01000011 01000010 01110100 01100011 00110011 01110000 01111001 01100010 00110010 01001001 01110101 01001001 01000101 00110001 01110010 01100101 01000011 01000010 01110000 01100101 01010111 01010101 01100111 01100011 01001000 01001110 00110100 01100010 01101001 01000010 01101011 01100011 01101101 00111000 01100111 01100011 01001000 01001110 00110100 01100001 00110011 01011001 01100111 01100011 01001000 01011010 01110010 01100011 01010100 00111000 01100111 01100011 01101110 01001110 00110100 01011010 01000100 01101111 01100111 01010010 00110010 00111000 01100111 01100100 01011000 01101000 00110101 01011010 01111001 01000010 01101011 01100011 01101101 01110100 01101011 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01110111 01100100 01101101 01110100 01111000 01001001 01001000 01001110 01101010 01001001 01001000 01000110 00110101 01100011 00110011 01101000 01111000 01001001 01000111 01010010 00110101 01001001 01000111 01111000 01110110 01001001 01001000 01101100 01110111 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01110111 01100101 01010111 01001010 00110011 01100001 00110010 01010001 01100111 01011010 01010111 01010010 01110111 01100100 01101101 01110100 01111000 01100101 01111001 00110100 01110101 01001100 01101110 00110000 01100111 01001100 01010011 01000010 01101110 01100011 01101110 01001110 01110100 01100011 01101001 01000010 00110011 01100010 00110010 01110100 00110100 01011001 01111001 01000010 01101011 01100011 01101101 01110100 01101011 01001001 01001000 01001110 01110111 01001001 01000111 01101100 00110101 01011010 01010011 01000010 01101010 01100010 00110010 00111000 01100111 01011010 01001000 01001010 01110010 01011010 01000011 01000010 00110110 01100001 00110010 01010010 01101011 01100010 00110010 01001010 00110100 01001100 01000011 01000010 01110000 01100101 01010111 01010101 01100111 01100100 01011000 01101000 00110101 01011010 01111001 01000010 01101110 01100011 01101101 01110100 01101011 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01110100 01100101 01010111 01001010 01101001 01100010 00110010 01001110 00110110 01100101 01011000 01101000 01110101 01100010 00110011 01101000 01110100 01100010 00110010 01001101 01100111 01100011 01001000 01101100 01101001 01001001 01000111 01010101 01110011 01001001 01000111 01010001 01110011 01001001 01001000 01000001 01110011 01001001 01001000 01011001 01100111 01100001 01111001 01110111 01100111 01100001 00110011 01101000 01110101 01001001 01001000 01000101 01100111 01100001 00110010 01001010 01110110 01001100 01101001 01000010 01001010 01100101 01010111 01010101 01100111 01100010 01010111 01110100 00110100 01001001 01001000 01110000 01101001 01100101 01010111 01111000 01110010 01100010 01001000 01011010 01110000 01001001 01000111 01100100 00110101 01011001 01101110 01010101 01100111 01100101 01010111 01010110 01101011 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01101001 01100010 00110011 01100100 01110010 01100011 00110011 01101000 01111010 01100101 01001000 01000101 01100111 01100010 01011000 01001010 01110010 01011001 01101101 01110100 01110100 01011010 01000111 00111001 01101001 01011001 01111001 01000010 01110011 01100001 01010011 01000010 01101001 01100010 00110011 01110000 00110010 01100001 00110010 00110001 01111010 01100101 01001000 01000101 01100111 01011010 01001000 01001010 01110110 01100100 01111001 01000010 01110010 01100101 01000111 00110100 01100111 01100011 00110011 01101000 01110111 01100010 00110010 01001010 01101001 01100011 00110011 01101000 01111000 01001001 01000111 00110001 00110101 01100100 00110011 01100100 00110101 01100101 01000011 01000010 01101110 01100101 01010111 01001010 01110101 01011001 01111001 01000010 01111010 01100101 01000011 01000010 01101011 01100011 01101101 00111000 01100111 01010100 00110011 01101000 01111000 01100100 01101110 01001110 01101010 01100011 01101001 01000010 00110010 01100001 00110011 01101000 01111000 01011010 01010111 01110100 01111000 01100010 01111001 00110100 01100111 01010011 00110011 01101000 00110101 01011010 01001000 01001010 01110110 01011001 01101001 01000010 01111000 01011001 01101101 00111001 01110010 01011010 01000011 01000010 00110011 01100010 00110010 01010010 01111001 01100101 01010111 00110100 01100111 01100011 00110010 01001101 01100111 01011010 01001000 01101011 01100111 01011010 01010111 01001110 01110110 01001001 01001000 01000010 01101001 01100010 00110010 01000110 01101100 01100010 00110011 01101000 01110100 01100001 01010011 01000010 01110010 01100101 01000111 01110100 00110010 01100001 01010111 01001110 01111010 01011001 01111010 01101111 01100111 01011010 00110010 00111000 01100111 01100100 01011000 01101000 00110101 01011010 01111001 01000010 01101011 01100011 01101101 01110100 01101011 01001001 01000011 01100100 01110110 01001010 01111001 01000010 01101010 01100011 01101110 01101100 01101110 01011001 01111001 01000010 01101100 01100101 01101001 01000010 00110011 01100101 01010111 01001110 01101011 01001001 01001000 01101100 01110111 01011010 01000111 00111001 00110100 01001001 01001000 01001110 00110100 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01110010 01100100 01101110 01110000 01111001 01100001 00110010 01111000 01110110 01011010 01000011 01110111 01100111 01011001 00110011 01101011 01100111 01011010 01001000 01001010 01110010 01011010 01000011 01100100 01101010 01001001 01001000 01110000 01101001 01100101 01010111 01111000 01110010 01100010 01001000 01011010 01110000 01001001 01000111 01010010 01111001 01100010 01111001 01000010 00110011 01100101 01010111 01001110 01101011 01001001 01000111 00110001 00110101 01100100 00110011 01100100 00110101 01100101 01000011 01000010 01110100 01100011 01101101 01110100 01101001 01100001 00110010 00110001 01101011 01100010 00110010 01001001 01100111 01100011 00110011 01100111 01100111 01011010 01001000 01001010 01110110 01001001 01000111 01010010 01110110 01100001 01000111 01010001 01110011 01001001 01001000 01000010 00110101 01100100 01101110 01011010 00110101 01011010 00110010 00111001 01110101 01001001 01000111 01111000 01110000 01001001 01000011 01100100 01101011 01001010 01111001 01110111 01100111 01100001 00110011 01101000 01110101 01001001 01000111 01001110 00110101 01001001 01001000 01101100 00110100 01001100 01101001 01000010 01011010 01100101 01000111 00110001 01110110 01001001 01000111 01101100 00110101 01011010 01010011 01000010 00110001 01100101 01001000 01101100 01101110 01001001 01000111 01110011 01100111 01100011 01000111 00111001 01101110 01001001 01000111 00110001 01111001 01100001 00110010 01001010 01110010 01100010 01010111 01010010 01110110 01011001 01101101 01001101 01110011 01001001 01000111 01101100 00110101 01011010 01010011 01000010 01110100 01100001 00110011 01100111 01100111 01100011 00110011 01101000 01110111 01100010 00110010 01001001 01100111 01011010 01001000 01001010 01110110 01001001 01000111 01001010 01110110 01011001 00110010 01010001 01100111 01100101 01011000 01000001 01100111 01011010 01001000 01001010 01110110 01001001 01000111 01100100 00110101 01011001 01101101 00110101 01101010 01001001 01000111 01111000 01110010 01011001 00110010 00111001 01110101 01001001 01001000 01101100 00110100 01001001 01000111 00110001 00110101 01100100 00110011 01100100 00110101 01100101 01000011 01000010 01101110 01100101 01010111 01001010 01110101 01011001 01111001 01000010 01101011 01100011 01101101 01110100 01101011 01001001 01000111 01001110 01111001 01100101 01010111 01100011 01100111 01011010 01011000 01101111 01100111 01100011 00110011 01100111 01100111 01011010 01001000 01001010 01110110 01001001 01000101 00111001 00110100 01100011 01011000 01011010 01111010 01011001 00110011 01001001 01100111 01100100 01101101 01110100 00110100 01100011 01010111 01010110 01110010 01100011 01010111 00111000 01110101 01000011 01101110 01001010 01101110 01100001 01000111 00110101 00110100 01100011 00110010 01010010 01101101 01100101 01011000 01001110 01101011 01100100 01000111 01100100 01101111 01100100 01010011 01000101 01100111 01100011 01010111 01100100 01101101 01001001 01000111 01101100 01111010 01011001 01010111 01110011 01100111 01011001 00110011 01010010 01101111 01100100 01001000 01010110 01110000 01100001 00110010 01010101 01100111 01011010 01000111 01101100 01110010 01001001 01001000 01110000 01110010 01100010 01101110 01010010 01101111 01100001 01000111 01110100 00110100 01001001 01001000 01001010 00110100 01100011 01010111 01111000 01101011 01011010 00110010 00110101 00110100 01100011 00110010 01111000 01110000 01100011 01010011 01000010 01111001 01100001 01011000 01001110 00110101 01100101 01010111 01110100 01101111 01100010 01101101 01110011 01110101 01001001 01000111 01101100 01110010 01100101 01000111 01110011 01100111 01100100 01001000 01010101 01100111 01100011 01111001 01000010 01101010 01100101 01011000 01001110 01110101 01001001 01000111 01001110 01101110 01100101 01000011 01000010 01111010 01100101 01011000 01101011 01100111 01100011 01010111 01100100 01101101 01100101 01000011 01000010 01110000 01100011 00110011 01101000 01101100 01001001 01000111 01110100 01101010 01011001 00110010 01100100 00110100 01011010 01001000 01010101 00110110 01001001 01000111 01011010 01101011 01011001 00110011 01101100 01111010 01100010 01101110 01110100 01101111 01001101 01001000 01011010 01100110 01011010 01000111 01101011 00110000 01011010 01001000 01010110 01100110 01100100 01101101 01101011 00110000 01011010 01000110 00111001 00110000 01011000 00110011 01001001 00110000 01100101 01011000 01101100 01100110 01100011 01101110 01101000 01111000 01100010 01000111 01010001 01110111 01100110 01010011 00110100 01100111 01100011 01010111 01100100 01101101 01001001 01001000 01011010 00110000 01100101 01011000 01101011 01100111 01011001 00110011 01010010 01101111 01011010 01010011 01000010 01101011 01100001 01011000 01001110 01101011 01001001 01001000 01001101 01100111 01100101 01010111 01100100 01101011 01001001 01000111 01100100 01101010 01001001 01001000 01001010 00110100 01100011 01010111 01111000 01101011 01011010 00110010 00110101 00110100 01100011 00110010 01111000 01110000 01100011 01010011 01000010 00110000 01100100 01010011 01000010 01110111 01011010 01101110 01010110 01101011 01001001 01001000 01110000 01101101 01100100 01001000 01101100 01101100 01100100 01000111 01101000 01110101 01001001 01000111 01100100 01101010 01011001 01111001 01000010 01101011 01100001 01011000 01010010 00110001 01001001 01001000 01010110 01101110 01100101 01000111 01010001 01100111 01011010 00110010 01001101 01100111 01100101 01101110 01001110 00110001 01100100 01001000 01001001 01100111 01011001 01101101 01101000 01101110 01100100 01101110 01101100 01110010 01011010 01010111 00110101 01110010 01001100 01000011 01000010 01111010 01100001 01000111 01010101 01100111 01100100 01000111 01010001 01100111 01100101 01000111 01110100 01111010 01100101 01011000 01101100 01111000 01001001 01001000 01010010 00110001 01001001 01000111 01101000 01101110 01011010 01000011 01000010 00110001 01011010 01111001 01000010 00110110 01100011 00110010 01010101 01100111 01100011 00110010 01001110 01101011 01100001 00110011 01100111 01100111 01100011 00110011 01101100 00110101 01001100 01101001 01000010 01110000 01011010 00110010 01111000 01110010 01001001 01001000 01000110 01101110 01011010 01101001 01000010 01110010 01100001 01001000 01000010 01101110 01100011 01010111 01110100 01101100 01001001 01000111 01010010 01110000 01100001 01111001 01000010 01111001 01100001 01011000 01001110 00110101 01100101 01010111 01110100 01101111 01100010 01101101 01110011 01101000 一堆二进制码，应该需要进行转码，将二进制码转成字符，可以使用个非常简单的脚本处理一下：\nimport libnum c = \u0026#34;01010101 01101000 00101101 01101111 01101000 00101100 00100000 01101100 01101111 01101111 01101011 01110011 00100000 01101100 01101001 01101011 01100101 00100000 01110111 01100101 00100000 01101000 01100001 01110110 01100101 00100000 01100001 01101110 01101111 01110100 01101000 01100101 01110010 00100000 01100010 01101100 01101111 01100011 01101011 00100000 01101111 01100110 00100000 01110100 01100101 01111000 01110100 00101100 00100000 01110111 01101001 01110100 01101000 00100000 01110011 01101111 01101101 01100101 00100000 01110011 01101111 01110010 01110100 00100000 01101111 01100110 00100000 01110011 01110000 01100101 01100011 01101001 01100001 01101100 00100000 01100101 01101110 01100011 01101111 01100100 01101001 01101110 01100111 00101110 00100000 01000011 01100001 01101110 00100000 01111001 01101111 01110101 00100000 01100110 01101001 01100111 01110101 01110010 01100101 00100000 01101111 01110101 01110100 00100000 01110111 01101000 01100001 01110100 00100000 01110100 01101000 01101001 01110011 00100000 01100101 01101110 01100011 01101111 01100100 01101001 01101110 01100111 00100000 01101001 01110011 00111111 00100000 00101000 01101000 01101001 01101110 01110100 00111010 00100000 01101001 01100110 00100000 01111001 01101111 01110101 00100000 01101100 01101111 01101111 01101011 00100000 01100011 01100001 01110010 01100101 01100110 01110101 01101100 01101100 01111001 00101100 00100000 01111001 01101111 01110101 00100111 01101100 01101100 00100000 01101110 01101111 01110100 01101001 01100011 01100101 00100000 01110100 01101000 01100001 01110100 00100000 01110100 01101000 01100101 01110010 01100101 00100000 01101111 01101110 01101100 01111001 00100000 01100011 01101000 01100001 01110010 01100001 01100011 01110100 01100101 01110010 01110011 00100000 01110000 01110010 01100101 01110011 01100101 01101110 01110100 00100000 01100001 01110010 01100101 00100000 01000001 00101101 01011010 00101100 00100000 01100001 00101101 01111010 00101100 00100000 00110000 00101101 00111001 00101100 00100000 01100001 01101110 01100100 00100000 01110011 01101111 01101101 01100101 01110100 01101001 01101101 01100101 01110011 00100000 00101111 00100000 01100001 01101110 01100100 00100000 00101011 00101110 00100000 01010011 01100101 01100101 00100000 01101001 01100110 00100000 01111001 01101111 01110101 00100000 01100011 01100001 01101110 00100000 01100110 01101001 01101110 01100100 00100000 01100001 01101110 00100000 01100101 01101110 01100011 01101111 01100100 01101001 01101110 01100111 00100000 01110100 01101000 01100001 01110100 00100000 01101100 01101111 01101111 01101011 01110011 00100000 01101100 01101001 01101011 01100101 00100000 01110100 01101000 01101001 01110011 00100000 01101111 01101110 01100101 00101110 00101001 00001010 01010100 01101101 01010110 00110011 01001001 01000111 01001110 01101111 01011001 01010111 01111000 01110011 01011010 01010111 00110101 01101110 01011010 01010011 01000101 01100111 01010001 00110010 01000110 01110101 01001001 01001000 01101100 01110110 01100100 01010011 01000010 01101101 01100001 01010111 01100100 00110001 01100011 01101101 01010101 01100111 01100010 00110011 01010110 00110000 01001001 01001000 01100100 01101111 01011001 01011000 01010001 01101110 01100011 01111001 01000010 01101110 01100010 00110010 01101100 01110101 01011010 01111001 01000010 01110110 01100010 01101001 01000010 01101111 01011010 01011000 01001010 01101100 01010000 01111001 01000010 01001010 01100100 01000011 01000010 01110011 01100010 00110010 00111001 01110010 01100011 01111001 01000010 01110011 01100001 01010111 01110100 01101100 01001001 01001000 01010010 01101111 01011010 01010011 01000010 01110011 01011010 01011000 01010010 00110000 01011010 01011000 01001010 01111010 01001001 01000111 01000110 01111001 01011010 01010011 01000010 01111010 01100001 01000111 01101100 01101101 01100100 01000111 01010110 01101011 01001001 01000111 01001010 00110101 01001001 01001000 01001110 01110110 01100010 01010111 01010101 01100111 01011001 00110010 00111001 01110101 01100011 00110011 01010010 01101000 01100010 01101110 01010001 01110101 01001001 01000011 01101000 01101111 01100001 01010111 00110101 00110000 01001111 01101001 01000010 00110101 01100010 00110011 01010101 01100111 01100010 01010111 01101100 01101110 01100001 01001000 01010001 01100111 01100100 00110010 01000110 01110101 01100100 01000011 01000010 00110000 01100010 01111001 01000010 01111010 01100100 01000111 01000110 01111001 01100100 01000011 01000010 01110011 01100010 00110010 00111001 01110010 01100001 01010111 00110101 01101110 01001001 01001000 01010110 01110111 01001001 01000110 01001010 01110110 01100010 01010111 01000110 01110101 01001001 01001000 01000010 01101100 01100010 00110011 01000010 01110011 01011010 01010011 01101011 01110101 01000011 01101101 01110100 00110010 01011001 01101110 01001110 01111000 01100011 01101101 01010001 01110011 01001001 01000111 01101100 00110101 01011010 01010011 01100100 01101001 01100010 01111001 01000010 01110010 01100100 01101110 01100100 00110101 01011001 00110010 01010001 01100111 01011010 01001000 01001010 01110110 01011001 01101101 00111000 01101000 01001001 01000110 01101000 00110101 01011010 01111001 01000010 01110111 01100101 01010111 01001001 01100111 01011010 01001000 01001010 01110110 01001001 01001000 01000010 01111010 01100101 01000111 01110100 00110010 01001001 01000011 01101000 01110010 01100101 01000111 00110100 01100111 01100100 00110010 01110100 01110000 01100010 01000111 00111000 01100111 01011010 01001000 01001010 01110110 01001001 01001000 01001010 01110010 01011001 01101101 00110101 01110110 01011001 00110010 01010001 01110101 01001100 01101001 00110100 01110000 01001001 01001000 01110000 01110010 01011001 01101101 01010001 00110110 01001001 01000111 01110011 01100111 01011001 00110010 01010110 01110011 01011001 00110010 01010010 01111010 01011010 01000111 01010110 01101011 01100011 00110011 01101100 00110100 01001001 01000111 00110001 01111010 01100101 01101110 01001010 01110110 01011001 01101001 00110100 01100111 01010101 00110011 01100111 01100111 01011010 01001000 01001010 01110110 01001001 01001000 01000010 00110101 01100100 01101110 01011010 00110101 01011010 00110011 01001110 00110100 01100011 01010011 01000010 01101011 01100010 00110010 01101000 01101011 01001100 01000011 01000010 01010100 01001010 00110010 01011010 01110110 01001001 01000111 01010010 01110010 01100100 01010111 00111001 00110100 01001001 01001000 01100100 01110000 01001001 01001000 01100100 01110110 01011001 00110010 01001110 01110010 01100011 01010111 00111000 01100111 01100001 00110011 01101000 01110101 01001001 01000111 01001010 01110110 01100101 01101110 01011010 01110010 01100010 01010111 00111001 01110101 01001001 01000111 00111001 01101101 01100010 00110010 01001010 01110000 01001001 01000111 01110100 00110010 01100101 01101110 01001010 01110010 01100010 01000111 00111001 01101011 01100011 00110010 00110000 01100111 01100010 01011000 01001010 01110010 01011001 01101101 01110100 01110100 01011010 01000111 00111001 01101001 01001001 01000111 01100100 01111010 01011010 01001000 01001001 01100111 01100001 01111001 01000010 01110100 01100101 01010111 01001010 01101001 01100010 00110010 01001110 00110110 01100101 01011000 01101000 01110101 01100010 00110011 01101000 01110100 01100010 01111001 01000010 01101011 01100101 01010011 01000010 01110010 01001001 01000111 00110101 01111010 01100011 01001000 01000010 01110110 01011001 01101101 00111001 00110100 01011010 01000011 01000010 01110100 01100011 01101101 01110100 01101001 01100001 00110010 00110001 01101011 01100010 00110010 01001001 01100111 01001100 01010011 01000010 00110001 01100101 01001000 01101100 01101110 01100101 01000011 01000010 01110010 01011001 01111001 01000010 01110010 01001001 01000111 01001110 01101100 01100010 01000111 01001110 01101011 01100011 00110010 01010010 01101100 01011010 01001000 01001110 00110101 01100101 01000011 01000010 01110100 01100011 00110011 01110000 01111001 01100010 00110010 01001001 01110101 01001001 01000101 00110001 01110010 01100101 01000011 01000010 01110000 01100101 01010111 01010101 01100111 01100011 01001000 01001110 00110100 01100010 01101001 01000010 01101011 01100011 01101101 00111000 01100111 01100011 01001000 01001110 00110100 01100001 00110011 01011001 01100111 01100011 01001000 01011010 01110010 01100011 01010100 00111000 01100111 01100011 01101110 01001110 00110100 01011010 01000100 01101111 01100111 01010010 00110010 00111000 01100111 01100100 01011000 01101000 00110101 01011010 01111001 01000010 01101011 01100011 01101101 01110100 01101011 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01110111 01100100 01101101 01110100 01111000 01001001 01001000 01001110 01101010 01001001 01001000 01000110 00110101 01100011 00110011 01101000 01111000 01001001 01000111 01010010 00110101 01001001 01000111 01111000 01110110 01001001 01001000 01101100 01110111 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01110111 01100101 01010111 01001010 00110011 01100001 00110010 01010001 01100111 01011010 01010111 01010010 01110111 01100100 01101101 01110100 01111000 01100101 01111001 00110100 01110101 01001100 01101110 00110000 01100111 01001100 01010011 01000010 01101110 01100011 01101110 01001110 01110100 01100011 01101001 01000010 00110011 01100010 00110010 01110100 00110100 01011001 01111001 01000010 01101011 01100011 01101101 01110100 01101011 01001001 01001000 01001110 01110111 01001001 01000111 01101100 00110101 01011010 01010011 01000010 01101010 01100010 00110010 00111000 01100111 01011010 01001000 01001010 01110010 01011010 01000011 01000010 00110110 01100001 00110010 01010010 01101011 01100010 00110010 01001010 00110100 01001100 01000011 01000010 01110000 01100101 01010111 01010101 01100111 01100100 01011000 01101000 00110101 01011010 01111001 01000010 01101110 01100011 01101101 01110100 01101011 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01110100 01100101 01010111 01001010 01101001 01100010 00110010 01001110 00110110 01100101 01011000 01101000 01110101 01100010 00110011 01101000 01110100 01100010 00110010 01001101 01100111 01100011 01001000 01101100 01101001 01001001 01000111 01010101 01110011 01001001 01000111 01010001 01110011 01001001 01001000 01000001 01110011 01001001 01001000 01011001 01100111 01100001 01111001 01110111 01100111 01100001 00110011 01101000 01110101 01001001 01001000 01000101 01100111 01100001 00110010 01001010 01110110 01001100 01101001 01000010 01001010 01100101 01010111 01010101 01100111 01100010 01010111 01110100 00110100 01001001 01001000 01110000 01101001 01100101 01010111 01111000 01110010 01100010 01001000 01011010 01110000 01001001 01000111 01100100 00110101 01011001 01101110 01010101 01100111 01100101 01010111 01010110 01101011 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01101001 01100010 00110011 01100100 01110010 01100011 00110011 01101000 01111010 01100101 01001000 01000101 01100111 01100010 01011000 01001010 01110010 01011001 01101101 01110100 01110100 01011010 01000111 00111001 01101001 01011001 01111001 01000010 01110011 01100001 01010011 01000010 01101001 01100010 00110011 01110000 00110010 01100001 00110010 00110001 01111010 01100101 01001000 01000101 01100111 01011010 01001000 01001010 01110110 01100100 01111001 01000010 01110010 01100101 01000111 00110100 01100111 01100011 00110011 01101000 01110111 01100010 00110010 01001010 01101001 01100011 00110011 01101000 01111000 01001001 01000111 00110001 00110101 01100100 00110011 01100100 00110101 01100101 01000011 01000010 01101110 01100101 01010111 01001010 01110101 01011001 01111001 01000010 01111010 01100101 01000011 01000010 01101011 01100011 01101101 00111000 01100111 01010100 00110011 01101000 01111000 01100100 01101110 01001110 01101010 01100011 01101001 01000010 00110010 01100001 00110011 01101000 01111000 01011010 01010111 01110100 01111000 01100010 01111001 00110100 01100111 01010011 00110011 01101000 00110101 01011010 01001000 01001010 01110110 01011001 01101001 01000010 01111000 01011001 01101101 00111001 01110010 01011010 01000011 01000010 00110011 01100010 00110010 01010010 01111001 01100101 01010111 00110100 01100111 01100011 00110010 01001101 01100111 01011010 01001000 01101011 01100111 01011010 01010111 01001110 01110110 01001001 01001000 01000010 01101001 01100010 00110010 01000110 01101100 01100010 00110011 01101000 01110100 01100001 01010011 01000010 01110010 01100101 01000111 01110100 00110010 01100001 01010111 01001110 01111010 01011001 01111010 01101111 01100111 01011010 00110010 00111000 01100111 01100100 01011000 01101000 00110101 01011010 01111001 01000010 01101011 01100011 01101101 01110100 01101011 01001001 01000011 01100100 01110110 01001010 01111001 01000010 01101010 01100011 01101110 01101100 01101110 01011001 01111001 01000010 01101100 01100101 01101001 01000010 00110011 01100101 01010111 01001110 01101011 01001001 01001000 01101100 01110111 01011010 01000111 00111001 00110100 01001001 01001000 01001110 00110100 01001001 01000111 01010010 01111001 01100010 01111001 01000010 01110010 01100100 01101110 01110000 01111001 01100001 00110010 01111000 01110110 01011010 01000011 01110111 01100111 01011001 00110011 01101011 01100111 01011010 01001000 01001010 01110010 01011010 01000011 01100100 01101010 01001001 01001000 01110000 01101001 01100101 01010111 01111000 01110010 01100010 01001000 01011010 01110000 01001001 01000111 01010010 01111001 01100010 01111001 01000010 00110011 01100101 01010111 01001110 01101011 01001001 01000111 00110001 00110101 01100100 00110011 01100100 00110101 01100101 01000011 01000010 01110100 01100011 01101101 01110100 01101001 01100001 00110010 00110001 01101011 01100010 00110010 01001001 01100111 01100011 00110011 01100111 01100111 01011010 01001000 01001010 01110110 01001001 01000111 01010010 01110110 01100001 01000111 01010001 01110011 01001001 01001000 01000010 00110101 01100100 01101110 01011010 00110101 01011010 00110010 00111001 01110101 01001001 01000111 01111000 01110000 01001001 01000011 01100100 01101011 01001010 01111001 01110111 01100111 01100001 00110011 01101000 01110101 01001001 01000111 01001110 00110101 01001001 01001000 01101100 00110100 01001100 01101001 01000010 01011010 01100101 01000111 00110001 01110110 01001001 01000111 01101100 00110101 01011010 01010011 01000010 00110001 01100101 01001000 01101100 01101110 01001001 01000111 01110011 01100111 01100011 01000111 00111001 01101110 01001001 01000111 00110001 01111001 01100001 00110010 01001010 01110010 01100010 01010111 01010010 01110110 01011001 01101101 01001101 01110011 01001001 01000111 01101100 00110101 01011010 01010011 01000010 01110100 01100001 00110011 01100111 01100111 01100011 00110011 01101000 01110111 01100010 00110010 01001001 01100111 01011010 01001000 01001010 01110110 01001001 01000111 01001010 01110110 01011001 00110010 01010001 01100111 01100101 01011000 01000001 01100111 01011010 01001000 01001010 01110110 01001001 01000111 01100100 00110101 01011001 01101101 00110101 01101010 01001001 01000111 01111000 01110010 01011001 00110010 00111001 01110101 01001001 01001000 01101100 00110100 01001001 01000111 00110001 00110101 01100100 00110011 01100100 00110101 01100101 01000011 01000010 01101110 01100101 01010111 01001010 01110101 01011001 01111001 01000010 01101011 01100011 01101101 01110100 01101011 01001001 01000111 01001110 01111001 01100101 01010111 01100011 01100111 01011010 01011000 01101111 01100111 01100011 00110011 01100111 01100111 01011010 01001000 01001010 01110110 01001001 01000101 00111001 00110100 01100011 01011000 01011010 01111010 01011001 00110011 01001001 01100111 01100100 01101101 01110100 00110100 01100011 01010111 01010110 01110010 01100011 01010111 00111000 01110101 01000011 01101110 01001010 01101110 01100001 01000111 00110101 00110100 01100011 00110010 01010010 01101101 01100101 01011000 01001110 01101011 01100100 01000111 01100100 01101111 01100100 01010011 01000101 01100111 01100011 01010111 01100100 01101101 01001001 01000111 01101100 01111010 01011001 01010111 01110011 01100111 01011001 00110011 01010010 01101111 01100100 01001000 01010110 01110000 01100001 00110010 01010101 01100111 01011010 01000111 01101100 01110010 01001001 01001000 01110000 01110010 01100010 01101110 01010010 01101111 01100001 01000111 01110100 00110100 01001001 01001000 01001010 00110100 01100011 01010111 01111000 01101011 01011010 00110010 00110101 00110100 01100011 00110010 01111000 01110000 01100011 01010011 01000010 01111001 01100001 01011000 01001110 00110101 01100101 01010111 01110100 01101111 01100010 01101101 01110011 01110101 01001001 01000111 01101100 01110010 01100101 01000111 01110011 01100111 01100100 01001000 01010101 01100111 01100011 01111001 01000010 01101010 01100101 01011000 01001110 01110101 01001001 01000111 01001110 01101110 01100101 01000011 01000010 01111010 01100101 01011000 01101011 01100111 01100011 01010111 01100100 01101101 01100101 01000011 01000010 01110000 01100011 00110011 01101000 01101100 01001001 01000111 01110100 01101010 01011001 00110010 01100100 00110100 01011010 01001000 01010101 00110110 01001001 01000111 01011010 01101011 01011001 00110011 01101100 01111010 01100010 01101110 01110100 01101111 01001101 01001000 01011010 01100110 01011010 01000111 01101011 00110000 01011010 01001000 01010110 01100110 01100100 01101101 01101011 00110000 01011010 01000110 00111001 00110000 01011000 00110011 01001001 00110000 01100101 01011000 01101100 01100110 01100011 01101110 01101000 01111000 01100010 01000111 01010001 01110111 01100110 01010011 00110100 01100111 01100011 01010111 01100100 01101101 01001001 01001000 01011010 00110000 01100101 01011000 01101011 01100111 01011001 00110011 01010010 01101111 01011010 01010011 01000010 01101011 01100001 01011000 01001110 01101011 01001001 01001000 01001101 01100111 01100101 01010111 01100100 01101011 01001001 01000111 01100100 01101010 01001001 01001000 01001010 00110100 01100011 01010111 01111000 01101011 01011010 00110010 00110101 00110100 01100011 00110010 01111000 01110000 01100011 01010011 01000010 00110000 01100100 01010011 01000010 01110111 01011010 01101110 01010110 01101011 01001001 01001000 01110000 01101101 01100100 01001000 01101100 01101100 01100100 01000111 01101000 01110101 01001001 01000111 01100100 01101010 01011001 01111001 01000010 01101011 01100001 01011000 01010010 00110001 01001001 01001000 01010110 01101110 01100101 01000111 01010001 01100111 01011010 00110010 01001101 01100111 01100101 01101110 01001110 00110001 01100100 01001000 01001001 01100111 01011001 01101101 01101000 01101110 01100100 01101110 01101100 01110010 01011010 01010111 00110101 01110010 01001100 01000011 01000010 01111010 01100001 01000111 01010101 01100111 01100100 01000111 01010001 01100111 01100101 01000111 01110100 01111010 01100101 01011000 01101100 01111000 01001001 01001000 01010010 00110001 01001001 01000111 01101000 01101110 01011010 01000011 01000010 00110001 01011010 01111001 01000010 00110110 01100011 00110010 01010101 01100111 01100011 00110010 01001110 01101011 01100001 00110011 01100111 01100111 01100011 00110011 01101100 00110101 01001100 01101001 01000010 01110000 01011010 00110010 01111000 01110010 01001001 01001000 01000110 01101110 01011010 01101001 01000010 01110010 01100001 01001000 01000010 01101110 01100011 01010111 01110100 01101100 01001001 01000111 01010010 01110000 01100001 01111001 01000010 01111001 01100001 01011000 01001110 00110101 01100101 01010111 01110100 01101111 01100010 01101101 01110011 01101000\u0026#34; c_list = c.split(\u0026#34; \u0026#34;) c_str = \u0026#34;\u0026#34; for i in c_list: c_str += libnum.n2s(int(i,2)) print c_str 得到一个结果：\nUh-oh, looks like we have another block of text, with some sort of special encoding. Can you figure out what this encoding is? (hint: if you look carefully, you\u0026#39;ll notice that there only characters present are A-Z, a-z, 0-9, and sometimes / and +. See if you can find an encoding that looks like this one.) TmV3IGNoYWxsZW5nZSEgQ2FuIHlvdSBmaWd1cmUgb3V0IHdoYXQncyBnb2luZyBvbiBoZXJlPyBJdCBsb29rcyBsaWtlIHRoZSBsZXR0ZXJzIGFyZSBzaGlmdGVkIGJ5IHNvbWUgY29uc3RhbnQuIChoaW50OiB5b3UgbWlnaHQgd2FudCB0byBzdGFydCBsb29raW5nIHVwIFJvbWFuIHBlb3BsZSkuCmt2YnNxcmQsIGl5ZSdibyBrdnd5Y2QgZHJvYm8hIFh5ZyBweWIgZHJvIHBzeGt2IChreG4gd2tpbG8gZHJvIHJrYm5vY2QuLi4pIHprYmQ6IGsgY2VsY2RzZGVkc3l4IG1zenJvYi4gU3ggZHJvIHB5dnZ5Z3N4cSBkb2hkLCBTJ2ZvIGRrdW94IHdpIHdvY2NrcW8ga3huIGJvenZrbW9uIG9mb2JpIGt2enJrbG9kc20gbXJrYmttZG9iIGdzZHIgayBteWJib2N6eXhub3htbyBkeSBrIG5zcHBvYm94ZCBtcmtia21kb2IgLSB1eHlneCBrYyBrIGNlbGNkc2RlZHN5eCBtc3pyb2IuIE1reCBpeWUgcHN4biBkcm8gcHN4a3YgcHZrcT8gcnN4ZDogR28gdXh5ZyBkcmtkIGRybyBwdmtxIHNjIHF5c3hxIGR5IGxvIHlwIGRybyBweWJ3a2QgZWRwdmtxey4uLn0gLSBncnNtciB3b2t4YyBkcmtkIHNwIGl5ZSBjb28gZHJrZCB6a2Rkb2J4LCBpeWUgdXh5ZyBncmtkIGRybyBteWJib2N6eXhub3htb2MgcHliIGUsIGQsIHAsIHYgaywga3huIHEga2JvLiBJeWUgbWt4IHpieWxrbHZpIGd5YnUgeWVkIGRybyBib3drc3hzeHEgbXJrYmttZG9iYyBsaSBib3p2a21zeHEgZHJvdyBreG4gc3hwb2Jic3hxIG15d3d5eCBneWJuYyBzeCBkcm8gT3hxdnNjciB2a3hxZWtxby4gS3h5ZHJvYiBxYm9rZCB3b2RyeW4gc2MgZHkgZWNvIHBib2Flb3htaSBreGt2aWNzYzogZ28gdXh5ZyBkcmtkICdvJyBjcnlnYyBleiB3eWNkIHlwZG94IHN4IGRybyBrdnpya2xvZCwgY3kgZHJrZCdjIHpieWxrbHZpIGRybyB3eWNkIG15d3d5eCBtcmtia21kb2Igc3ggZHJvIGRvaGQsIHB5dnZ5Z29uIGxpICdkJywga3huIGN5IHl4LiBZeG1vIGl5ZSB1eHlnIGsgcG9nIG1ya2JrbWRvYmMsIGl5ZSBta3ggc3hwb2IgZHJvIGJvY2QgeXAgZHJvIGd5Ym5jIGxrY29uIHl4IG15d3d5eCBneWJuYyBkcmtkIGNyeWcgZXogc3ggZHJvIE94cXZzY3Igdmt4cWVrcW8uCnJnaG54c2RmeXNkdGdodSEgcWdmIGlzYWsgY3RodHVpa2UgZGlrIHprbnRoaGt4IHJ4cWxkZ254c2xpcSByaXN5eWtobmsuIGlreGsgdHUgcyBjeXNuIGNneCBzeXkgcWdmeCBpc3hlIGtjY2d4ZHU6IGZkY3lzbntoMHZfZGk0ZHVfdmk0ZF90X3I0eXlfcnhxbGQwfS4gcWdmIHZ0eXkgY3RoZSBkaXNkIHMgeWdkIGdjIHJ4cWxkZ254c2xpcSB0dSBwZnVkIHpmdHlldGhuIGdjYyBkaXR1IHVneGQgZ2MgenN1dHIgYmhndnlrZW5rLCBzaGUgdGQgeGtzeXlxIHR1IGhnZCB1ZyB6c2Ugc2Nka3ggc3l5LiBpZ2xrIHFnZiBraHBncWtlIGRpayByaXN5eWtobmsh 根据解码出来的结构，应该是base64编码，还需要进一步解码，接着这个脚本进行完善：\nimport base64 c_base64 = c_str[c_str.find(\u0026#34;Tm\u0026#34;):] print base64.b64decode(c_base64) 看看输出结果：\nNew challenge! Can you figure out what\u0026#39;s going on here? It looks like the letters are shifted by some constant. (hint: you might want to start looking up Roman people). kvbsqrd, iye\u0026#39;bo kvwycd drobo! Xyg pyb dro psxkv (kxn wkilo dro rkbnocd...) zkbd: k celcdsdedsyx mszrob. Sx dro pyvvygsxq dohd, S\u0026#39;fo dkuox wi wocckqo kxn bozvkmon ofobi kvzrklodsm mrkbkmdob gsdr k mybboczyxnoxmo dy k nsppoboxd mrkbkmdob - uxygx kc k celcdsdedsyx mszrob. Mkx iye psxn dro psxkv pvkq? rsxd: Go uxyg drkd dro pvkq sc qysxq dy lo yp dro pybwkd edpvkq{...} - grsmr wokxc drkd sp iye coo drkd zkddobx, iye uxyg grkd dro mybboczyxnoxmoc pyb e, d, p, v k, kxn q kbo. Iye mkx zbylklvi gybu yed dro bowksxsxq mrkbkmdobc li bozvkmsxq drow kxn sxpobbsxq mywwyx gybnc sx dro Oxqvscr vkxqekqo. Kxydrob qbokd wodryn sc dy eco pboaeoxmi kxkvicsc: go uxyg drkd \u0026#39;o\u0026#39; crygc ez wycd ypdox sx dro kvzrklod, cy drkd\u0026#39;c zbylklvi dro wycd mywwyx mrkbkmdob sx dro dohd, pyvvygon li \u0026#39;d\u0026#39;, kxn cy yx. Yxmo iye uxyg k pog mrkbkmdobc, iye mkx sxpob dro bocd yp dro gybnc lkcon yx mywwyx gybnc drkd cryg ez sx dro Oxqvscr vkxqekqo. rghnxsdfysdtghu! qgf isak cthtuike dik zknthhkx rxqldgnxsliq risyykhnk. ikxk tu s cysn cgx syy qgfx isxe kccgxdu: fdcysn{h0v_di4du_vi4d_t_r4yy_rxqld0}. qgf vtyy cthe disd s ygd gc rxqldgnxsliq tu pfud zftyethn gcc ditu ugxd gc zsutr bhgvykenk, she td xksyyq tu hgd ug zse scdkx syy. iglk qgf khpgqke dik risyykhnk! 果然继续啊套娃，看样子新挑战是词频分析，凯撒密码，使用凯撒密码求解得到：\nalright, you\u0026#39;re almost there! Now for the final (and maybe the hardest...) part: a substitution cipher. In the following text, I\u0026#39;ve taken my message and replaced every alphabetic character with a correspondence to a different character - known as a substitution cipher. Can you find the final flag? hint: We know that the flag is going to be of the format utflag{...} - which means that if you see that pattern, you know what the correspondences for u, t, f, l a, and g are. You can probably work out the remaining characters by replacing them and inferring common words in the English language. Another great method is to use frequency analysis: we know that \u0026#39;e\u0026#39; shows up most often in the alphabet, so that\u0026#39;s probably the most common character in the text, followed by \u0026#39;t\u0026#39;, and so on. Once you know a few characters, you can infer the rest of the words based on common words that show up in the English language. hwxdnitvoitjwxk! gwv yiqa sjxjkyau tya padjxxan hngbtwdnibyg hyiooaxda. yana jk i soid swn ioo gwvn yinu asswntk: vtsoid{x0l_ty4tk_ly4t_j_h4oo_hngbt0}. gwv ljoo sjxu tyit i owt ws hngbtwdnibyg jk fvkt pvjoujxd wss tyjk kwnt ws pikjh rxwloauda, ixu jt naioog jk xwt kw piu istan ioo. ywba gwv axfwgau tya hyiooaxda! 看样子最后的挑战，应该是词频分析，丢进在线工具得到：\ncongratulations! you have finished the beginner cryptography challenge. here is a flag for all your hard efforts: utflag{n0w_th4ts_wh4t_i_c4ll_crypt0}. you will find that a lot of cryptography is just building off this sort of basic knowledge, and it really is not so bad after all. hope you enjoyed the challenge! 看来顺利完成挑战，拿到了flag：\nutflag{n0w_th4ts_wh4t_i_c4ll_crypt0} 0xB [WUSTCTF2020]dp_leaking_1s_very_d@angerous # 看题目应该是RSA题目的dp泄露问题，dp泄露问题。需要进行推导一下，和前面的RSA2题目一样，可以直接拉那道题的脚本稍微修改一下进行求解。\n在求解之前，还是先看看题目：\ne = 65537 n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847 c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869 dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825 直接拉之前的dp脚本，修改数据得到修改后的脚本\nfrom Crypto.Util.number import * import gmpy2 e = 65537 n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847 dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825 c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869 temp = dp *e for i in range(1,e): if (temp-1)%i == 0: x = (temp-1)//i + 1 y = n%x if y == 0: p=x break q = n // p # print p # print q phi = (q-1)*(p-1) d = gmpy2.invert(e,phi) m = pow(c,d,n) flag = long_to_bytes(m) print flag 运行脚本，得到flag：\nwctf2020{dp_leaking_1s_very_d@angerous} 0xC [AFCTF2018]你听过一次一密么？ # 一次一密的题目，应该是比较有难度的题目。\n看看题目吧：\n25030206463d3d393131555f7f1d061d4052111a19544e2e5d 0f020606150f203f307f5c0a7f24070747130e16545000035d 1203075429152a7020365c167f390f1013170b1006481e1314 0f4610170e1e2235787f7853372c0f065752111b15454e0e09 081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a18 0909075412132e247436425332281a1c561f04071d520f0b11 4116111b101e2170203011113a69001b475206011552050219 041006064612297020375453342c17545a01451811411a470e 021311114a5b0335207f7c167f22001b44520c15544801125d 06140611460c26243c7f5c167f3d015446010053005907145d 0f05110d160f263f3a7f4210372c03111313090415481d49 暂时看不出什么求解方法。只好看看[大佬的wp](Many-Time-Pad 攻击 (ruanx.net)) 发现这道题目是采用Many-Time-Pad攻击，是对于流密码的加密进行的攻击方式。目前的知识空缺还不足以让我驾驭这个这道题目的脚本和这道题目的思路方式，于是就借个脚本和大佬的wp来求解吧。\n丢个EXP：\n#!/usr/bin/python ## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017 # Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py) import string import collections import sets, sys # 11 unknown ciphertexts (in hex format), all encrpyted with the same key c1=\u0026#39;25030206463d3d393131555f7f1d061d4052111a19544e2e5d\u0026#39; c2=\u0026#39;0f020606150f203f307f5c0a7f24070747130e16545000035d\u0026#39; c3=\u0026#39;1203075429152a7020365c167f390f1013170b1006481e1314\u0026#39; c4=\u0026#39;0f4610170e1e2235787f7853372c0f065752111b15454e0e09\u0026#39; c5=\u0026#39;081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a18\u0026#39; c6=\u0026#39;0909075412132e247436425332281a1c561f04071d520f0b11\u0026#39; c7=\u0026#39;4116111b101e2170203011113a69001b475206011552050219\u0026#39; c8=\u0026#39;041006064612297020375453342c17545a01451811411a470e\u0026#39; c9=\u0026#39;021311114a5b0335207f7c167f22001b44520c15544801125d\u0026#39; c10=\u0026#39;06140611460c26243c7f5c167f3d015446010053005907145d\u0026#39; c11=\u0026#39;0f05110d160f263f3a7f4210372c03111313090415481d49\u0026#39; ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11] # The target ciphertext we want to crack #target_cipher = \u0026#34;0529242a631234122d2b36697f13272c207f2021283a6b0c7908\u0026#34; # XORs two string def strxor(a, b): # xor two strings (trims the longer input) return \u0026#34;\u0026#34;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)]) def target_fix(target_cipher): # To store the final key final_key = [None]*150 # To store the positions we know are broken known_key_positions = set() # For each ciphertext for current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don\u0026#39;t xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode(\u0026#39;hex\u0026#39;), ciphertext2.decode(\u0026#39;hex\u0026#39;))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don\u0026#39;t know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val \u0026gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode(\u0026#39;hex\u0026#39;),\u0026#39; \u0026#39;*150) for index in knownSpaceIndexes: # Store the key\u0026#39;s value at the correct position final_key[index] = xor_with_spaces[index].encode(\u0026#39;hex\u0026#39;) # Record that we known the key at this position known_key_positions.add(index) # Construct a hex key from the currently known key, adding in \u0026#39;00\u0026#39; hex chars where we do not know (to make a complete hex string) final_key_hex = \u0026#39;\u0026#39;.join([val if val is not None else \u0026#39;00\u0026#39; for val in final_key]) # Xor the currently known key with the target cipher output = strxor(target_cipher.decode(\u0026#39;hex\u0026#39;),final_key_hex.decode(\u0026#39;hex\u0026#39;)) print \u0026#34;Fix this sentence:\u0026#34; print \u0026#39;\u0026#39;.join([char if index in known_key_positions else \u0026#39;*\u0026#39; for index, char in enumerate(output)])+\u0026#34;n\u0026#34; # WAIT.. MANUAL STEP HERE # This output are printing a * if that character is not known yet # fix the missing characters like this: \u0026#34;Let*M**k*ow if *o{*a\u0026#34; = \u0026#34;cure, Let Me know if you a\u0026#34; # if is too hard, change the target_cipher to another one and try again # and we have our key to fix the entire text! #sys.exit(0) #comment and continue if u got a good key target_plaintext = \u0026#34;cure, Let Me know if you a\u0026#34; print \u0026#34;Fixed:\u0026#34; print target_plaintext+\u0026#34;n\u0026#34; key = strxor(target_cipher.decode(\u0026#39;hex\u0026#39;),target_plaintext) print \u0026#34;Decrypted msg:\u0026#34; for cipher in ciphers: print strxor(cipher.decode(\u0026#39;hex\u0026#39;),key) print \u0026#34;nPrivate key recovered: \u0026#34;+key+\u0026#34;n\u0026#34; for i in ciphers: target_fix(i) 这道题目也有一个秒杀解法：\npip install mtp mtp Problem.txt 也可以获取密钥和明文，得到flag。流密码题目，以后还是有待继续研究和学习的。\n0xD [AFCTF2018]BASE # 应该会是BASE家族的题目，考察BASE编码。\n看题目：\n一个非常大的密文文件，文件内容是Base加密。\n看样子像是Base，但是发现解码后又是一个Base，之后又是一个不断循环。应该是套了好多层。写个脚本进行循环解码：\nimport base64 file = open(\u0026#34;flag_encode.txt\u0026#34;,\u0026#39;r\u0026#39;) file_out = open(\u0026#34;flag.txt\u0026#34;,\u0026#39;w\u0026#39;) base = file.read() index = 0 while(1): try: base = base64.b32decode(base).decode() index += 1 except: try: base = base64.b64decode(base).decode() index += 1 except: try: base = base64.b16decode(base).decode() index += 1 except: print(\u0026#34;decode finish QWQ！\u0026#34;) file_out.write(base) file_out.write(\u0026#34;\\n\u0026#34;) file_out.write(str(index)) break 运行脚本后，查看写入的文件：\nafctf{U_5h0u1d_Us3_T00l5} 30 嵌套了30层base，最后也成功拿到了flag。\n0xE [NPUCTF2020]Classical Cipher # 古典密码的题目，打开看看：\n两个文件，一个key.txt解压密码文件，一个flag.zip压缩文件。压缩文件有密码，可以看看key.txt里面具体是什么东西：\n解密后的flag请用flag{}包裹 压缩包密码：gsv_pvb_rh_zgyzhs 对应明文： ***_key_**_****** 对应明文，应该是这个古典密码的提示，k对应p，e对应v以及y对应b。这种古典密码有非常好的对称性，可以自然而然地联想到埃特巴什码。\n然后使用Atbash码进行解密，就能得到压缩包的解压密码：\nthe_key_is_atbash 使用解出的密码，解开压缩文件，得到一张图片：\n看样子奇奇怪怪的，是猪圈密码和古埃及象形密码的组合\n直接根据猪圈密码变体和古埃及象形密码的对应关系进行解码得到flag：\nclassicalcode 猪圈密码变体：\n古埃及象形密码：\nEasyProgram # 简单的程序，应该是针对这个程序进行逆算法设计来完成相应的算法求解来获取到flag，看看题目：\nEeemmm......this is a easy game.Have fun~ 注意：得到的 flag 请包上 flag{} 提交 题目附件：\nget buf unsign s[256] get buf t[256] we have key:whoami we have flag:???????????????????????????????? for i:0 to 256 set s[i]:i for i:0 to 256 set t[i]:key[(i)mod(key.lenth)] for i:0 to 256 set j:(j+s[i]+t[i])mod(256) swap:s[i],s[j] for m:0 to 38 set i:(i + 1)mod(256) set j:(j + S[i])mod(256) swap:s[i],s[j] set x:(s[i] + (s[j]mod(256))mod(256)) set flag[m]:flag[m]^s[x] fprint flagx to file 附件是伪代码文件，写一个逆算法程序脚本：\nkey = \u0026#34;whoami\u0026#34; flags = \u0026#34;\u0026#34; s = [i for i in range(256)] t = [key[i%(len(key))] for i in range(256)] j = 0 for i in range(256): j = (j+s[i]+ord(t[i]))%256 s[i],s[j] = s[j],s[i] j = 0 i = 0 with open(\u0026#34;file.txt\u0026#34;,\u0026#34;rb\u0026#34;) as f: flag = f.read() for m in range(38): i = (i+1)%256 j = (j+s[i])%256 s[i],s[j] = s[j],s[i] x = (s[i]+(s[j]%256))%256 flags += chr(ord(flag[m])^s[x]) print flags 运行脚本，得到flag：\nflag{f238yu28323uf28u2yef2ud8uf289euf} ","date":"July 8, 2021","permalink":"/posts/buuctf-crypto-6_writeup/","section":"Posts","summary":"百题计划，冲呀！冲呀！冲呀！\n本次16道题目，难度开始逐渐上升，越来越有挑战性喽！\n0x0 RSA \u0026amp; what # 开场就是一道RSA题目，真是不错！\n附件有四个文件，一个README.txt文件，一个rsa.py算法文件，一个HUB1输出文件和一个HUB2输出文件。看看这些文件都是些什么内容吧！\nREADME.txt：\n素数生成算法太麻烦了，有没有取巧的方法呢？ 诶，这里好像有个不错的想法哟。 看起来节约了不少时间呢，嘿嘿嘿…… 顺便问问，应该大家都知道base64吧，用来编码还是很方便的呢！ rsa.py：\nfrom Crypto.Util.number import bytes_to_long, getPrime from random import randint from gmpy2 import powmod p = getPrime(2048) q = getPrime(2048) N = p*q Phi = (p-1)*(q-1) def get_enc_key(N,Phi): e = getPrime(N) if Phi % e == 0: return get_enc_key(N, Phi) else: return e e1 = get_enc_key(randint(10, 12), Phi) e2 = get_enc_key(randint(10, 12), Phi) fr = open(r\u0026#34;./base64\u0026#34;, \u0026#34;rb\u0026#34;)#flag is in this file f1 = open(r\u0026#34;.","title":"BUUCTF CRYPTO (6) writeup"},{"content":"密码学百题计划启动！进行勇往直前！\n本次的16道题目，也是非常有意思的呢！各种各样的呢……\n0x0 浪里淘沙 # 看样子，应该是个脑洞题没错了\n来康康这题的题目：\n我有密集恐惧症，所以大家自求多福吧，把获得的单词连在一起提交即可。（我这里有一串数字：4，8，11，15，16） 注意：得到的 flag 请包上 flag{} 提交 这题目好像有点意思，可以从题目中提炼一些信息：\n密集恐惧症 获得的单词连在一起提交 我这里有一串数字：4，8，11，15，16 根据提炼的数据进行分享，应该是词频统计类的题目，这题有点意思\n看看附件是啥吧：\ntonightsuccessnoticenoticewewesuccesstonightweexamplecryptoshouldwebackspacetonightbackspaceexamplelearnwesublimlearnbackspacetheshouldwelearnfoundsublimsystemexamplesublimfoundlearnshouldmorningsublimsystemuserlearnthecryptomorningexamplenoticetonightlearntonightlearntonightsublimenterusermorningfoundtonightweenterfoundnoticethecryptomorningthebackspacelearntonightlearnsublimtonightlearnfoundenterfoundsuccesstonightsuccessuserfoundmorningtonighttheshouldsublimentertonightenterbackspacelearnexamplenoticeexamplefoundsystemsuccesssublimsuccessshouldtonightcryptowelearncryptofoundshouldsublimsublimweentertonightsuccessshouldentertheentercryptouserbackspaceshouldentersystemsuccesssystementerfoundenterlearnexampletonightnoticemorningusertonightlearnmorningtonightfoundfoundsuccessnoticesystementerlearnexamplebackspaceshouldcryptocryptosublimweexampletonighttheshouldthemorningbackspacelearntonightsystemsuccesssuccessbackspacemorningnoticeuserfoundfoundtonightmorningenterenterthefoundbackspacelearnenterentershouldthesystemfounduserlearnlearnsystemnoticetonighttheshouldlearnuserbackspaceweusernoticeshouldthewefoundsystemwecryptocryptowethebackspacesystementershouldtonightsystemnoticemorningsystemweentermorningfoundsuccessusertonightsuccesstonightbackspaceshouldweenterthewesystemusernoticesystemthelearnexamplelearnfoundlearnnoticeexamplesystemthecryptocryptolearnsystemthecryptoenterlearnexamplemorningmorningweenterentersuccessexampleuserthebackspacenoticesublimenterbackspacesuccessbackspacethesublimexamplesystemtheexamplecryptolearnuserexamplelearnsystemusersuccessenterentersuccesstheuserbackspacelearnsuccessbackspacethesublimshouldwebackspaceexamplesuccesssuccesstonightweusershouldsuccessmorningcryptomorningfoundbackspacesublimshouldentershouldnoticesuccessmorningsuccessexamplelearnshouldsublimlearntonightshoulduserbackspacesublimlearncryptosuccessenternoticetonightmorningtonightwesuccessweuserbackspaceexamplewesystemnoticemorningsystemmorningcryptolearnsystemthethefoundcryptouserlearnusersystemwemorningenterexampleshouldlearncryptofoundenterbackspacelearnenterenterbackspaceshouldbackspacetheshouldthesystemshouldshouldsuccessmorningthefoundsystementersystemtonightcryptowelearnexampleexamplesystementerbackspaceshouldtheentersublimtonightfoundfoundsuccesssuccesssystemsublimcryptoshouldentersublimmorninglearnfoundtonightcryptobackspacesuccesscryptowebackspacefoundshouldnoticeshouldmorningnoticesystemcryptosystemlearnsystemnoticemorningsystementerwemorninglearnsuccessfoundwesuccesswetheusercryptousernoticebackspacesuccessshouldtonightmorningentermorninguserenternoticefoundmorningwetonightsystemthecryptotonightcryptosystemuserthefoundexampletonightusersystemcryptosublimmorninguserthefoundbackspaceshouldsuccesscryptotonightsystemnoticebackspaceusershouldenterthecryptomorningwesublimnoticesuccessnoticeusersuccesstonightlearnweuserenterfounduserexampleshouldshouldtonightwelearnthenoticethewefoundmorningexampleshouldexamplethesuccessnoticeenterfoundthecryptonoticeuserlearnuserweenterfoundmorningsystemweexamplenoticethebackspaceexamplesublimtheusermorningtonightthesuccesscryptosuccessusersuccesstonighttonightwelearnenterenterthemorningentersystemcryptobackspacemorningsystemexamplecryptouserexamplelearnsublimsuccessusersystemfoundmorningshouldcryptotonightsublimtheexamplemorningsystemuserexampleweexamplenoticesuccesssublimnoticecryptoshouldbackspaceshouldthetonightfoundsublimbackspacebackspacetonightshouldbackspacesuccesstonightbackspacesuccessmorningsystemcryptobackspaceentertonighttonightnoticelearnshoulduserfoundexamplesystemthesuccessweusertonightcryptousernoticeenternoticebackspaceusersystemfoundusernoticeshouldlearnuserfoundexampleusermorningshouldsuccessmorningmorningexampleexamplefoundsublimfoundenterbackspacenoticelearnfoundmorningcryptonoticecryptoshouldweshouldtonightcryptobackspacesublimcryptosublimenterentersublimentercryptonoticethethesublimexampleenterentershouldlearncryptoentershouldmorninglearnnoticeuserexamplesublimtonightshouldfoundtonightsuccessshouldmorningfoundtheweuserlearnsublimsystembackspacecryptotheusertonightcryptosublimmorningmorningexamplenoticetheenterlearnshouldmorningsublimfoundtonightsublimsublimexamplefounduserexamplethefoundwemorningnoticefoundcryptosuccesssublimsublimexamplethesuccessexamplenoticesuccessbackspacesublimlearnuserexamplesuccesssuccesssystemsuccessmorningmorninglearnexamplemorningtonightfoundbackspaceenternoticemorningentersuccessmorningusermorningbackspacelearncryptoenteruserenteruserthetonighttonightsuccesslearnenterfoundsuccesssystemfoundbackspaceenterlearnsystemsublimcryptoentermorningwetonightshouldlearnenterfoundcryptonoticelearnlearnshouldfoundsuccessexampletonightthesuccessfoundusertonightenterfoundsuccessshouldmorningusernoticemorningsystemsystemsuccessshouldwelearnenterfoundexamplewethefoundweshouldsystemsystemmorningmorningbackspaceshouldentersublimentertonightsuccesssystemsystemcryptousershouldsublimfoundwetonightnoticeexamplewewesuccessfoundusertonightfoundsystemexamplecryptofoundshouldshouldsuccessenterbackspaceexampletonightthelearnnoticeuserlearnsystemsublimfoundlearnsuccesssystemshouldsublimnoticelearnsystemnoticetonightexamplefoundusernoticeenterlearnnoticecryptousersystemmorningthewesystemfoundfoundshouldsystementerenterbackspacesystemsublimcryptousermorninglearnlearntonightsublimlearnenterenterbackspacesystemuserusercryptoentershouldtheusersublimnoticeexamplemorningexamplesublimsublimbackspacesystemexampleshouldsublimlearnfoundenterbackspacelearnmorningmorningfoundthetonightmorningnoticeenterlearnusersystemtonightbackspaceexamplelearntonightbackspaceweshouldcryptosuccessbackspaceexamplesuccesstheshouldmorninguserbackspacelearnthetheshouldcryptocryptotonightbackspacecryptocryptobackspacebackspacenoticeusertonightentermorningfoundweenterexampleenterfoundusersublimsystemtheexampleexamplesystemsuccessusersublimentermorningbackspacesystemfoundlearnsystemshouldsublimsublimentershouldtheusershouldexampleexampleshouldsuccesswelearnfoundsublimshoulduserweentertonightwenoticesublimsystemlearnshouldfoundsuccessuserentersuccessmorningcryptoenteruserfoundexampletonightlearnexampleexamplefoundlearnsuccesssystembackspacecryptonoticethefoundbackspacelearncryptothelearnlearnexamplesuccessnoticenoticesystemmorningcryptotonightnoticenoticeentersuccesscryptoenterbackspacesublimexampleenterfoundtonightcryptotonightsublimnoticesuccesssublimtheentertonighttheshouldthefoundsystemtonightuserbackspacesuccessshouldwebackspacenoticebackspacebackspacenoticewecryptobackspacebackspaceusertonightlearnsuccessmorningusertonightsuccessshouldbackspacecryptoenterentershouldsublimsystemexamplemorningcryptonoticethesuccessthebackspacenoticelearnsublimlearnsuccesscryptothesuccessenternoticecryptosystemsublimsuccesswebackspaceuserenterlearnuserwewemorningsuccesslearncryptobackspacewecryptosystemlearnenterenteruserexamplefoundsystemcryptousernoticefoundusersublimbackspacewesublimnoticemorningshouldexamplenoticecryptoshouldtonightmorningthefoundsystementerentersystemthecryptobackspacesublimlearnsuccessmorningsublimsystemcryptousersublimwesuccessmorningsublimbackspacecryptobackspacesublimthelearnsuccesssublimlearncryptoweweexamplecryptowenoticelearnfoundbackspacesystemsystemexampleshouldlearnsuccesssublimcryptobackspacetonightbackspacemorningmorningnoticeshouldnoticefoundthetheshouldtheshouldfoundfoundcryptosuccessbackspacesuccessshouldweenternoticeweweshouldmorningfoundusersuccessbackspacewenoticeusersuccessenterenterexamplelearnfoundwetonightusercryptothesublimsublimtonightsuccesslearnbackspacetonightentertonightthesublimnoticewefoundcryptobackspaceenterenterlearnlearntonightexamplesystementersublimnoticecryptoshoulduseruserbackspaceuserwesublimmorningwesystemshouldtonighttheusershouldnoticefoundusernoticeentersublimwethewefoundfoundlearnfoundwecryptosystemexamplemorningcryptocryptosublimtheexamplenoticefoundlearnwelearnmorningtheenterthesystemsublimtonightsuccesssystemlearnshouldenterbackspaceentersuccesssuccessbackspaceexamplenoticeentershouldsublimlearnbackspacetheshouldexamplelearnsystemusersublimbackspacebackspacesuccesswelearntonightexamplewecryptoenterwesystemsystemsublimexamplecryptolearnmorningsublimfoundsublimfoundbackspacefoundtonighttonightnoticesuccesssuccessexampleusersuccesstonightsublimcryptosystemweenterexamplesystemthethenoticesublimtonightbackspacenoticesystemexamplethesuccesstonightmorningsuccesstonightwenoticesublimtonightwelearntonightmorningsublimbackspaceenterthetonightenterwecryptofoundtheenternoticebackspacesuccesswesystemuserexamplebackspaceentersuccesstonightsublimwemorningsuccesssuccesswesublimsuccessnoticesublimfoundlearnlearnweexamplecryptonoticelearnweusershoulduserfoundcryptolearnfoundmorningtonightmorningmorningnoticewecryptowewesuccessfoundsublimweuserentershouldshouldshouldsublimbackspacetonightenterwesublimsuccessshouldfoundthethetonightwecryptoweenterfoundcryptoshouldcryptouseruserfoundentersublimsublimthelearntheshouldnoticebackspacefoundsuccessshouldtonightentermorningsystemmorningtonightwenoticelearnbackspaceexampleusershouldnoticesublimsublimexamplethesuccessnoticesystemmorningnoticecryptosystemsublimcryptosystemsuccessshouldmorningbackspaceshouldmorninglearnnoticenoticeshouldthewewesublimsublimnoticeusersuccessentersystemfoundshouldshouldcryptobackspaceusermorningsystemshouldshouldtonightwesublimuserfoundlearnbackspacethetonightmorningexampleuserthefoundbackspaceshouldtonightcryptocryptofounduserexamplenoticecryptousernoticethenoticeshouldweshouldfoundwemorningcryptosuccesslearnfoundtonightsublimnoticenoticewefoundwewesuccesssublimsublimcryptoweexampletonightsuccessfoundshouldsuccesstonightbackspacesystemshouldwesystemnoticebackspaceusersystembackspacewenoticelearnnoticenoticesuccesslearntonightuserlearnsuccessbackspacesuccesswesystemusercryptonoticethesystemusernoticewethesuccessweshouldfoundshouldcryptomorningtonightwethewesuccesslearntheshouldweexampletonightsuccessnoticenoticemorningfoundmorningfoundusersublimsystemsuccessbackspacesuccessmorninguserthefoundweexamplemorningsublimlearnfoundfoundnoticemorningshouldweuserwemorningexamplesuccesssuccessfoundthetheshouldweusershouldtheshouldexamplenoticefoundsuccesssystemfoundshouldsublimbackspacetonightshouldsystemtonightsuccesslearntonightsystemsublimsuccesscryptobackspacesystemsublimmorningmorningshouldmorninglearnsuccesslearnmorningusermorninglearnexamplecryptoshouldbackspacesublimshouldfoundbackspacesystemsystemweexamplesystemtonightsublimmorningmorninguserfoundcryptolearnbackspaceshouldbackspacenoticesublimfoundthecryptousershouldsuccesssystemsuccessshouldsystembackspacesublimshouldsublimsystembackspaceexampleshouldbackspacesublimnoticelearnsublimuserbackspaceusersublimsuccesssublimuserusernoticeshouldsuccessnoticenoticelearnexamplesystemweexamplesublimbackspacebackspacecryptoshouldusercryptosublimbackspacesublimshouldsystemnoticenoticethesuccesssuccesslearnsystemsublimwenoticelearnusersublimsystemusernoticeuserthesuccesslearnwelearnwenoticecryptolearncryptonoticenoticebackspacecryptothecryptousercryptobackspacesuccesslearnthesystemsuccessthesystemsystemcryptosuccessbackspacesublimlearnsublimcryptobackspacelearnsublimusersublimexamplecryptosublimsystemnoticecryptocryptousertheusernoticebackspacenoticenoticethecryptocryptosystembackspacesublimbackspacecryptocryptobackspacesystemuserthenoticesystemsystemsystemusernoticethecryptouserusersystemtheusercryptoexamplenoticecryptoexamplenoticetheexampleexamplethecryptotheusernoticetheexampleexamplecryptotheexampleexamplethenoticethecryptocryptoexampletheexamplecryptocryptothenoticeexamplecryptonoticetheexampleexampleexamplecryptocryptoexampleexamplethenoticethecryptothethethethethetheexampleexamplethetheexampletheexampletheexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexample 好多连在一起的词汇，应该是一个简单NTP题目，也就是NLP最基础的一个步骤，分词。\n这道题目的大致思路应该是：\n分词 词频统计 统计排序 根据排序位置找到指定的单词 拼接单词 根据这个思路，写个脚本处理一下哈：\nfrom collections import Counter // 统计库 import wordninja // 英语单词词库 data=\u0026#34;tonightsuccessnoticenoticewewesuccesstonightweexamplecryptoshouldwebackspacetonightbackspaceexamplelearnwesublimlearnbackspacetheshouldwelearnfoundsublimsystemexamplesublimfoundlearnshouldmorningsublimsystemuserlearnthecryptomorningexamplenoticetonightlearntonightlearntonightsublimenterusermorningfoundtonightweenterfoundnoticethecryptomorningthebackspacelearntonightlearnsublimtonightlearnfoundenterfoundsuccesstonightsuccessuserfoundmorningtonighttheshouldsublimentertonightenterbackspacelearnexamplenoticeexamplefoundsystemsuccesssublimsuccessshouldtonightcryptowelearncryptofoundshouldsublimsublimweentertonightsuccessshouldentertheentercryptouserbackspaceshouldentersystemsuccesssystementerfoundenterlearnexampletonightnoticemorningusertonightlearnmorningtonightfoundfoundsuccessnoticesystementerlearnexamplebackspaceshouldcryptocryptosublimweexampletonighttheshouldthemorningbackspacelearntonightsystemsuccesssuccessbackspacemorningnoticeuserfoundfoundtonightmorningenterenterthefoundbackspacelearnenterentershouldthesystemfounduserlearnlearnsystemnoticetonighttheshouldlearnuserbackspaceweusernoticeshouldthewefoundsystemwecryptocryptowethebackspacesystementershouldtonightsystemnoticemorningsystemweentermorningfoundsuccessusertonightsuccesstonightbackspaceshouldweenterthewesystemusernoticesystemthelearnexamplelearnfoundlearnnoticeexamplesystemthecryptocryptolearnsystemthecryptoenterlearnexamplemorningmorningweenterentersuccessexampleuserthebackspacenoticesublimenterbackspacesuccessbackspacethesublimexamplesystemtheexamplecryptolearnuserexamplelearnsystemusersuccessenterentersuccesstheuserbackspacelearnsuccessbackspacethesublimshouldwebackspaceexamplesuccesssuccesstonightweusershouldsuccessmorningcryptomorningfoundbackspacesublimshouldentershouldnoticesuccessmorningsuccessexamplelearnshouldsublimlearntonightshoulduserbackspacesublimlearncryptosuccessenternoticetonightmorningtonightwesuccessweuserbackspaceexamplewesystemnoticemorningsystemmorningcryptolearnsystemthethefoundcryptouserlearnusersystemwemorningenterexampleshouldlearncryptofoundenterbackspacelearnenterenterbackspaceshouldbackspacetheshouldthesystemshouldshouldsuccessmorningthefoundsystementersystemtonightcryptowelearnexampleexamplesystementerbackspaceshouldtheentersublimtonightfoundfoundsuccesssuccesssystemsublimcryptoshouldentersublimmorninglearnfoundtonightcryptobackspacesuccesscryptowebackspacefoundshouldnoticeshouldmorningnoticesystemcryptosystemlearnsystemnoticemorningsystementerwemorninglearnsuccessfoundwesuccesswetheusercryptousernoticebackspacesuccessshouldtonightmorningentermorninguserenternoticefoundmorningwetonightsystemthecryptotonightcryptosystemuserthefoundexampletonightusersystemcryptosublimmorninguserthefoundbackspaceshouldsuccesscryptotonightsystemnoticebackspaceusershouldenterthecryptomorningwesublimnoticesuccessnoticeusersuccesstonightlearnweuserenterfounduserexampleshouldshouldtonightwelearnthenoticethewefoundmorningexampleshouldexamplethesuccessnoticeenterfoundthecryptonoticeuserlearnuserweenterfoundmorningsystemweexamplenoticethebackspaceexamplesublimtheusermorningtonightthesuccesscryptosuccessusersuccesstonighttonightwelearnenterenterthemorningentersystemcryptobackspacemorningsystemexamplecryptouserexamplelearnsublimsuccessusersystemfoundmorningshouldcryptotonightsublimtheexamplemorningsystemuserexampleweexamplenoticesuccesssublimnoticecryptoshouldbackspaceshouldthetonightfoundsublimbackspacebackspacetonightshouldbackspacesuccesstonightbackspacesuccessmorningsystemcryptobackspaceentertonighttonightnoticelearnshoulduserfoundexamplesystemthesuccessweusertonightcryptousernoticeenternoticebackspaceusersystemfoundusernoticeshouldlearnuserfoundexampleusermorningshouldsuccessmorningmorningexampleexamplefoundsublimfoundenterbackspacenoticelearnfoundmorningcryptonoticecryptoshouldweshouldtonightcryptobackspacesublimcryptosublimenterentersublimentercryptonoticethethesublimexampleenterentershouldlearncryptoentershouldmorninglearnnoticeuserexamplesublimtonightshouldfoundtonightsuccessshouldmorningfoundtheweuserlearnsublimsystembackspacecryptotheusertonightcryptosublimmorningmorningexamplenoticetheenterlearnshouldmorningsublimfoundtonightsublimsublimexamplefounduserexamplethefoundwemorningnoticefoundcryptosuccesssublimsublimexamplethesuccessexamplenoticesuccessbackspacesublimlearnuserexamplesuccesssuccesssystemsuccessmorningmorninglearnexamplemorningtonightfoundbackspaceenternoticemorningentersuccessmorningusermorningbackspacelearncryptoenteruserenteruserthetonighttonightsuccesslearnenterfoundsuccesssystemfoundbackspaceenterlearnsystemsublimcryptoentermorningwetonightshouldlearnenterfoundcryptonoticelearnlearnshouldfoundsuccessexampletonightthesuccessfoundusertonightenterfoundsuccessshouldmorningusernoticemorningsystemsystemsuccessshouldwelearnenterfoundexamplewethefoundweshouldsystemsystemmorningmorningbackspaceshouldentersublimentertonightsuccesssystemsystemcryptousershouldsublimfoundwetonightnoticeexamplewewesuccessfoundusertonightfoundsystemexamplecryptofoundshouldshouldsuccessenterbackspaceexampletonightthelearnnoticeuserlearnsystemsublimfoundlearnsuccesssystemshouldsublimnoticelearnsystemnoticetonightexamplefoundusernoticeenterlearnnoticecryptousersystemmorningthewesystemfoundfoundshouldsystementerenterbackspacesystemsublimcryptousermorninglearnlearntonightsublimlearnenterenterbackspacesystemuserusercryptoentershouldtheusersublimnoticeexamplemorningexamplesublimsublimbackspacesystemexampleshouldsublimlearnfoundenterbackspacelearnmorningmorningfoundthetonightmorningnoticeenterlearnusersystemtonightbackspaceexamplelearntonightbackspaceweshouldcryptosuccessbackspaceexamplesuccesstheshouldmorninguserbackspacelearnthetheshouldcryptocryptotonightbackspacecryptocryptobackspacebackspacenoticeusertonightentermorningfoundweenterexampleenterfoundusersublimsystemtheexampleexamplesystemsuccessusersublimentermorningbackspacesystemfoundlearnsystemshouldsublimsublimentershouldtheusershouldexampleexampleshouldsuccesswelearnfoundsublimshoulduserweentertonightwenoticesublimsystemlearnshouldfoundsuccessuserentersuccessmorningcryptoenteruserfoundexampletonightlearnexampleexamplefoundlearnsuccesssystembackspacecryptonoticethefoundbackspacelearncryptothelearnlearnexamplesuccessnoticenoticesystemmorningcryptotonightnoticenoticeentersuccesscryptoenterbackspacesublimexampleenterfoundtonightcryptotonightsublimnoticesuccesssublimtheentertonighttheshouldthefoundsystemtonightuserbackspacesuccessshouldwebackspacenoticebackspacebackspacenoticewecryptobackspacebackspaceusertonightlearnsuccessmorningusertonightsuccessshouldbackspacecryptoenterentershouldsublimsystemexamplemorningcryptonoticethesuccessthebackspacenoticelearnsublimlearnsuccesscryptothesuccessenternoticecryptosystemsublimsuccesswebackspaceuserenterlearnuserwewemorningsuccesslearncryptobackspacewecryptosystemlearnenterenteruserexamplefoundsystemcryptousernoticefoundusersublimbackspacewesublimnoticemorningshouldexamplenoticecryptoshouldtonightmorningthefoundsystementerentersystemthecryptobackspacesublimlearnsuccessmorningsublimsystemcryptousersublimwesuccessmorningsublimbackspacecryptobackspacesublimthelearnsuccesssublimlearncryptoweweexamplecryptowenoticelearnfoundbackspacesystemsystemexampleshouldlearnsuccesssublimcryptobackspacetonightbackspacemorningmorningnoticeshouldnoticefoundthetheshouldtheshouldfoundfoundcryptosuccessbackspacesuccessshouldweenternoticeweweshouldmorningfoundusersuccessbackspacewenoticeusersuccessenterenterexamplelearnfoundwetonightusercryptothesublimsublimtonightsuccesslearnbackspacetonightentertonightthesublimnoticewefoundcryptobackspaceenterenterlearnlearntonightexamplesystementersublimnoticecryptoshoulduseruserbackspaceuserwesublimmorningwesystemshouldtonighttheusershouldnoticefoundusernoticeentersublimwethewefoundfoundlearnfoundwecryptosystemexamplemorningcryptocryptosublimtheexamplenoticefoundlearnwelearnmorningtheenterthesystemsublimtonightsuccesssystemlearnshouldenterbackspaceentersuccesssuccessbackspaceexamplenoticeentershouldsublimlearnbackspacetheshouldexamplelearnsystemusersublimbackspacebackspacesuccesswelearntonightexamplewecryptoenterwesystemsystemsublimexamplecryptolearnmorningsublimfoundsublimfoundbackspacefoundtonighttonightnoticesuccesssuccessexampleusersuccesstonightsublimcryptosystemweenterexamplesystemthethenoticesublimtonightbackspacenoticesystemexamplethesuccesstonightmorningsuccesstonightwenoticesublimtonightwelearntonightmorningsublimbackspaceenterthetonightenterwecryptofoundtheenternoticebackspacesuccesswesystemuserexamplebackspaceentersuccesstonightsublimwemorningsuccesssuccesswesublimsuccessnoticesublimfoundlearnlearnweexamplecryptonoticelearnweusershoulduserfoundcryptolearnfoundmorningtonightmorningmorningnoticewecryptowewesuccessfoundsublimweuserentershouldshouldshouldsublimbackspacetonightenterwesublimsuccessshouldfoundthethetonightwecryptoweenterfoundcryptoshouldcryptouseruserfoundentersublimsublimthelearntheshouldnoticebackspacefoundsuccessshouldtonightentermorningsystemmorningtonightwenoticelearnbackspaceexampleusershouldnoticesublimsublimexamplethesuccessnoticesystemmorningnoticecryptosystemsublimcryptosystemsuccessshouldmorningbackspaceshouldmorninglearnnoticenoticeshouldthewewesublimsublimnoticeusersuccessentersystemfoundshouldshouldcryptobackspaceusermorningsystemshouldshouldtonightwesublimuserfoundlearnbackspacethetonightmorningexampleuserthefoundbackspaceshouldtonightcryptocryptofounduserexamplenoticecryptousernoticethenoticeshouldweshouldfoundwemorningcryptosuccesslearnfoundtonightsublimnoticenoticewefoundwewesuccesssublimsublimcryptoweexampletonightsuccessfoundshouldsuccesstonightbackspacesystemshouldwesystemnoticebackspaceusersystembackspacewenoticelearnnoticenoticesuccesslearntonightuserlearnsuccessbackspacesuccesswesystemusercryptonoticethesystemusernoticewethesuccessweshouldfoundshouldcryptomorningtonightwethewesuccesslearntheshouldweexampletonightsuccessnoticenoticemorningfoundmorningfoundusersublimsystemsuccessbackspacesuccessmorninguserthefoundweexamplemorningsublimlearnfoundfoundnoticemorningshouldweuserwemorningexamplesuccesssuccessfoundthetheshouldweusershouldtheshouldexamplenoticefoundsuccesssystemfoundshouldsublimbackspacetonightshouldsystemtonightsuccesslearntonightsystemsublimsuccesscryptobackspacesystemsublimmorningmorningshouldmorninglearnsuccesslearnmorningusermorninglearnexamplecryptoshouldbackspacesublimshouldfoundbackspacesystemsystemweexamplesystemtonightsublimmorningmorninguserfoundcryptolearnbackspaceshouldbackspacenoticesublimfoundthecryptousershouldsuccesssystemsuccessshouldsystembackspacesublimshouldsublimsystembackspaceexampleshouldbackspacesublimnoticelearnsublimuserbackspaceusersublimsuccesssublimuserusernoticeshouldsuccessnoticenoticelearnexamplesystemweexamplesublimbackspacebackspacecryptoshouldusercryptosublimbackspacesublimshouldsystemnoticenoticethesuccesssuccesslearnsystemsublimwenoticelearnusersublimsystemusernoticeuserthesuccesslearnwelearnwenoticecryptolearncryptonoticenoticebackspacecryptothecryptousercryptobackspacesuccesslearnthesystemsuccessthesystemsystemcryptosuccessbackspacesublimlearnsublimcryptobackspacelearnsublimusersublimexamplecryptosublimsystemnoticecryptocryptousertheusernoticebackspacenoticenoticethecryptocryptosystembackspacesublimbackspacecryptocryptobackspacesystemuserthenoticesystemsystemsystemusernoticethecryptouserusersystemtheusercryptoexamplenoticecryptoexamplenoticetheexampleexamplethecryptotheusernoticetheexampleexamplecryptotheexampleexamplethenoticethecryptocryptoexampletheexamplecryptocryptothenoticeexamplecryptonoticetheexampleexampleexamplecryptocryptoexampleexamplethenoticethecryptothethethethethetheexampleexamplethetheexampletheexampletheexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexample\u0026#34; lm = wordninja.LanguageModel(\u0026#39;my_dict.txt.gz\u0026#39;) // 通过调试写出的简单字典 data_list = lm.split(data) data_count = Counter(data_list) index = 1 hint_list = [4,8,11,15,16] m = \u0026#34;\u0026#34; for i in data_count.most_common(20)[::-1]: if index in hint_list: m += i[0] index += 1 print(m) 运行一下脚本：\nweshouldlearnthecrypto 游戏结束！得到flag：\nflag{weshouldlearnthecrypto} 0x1 [AFCTF2018]Vigenere # 维吉尼亚密码，多表替换密码。来瞧瞧题目的附件：\n两个附件文件，一个加密的flag_encode.txt和加密算法的Encode.c\nEncode.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { freopen(\u0026#34;flag.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;flag_encode.txt\u0026#34;,\u0026#34;w\u0026#34;,stdout); char key[] = /*SADLY SAYING! Key is eaten by Monster!*/; int len = strlen(key); char ch; int index = 0; while((ch = getchar()) != EOF){ if(ch\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;z\u0026#39;){ putchar((ch-\u0026#39;a\u0026#39;+key[index%len]-\u0026#39;a\u0026#39;)%26+\u0026#39;a\u0026#39;); ++index; }else if(ch\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;Z\u0026#39;){ putchar((ch-\u0026#39;A\u0026#39;+key[index%len]-\u0026#39;a\u0026#39;)%26+\u0026#39;A\u0026#39;); ++index; }else{ putchar(ch); } } return 0; } flag_encode.txt\nYzyj ia zqm Cbatky kf uavin rbgfno ig hnkozku fyyefyjzy sut gha pruyte gu famooybn bhr vqdcpipgu jaaju obecu njde pupfyytrj cpez cklb wnbzqmr ntf li wsfavm azupy nde cufmrf uh lba enxcp, tuk uwjwrnzn inq ksmuh sggcqoa zq obecu zqm Lncu gz Jagaam aaj qx Hwthxn\u0026#39;a Gbj gfnetyk cpez, g fwwang xnapriv li phr uyqnvupk ib mnttqnq xgioerry cpag zjws ohbaul drinsla tuk liufku obecu ovxey zjwg po gnn aecgtsneoa. Cn poyj vzyoe gxdbhf zq ty oeyl-ndiqkpl, ndag gut mrt cjy yrrgcmd rwwsf, phnz cpel gtw yjdbcnl bl zjwcn Cekjboe cklb yeezjqn htcdcannhum Rvmjlm, phnz juoam vzyoe nxn Tisk, Navarge jvd gng honshoc wf Ugrhcjefy. — Cpag zq kyyuek cpefk taadtf, Mxdeetowhps nxn qnfzklopeq gvwnt Sgf, xarvbrvg gngal fufz ywwrxu xlkm gnn koaygfn kf gnn ooiktfyz, — Tugc ehrtgnyn aae Owrz uh Yireetvmng hguiief jnateaelcre bl cpefk gfxo, ig ob bhr Xkybp os zqm Prurdy po nrcmr bx vg uxoyobp ig, gpv nk iaycqthzg fys Gbbnznzkpl, fwyvtp qtf lqmhzagoxv oa ywub lrvtlqpyku shz oemjvimopy cps cufmrf op koyh suau, af zq lbam fnjtl fkge gksg rrseye vg ybfric bhrot Kubege jvd Ugrhcjefy. Yzuqkpuy, enqknl, wvrn vcytnzn bhnz Igparasnvtf rqfa asggktifngv mdohrm vog hg ubwntkm noe rkybp aaj czaaykwhp cnabms; ntf swyoejrvgye cdf axckaqeaig zuph fnnen gncl gwnxowl aek ogla dvyywsrj vg mqfska, ehvrg wpelf gam shlhwlwbyk cpaa zq jcchg zqmmfknnyo bl gkwlvyjahc tuk owrzy vg qdipn cpel gtw uychycwmrj. Dmn shrt j toam vjuen bl jjufku shz ufaaxagoqfm, lueydqnt opnuninhug tuk usga Oopnkt rbkfwas n jnaitt vg ladhin bhrs wfxar nhbwlhzg Vyopbzram, vz kk ndevx aqguz, kl co tukrz dhza, li pheuf wfs ywub Coikavmrtv, shz tb vawvvjg fys Ghgals sut lbaie ldbuek uwwqrvzh. — Aupn jsm xert cpe cgvayjt faoneegpuy kf gnnae Pungheef; gwl shij am joj zqm nrigkmetl cqqcu iqfmprnowa tuko li wlgka bhrot xinmrx Bgsgkok ib Gbbnznzkpl. Nde uobboee qx nde cxnaeaz Mahc os Mamag Htanwia ob i hvyvglu os xnxenzgv cjjhxrms ntf mmqrcgcqoay, cdf daiowo ia jkjyyt bhsmcg zjw yotnhuqsusgfn kf nt jjsbrwly Pyegwvy bbgj ndefk Bbagku. Li lrbbn bhvy, nwn Bapzb je fadecptrj cw a pgpvcz wbxul. Hr nck lafhynl hvy Ckmang zx Tajy, vzy iofz fpoykugga aaj wmcryuslu fbx cpe caddcy gbum. Pe ugu xinbvjmmn uou Yireetxzs gu rsmo Lncb wf vsowxeagk jvd cxgkment ovxoezcfwa, uarnas fauhyjdrj rv tukkj ileegcqoa zkdf dif Gbaeaz uziqlq hn wbggkfyz; aaj fpea yq kooprtmmd, uk jsm qtgkaty akidyytrj cw agzgfx po gnnu. Hr nck lafhynl tb vckm ktuka Tajy hgl phr glkozsqvupibt xn lnxiw xesgxrktf uh hykpyk, dvlryu lbksr vnwpyk ygohd ekuqndakkb phr xrohg uh Jylrrynvtnzkgh en gnn Tetoudupuek, j zitnv ahasgovibyk vg ndez gwl fbxoaxwbyk cw tlxcfno oarh. Pe ugu uuhlrj cwgrzjwl hetobtagoxw vkdvkb it crcuyo uaabcay, apuiifbxcibyk, cfx zifzjvt sxqe nde qkywsvzqjs kf gnnqr Caddcy Rrixzdf, lqj nde fuum phxrgma os ljbitakfa phrs rvtb iqejhintlm wvzj zco mrgbcrry. Jw bws qobaoybgv Lapekbmnggvapa Hbabms ekrwupeqrh, noe urhioiam fqtu scffu fvxvvefy jam enigbqoay qf nde eopptf uh lba pruyte. Uk jsm nesabmd sut s fknt zrue, nlvwl oupn mqsfunmneoay, cw cnauw iphrxb bo ok gdyytrj, fpeekdq nde Ykpqsygvapa Pbcnzs, vtesjwbyk xn Aatkzchagoxv, hnbg jypuetnl tb zjw Jaocrn it ygtyy boe zqmie kzwlyifk; cpe Fzcly nezgrviam kf nde zkjv tvsg wrlofkm bo nrn lba dntpmrf uh ahrafoxv feuo ocphbac, inq iqfpqlfoxvs jovzcj. Hr nja eajgspkuekm bo cxgnyjt gnn xocansneoa uo bhryg Knwtry; owr gncl jqrcubm ooyvjoytvtp bhr Rcom boe Tjbuegnatwtvuw wf Sutwccnrxb; zesauahc tb vjas bzjwlo tb kwkohxcyy phroa uitxclcknf nrbhrx, cfx navyrvg gng uijdvzrwnf uh fys Acvawpeoclcknf uo Taaju. Zy daf ukateaelyz tuk Jlmvtkknnagoxv os Pwknecr hh zesauahc hvy Jasrtv li Hajy owr ryvsvhifnrvg Wafaweaee Ywwrxu. Zy daf sjle Wafyyo drvnvdrtv gh dif Crtl nrqfy boe zqm trtwjy kf gnnqr blhawas, ntm bhr gogojt ntm xalsgfn kf gnnqr fgnsleef. luig vy cxwpf{Jnxwobuqg_O_Cogiqi!} Hr nck ynepznl a zanlcpuqk xn Nrc Qxzecry, jvd fkpl betuka awnxok ib Oslrkeey vg bwrnyb wue vggjhe ntm mag uwl ndevx bcbfzcfwa. Hr nja krvv sgknt ab, qn goowm kf ckjke, Fzcfxent Gauiry yandohz cpe Pupkyjt bl xcr ykiamhagaams. Uk jsm wfsklbeq zq jyjdrx cpe Zonanwrl owleckpvyjt bl jvd farwleoe zx bhr Iknch Pbcnz. Hr nck wkmoowmd jovz iphrxb bo fadbyyt hy cw a watamzipzrwn sutwccn gu xcr pupknethzrwn, ntf mhwcxtxelrjiwx xy baa tajy; iapent nra Afygfn po gnnqr Nivk ib pekcmnqkf Dycifrjbibt: Hgl munxcmrvti dungr hxliry qx unmrj czobvu sgknt ab: Noe vtgnacgowo tuko, ts w mbit Brvgn xlkm cawqsusgfn boe gwg Mhxfwlo wuolp tuka kbkuyj lwmzov gh phr Owpaoovshps bl cpefk Ulupef: Lxz chzvahc osl xcr Gxcvy sign jtl cgtlm kf gnn eoerf: Xin izvxaiam Vsras bt da wvzjgop ohx Lwnfkpl: Zkr qkyziiopy oo ia sjvy pguwm, kf gnn jeakhan kf Gxril oe Lmlu: Fbx czaayrglpiam da breqfx Oeny cw br ztayz fbx yzegkpvyz oslnvcry: Hgl wbbrrahvti lba fekn Ayfzge ib Eamuqsu Rcom en n tnqguhqmlent Vawvvtew, yotnhuqsuopy ndeekrv aa Gttcprnxh ooiktfgang, gwl earcjaent oca Bbapvuniry bw af zq jyjdrx rb ag upuy wn rdjupyk cfx big owateaowhp fbx rvteufmwent zqm snsg svooyacm rhrg ahpo gnnae Pungheef Lxz tnqkfa wwne xcr Pncjnarf, gkwlvyjahc ohx vwsg bcdowbyk Uiwf gpv uhtrxrvg sapvuieazjtll zjw Zkrzy xn ohx Igparasnvtf: Lqj mqsckwliam qml kwa Rnoifrclonef, gwl drinslent zqmmfknnyo iabnatrj yand pbcnz tb rgycolnzn noe au ah wly ijaef cjsnoorbnz. Hr nck uxdvijbeq Mqnynnzkwb hrxg, ts zeprjziam wk iqt bl qqs Cxqlyytvuw inq ccycjg Jga ignopkn qs. Uk qis crwfxarrj xcr fkck, lwvnmnl ohx eguotf, hdzng uwj nkway, jvd qkullkyrj cpe yoxwm kf baa xebvnw. Ba if gc bhvy vaga tegwapbxvahc lnxpm Aeskwm kf suamitt Owlyeagaqef zq uiipykjb tuk yglgs bl mmagn, fwmklnzrwn, ntf lsnaath, ilekcvs xetaw eign ealyuzycinpku gz Yrhkuby \u0026amp; Cktxczy fijzcrra hunayrnteq op lba mbyc jaehcjiqs nmna, aaj vgnwlye dvwbxvzs phr Nnid bl c ucriyoimd agvaij. Hr nja cbtullwiakm wue lgdfkw Pocqzrtu lugea Ijxtvbg gh phr nroh Fkck nk brga Irzy cyuenfz cpevx Egojtee, cw briqey phr kgmchzkgharf uo bhrot xleeajb inq Htwndrrt, xz tb lcdf phrsbmliku ts phroa Paaju. Zy daf kgkigkf viiefzrk iaywjlacgoxvs nsqfaot hy, jvd ugu whzenbxcrrj vg vniam xv tuk kfbwbvzjvtf uh gon feuwbirxu, lba mrxlqlryu Ahzint Bivnmgk qdofk tvojt tmfa os cjzfnxg, am wn htmqsgopyoesukm lefztmwpibt xn ayr cyyo, srdna aaj eghzigoxvs. Vt gnyny fzjoe bl vzyoe Bvyzefykgho Wr njde Ckvaneoakm noe Xgvlasf ow bhr sqkn duzhum trxok: Iqr ekymagkf Hypigoxvs ugxw vaea gwawrxgv ijll hh zeckclyz iapdzy. N Vtahye, jnxae pncjuytrx ra tuau eunkrj kg eiktq uyt jnrkh zga vybiak j Byegpl, co ualrb tb hg lba rhrnz os g hjya pruyte. Aut zure Jk kmea ccfnent ow itgkplcknf zx wue Htanesu hamtuxgf. Qa hnbn eaetgv ndez lawm goow nk tvsn wf nzvwgltf hh bhrot dycifrjbuek vg yttrtm in htyslnaazjjlr pwjcodvicqoa uxwl qs. Jk qivr xgecjdrj cpez uh lba cvxlcmfzcfwas bl xcr rskylwtvuw inq yglnhezkwb hrxg. Oy daik jxprgnwx po gnnqr agvapa jhycqcr gpv gwgagwqmvza, shz wr njde pupboneq zqmm oe vzy piry xn ohx eggioa qrvdekf li zifgeww gngky qshxyitvupk, qdipn fwuyj kfyriggkty vtvwlnucz xcr pupfyytvuwa aaj eglnefvxvdrtew. Ndel zxw hnbg tyan qkjn tb zjw pkipk xn jhyvawa aaj xn cbtushcuvtrby. Jk ommp, tukamfbxg, swmuvkbke vt vzy jepkbaige, yzcyh qkwwuaigk iqr Fkyirnzkgh, wnq nxtd gnge, uo wr nxtd gng jyot bl vinxopv, Yjezona ia Ccj, cj Prglm Feogfxo. Wr, zqmrrlqjy, phr Xnxrrygfnwtvbna os zjw ojigkm Atnzgk ib Azkaqcn, op Yyjeegu Koamtwmo, Afynubykf, sjlenrrvg gu vzy Oucxnue Wafyy kf gnn eoerf xin tuk amcgovmxa os udz iazgfneoay, mw, ia zjw Hwmr, gwl bl Gwlbkrvzh wf gng yikd Ckxxlr uh lbasr Ixtoaogk, mklrswty caddcoh ntm leprcjy, Phnz cpefk wfcpeq Ixtoaogk une, ntm wf Eoizn kutnc bo ok Hjya aaj Rvdrvgfxang Ycitry, vzup tukh irr Gdkihvrj ozoz gnd Uhlrmrinpk vg nde Oxrbifn Ejisn, ntm bhnz cdf loyocqcnr eghjepzrwn okvoyan gnnu aaj vzy Otnzn wf Txgsn Xrvzjqn, vy cfx kutnc bo ok vgnwlye mqsfunnyz; aaj cpag gu Xlae ntm Qnqkrwhzeaz Bbagku, lbay ugem fhrn Hisee zx teie Ysl, yoaiucdr Vgswa, cbtczapz Cdfeaaina, efzctfesu Ixumrxew, ujd gu mw ayr qlbar Nica aaj Vzcjgf cqqcu Opvyleajnvt Fzclyo mne xn rvmjl xk. — Aaj owr gng kolpbxc wf gnkk Xacygaitvup, ocph n lrzm eknaujcr uw bhr vtgnacgoxv os Jkncje Cxxdiqkpuy, se zaccayra hfadtk cw enij gndee udz Lvbgk, iqr Suabuaku, shz ohx bicekf Zijoe. 直接去维吉尼亚密码破解网站进行破解就好，进行破解得到：\nWhen in the Course of human events it becomes necessary for one people to dissolve the political bands which have connected them with another and to assume among the powers of the earth, the separate and equal station to which the Laws of Nature and of Nature\u0026#39;s God entitle them, a decent respect to the opinions of mankind requires that they should declare the causes which impel them to the separation. We hold these truths to be self-evident, that all men are created equal, that they are endowed by their Creator with certain unalienable Rights, that among these are Life, Liberty and the pursuit of Happiness. — That to secure these rights, Governments are instituted among Men, deriving their just powers from the consent of the governed, — That whenever any Form of Government becomes destructive of these ends, it is the Right of the People to alter or to abolish it, and to institute new Government, laying its foundation on such principles and organizing its powers in such form, as to them shall seem most likely to effect their Safety and Happiness. Prudence, indeed, will dictate that Governments long established should not be changed for light and transient causes; and accordingly all experience hath shewn that mankind are more disposed to suffer, while evils are sufferable than to right themselves by abolishing the forms to which they are accustomed. But when a long train of abuses and usurpations, pursuing invariably the same Object evinces a design to reduce them under absolute Despotism, it is their right, it is their duty, to throw off such Government, and to provide new Guards for their future security. — Such has been the patient sufferance of these Colonies; and such is now the necessity which constrains them to alter their former Systems of Government. The history of the present King of Great Britain is a history of repeated injuries and usurpations, all having in direct object the establishment of an absolute Tyranny over these States. To prove this, let Facts be submitted to a candid world. He has refused his Assent to Laws, the most wholesome and necessary for the public good. He has forbidden his Governors to pass Laws of immediate and pressing importance, unless suspended in their operation till his Assent should be obtained; and when so suspended, he has utterly neglected to attend to them. He has refused to pass other Laws for the accommodation of large districts of people, unless those people would relinquish the right of Representation in the Legislature, a right inestimable to them and formidable to tyrants only. He has called together legislative bodies at places unusual, uncomfortable, and distant from the depository of their Public Records, for the sole purpose of fatiguing them into compliance with his measures. He has dissolved Representative Houses repeatedly, for opposing with manly firmness his invasions on the rights of the people. He has refused for a long time, after such dissolutions, to cause others to be elected, whereby the Legislative Powers, incapable of Annihilation, have returned to the People at large for their exercise; the State remaining in the mean time exposed to all the dangers of invasion from without, and convulsions within. He has endeavoured to prevent the population of these States; for that purpose obstructing the Laws for Naturalization of Foreigners; refusing to pass others to encourage their migrations hither, and raising the conditions of new Appropriations of Lands. He has obstructed the Administration of Justice by refusing his Assent to Laws for establishing Judiciary Powers. He has made Judges dependent on his Will alone for the tenure of their offices, and the amount and payment of their salaries. flag is afctf{Whooooooo_U_Gotcha!} He has erected a multitude of New Offices, and sent hither swarms of Officers to harass our people and eat out their substance. He has kept among us, in times of peace, Standing Armies without the Consent of our legislatures. He has affected to render the Military independent of and superior to the Civil Power. He has combined with others to subject us to a jurisdiction foreign to our constitution, and unacknowledged by our laws; giving his Assent to their Acts of pretended Legislation: For quartering large bodies of armed troops among us: For protecting them, by a mock Trial from punishment for any Murders which they should commit on the Inhabitants of these States: For cutting off our Trade with all parts of the world: For imposing Taxes on us without our Consent: For depriving us in many cases, of the benefit of Trial by Jury: For transporting us beyond Seas to be tried for pretended offences: For abolishing the free System of English Laws in a neighbouring Province, establishing therein an Arbitrary government, and enlarging its Boundaries so as to render it at once an example and fit instrument for introducing the same absolute rule into these Colonies For taking away our Charters, abolishing our most valuable Laws and altering fundamentally the Forms of our Governments: For suspending our own Legislatures, and declaring themselves invested with power to legislate for us in all cases whatsoever. He has abdicated Government here, by declaring us out of his Protection and waging War against us. He has plundered our seas, ravaged our coasts, burnt our towns, and destroyed the lives of our people. He is at this time transporting large Armies of foreign Mercenaries to compleat the works of death, desolation, and tyranny, already begun with circumstances of Cruelty \u0026amp; Perfidy scarcely paralleled in the most barbarous ages, and totally unworthy the Head of a civilized nation. He has constrained our fellow Citizens taken Captive on the high Seas to bear Arms against their Country, to become the executioners of their friends and Brethren, or to fall themselves by their Hands. He has excited domestic insurrections amongst us, and has endeavoured to bring on the inhabitants of our frontiers, the merciless Indian Savages whose known rule of warfare, is an undistinguished destruction of all ages, sexes and conditions. In every stage of these Oppressions We have Petitioned for Redress in the most humble terms: Our repeated Petitions have been answered only by repeated injury. A Prince, whose character is thus marked by every act which may define a Tyrant, is unfit to be the ruler of a free people. Nor have We been wanting in attentions to our British brethren. We have warned them from time to time of attempts by their legislature to extend an unwarrantable jurisdiction over us. We have reminded them of the circumstances of our emigration and settlement here. We have appealed to their native justice and magnanimity, and we have conjured them by the ties of our common kindred to disavow these usurpations, which would inevitably interrupt our connections and correspondence. They too have been deaf to the voice of justice and of consanguinity. We must, therefore, acquiesce in the necessity, which denounces our Separation, and hold them, as we hold the rest of mankind, Enemies in War, in Peace Friends. We, therefore, the Representatives of the united States of America, in General Congress, Assembled, appealing to the Supreme Judge of the world for the rectitude of our intentions, do, in the Name, and by Authority of the good People of these Colonies, solemnly publish and declare, That these united Colonies are, and of Right ought to be Free and Independent States, that they are Absolved from all Allegiance to the British Crown, and that all political connection between them and the State of Great Britain, is and ought to be totally dissolved; and that as Free and Independent States, they have full Power to levy War, conclude Peace, contract Alliances, establish Commerce, and to do all other Acts and Things which Independent States may of right do. — And for the support of this Declaration, with a firm reliance on the protection of Divine Providence, we mutually pledge to each other our Lives, our Fortunes, and our sacred Honor. 在破解得到文字中找到flag：\nafctf{Whooooooo_U_Gotcha!} 0x2 [NPUCTF2020]这是什么🐎 # 看题目应该是个脑洞题，古典密码学题目，瞧瞧附件吧：\n附件是一个attachment文件，没有文件扩展名……那就先探测一下：\nfile attachment 得到探测输出：\nattachment: Zip archive data, at least v2.0 to extract 应该是一个压缩文件，修改文件名为attachment.zip，然后进行解压，得到了一个图片：\n（这是杂项题目，越做越不像密码学）\n这个图片应该就是密码，认真观察一下图片，发现图片底部有密文。\n对密文进行分析：\n日历的周是按英文来进行显示的 密文数组中的首字母好像对应着英文的周 因此可以根据以下思路进行解题：\n根据密码需要对应数字 将数字映射到字母表 讲字母拼接 根据思路，写个脚本求解：\nimport string c = \u0026#34;F1 W1 S22 S21 T12 S11 W1 S13\u0026#34; def encode_cal(data): encode_dict = { \u0026#39;M\u0026#39;:[], \u0026#39;T1\u0026#39;:[], \u0026#39;W\u0026#39;:[], \u0026#39;T2\u0026#39;:[], \u0026#39;F\u0026#39;:[], \u0026#39;S1\u0026#39;:[], \u0026#39;S2\u0026#39;:[] } dict_index=[\u0026#39;M\u0026#39;,\u0026#39;T1\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;T2\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;S1\u0026#39;,\u0026#39;S2\u0026#39;] index = 2 for i in range(30): encode_dict[dict_index[(index+i)%7]].append(i+1) result=\u0026#34;\u0026#34; for m in data: if len(m)==2: result += string.ascii_lowercase[encode_dict[m[0]][int(m[1])-1]-1] elif len(m)==3: result += string.ascii_lowercase[encode_dict[m[0:2]][int(m[2])-1]-1] return result if __name__ == \u0026#34;__main__\u0026#34;: c_list = c.split(\u0026#34; \u0026#34;) flag = encode_cal(c_list) print(flag) 运行脚本，游戏结束！\ncalendar 0x3 easyrsa # rsa题目，来，让我们暴打出题人！\n附件是个python源码程序\nfrom Crypto.Util.number import getPrime,bytes_to_long from sympy import Derivative from fractions import Fraction from secret import flag p=getPrime(1024) q=getPrime(1024) e=65537 n=p*q z=Fraction(1,Derivative(arctan(p),p))-Fraction(1,Derivative(arth(q),q)) m=bytes_to_long(flag) c=pow(m,e,n) print(c,z,n) \u0026#39;\u0026#39;\u0026#39; output: 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035 32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441 \u0026#39;\u0026#39;\u0026#39; 简单审计一下，发现就是道数学题，微分方程的题目。这python程序的关键代码也只有一行：\nz=Fraction(1,Derivative(arctan(p),p))-Fraction(1,Derivative(arth(q),q)) 应该就是求解方程的事情，因为涉及数学运算，所以写个sage脚本求解吧\nfrom Crypto.Util.number import long_to_bytes c = 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035 z = 32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482 n = 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441 e = 65537 var(\u0026#39;p, q\u0026#39;) f1 = (1/diff(arctan(p),p))-(1/diff(arctanh(q),q)) f2 = p*q result = sorted(solve([f1==z,f2==n],(p,q))) p = result[1][0] q = result[1][1] p =int(str(p)[5:]) q =int(str(q)[5:]) phi = (p-1)*(q-1) d = inverse_mod(e,phi) m = pow(c,d,n) flag = long_to_bytes(m) print(flag) 由于sagemath是基于python3的开源数学软件，进行sage运行sage脚本是会转换成python格式进行运行，代码非常像python3\n运行脚本，暴打出题人！\nb\u0026#39;BJD{Advanced_mathematics_is_too_hard!!!}\u0026#39; 0x4 babyRSA # 又一个RSA题目，希望这个不单单只是数学运算了，看看题目：\nfrom Crypto.Util.number import * from flag import flag def nextPrime(n): n += 2 if n \u0026amp; 1 else 1 while not isPrime(n): n += 2 return n p = getPrime(1024) q = nextPrime(p) n = p * q e = 0x10001 d = inverse(e, (p-1) * (q-1)) c = pow(bytes_to_long(flag.encode()), e, n) # d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913 # c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804 这道题目的输出是d、c，在算法程序里面暴露出了e。但是n不知道，这就有点麻烦了。简单推导一下公式： $$ \\phi = (p-1)\\times(q-1) $$\n$$ d \\equiv e^{-1} \\text{mod}\\phi $$\n$$ d \\cdot e \\equiv 1\\text{mod} \\phi $$\n$$ d\\cdot e -1 = k \\cdot(p-1)\\cdot(q-1) $$ 根据推导，可以肯定的是这道题目需要进行爆破。为了提高爆破效率，需要进行缩小范围来进行更快求解。缩小范围需要先进行判断：p和q都是1024位，n就是2048位。进行简单的测试发现ed-1是2064位，那么可以判断出k一定是小于16位的，根据目前的推断来写脚本进行求解：\nimport libnum import sympy e = 0x10001 d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913 c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804 ed_1 = e*d-1 n = 0 for k in range(pow(2,15),pow(2,16)): if ed_1 % k == 0: phi = ed_1//k base = libnum.nroot(phi,2) p = sympy.nextprime(base) q = sympy.prevprime(base) if (p-1)*(q-1)*k == ed_1: n = p*q break m = pow(c,d,n) flag = libnum.n2s(m) print flag 求解方式比较暴力，执行脚本就拿到flag了：\nNCTF{70u2_nn47h_14_v3ry_gOO0000000d} 0x5 [AFCTF2018]你能看出这是什么加密么 # 脑洞题，看看题目推测一下这是什么加密：\np=0x928fb6aa9d813b6c3270131818a7c54edb18e3806942b88670106c1821e0326364194a8c49392849432b37632f0abe3f3c52e909b939c91c50e41a7b8cd00c67d6743b4f q=0xec301417ccdffa679a8dcc4027dd0d75baf9d441625ed8930472165717f4732884c33f25d4ee6a6c9ae6c44aedad039b0b72cf42cab7f80d32b74061 e=0x10001 c=0x70c9133e1647e95c3cb99bd998a9028b5bf492929725a9e8e6d2e277fa0f37205580b196e5f121a2e83bc80a8204c99f5036a07c8cf6f96c420369b4161d2654a7eccbdaf583204b645e137b3bd15c5ce865298416fd5831cba0d947113ed5be5426b708b89451934d11f9aed9085b48b729449e461ff0863552149b965e22b6 好常规的RSA题目，这是签到题目吧\n写个脚本解决：\nimport libnum p=0x928fb6aa9d813b6c3270131818a7c54edb18e3806942b88670106c1821e0326364194a8c49392849432b37632f0abe3f3c52e909b939c91c50e41a7b8cd00c67d6743b4f q=0xec301417ccdffa679a8dcc4027dd0d75baf9d441625ed8930472165717f4732884c33f25d4ee6a6c9ae6c44aedad039b0b72cf42cab7f80d32b74061 e=0x10001 c=0x70c9133e1647e95c3cb99bd998a9028b5bf492929725a9e8e6d2e277fa0f37205580b196e5f121a2e83bc80a8204c99f5036a07c8cf6f96c420369b4161d2654a7eccbdaf583204b645e137b3bd15c5ce865298416fd5831cba0d947113ed5be5426b708b89451934d11f9aed9085b48b729449e461ff0863552149b965e22b6 phi = (p-1)*(q-1) n = p*q d = libnum.invmod(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，拿到flag：\nafctf{R54_|5_$0_$imp13} 0x6 [ACTF新生赛2020]crypto-rsa3 # RSA算法的题目，有点意思哦！(*^_^*)\n瞅一瞅题目附件：\n有两个附件，比较常规的形式，一个是output.txt的输出文件，一个rsa3.py的算法文件\nrsa3.py：\nfrom flag import FLAG from Cryptodome.Util.number import * import gmpy2 import random e=65537 p = getPrime(512) q = int(gmpy2.next_prime(p)) n = p*q m = bytes_to_long(FLAG) c = pow(m,e,n) print(n) print(c) output.txt：\n177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683 1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049 非常常规的RSA题目，给出了n，c，e。加密算法也比较常规，其中p和q的数值比较接近，可以直接对n开方来得到p和q的数值。根据这一思路，写个脚本求解：\nimport libnum import sympy n = 177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683 c = 1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049 e = 65537 base = libnum.nroot(n,2) p = sympy.prevprime(base) q = sympy.nextprime(base) assert(p*q == n) phi = (p-1)*(q-1) d = libnum.invmod(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，得到flag：\nactf{p_and_q_should_not_be_so_close_in_value} 0x7 鸡藕椒盐味 # 题目比较奇怪，那看看题目究竟什么样的题目吧：\n公司食堂最新出了一种小吃，叫鸡藕椒盐味汉堡，售价八块钱，为了促销，上面有一个验证码，输入后可以再换取一个汉堡。但是问题是每个验证码几乎都有错误,而且打印的时候倒了一下。小明买到了一个汉堡，准备还原验证码，因为一个吃不饱啊验证码如下：1100 1010 0000 ,而且打印的时候倒了一下。把答案哈希一下就可以提交了。(答案为正确值(不包括数字之间的空格)的32位md5值的小写形式) 注意：得到的 flag 请包上 flag{} 提交 可以从题目中提炼出一些关键信息：\n验证码：1100 1010 0000 打印的时候倒了一下 哈希提交。(答案为正确值(不包括数字之间的空格)的32位md5值的小写形式) 而且打印的时候倒了一下 这些信息咋看不出来什么东西呀，嘤嘤嘤~\n仔细看看题目，鸡藕椒盐味是不是很像是奇偶校验位，应该是这个。可以沿着奇偶校验位的这个方向沿着方向走一下，看看能否找到突破的入口。沿着奇偶校验位进行探索，发现有个海明校验码的东西，而且还有一个海明纠错码。这道题目，应该是使用海明纠错码来进行纠错的，那么什么是海明码呢？可以看看这篇知乎文章大致原理都有了，根据这篇文章阐述的原理进行脚本编写，应该就可以找出答案了。写下脚本：\nimport hashlib c = \u0026#34;110010100000\u0026#34; c_r = c[::-1] c_list =[] for i in c_r: c_list.append(int(i)) h1 = c_list[2]^c_list[4]^c_list[6]^c_list[8]^c_list[10] ^ c_list[0] h2 = c_list[2]^c_list[5]^c_list[6]^c_list[9]^c_list[10] ^ c_list[1] h3 = c_list[4]^c_list[5]^c_list[6]^c_list[11] ^ c_list[3] h4 = c_list[8]^c_list[9]^c_list[10]^c_list[11] ^ c_list[7] mistake_bit = int(str(h4)+str(h3)+str(h2)+str(h1),2) if c_list[mistake_bit-1]==1: c_list[mistake_bit-1] = 0 else: c_list[mistake_bit-1] = 1 m = \u0026#34;\u0026#34; for i in c_list: m += str(i) m = m[::-1] flag = hashlib.md5(m).hexdigest() print flag 运行一下脚本，flag就有了：\nd14084c7ceca6359eaac6df3c234dd3b 0x8 [ACTF新生赛2020]crypto-classic0 # 看题目就知道，这个是古典密码学的题目，看看究竟是在考察些什么古典密码吧：\n附件文件里面有三个文件，一个cipher文本文件，一个hint.txt提示文件和一个howtoencrypt.zip加密压缩文件。\nhint.txt:\n哼，压缩包的密码？这是小Z童鞋的生日吧== 应该是压缩包文件的提示内容\n另一个cipher文件需要进行探测一下，使用file命令简单探测一下\ncipher: International EBCDIC text, with no line terminators 是一个纯文本文件，这样可以使用记事本直接打开：\nYgvdmq[lYate[elghqvakl} 这个提示应该告诉压缩文件的密码长度，这里可以使用压缩爆破工具进行爆破，经过爆破可以得到密码是19990306。使用密码进行解压得到一个c语言源程序，应该是加密算法。\nclassic0.c：\n#include\u0026lt;stdio.h\u0026gt; char flag[25] = *** int main() { int i; for(i=0;i\u0026lt;25;i++) { flag[i] -= 3; flag[i] ^= 0x7; printf(\u0026#34;%c\u0026#34;,flag[i]); } return 0; } 根据这个c程序算法设计一个逆算法应该就可以进行求解，这里写个c语言逆算法：\n#include \u0026lt;stdio.h\u0026gt; int main() { char flag[25]; FILE *fp = NULL; fp = fopen(\u0026#34;cipher.txt\u0026#34;,\u0026#34;r\u0026#34;); fgets(flag,25,fp); for(int i=0;i\u0026lt;25;i++) { flag[i] ^= 0x7; flag[i] += 3; printf(\u0026#34;%c\u0026#34;, flag[i]); } fclose(fp); return 0; } 编译并执行得到flag：\nactf{my_naive_encrytion} 0x9 [RoarCTF2019]babyRSA # RSA题目，看看这次又有什么样的惊喜！\nimport sympy import random def myGetPrime(): A= getPrime(513) print(A) B=A-random.randint(1e3,1e5) print(B) return sympy.nextPrime((B!)%A) p=myGetPrime() #A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407 #B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596 q=myGetPrime() #A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927 #B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026 r=myGetPrime() n=p*q*r #n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733 c=pow(flag,e,n) #e=0x1001 #c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428 #so,what is the flag? 代码挺长的，考察的内容是阶乘？是不是要考虑一下递归的方式进行求解？那估计慢的不得了，肯定有更好的算法进行求解，垃圾的我去翻翻了王小云院士写的数学书，发现有个叫威尔逊定理的东西可以用于算法的求解，这道题目就是考察威尔逊定理的内容。\n威尔逊定理的内容很简单： $$ (p-1)! \\equiv -1 (\\text{mod} p) $$ 其中p为素数\n根据威尔逊定理就可以对这道题目进行简单的推导求解：\n首先，了解一下算法的加密过程： $$ p \\equiv B_1! \\text{mod}A_1 $$\n$$ q\\equiv B_2! \\text{mod}A_2 $$\n$$ r \\equiv B_3! \\text{mod}A_3 $$\n$$ n = p \\cdot q \\cdot r $$\n$$ c \\equiv m ^e \\text{mod} n $$\n加密过程也是非常清晰，问题是如何更快地计算出p和q的数值，这里就需要用到威尔逊定理来进行相应的计算：\n根据代码中的算法，可以看出有一句代码表明：\nB=A-random.randint(1e3,1e5) 因此，这里可以根据这一信息使用威尔逊定理进行推导： $$ (A-1)! \\equiv -1\\text{mod}A $$\n$$ (A-1)\\cdot(A-2)\\cdot(A-3)\\dots(B+1)\\cdot(B)\\dots2\\cdot1\\equiv-1\\text{mod} A $$\n$$ (A-1)\\cdot(A-2)\\cdot(A-3)\\dots(B+1)\\cdot(B!)\\equiv-1\\text{mod} A $$\n$$ (A-1)\\cdot(A-2)\\cdot(A-3)\\dots(B+1)\\cdot(B!)\\equiv(A-1)\\text{mod} A $$\n$$ (A-2)\\cdot(A-3)\\dots(B+1)\\cdot(B!)\\equiv1\\text{mod} A $$\n因此要求(B!)%A可以通过求$(A-2)\\cdot(A-1)\\dots(B+1)$的逆元来进行优化求解，提高运算的效率，这样分析完，这道题目的大致思路也就有了。根据这个思路，写个脚本求解就好：\nimport libnum import sympy def wilson(A,B): tmp = 1 for i in range(B+1,A-1): tmp *= i tmp %= A tmp_inv = libnum.invmod(tmp,A) result = sympy.nextprime(tmp_inv) return result A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407 B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596 A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927 B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026 n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733 e=0x1001 c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428 p = wilson(A1, B1) q = wilson(A2, B2) r = n //(p*q) phi = (p-1)*(q-1)*(r-1) d = libnum.invmod(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，拿到flag\nRoarCTF{wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A} 这道题目还是挺有意思的，考的内容比较综合，是一道不错的RSA题目。\n0xA [AFCTF2018]可怜的RSA # 这次又有什么花样呢？可怜的RSA\n瞧瞧题目：\n附件里面有两个文件，一个flag.enc的密文文件和一个public.enc的公钥文件\n这道题目的思路应该是读取公钥文件，然后对公钥文件中的modulus进行大数分解，最后使用实际应用的会用到的填充方法进行解密。\n思路很简单，根据思路写个脚本：\nfrom Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP from base64 import b64decode from sympy.ntheory.factor_ import smoothness import sympy import libnum with open(\u0026#34;public.key\u0026#34;,\u0026#34;rb\u0026#34;) as f: rsakey = RSA.importKey(f.read()) n = rsakey.n e = rsakey.e result = sympy.factorint(n) p = long(result.keys()[0]) q = long(result.keys()[1]) phi = (p-1)*(q-1) d = libnum.invmod(e,phi) key_info = RSA.construct((n,e,d,p,q)) key = RSA.importKey(key_info.exportKey()) key = PKCS1_OAEP.new(key) with open(\u0026#34;flag.enc\u0026#34;,\u0026#34;rb\u0026#34;) as f: c = b64decode(f.read()) flag = key.decrypt(c) print flag 运行脚本，得到flag：\nafctf{R54_|5_$0_B0rin9} 这道题目比较偏向于应用方面，涉及到了RSA的加密算法填充方法，不再是裸露再外面的RSA算法。可以进一步了解一下。\n0xB 救主捷径 # 救主捷径，应该是一个脑洞题目，看看题目：\n一个名叫CPU的神秘大陆有26个国家，有些国家之间会有一条无向路，每条路径都有不同的长度和一段神秘代码，救世主尼奥要从国家1出发，赶往国家26拯救大陆，请你帮助救世主选择最短路径，而走过的路的神秘代码连接起来便是flag。 以下是数行数据，每行第一个，第二个数字代表这条路的两个端点国家，第三个数字代表路途长度，最后一个字符串便是神秘代码。路在附件中~ 帮助救世主尼奥吧，他快被吓尿了。。。 注意：得到的 flag 请包上 flag{} 提交 看样子应该是广度优先算法的应用，题目中只说到了距离，没有涉及权重，应该就是广度优先算法，看看附件是什么吧！\n1 2 100 FLAG{ 2 3 87 AFQWE 2 4 57 ETKLS 2 5 50 WEIVK 2 6 51 AWEIW 3 7 94 QIECJF 3 8 78 QSXKE 3 9 85 QWEIH 4 13 54 WQOJF 4 14 47 KDNVE 4 15 98 QISNV 5 10 43 AEWJV 5 11 32 QWKXF 5 12 44 ASJVL 6 16 59 ASJXJ 6 17 92 QJXNV 6 18 39 SCJJF 6 23 99 SJVHF 7 19 99 WJCNF 8 20 96 SKCNG 9 20 86 SJXHF 10 21 60 SJJCH 11 21 57 SJHGG 12 22 47 SJCHF 14 10 55 EJFHG 16 17 59 ASJVH 18 12 53 SJFHG 18 24 93 SHFVG 21 22 33 SJFHB 19 25 88 ASHHF 20 25 96 SJVHG 22 25 23 SJVHJ 25 26 75 SDEV} 根据附件文件绘制个图，也方便进行广度优先算法的使用和计算：\n根据图示来使用广度优先算法的设计，这里可以使用比较经典的Dijkstra算法来求解最优问题，使用python进行算法实现：\nimport networkx as nx def Dijkstra(G, start, end): RG = G.reverse(); dist = {}; previous = {} for v in RG.nodes(): dist[v] = float(\u0026#39;inf\u0026#39;) previous[v] = \u0026#39;none\u0026#39; dist[end] = 0 u = end while u != start: u = min(dist, key=dist.get) distu = dist[u] del dist[u] for u, v in RG.edges(u): if v in dist: alt = distu + RG[u][v][\u0026#39;weight\u0026#39;] if alt \u0026lt; dist[v]: dist[v] = alt previous[v] = u path = (start,) last = start while last != end: nxt = previous[last] path += (nxt,) last = nxt return path G = nx.DiGraph() datalist = [] datadict = {} with open(\u0026#34;data.txt\u0026#34;,\u0026#34;rb\u0026#34;) as f: lines = f.readlines() for line in lines: line = line.strip(\u0026#34;\\r\\n\u0026#34;) datalist.append(line) for i in datalist: data = i.split(\u0026#34; \u0026#34;) datadict[data[0]+\u0026#34;-\u0026#34;+data[1]] = data[3] G.add_edge(int(data[0]),int(data[1]),weight=int(data[2])) rs = Dijkstra(G, 1, 26) flag = \u0026#34;\u0026#34; for i in range(len(rs)-1): flag += datadict[str(rs[i])+\u0026#34;-\u0026#34;+str(rs[i+1])] print flag print flag.lower() 运行脚本，即可获得flag：\nFLAG{WEIVKASJVLSJCHFSJVHJSDEV} flag{weivkasjvlsjchfsjvhjsdev} 0xC [网鼎杯 2020 青龙组]boom # 这道题目，boom的意思爆炸，这道题目应该会有点意思。\n来看看题目呀：\n看到附件内容是一个exe文件，可执行文件，有点像是逆向题目。首先执行一下exe程序，看看程序会给我们展示什么样的效果？\n按一下任意键：\n应该是一个进行答题的exe程序，这里有两条路可以走，第一条路就是通过答题来拿到flag，而第二条路就是通过逆向工具进行逆向。下面绘制一个拓扑图来看看这道题目的思路：\n无论怎么走，都需要解决题目的问题，这道题目的本意应该是考察数学技能，这道题目就使用IDA逆向工具进行分析，打开IDA看到伪代码：\nint __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax char Str[50]; // [esp+24h] [ebp-128h] BYREF unsigned __int8 v6[50]; // [esp+56h] [ebp-F6h] BYREF _DWORD v7[16]; // [esp+88h] [ebp-C4h] unsigned int v8[22]; // [esp+C8h] [ebp-84h] BYREF __int64 v9; // [esp+120h] [ebp-2Ch] BYREF int v10; // [esp+12Ch] [ebp-20h] BYREF int v11; // [esp+130h] [ebp-1Ch] BYREF int v12; // [esp+134h] [ebp-18h] BYREF int v13; // [esp+138h] [ebp-14h] int i; // [esp+13Ch] [ebp-10h] __main(); menu(); system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); v7[0] = 70; v7[1] = 229; v7[2] = 239; v7[3] = 230; v7[4] = 22; v7[5] = 90; v7[6] = 90; v7[7] = 251; v7[8] = 54; v7[9] = 18; v7[10] = 23; v7[11] = 68; v7[12] = 106; v7[13] = 45; v7[14] = 189; v7[15] = 1; puts(\u0026#34;first:this string md5:46e5efe6165a5afb361217446a2dbd01\u0026#34;); scanf(\u0026#34;%s\u0026#34;, Str); MD5Init(v8); v3 = strlen(Str); MD5Update((int)v8, Str, v3); MD5Final(v8, v6); v13 = 1; for ( i = 0; i \u0026lt;= 15; ++i ) { if ( v6[i] != v7[i] ) { v13 = 0; break; } } if ( v13 != 1 ) { printf(\u0026#34;Game over\u0026#34;); system(\u0026#34;pause\u0026#34;); exit(0); } puts(\u0026#34;Great next level\u0026#34;); system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); puts(\u0026#34;This time:Here are have some formulas\u0026#34;); puts(\u0026#34;3x-y+z=185\u0026#34;); puts(\u0026#34;2x+3y-z=321\u0026#34;); puts(\u0026#34;x+y+z=173\u0026#34;); printf(\u0026#34;input: x = \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;v12); printf(\u0026#34;input: y = \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;v11); printf(\u0026#34;input : z = \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;v10); if ( 3 * v12 - v11 + v10 != 185 || 2 * v12 + 3 * v11 - v10 != 321 || v11 + v12 + v10 != 173 ) { printf(\u0026#34;Game over\u0026#34;); exit(0); } printf(\u0026#34;Great last level coming...\u0026#34;); printf(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); puts(\u0026#34;Last time: Kill it\u0026#34;); puts(\u0026#34;x*x+x-7943722218936282=0\u0026#34;); printf(\u0026#34;input x: \u0026#34;); scanf(\u0026#34;%lld\u0026#34;, \u0026amp;v9); if ( v9 * (v9 + 1) != 0x1C38C5F50DD7DALL ) { printf(\u0026#34;Game over\u0026#34;); exit(0); } puts(\u0026#34;Great This is your FLAG\u0026#34;); return 0; } 可以从逆向的伪代码中找到一些比较关键的代码：\n原始内存数据\nsystem(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); v7[0] = 70; v7[1] = 229; v7[2] = 239; v7[3] = 230; v7[4] = 22; v7[5] = 90; v7[6] = 90; v7[7] = 251; v7[8] = 54; v7[9] = 18; v7[10] = 23; v7[11] = 68; v7[12] = 106; v7[13] = 45; v7[14] = 189; v7[15] = 1; level 1关键代码\nputs(\u0026#34;first:this string md5:46e5efe6165a5afb361217446a2dbd01\u0026#34;); scanf(\u0026#34;%s\u0026#34;, Str); MD5Init(v8); v3 = strlen(Str); MD5Update((int)v8, Str, v3); MD5Final(v8, v6); v13 = 1; for ( i = 0; i \u0026lt;= 15; ++i ) { if ( v6[i] != v7[i] ) { v13 = 0; break; } } if ( v13 != 1 ) { printf(\u0026#34;Game over\u0026#34;); system(\u0026#34;pause\u0026#34;); exit(0); } puts(\u0026#34;Great next level\u0026#34;); system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); level 2关键代码\nputs(\u0026#34;This time:Here are have some formulas\u0026#34;); puts(\u0026#34;3x-y+z=185\u0026#34;); puts(\u0026#34;2x+3y-z=321\u0026#34;); puts(\u0026#34;x+y+z=173\u0026#34;); printf(\u0026#34;input: x = \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;v12); printf(\u0026#34;input: y = \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;v11); printf(\u0026#34;input : z = \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;v10); if ( 3 * v12 - v11 + v10 != 185 || 2 * v12 + 3 * v11 - v10 != 321 || v11 + v12 + v10 != 173 ) { printf(\u0026#34;Game over\u0026#34;); exit(0); } printf(\u0026#34;Great last level coming...\u0026#34;); printf(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); level 3关键代码\nputs(\u0026#34;Last time: Kill it\u0026#34;); puts(\u0026#34;x*x+x-7943722218936282=0\u0026#34;); printf(\u0026#34;input x: \u0026#34;); scanf(\u0026#34;%lld\u0026#34;, \u0026amp;v9); if ( v9 * (v9 + 1) != 0x1C38C5F50DD7DALL ) { printf(\u0026#34;Game over\u0026#34;); exit(0); } puts(\u0026#34;Great This is your FLAG\u0026#34;); return 0; } 根据三个关键代码进行代码审计，代码审计还是老基本功了\nlevel 1的关键代码是判断md5值的，使用[cmd5](md5在线解密破解,md5解密加密 (cmd5.com))就可以解出，即：\nStr = \u0026#34;en5oy\u0026#34;; level 2的关键代码是解方程组，使用sage求解：\nvar(\u0026#34;x y z\u0026#34;) solve([3*x-y+z==185,2*x+3*y-z==321,x+y+z==173],x,y,z) 运行就可以求解得出x，y和z的值：\n[[x == 74, y == 68, z == 31]] 因此，可以得到：\nv12 == 74; v11 == 68; v10 == 31; leve 3的关键代码就是解一元二次方程或者可以简化，就是解v9 * (v9 + 1) == 7943722218936282，可以使用sage直接进行求解：\nsolve(x * (x + 1) == 7943722218936282,x) 运行可得：\n[x == 89127561, x == -89127562] 由此，可以得到：\nv9 == 89127561; 然后进行组合就可以得到flag：\nflag{en5oy_746831_89127561} 0xD [RoarCTF2019]RSA # 又来了一道RSA题目，看看有些什么东西吧！\nA=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x p=next_prime(z*x*y) q=next_prime(z) A = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724 n = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127 c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128 这道题目涉及到了模线性方程，需要考虑模线性方程该如何进行求解。目前，我尚未找到除了爆破外的解法，因此，这次就用爆破来求解，但是要用爆破求解就必然需要考虑爆破时间，如何来缩短爆破时间。\n再来看看题目：\n题目给定了$A$ 、$n$ 、$c$ ，且满足\n$$ A = [ (y \\text{ % } x ) ^ 5 \\text{ % } ( x \\text{ % } y ) ] ^ {2019} + y ^ {316} + \\frac{y+1}{x} $$\n根据方程可以得知 $x | y+1$ 因此，可以推断出来 $ y \\equiv -1 \\text{mod}x$ 。而且由于 $ y+1$ 比 $x$ 大，因此，应该有$x%y=x$ 。于是：\n$$ [(y\\text{ % }x)^5\\text{ % }(x\\text{ % }y)]^{2019} = (x-1)^{2019} $$\n因此，可以得到：\n$$ A = (x-1)^{2019} + y^{316} + \\frac{y+1}{x} $$\n通过观察发现$A$的值是一个2015个bit的数。而且：\n$$ A \\geq (x-1)^{2019} $$\n显然只有：\n$$ x \\leq 2 $$\n因此进行讨论$x=1 $和$x =2$这两种情况时，发现存在有唯一解，即：\n$$ (x,y) = (2,83) $$\n现在$ x $和$ y $知道了，看一下算法的其他细节吧\np=next_prime(z*x*y) q=next_prime(z) 由于已经知道了$x$和$y$ ，因此，可以知道： $$ n = p \\cdot q $$\n$$ n = z\\cdot x \\cdot y \\cdot z $$\n因此可以推出： $$ q \\approx \\sqrt{\\frac{n}{x\\cdot y}} $$\n$$ p \\approx x\\cdot y \\cdot q $$\n于是可以通过爆破求出 $p$ 和 $q$ 来进行求解，但是题目没有告知 $e$ ，可以先猜测 $e = 65537$ 。根据这个思路写个完整脚本：^1^\nimport libnum, gmpy2, itertools A = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724 n = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127 c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128 x , y = 2, 83 A_t = (((y%x)**5)%(x%y))**2019+y**316+(y+1)/x assert A_t == A for q in itertools.count(gmpy2.iroot(n//166,2)[0]): if n%q == 0: break p = n//q assert n == p*q e = 65537 phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = gmpy2.powmod(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，即可得到flag：\nRoarCTF{wm-l1l1ll1l1l1l111ll} 这道题目的求解方法是优雅与暴力相结合的，能展现出一种特别的美感，数学推导的优雅和蛮力攻击的暴力。野蛮与优雅，展现出密码学独有美，题目还是挺不错的。\n0xE [AFCTF2018]Single # 单一的，看看题目给了我们什么包裹吧！\n一个Cipher.txt密文文件和一个Encode.cpp加密文件。\nEncode.cpp\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { freopen(\u0026#34;Plain.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;Cipher.txt\u0026#34;,\u0026#34;w\u0026#34;,stdout); map\u0026lt;char, char\u0026gt; f; int arr[26]; for(int i=0;i\u0026lt;26;++i){ arr[i]=i; } random_shuffle(arr,arr+26); for(int i=0;i\u0026lt;26;++i){ f[\u0026#39;a\u0026#39;+i]=\u0026#39;a\u0026#39;+arr[i]; f[\u0026#39;A\u0026#39;+i]=\u0026#39;A\u0026#39;+arr[i]; } char ch; while((ch=getchar())!=EOF){ if(f.count(ch)){ putchar(f[ch]); }else{ putchar(ch); } } return 0; } Cipher.txt\nJmqrida rva Lfmz (JRL) eu m uqajemf seny xl enlxdomrexn uajiderc jxoqarerexnu. Rvada mda rvdaa jxooxn rcqau xl JRLu: Paxqmdyc, Mrrmjs-Yalanja mny oekay. Paxqmdyc-urcfa JRLu vmu m jxiqfa xl giaurexnu (rmusu) en dmnza xl jmrazxdeau. Lxd akmoqfa, Wab, Lxdanuej, Jdcqrx, Benmdc xd uxoarvenz afua. Ramo jmn zmen uxoa qxenru lxd atadc uxftay rmus. Oxda qxenru lxd oxda jxoqfejmray rmusu iuimffc. Rva nakr rmus en jvmen jmn ba xqanay xnfc mlrad uxoa ramo uxfta qdatexiu rmus. Rvan rva zmoa reoa eu xtad uio xl qxenru uvxwu cxi m JRL wenad. Lmoxiu akmoqfa xl uijv JRL eu Yaljxn JRL gimfu. Waff, mrrmjs-yalanja eu mnxrvad enradaurenz seny xl jxoqarerexnu. Vada atadc ramo vmu xwn narwxds(xd xnfc xna vxur) werv tifnmdmbfa uadtejau. Cxid ramo vmu reoa lxd qmrjvenz cxid uadtejau mny yatafxqenz akqfxeru iuimffc. Ux, rvan xdzmnehadu jxnnajru qmdrejeqmnru xl jxoqarerexn mny rva wmdzmoa urmdru! Cxi uvxify qdxrajr xwn uadtejau lxd yalanja qxenru mny vmjs xqqxnanru lxd mrrmjs qxenru. Veurxdejmffc rveu eu m ledur rcqa xl JRLu, atadcbxyc snxwu mbxir YAL JXN JRL - uxoarvenz fesa m Wxdfy Jiq xl mff xrvad jxoqarerexnu. Oekay jxoqarerexnu omc tmdc qxuuebfa lxdomru. Er omc ba uxoarvenz fesa wmdzmoa werv uqajemf reoa lxd rmus-bmuay afaoanru (a.z. IJUB eJRL). JRL zmoau xlran rxijv xn omnc xrvad muqajru xl enlxdomrexn uajiderc: jdcqrxzdmqvc, urazx, benmdc mnmfcueu, datadua anzanaadenz, oxbefa uajiderc mny xrvadu. Zxxy ramou zanadmffc vmta urdxnz useffu mny akqadeanja en mff rvaua euuiau. Iuimffc, lfmz eu uxoa urdenz xl dmnyxo ymrm xd rakr en uxoa lxdomr. Akmoqfa mljrl{Xv_I_lxiny_er_neja_rDc} 看样子，应该是一个替换加密的题目。可以直接扔进词频分析网站进行词频分析来求解，得到求解结果：\nCapture the Flag (CTF) is a special kind of information security competitions. There are three common types of CTFs: Jeopardy, Attack-Defence and mixed. Jeopardy-style CTFs has a couple of questions (tasks) in range of categories. For example, Web, Forensic, Crypto, Binary or something else. Team can gain some points for every solved task. More points for more complicated tasks usually. The next task in chain can be opened only after some team solve previous task. Then the game time is over sum of points shows you a CTF winer. Famous example of such CTF is Defcon CTF quals. Well, attack-defence is another interesting kind of competitions. Here every team has own network(or only one host) with vulnarable services. Your team has time for patching your services and developing exploits usually. So, then organizers connects participants of competition and the wargame starts! You should protect own services for defence points and hack opponents for attack points. Historically this is a first type of CTFs, everybody knows about DEF CON CTF - something like a World Cup of all other competitions. Mixed competitions may vary possible formats. It may be something like wargame with special time for task-based elements (e.g. UCSB iCTF). CTF games often touch on many other aspects of information security: cryptography, stego, binary analysis, reverse engeneering, mobile security and others. Good teams generally have strong skills and experience in all these issues. Usually, flag is some string of random data or text in some format. Example afctf{Oh_U_found_it_nice_tRy} 快瞧，flag就在最后一行！这题就这么完了，有工具真是好(*^_^*)\n0xF [WUSTCTF2020]B@se # 看题目，应该是一道BASE的题目。看看附件会给些什么吧！\n密文：MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD== JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/ oh holy shit, something is missing... 这道题目的应该是变换了编码表的base64，修改并替换一下使用base64进行解密，但是变换后的编码表中有四个字母是顺序位置，因此可能会有24种可能的情况。需要进行爆破，首先要知道是那些字符缺失了，然后对缺失字符的数组进行爆破，然后在使用base64替换来进行base64的求解。根据这个思路来写个脚本：\nimport base64 import string import itertools base64_stand = string.uppercase+string.lowercase+string.digits+\u0026#34;+/\u0026#34; new_base64 = \u0026#34;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/\u0026#34; lose_letters =\u0026#34;\u0026#34; c = \u0026#34;MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD==\u0026#34; flags = [] def base64_change(c,s,n): result = \u0026#34;\u0026#34; for i in c: if n.find(i) != -1: result += s[n.find(i)] else: result += i result = base64.b64decode(result) if len(result)+2 == len(repr(result)): return result else: return for i in base64_stand: test = new_base64.find(i) if test == -1: lose_letters += i for i in list(itertools.permutations(lose_letters,4)): m = \u0026#34;\u0026#34;.join(i) base64_new = new_base64.replace(\u0026#34;****\u0026#34;, m) flag = base64_change(c, base64_stand, base64_new) if flag and \u0026#34;2020\u0026#34; in flag: flags.append(flag) for flag in set(flags): print flag 运行脚本，得到可能的flag：\nwctf2020{base64_1s_v3ry_e@sy_and_fuN} wctf2020{bare64_!r_v2ry_e@ry_and_fuN} 经过测试，flag应该是：\nwctf2220{base64_1s_v3ry_e@sy_and_fuN} 本题到此结束！\n参考 # CTF RSA题解集 (ruanx.net) ","date":"July 1, 2021","permalink":"/posts/buuctf-crypto-5_writeup/","section":"Posts","summary":"密码学百题计划启动！进行勇往直前！\n本次的16道题目，也是非常有意思的呢！各种各样的呢……\n0x0 浪里淘沙 # 看样子，应该是个脑洞题没错了\n来康康这题的题目：\n我有密集恐惧症，所以大家自求多福吧，把获得的单词连在一起提交即可。（我这里有一串数字：4，8，11，15，16） 注意：得到的 flag 请包上 flag{} 提交 这题目好像有点意思，可以从题目中提炼一些信息：\n密集恐惧症 获得的单词连在一起提交 我这里有一串数字：4，8，11，15，16 根据提炼的数据进行分享，应该是词频统计类的题目，这题有点意思\n看看附件是啥吧：\ntonightsuccessnoticenoticewewesuccesstonightweexamplecryptoshouldwebackspacetonightbackspaceexamplelearnwesublimlearnbackspacetheshouldwelearnfoundsublimsystemexamplesublimfoundlearnshouldmorningsublimsystemuserlearnthecryptomorningexamplenoticetonightlearntonightlearntonightsublimenterusermorningfoundtonightweenterfoundnoticethecryptomorningthebackspacelearntonightlearnsublimtonightlearnfoundenterfoundsuccesstonightsuccessuserfoundmorningtonighttheshouldsublimentertonightenterbackspacelearnexamplenoticeexamplefoundsystemsuccesssublimsuccessshouldtonightcryptowelearncryptofoundshouldsublimsublimweentertonightsuccessshouldentertheentercryptouserbackspaceshouldentersystemsuccesssystementerfoundenterlearnexampletonightnoticemorningusertonightlearnmorningtonightfoundfoundsuccessnoticesystementerlearnexamplebackspaceshouldcryptocryptosublimweexampletonighttheshouldthemorningbackspacelearntonightsystemsuccesssuccessbackspacemorningnoticeuserfoundfoundtonightmorningenterenterthefoundbackspacelearnenterentershouldthesystemfounduserlearnlearnsystemnoticetonighttheshouldlearnuserbackspaceweusernoticeshouldthewefoundsystemwecryptocryptowethebackspacesystementershouldtonightsystemnoticemorningsystemweentermorningfoundsuccessusertonightsuccesstonightbackspaceshouldweenterthewesystemusernoticesystemthelearnexamplelearnfoundlearnnoticeexamplesystemthecryptocryptolearnsystemthecryptoenterlearnexamplemorningmorningweenterentersuccessexampleuserthebackspacenoticesublimenterbackspacesuccessbackspacethesublimexamplesystemtheexamplecryptolearnuserexamplelearnsystemusersuccessenterentersuccesstheuserbackspacelearnsuccessbackspacethesublimshouldwebackspaceexamplesuccesssuccesstonightweusershouldsuccessmorningcryptomorningfoundbackspacesublimshouldentershouldnoticesuccessmorningsuccessexamplelearnshouldsublimlearntonightshoulduserbackspacesublimlearncryptosuccessenternoticetonightmorningtonightwesuccessweuserbackspaceexamplewesystemnoticemorningsystemmorningcryptolearnsystemthethefoundcryptouserlearnusersystemwemorningenterexampleshouldlearncryptofoundenterbackspacelearnenterenterbackspaceshouldbackspacetheshouldthesystemshouldshouldsuccessmorningthefoundsystementersystemtonightcryptowelearnexampleexamplesystementerbackspaceshouldtheentersublimtonightfoundfoundsuccesssuccesssystemsublimcryptoshouldentersublimmorninglearnfoundtonightcryptobackspacesuccesscryptowebackspacefoundshouldnoticeshouldmorningnoticesystemcryptosystemlearnsystemnoticemorningsystementerwemorninglearnsuccessfoundwesuccesswetheusercryptousernoticebackspacesuccessshouldtonightmorningentermorninguserenternoticefoundmorningwetonightsystemthecryptotonightcryptosystemuserthefoundexampletonightusersystemcryptosublimmorninguserthefoundbackspaceshouldsuccesscryptotonightsystemnoticebackspaceusershouldenterthecryptomorningwesublimnoticesuccessnoticeusersuccesstonightlearnweuserenterfounduserexampleshouldshouldtonightwelearnthenoticethewefoundmorningexampleshouldexamplethesuccessnoticeenterfoundthecryptonoticeuserlearnuserweenterfoundmorningsystemweexamplenoticethebackspaceexamplesublimtheusermorningtonightthesuccesscryptosuccessusersuccesstonighttonightwelearnenterenterthemorningentersystemcryptobackspacemorningsystemexamplecryptouserexamplelearnsublimsuccessusersystemfoundmorningshouldcryptotonightsublimtheexamplemorningsystemuserexampleweexamplenoticesuccesssublimnoticecryptoshouldbackspaceshouldthetonightfoundsublimbackspacebackspacetonightshouldbackspacesuccesstonightbackspacesuccessmorningsystemcryptobackspaceentertonighttonightnoticelearnshoulduserfoundexamplesystemthesuccessweusertonightcryptousernoticeenternoticebackspaceusersystemfoundusernoticeshouldlearnuserfoundexampleusermorningshouldsuccessmorningmorningexampleexamplefoundsublimfoundenterbackspacenoticelearnfoundmorningcryptonoticecryptoshouldweshouldtonightcryptobackspacesublimcryptosublimenterentersublimentercryptonoticethethesublimexampleenterentershouldlearncryptoentershouldmorninglearnnoticeuserexamplesublimtonightshouldfoundtonightsuccessshouldmorningfoundtheweuserlearnsublimsystembackspacecryptotheusertonightcryptosublimmorningmorningexamplenoticetheenterlearnshouldmorningsublimfoundtonightsublimsublimexamplefounduserexamplethefoundwemorningnoticefoundcryptosuccesssublimsublimexamplethesuccessexamplenoticesuccessbackspacesublimlearnuserexamplesuccesssuccesssystemsuccessmorningmorninglearnexamplemorningtonightfoundbackspaceenternoticemorningentersuccessmorningusermorningbackspacelearncryptoenteruserenteruserthetonighttonightsuccesslearnenterfoundsuccesssystemfoundbackspaceenterlearnsystemsublimcryptoentermorningwetonightshouldlearnenterfoundcryptonoticelearnlearnshouldfoundsuccessexampletonightthesuccessfoundusertonightenterfoundsuccessshouldmorningusernoticemorningsystemsystemsuccessshouldwelearnenterfoundexamplewethefoundweshouldsystemsystemmorningmorningbackspaceshouldentersublimentertonightsuccesssystemsystemcryptousershouldsublimfoundwetonightnoticeexamplewewesuccessfoundusertonightfoundsystemexamplecryptofoundshouldshouldsuccessenterbackspaceexampletonightthelearnnoticeuserlearnsystemsublimfoundlearnsuccesssystemshouldsublimnoticelearnsystemnoticetonightexamplefoundusernoticeenterlearnnoticecryptousersystemmorningthewesystemfoundfoundshouldsystementerenterbackspacesystemsublimcryptousermorninglearnlearntonightsublimlearnenterenterbackspacesystemuserusercryptoentershouldtheusersublimnoticeexamplemorningexamplesublimsublimbackspacesystemexampleshouldsublimlearnfoundenterbackspacelearnmorningmorningfoundthetonightmorningnoticeenterlearnusersystemtonightbackspaceexamplelearntonightbackspaceweshouldcryptosuccessbackspaceexamplesuccesstheshouldmorninguserbackspacelearnthetheshouldcryptocryptotonightbackspacecryptocryptobackspacebackspacenoticeusertonightentermorningfoundweenterexampleenterfoundusersublimsystemtheexampleexamplesystemsuccessusersublimentermorningbackspacesystemfoundlearnsystemshouldsublimsublimentershouldtheusershouldexampleexampleshouldsuccesswelearnfoundsublimshoulduserweentertonightwenoticesublimsystemlearnshouldfoundsuccessuserentersuccessmorningcryptoenteruserfoundexampletonightlearnexampleexamplefoundlearnsuccesssystembackspacecryptonoticethefoundbackspacelearncryptothelearnlearnexamplesuccessnoticenoticesystemmorningcryptotonightnoticenoticeentersuccesscryptoenterbackspacesublimexampleenterfoundtonightcryptotonightsublimnoticesuccesssublimtheentertonighttheshouldthefoundsystemtonightuserbackspacesuccessshouldwebackspacenoticebackspacebackspacenoticewecryptobackspacebackspaceusertonightlearnsuccessmorningusertonightsuccessshouldbackspacecryptoenterentershouldsublimsystemexamplemorningcryptonoticethesuccessthebackspacenoticelearnsublimlearnsuccesscryptothesuccessenternoticecryptosystemsublimsuccesswebackspaceuserenterlearnuserwewemorningsuccesslearncryptobackspacewecryptosystemlearnenterenteruserexamplefoundsystemcryptousernoticefoundusersublimbackspacewesublimnoticemorningshouldexamplenoticecryptoshouldtonightmorningthefoundsystementerentersystemthecryptobackspacesublimlearnsuccessmorningsublimsystemcryptousersublimwesuccessmorningsublimbackspacecryptobackspacesublimthelearnsuccesssublimlearncryptoweweexamplecryptowenoticelearnfoundbackspacesystemsystemexampleshouldlearnsuccesssublimcryptobackspacetonightbackspacemorningmorningnoticeshouldnoticefoundthetheshouldtheshouldfoundfoundcryptosuccessbackspacesuccessshouldweenternoticeweweshouldmorningfoundusersuccessbackspacewenoticeusersuccessenterenterexamplelearnfoundwetonightusercryptothesublimsublimtonightsuccesslearnbackspacetonightentertonightthesublimnoticewefoundcryptobackspaceenterenterlearnlearntonightexamplesystementersublimnoticecryptoshoulduseruserbackspaceuserwesublimmorningwesystemshouldtonighttheusershouldnoticefoundusernoticeentersublimwethewefoundfoundlearnfoundwecryptosystemexamplemorningcryptocryptosublimtheexamplenoticefoundlearnwelearnmorningtheenterthesystemsublimtonightsuccesssystemlearnshouldenterbackspaceentersuccesssuccessbackspaceexamplenoticeentershouldsublimlearnbackspacetheshouldexamplelearnsystemusersublimbackspacebackspacesuccesswelearntonightexamplewecryptoenterwesystemsystemsublimexamplecryptolearnmorningsublimfoundsublimfoundbackspacefoundtonighttonightnoticesuccesssuccessexampleusersuccesstonightsublimcryptosystemweenterexamplesystemthethenoticesublimtonightbackspacenoticesystemexamplethesuccesstonightmorningsuccesstonightwenoticesublimtonightwelearntonightmorningsublimbackspaceenterthetonightenterwecryptofoundtheenternoticebackspacesuccesswesystemuserexamplebackspaceentersuccesstonightsublimwemorningsuccesssuccesswesublimsuccessnoticesublimfoundlearnlearnweexamplecryptonoticelearnweusershoulduserfoundcryptolearnfoundmorningtonightmorningmorningnoticewecryptowewesuccessfoundsublimweuserentershouldshouldshouldsublimbackspacetonightenterwesublimsuccessshouldfoundthethetonightwecryptoweenterfoundcryptoshouldcryptouseruserfoundentersublimsublimthelearntheshouldnoticebackspacefoundsuccessshouldtonightentermorningsystemmorningtonightwenoticelearnbackspaceexampleusershouldnoticesublimsublimexamplethesuccessnoticesystemmorningnoticecryptosystemsublimcryptosystemsuccessshouldmorningbackspaceshouldmorninglearnnoticenoticeshouldthewewesublimsublimnoticeusersuccessentersystemfoundshouldshouldcryptobackspaceusermorningsystemshouldshouldtonightwesublimuserfoundlearnbackspacethetonightmorningexampleuserthefoundbackspaceshouldtonightcryptocryptofounduserexamplenoticecryptousernoticethenoticeshouldweshouldfoundwemorningcryptosuccesslearnfoundtonightsublimnoticenoticewefoundwewesuccesssublimsublimcryptoweexampletonightsuccessfoundshouldsuccesstonightbackspacesystemshouldwesystemnoticebackspaceusersystembackspacewenoticelearnnoticenoticesuccesslearntonightuserlearnsuccessbackspacesuccesswesystemusercryptonoticethesystemusernoticewethesuccessweshouldfoundshouldcryptomorningtonightwethewesuccesslearntheshouldweexampletonightsuccessnoticenoticemorningfoundmorningfoundusersublimsystemsuccessbackspacesuccessmorninguserthefoundweexamplemorningsublimlearnfoundfoundnoticemorningshouldweuserwemorningexamplesuccesssuccessfoundthetheshouldweusershouldtheshouldexamplenoticefoundsuccesssystemfoundshouldsublimbackspacetonightshouldsystemtonightsuccesslearntonightsystemsublimsuccesscryptobackspacesystemsublimmorningmorningshouldmorninglearnsuccesslearnmorningusermorninglearnexamplecryptoshouldbackspacesublimshouldfoundbackspacesystemsystemweexamplesystemtonightsublimmorningmorninguserfoundcryptolearnbackspaceshouldbackspacenoticesublimfoundthecryptousershouldsuccesssystemsuccessshouldsystembackspacesublimshouldsublimsystembackspaceexampleshouldbackspacesublimnoticelearnsublimuserbackspaceusersublimsuccesssublimuserusernoticeshouldsuccessnoticenoticelearnexamplesystemweexamplesublimbackspacebackspacecryptoshouldusercryptosublimbackspacesublimshouldsystemnoticenoticethesuccesssuccesslearnsystemsublimwenoticelearnusersublimsystemusernoticeuserthesuccesslearnwelearnwenoticecryptolearncryptonoticenoticebackspacecryptothecryptousercryptobackspacesuccesslearnthesystemsuccessthesystemsystemcryptosuccessbackspacesublimlearnsublimcryptobackspacelearnsublimusersublimexamplecryptosublimsystemnoticecryptocryptousertheusernoticebackspacenoticenoticethecryptocryptosystembackspacesublimbackspacecryptocryptobackspacesystemuserthenoticesystemsystemsystemusernoticethecryptouserusersystemtheusercryptoexamplenoticecryptoexamplenoticetheexampleexamplethecryptotheusernoticetheexampleexamplecryptotheexampleexamplethenoticethecryptocryptoexampletheexamplecryptocryptothenoticeexamplecryptonoticetheexampleexampleexamplecryptocryptoexampleexamplethenoticethecryptothethethethethetheexampleexamplethetheexampletheexampletheexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexample 好多连在一起的词汇，应该是一个简单NTP题目，也就是NLP最基础的一个步骤，分词。\n这道题目的大致思路应该是：\n分词 词频统计 统计排序 根据排序位置找到指定的单词 拼接单词 根据这个思路，写个脚本处理一下哈：\nfrom collections import Counter // 统计库 import wordninja // 英语单词词库 data=\u0026#34;tonightsuccessnoticenoticewewesuccesstonightweexamplecryptoshouldwebackspacetonightbackspaceexamplelearnwesublimlearnbackspacetheshouldwelearnfoundsublimsystemexamplesublimfoundlearnshouldmorningsublimsystemuserlearnthecryptomorningexamplenoticetonightlearntonightlearntonightsublimenterusermorningfoundtonightweenterfoundnoticethecryptomorningthebackspacelearntonightlearnsublimtonightlearnfoundenterfoundsuccesstonightsuccessuserfoundmorningtonighttheshouldsublimentertonightenterbackspacelearnexamplenoticeexamplefoundsystemsuccesssublimsuccessshouldtonightcryptowelearncryptofoundshouldsublimsublimweentertonightsuccessshouldentertheentercryptouserbackspaceshouldentersystemsuccesssystementerfoundenterlearnexampletonightnoticemorningusertonightlearnmorningtonightfoundfoundsuccessnoticesystementerlearnexamplebackspaceshouldcryptocryptosublimweexampletonighttheshouldthemorningbackspacelearntonightsystemsuccesssuccessbackspacemorningnoticeuserfoundfoundtonightmorningenterenterthefoundbackspacelearnenterentershouldthesystemfounduserlearnlearnsystemnoticetonighttheshouldlearnuserbackspaceweusernoticeshouldthewefoundsystemwecryptocryptowethebackspacesystementershouldtonightsystemnoticemorningsystemweentermorningfoundsuccessusertonightsuccesstonightbackspaceshouldweenterthewesystemusernoticesystemthelearnexamplelearnfoundlearnnoticeexamplesystemthecryptocryptolearnsystemthecryptoenterlearnexamplemorningmorningweenterentersuccessexampleuserthebackspacenoticesublimenterbackspacesuccessbackspacethesublimexamplesystemtheexamplecryptolearnuserexamplelearnsystemusersuccessenterentersuccesstheuserbackspacelearnsuccessbackspacethesublimshouldwebackspaceexamplesuccesssuccesstonightweusershouldsuccessmorningcryptomorningfoundbackspacesublimshouldentershouldnoticesuccessmorningsuccessexamplelearnshouldsublimlearntonightshoulduserbackspacesublimlearncryptosuccessenternoticetonightmorningtonightwesuccessweuserbackspaceexamplewesystemnoticemorningsystemmorningcryptolearnsystemthethefoundcryptouserlearnusersystemwemorningenterexampleshouldlearncryptofoundenterbackspacelearnenterenterbackspaceshouldbackspacetheshouldthesystemshouldshouldsuccessmorningthefoundsystementersystemtonightcryptowelearnexampleexamplesystementerbackspaceshouldtheentersublimtonightfoundfoundsuccesssuccesssystemsublimcryptoshouldentersublimmorninglearnfoundtonightcryptobackspacesuccesscryptowebackspacefoundshouldnoticeshouldmorningnoticesystemcryptosystemlearnsystemnoticemorningsystementerwemorninglearnsuccessfoundwesuccesswetheusercryptousernoticebackspacesuccessshouldtonightmorningentermorninguserenternoticefoundmorningwetonightsystemthecryptotonightcryptosystemuserthefoundexampletonightusersystemcryptosublimmorninguserthefoundbackspaceshouldsuccesscryptotonightsystemnoticebackspaceusershouldenterthecryptomorningwesublimnoticesuccessnoticeusersuccesstonightlearnweuserenterfounduserexampleshouldshouldtonightwelearnthenoticethewefoundmorningexampleshouldexamplethesuccessnoticeenterfoundthecryptonoticeuserlearnuserweenterfoundmorningsystemweexamplenoticethebackspaceexamplesublimtheusermorningtonightthesuccesscryptosuccessusersuccesstonighttonightwelearnenterenterthemorningentersystemcryptobackspacemorningsystemexamplecryptouserexamplelearnsublimsuccessusersystemfoundmorningshouldcryptotonightsublimtheexamplemorningsystemuserexampleweexamplenoticesuccesssublimnoticecryptoshouldbackspaceshouldthetonightfoundsublimbackspacebackspacetonightshouldbackspacesuccesstonightbackspacesuccessmorningsystemcryptobackspaceentertonighttonightnoticelearnshoulduserfoundexamplesystemthesuccessweusertonightcryptousernoticeenternoticebackspaceusersystemfoundusernoticeshouldlearnuserfoundexampleusermorningshouldsuccessmorningmorningexampleexamplefoundsublimfoundenterbackspacenoticelearnfoundmorningcryptonoticecryptoshouldweshouldtonightcryptobackspacesublimcryptosublimenterentersublimentercryptonoticethethesublimexampleenterentershouldlearncryptoentershouldmorninglearnnoticeuserexamplesublimtonightshouldfoundtonightsuccessshouldmorningfoundtheweuserlearnsublimsystembackspacecryptotheusertonightcryptosublimmorningmorningexamplenoticetheenterlearnshouldmorningsublimfoundtonightsublimsublimexamplefounduserexamplethefoundwemorningnoticefoundcryptosuccesssublimsublimexamplethesuccessexamplenoticesuccessbackspacesublimlearnuserexamplesuccesssuccesssystemsuccessmorningmorninglearnexamplemorningtonightfoundbackspaceenternoticemorningentersuccessmorningusermorningbackspacelearncryptoenteruserenteruserthetonighttonightsuccesslearnenterfoundsuccesssystemfoundbackspaceenterlearnsystemsublimcryptoentermorningwetonightshouldlearnenterfoundcryptonoticelearnlearnshouldfoundsuccessexampletonightthesuccessfoundusertonightenterfoundsuccessshouldmorningusernoticemorningsystemsystemsuccessshouldwelearnenterfoundexamplewethefoundweshouldsystemsystemmorningmorningbackspaceshouldentersublimentertonightsuccesssystemsystemcryptousershouldsublimfoundwetonightnoticeexamplewewesuccessfoundusertonightfoundsystemexamplecryptofoundshouldshouldsuccessenterbackspaceexampletonightthelearnnoticeuserlearnsystemsublimfoundlearnsuccesssystemshouldsublimnoticelearnsystemnoticetonightexamplefoundusernoticeenterlearnnoticecryptousersystemmorningthewesystemfoundfoundshouldsystementerenterbackspacesystemsublimcryptousermorninglearnlearntonightsublimlearnenterenterbackspacesystemuserusercryptoentershouldtheusersublimnoticeexamplemorningexamplesublimsublimbackspacesystemexampleshouldsublimlearnfoundenterbackspacelearnmorningmorningfoundthetonightmorningnoticeenterlearnusersystemtonightbackspaceexamplelearntonightbackspaceweshouldcryptosuccessbackspaceexamplesuccesstheshouldmorninguserbackspacelearnthetheshouldcryptocryptotonightbackspacecryptocryptobackspacebackspacenoticeusertonightentermorningfoundweenterexampleenterfoundusersublimsystemtheexampleexamplesystemsuccessusersublimentermorningbackspacesystemfoundlearnsystemshouldsublimsublimentershouldtheusershouldexampleexampleshouldsuccesswelearnfoundsublimshoulduserweentertonightwenoticesublimsystemlearnshouldfoundsuccessuserentersuccessmorningcryptoenteruserfoundexampletonightlearnexampleexamplefoundlearnsuccesssystembackspacecryptonoticethefoundbackspacelearncryptothelearnlearnexamplesuccessnoticenoticesystemmorningcryptotonightnoticenoticeentersuccesscryptoenterbackspacesublimexampleenterfoundtonightcryptotonightsublimnoticesuccesssublimtheentertonighttheshouldthefoundsystemtonightuserbackspacesuccessshouldwebackspacenoticebackspacebackspacenoticewecryptobackspacebackspaceusertonightlearnsuccessmorningusertonightsuccessshouldbackspacecryptoenterentershouldsublimsystemexamplemorningcryptonoticethesuccessthebackspacenoticelearnsublimlearnsuccesscryptothesuccessenternoticecryptosystemsublimsuccesswebackspaceuserenterlearnuserwewemorningsuccesslearncryptobackspacewecryptosystemlearnenterenteruserexamplefoundsystemcryptousernoticefoundusersublimbackspacewesublimnoticemorningshouldexamplenoticecryptoshouldtonightmorningthefoundsystementerentersystemthecryptobackspacesublimlearnsuccessmorningsublimsystemcryptousersublimwesuccessmorningsublimbackspacecryptobackspacesublimthelearnsuccesssublimlearncryptoweweexamplecryptowenoticelearnfoundbackspacesystemsystemexampleshouldlearnsuccesssublimcryptobackspacetonightbackspacemorningmorningnoticeshouldnoticefoundthetheshouldtheshouldfoundfoundcryptosuccessbackspacesuccessshouldweenternoticeweweshouldmorningfoundusersuccessbackspacewenoticeusersuccessenterenterexamplelearnfoundwetonightusercryptothesublimsublimtonightsuccesslearnbackspacetonightentertonightthesublimnoticewefoundcryptobackspaceenterenterlearnlearntonightexamplesystementersublimnoticecryptoshoulduseruserbackspaceuserwesublimmorningwesystemshouldtonighttheusershouldnoticefoundusernoticeentersublimwethewefoundfoundlearnfoundwecryptosystemexamplemorningcryptocryptosublimtheexamplenoticefoundlearnwelearnmorningtheenterthesystemsublimtonightsuccesssystemlearnshouldenterbackspaceentersuccesssuccessbackspaceexamplenoticeentershouldsublimlearnbackspacetheshouldexamplelearnsystemusersublimbackspacebackspacesuccesswelearntonightexamplewecryptoenterwesystemsystemsublimexamplecryptolearnmorningsublimfoundsublimfoundbackspacefoundtonighttonightnoticesuccesssuccessexampleusersuccesstonightsublimcryptosystemweenterexamplesystemthethenoticesublimtonightbackspacenoticesystemexamplethesuccesstonightmorningsuccesstonightwenoticesublimtonightwelearntonightmorningsublimbackspaceenterthetonightenterwecryptofoundtheenternoticebackspacesuccesswesystemuserexamplebackspaceentersuccesstonightsublimwemorningsuccesssuccesswesublimsuccessnoticesublimfoundlearnlearnweexamplecryptonoticelearnweusershoulduserfoundcryptolearnfoundmorningtonightmorningmorningnoticewecryptowewesuccessfoundsublimweuserentershouldshouldshouldsublimbackspacetonightenterwesublimsuccessshouldfoundthethetonightwecryptoweenterfoundcryptoshouldcryptouseruserfoundentersublimsublimthelearntheshouldnoticebackspacefoundsuccessshouldtonightentermorningsystemmorningtonightwenoticelearnbackspaceexampleusershouldnoticesublimsublimexamplethesuccessnoticesystemmorningnoticecryptosystemsublimcryptosystemsuccessshouldmorningbackspaceshouldmorninglearnnoticenoticeshouldthewewesublimsublimnoticeusersuccessentersystemfoundshouldshouldcryptobackspaceusermorningsystemshouldshouldtonightwesublimuserfoundlearnbackspacethetonightmorningexampleuserthefoundbackspaceshouldtonightcryptocryptofounduserexamplenoticecryptousernoticethenoticeshouldweshouldfoundwemorningcryptosuccesslearnfoundtonightsublimnoticenoticewefoundwewesuccesssublimsublimcryptoweexampletonightsuccessfoundshouldsuccesstonightbackspacesystemshouldwesystemnoticebackspaceusersystembackspacewenoticelearnnoticenoticesuccesslearntonightuserlearnsuccessbackspacesuccesswesystemusercryptonoticethesystemusernoticewethesuccessweshouldfoundshouldcryptomorningtonightwethewesuccesslearntheshouldweexampletonightsuccessnoticenoticemorningfoundmorningfoundusersublimsystemsuccessbackspacesuccessmorninguserthefoundweexamplemorningsublimlearnfoundfoundnoticemorningshouldweuserwemorningexamplesuccesssuccessfoundthetheshouldweusershouldtheshouldexamplenoticefoundsuccesssystemfoundshouldsublimbackspacetonightshouldsystemtonightsuccesslearntonightsystemsublimsuccesscryptobackspacesystemsublimmorningmorningshouldmorninglearnsuccesslearnmorningusermorninglearnexamplecryptoshouldbackspacesublimshouldfoundbackspacesystemsystemweexamplesystemtonightsublimmorningmorninguserfoundcryptolearnbackspaceshouldbackspacenoticesublimfoundthecryptousershouldsuccesssystemsuccessshouldsystembackspacesublimshouldsublimsystembackspaceexampleshouldbackspacesublimnoticelearnsublimuserbackspaceusersublimsuccesssublimuserusernoticeshouldsuccessnoticenoticelearnexamplesystemweexamplesublimbackspacebackspacecryptoshouldusercryptosublimbackspacesublimshouldsystemnoticenoticethesuccesssuccesslearnsystemsublimwenoticelearnusersublimsystemusernoticeuserthesuccesslearnwelearnwenoticecryptolearncryptonoticenoticebackspacecryptothecryptousercryptobackspacesuccesslearnthesystemsuccessthesystemsystemcryptosuccessbackspacesublimlearnsublimcryptobackspacelearnsublimusersublimexamplecryptosublimsystemnoticecryptocryptousertheusernoticebackspacenoticenoticethecryptocryptosystembackspacesublimbackspacecryptocryptobackspacesystemuserthenoticesystemsystemsystemusernoticethecryptouserusersystemtheusercryptoexamplenoticecryptoexamplenoticetheexampleexamplethecryptotheusernoticetheexampleexamplecryptotheexampleexamplethenoticethecryptocryptoexampletheexamplecryptocryptothenoticeexamplecryptonoticetheexampleexampleexamplecryptocryptoexampleexamplethenoticethecryptothethethethethetheexampleexamplethetheexampletheexampletheexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexample\u0026#34; lm = wordninja.LanguageModel(\u0026#39;my_dict.txt.gz\u0026#39;) // 通过调试写出的简单字典 data_list = lm.split(data) data_count = Counter(data_list) index = 1 hint_list = [4,8,11,15,16] m = \u0026#34;\u0026#34; for i in data_count.most_common(20)[::-1]: if index in hint_list: m += i[0] index += 1 print(m) 运行一下脚本：","title":"BUUCTF CRYPTO (5) writeup"},{"content":"沉浸在密码学的世界里面，缓缓浸入题目的海洋，16道crypto题目！\n这次的题目，难度也开始逐渐上来咯！当然不仅仅只有难度，还有脑洞！\n0x0 古典密码知多少 # 应该是考察古典密码的题目，点开题目下载附件，瞧一瞧\n打开图片就察觉到这题可能会非常草……，果然古典的恶心，应该是三种古典密码的组合，可以清晰地看出有猪圈密码和变种圣堂武士密码，至于剩下那一种密码实在是找不到……，只能无奈地去瞧一瞧大佬的wp，发现是标准银河字母。根据得到的信息进行比对，蓝色的是猪圈密码，橙色的是圣堂武士密码，黑色的是标准银河字母。根据信息，进行解密得：\nFGCPFLIRTUASYON 看样子应该还有一层加密，最常见的古典加密方法就是凯撒加密和栅栏密码，经过尝试发现是栅栏密码，使用栅栏密码进行解密得到flag：\nFLAGISCRYPTOFUN 猪圈密码对照表：\n圣堂武士密码对照表：\n标准银河字母对照表：\n0x1 [HDCTF2019]bbbbbbrsa # 看来又是熟悉的RSA题目，嘤嘤嘤~\n下载附件，打开发现有两个文件，一个enc文件，一个encode.py文件\nenc文件：\np = 177077389675257695042507998165006460849 n = 37421829509887796274897162249367329400988647145613325367337968063341372726061 c = ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM encode.py文件：\nfrom base64 import b64encode as b32encode from gmpy2 import invert,gcd,iroot from Crypto.Util.number import * from binascii import a2b_hex,b2a_hex import random flag = \u0026#34;******************************\u0026#34; nbit = 128 p = getPrime(nbit) q = getPrime(nbit) n = p*q print p print n phi = (p-1)*(q-1) e = random.randint(50000,70000) while True: if gcd(e,phi) == 1: break; else: e -= 1; c = pow(int(b2a_hex(flag),16),e,n) print b32encode(str(c))[::-1] # 2373740699529364991763589324200093466206785561836101840381622237225512234632 题目给了n、p、c而没有给e，根据python源码 e需要爆破一下，写个小脚本解决这道题目：\nimport libnum import gmpy2 from base64 import b64decode as b32decode p = 177077389675257695042507998165006460849 n = 37421829509887796274897162249367329400988647145613325367337968063341372726061 c = \u0026#39;==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM\u0026#39; q = n // p phi = (p-1)*(q-1) c = int(b32decode(str(c)[::-1])) for e in range(50000,70000): if gmpy2.gcd(e,phi) == 1: d = gmpy2.invert(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) if \u0026#39;flag\u0026#39; in str(flag): print \u0026#39;e=%d\u0026#39;%e print flag break 运行脚本，得到flag：\nflag{rs4_1s_s1mpl3!#} 0x2 [BJDCTF2020]RSA # RSA题目，妙呀！下载附件看看：\nfrom Crypto.Util.number import getPrime,bytes_to_long flag=open(\u0026#34;flag\u0026#34;,\u0026#34;rb\u0026#34;).read() p=getPrime(1024) q=getPrime(1024) assert(e\u0026amp;lt;100000) n=p*q m=bytes_to_long(flag) c=pow(m,e,n) print c,n print pow(294,e,n) p=getPrime(1024) n=p*q m=bytes_to_long(\u0026#34;BJD\u0026#34;*32) c=pow(m,e,n) print c,n \u0026#39;\u0026#39;\u0026#39; output: 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037 381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018 979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047 \u0026#39;\u0026#39;\u0026#39; 一个python源程序，看样子还是有点意思的，发现这里有三个密文，两个n数值，两个n的数值是共用同一个q值，可以使用欧几里得算法求出q，e给出了范围，应该是使用爆破的方法求出e的数值，这里写个小脚本：\nimport libnum import gmpy2 c = 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120 n = 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037 _294_c =381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018 BJD_c = 979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721 BJD_n = 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047 q = gmpy2.gcd(n,BJD_n) p = n // q e = 0 for i in range(100000): if _294_c == pow(294,i,n): e = i break phi = (p-1)*(q-1) d = gmpy2.invert(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，得到flag：\nBJD{p_is_common_divisor} 0x3 [WUSTCTF2020]佛说：只能四天 # 看题目还挺有意思的，应该是一道古典密码学题目，看下题目描述：\n圣经分为《旧约全书》和《新约全书》 再看下题目：\n尊即寂修我劫修如婆愍闍嚤婆莊愍耨羅嚴是喼婆斯吶眾喼修迦慧迦嚩喼斯願嚤摩隸所迦摩吽即塞願修咒莊波斯訶喃壽祗僧若即亦嘇蜜迦須色喼羅囉咒諦若陀喃慧愍夷羅波若劫蜜斯哆咒塞隸蜜波哆咤慧聞亦吽念彌諸嘚嚴諦咒陀叻咤叻諦缽隸祗婆諦嚩阿兜宣囉吽色缽吶諸劫婆咤咤喼愍尊寂色缽嘚闍兜阿婆若叻般壽聞彌即念若降宣空陀壽愍嚤亦喼寂僧迦色莊壽吽哆尊僧喼喃壽嘚兜我空所吶般所即諸吽薩咤諸莊囉隸般咤色空咤亦喃亦色兜哆嘇亦隸空闍修眾哆咒婆菩迦壽薩塞宣嚩缽寂夷摩所修囉菩阿伏嘚宣嚩薩塞菩波吶波菩哆若慧愍蜜訶壽色咒兜摩缽摩諦劫諸陀即壽所波咤聞如訶摩壽宣咤彌即嚩蜜叻劫嘇缽所摩闍壽波壽劫修訶如嚩嘇囉薩色嚤薩壽修闍夷闍是壽僧劫祗蜜嚴嚩我若空伏諦念降若心吽咤隸嘚耨缽伏吽色寂喃喼吽壽夷若心眾祗喃慧嚴即聞空僧須夷嚴叻心願哆波隸塞吶心須嘇摩咤壽嘚吶夷亦心亦喃若咒壽亦壽囑囑 唔，好像还有hint，去瞧一瞧：\n1. 虽然有点不环保，但hint好像是一次性的，得到后就没有利用价值了。 2. 凯撒不是最后一步，by the way，凯撒为什么叫做凯撒？ 新约全书和旧约全书，用与佛论禅解不出来，“新约全书”可能是提示吧，最后用新约佛论禅解得(注意前面要加上“佛曰：”)：\n平等文明自由友善公正自由诚信富强自由自由平等民主平等自由自由友善敬业平等公正平等富强平等自由平等民主和谐公正自由诚信平等和谐公正公正自由法治平等法治法治法治和谐和谐平等自由和谐自由自由和谐公正自由敬业自由文明和谐平等自由文明和谐平等和谐文明自由和谐自由和谐和谐平等和谐法治公正诚信平等公正诚信民主自由和谐公正民主平等平等平等平等自由和谐和谐和谐平等和谐自由诚信平等和谐自由自由友善敬业平等和谐自由友善敬业平等法治自由法治和谐和谐自由友善公正法治敬业公正友善爱国公正民主法治文明自由民主平等公正自由法治平等文明平等友善自由平等和谐自由友善自由平等文明自由民主自由平等平等敬业自由平等平等诚信富强平等友善敬业公正诚信平等公正友善敬业公正平等平等诚信平等公正自由公正诚信平等法治敬业公正诚信平等法治平等公正友善平等公正诚信自由公正友善敬业法治法治公正公正公正平等公正诚信自由公正和谐公正平等 又是套套，应该是社会主义核心价值观密码，使用在线工具解密一下：\nRLJDQTOVPTQ6O6duws5CD6IB5B52CC57okCaUUC3SO4OSOWG3LynarAVGRZSJRAEYEZ_ooe_doyouknowfence 发现后面有一个提示，好像是栅栏密码，需要进行解密，使用在线工具解一下：\nR5UALCUVJDCGD63RQISZTBOSO54JVBORP5SAT2OEQCWY6CGEO53Z67L_doyouknowCaesar 后面又有提示，应该是凯撒密码，由于hint说凯撒密码不是最后一步，因此看密文格式像是base32加密的格式，因此这里需要进行测试检验，经过检验发现是3位的凯撒密码可以成功使用base32。故使用3位凯撒密码解密：\nO5RXIZRSGAZDA63ONFPWQYLPL54GSYLOM5PXQ2LBNZTV6ZDBL53W67I 然后使用base32解密，即可：\nwctf2020{ni_hao_xiang_xiang_da_wo} 0x4 [MRCTF2020]天干地支+甲子 # 看样子是蛮有意思的样子~，看看题目到底是个啥：\n得到得字符串用MRCTF{}包裹 一天Eki收到了一封来自Sndav的信，但是他有点迷希望您来解决一下 甲戌 甲寅 甲寅 癸卯 己酉 甲寅 辛丑 看题目应该是考察的是六十甲子纳音表：（和BUUCTF上的传统文化+古典密码那道题目非常类似，估计思路也是相似的）\n根据六十甲子纳音表编写脚本：\nc_sky = \u0026#34;甲乙丙丁戊己庚辛壬癸\u0026#34; c_earth = \u0026#34;子丑寅卯辰巳午未申酉戌亥\u0026#34; c_dict = {} for i in range(60): c_dict[c_sky[i%len(c_sky)]+c_earth[i%len(c_earth)]] = i+1 c = \u0026#34;甲戌 甲寅 甲寅 癸卯 己酉 甲寅 辛丑\u0026#34; c_list = c.split(\u0026#34; \u0026#34;) m_list = [] for i in c_list: m_list.append(chr(c_dict[i]+60)) m = \u0026#34;\u0026#34;.join(m_list) print(m) 运行脚本，得到flag：（注意要python3环境下运行哟！）\nGoodjob 0x5 [MRCTF2020]vigenere # 看样子应该是维吉尼亚密码，也就是考察多表替换密码的题目，看看题目有些什么东西吧！\n两个文件，一个cipher.txt密文文件，一个vigenere.py加密源码文件\nvigenere.py文件\n#!/bin/python3 from ctf import source_text, key_string getdiff = lambda char: ord(char)-ord(\u0026#39;a\u0026#39;) getchar = lambda num: chr(ord(\u0026#39;a\u0026#39;)+num) def vigenere(src: chr, key: chr) -\u0026amp;gt; chr: assert(src.isalpha() and key.isalpha()) return(getchar((getdiff(src) + getdiff(key) + 1) % 26)) src = source_text.lower() count = 0 assert(len(key_string) \u0026amp;gt; 5 and len(key_string) \u0026amp;lt; 10) for i in src: if(i.isalpha()): print(vigenere(i, key_string[count % len(key_string)]), end=\u0026#39;\u0026#39;) count+=1 else: print(i, end=\u0026#39;\u0026#39;) cipher.txt\ng vjganxsymda ux ylt vtvjttajwsgt bl udfteyhfgt oe btlc ckjwc qnxdta vbbwwrbrtlx su gnw nrshylwmpy cgwps, lum bipee ynecgy gk jaryz frs fzwjp, x puej jgbs udfteyhfgt, gnw sil uuej su zofi. sc okzfpu bl lmi uhzmwi, x nyc dsj bl lmi enyl ys argnj yh nrgsi. nba swi cbz ojprbsw fqdam mx. cdh nsai cb ygaigroysxn jnwwi lr msylte. cw mekr tg jptpzwi kdikjsqtaz, ftv pek oj pxxkdd xd ugnj scr, yg n esqxwxw nba onxw au ywipgkj fyiuujnxn gnss xwnz onxw jnahl avhwwxn vzkjpu nrofch fvwfoh. v jwhppek lmi vyutfp hbiafp hcguj at nxw gyxyjask ib hw seihxsqpn vtvjttajwsx ds zzj xnegfsmtf egz wtrq lt mbcukj sc hy. qty wnbw ss bbxsq vxtnl ys ghrw zw cbx vt cdh vgxwtfy ssc brzzthh bl wsjdeiwricg cw mekr zjzi grgktr ib lwfv. vbbwwrbrtlx hteonj xwroj oyhg vgbigf ljtq iuk utrhrtl tj iuk ytztetwi. cdh nsai crolmig fudngxgkv ssg ekujmkrj gzvh. jk vnh cbz aszxgk qty. nba vt rdg qfta jf, tgw hd lum prdj umw aderv. hcqrxkuerr jgjw cbz dni lvzznr nbaj gsgqkjx. hd aul ylxaq lmei lum hec oaaqh xg, gk yldhmz nx lrxw f tjorah gdaylwyrgogs tgbpwhx. nba ufrcbz. ay mh nt shx ds tsyygr gfi mi txgbw xgywqj iuxgzkw baj hsaykuymkr guymday. qty wnbw ssi rtyfktq of tyg txwfx paj yfxwrxask rbtnjvhnzatr, cbx vnh nba uwipgk lmi lrgdyl ds umw qpeqwytaniwx. cdh jg ssi xtgb sje imqxjek, gzv tgnahw, de zzj ycjxayxta igiih gnsy eaeksic eeunnht baj xsrvkld qdek gwhte zzfr rbadi ft bhlfmcrj td ecl ux dsje oeushvzatrh. lum hppvs lmigr gjj tgbhdjqh nsgsk jf zzfx nba fjis gu ktpkr. egz yhr zznw rygar eh nt wcgjfk lt mcigvj sje vjjgxailx. qpae gk xwryw uvdorwrw sbt\u0026#39;l jbxfz. omigr zzjvt nxw wipy igsjavilx, awrxw yltek swi leuflw, lr caqp xqkfymul zzjq paj sihgryk yltz hq tyg zkssw. lr gjj jdesask dhx gbr hbiafp rbtlwerg. zznw vbbwwrpaiw bmay gjnwt niutvsvty ys iuk utrsvzatrh bl gzv lbxdi, rdg egzvh. baj bsgyj ax hxslwwicg. iqgigfvshi rbtknwif ux yvpayshxxbtk, wianzatrhuohx, ecq zztyvuz aywtyl, swvplkv qmzr g kyecqofl apik as xwr cwg su baj hsbzafngpgogsw. dhxk nw p jujqh iugl nw qbzz jzteeomigr gfi rdjnwwi, qhz ay mh aul bltek tthxry dnzt. jk swi reksymct g otvaq zzfx pyr efc tazww axgngzx eeonnpttk gw tgrpmimrr guhsgqkv gc gniw, jgdaueng ebcww, qxyolfvn sujhi, de ylfxxbt gk fxezz. bi pek uwipgofl e lbxdi awrxw frnbtw, frnjnwwi bne wctgryk mmh bx zjv qrrajjh, au efxirx zta hvtyzppe, cayldhz xjeg bl tjmct igjvrrj asxd fodjrrr uj hscsujrmil. egzv armsq gdaiwuxh bl hwserxld, imcxwxwxbt, aiicgold, qdikejri, ntv hscgkpy hd aul fteye lt yh. gnwd egr gdq fpfkv tr bnzljv, paj lmigr ok ss bnzljv wrxw. tyg vjwsxxgowx lpik ft fdqowx, wd, htdnot lum, bi rntftx dozsnr dejww fn cnqxmrnr utigpogs. at okdnikr zzfx ueue jxwvik, jravmzyicrj kjpu-vtljvtfz, ssh iuk utqbbtojea, baj lskrxffrrr caqp tzkjli. dhx aiicgolnih zgq gi svylwmqhzwi ereukx qpae gk cdhx bzvxfjahxxbtk. ylt btdd ppj zzfx pyr gzv rbtkymihkfy gjyzmwih jumqh vrtwweaye jjgdttaei xf zzj kdyjws vjyk. oj ldck oj axyr tj eqyk lt fjvrv tyg cgjymrhrsw wdyalnscf uf ylpg hsxmh. oal bi rntftx ppiwux iuk ktpjgogsw nba swi pgzwrtivty ys xzvgxi. xa zzj ycvzwi winzwx, cdh nsai ibjsd ggrgljh p ygo, ylt gkdjgdzsmsmrnzatrh ekxtvb nil, blxpn jjtjqosyih lumw sla igswivzmymda gfi mcfadyw iuk vwipzy gk ntslwwwda, csxlxamltr, bvrd, resvygs, htguizikvrdj, ecq hjfrsrok. yltfk vwipzy ezwi auo gi qbxf frtj of zw. nba swi irxjnjxrj gk cdhx gbr ruodivta, yasgt gnwd egr tsymkry as e lbxdi awrxw dsj jodq eajgqx ft vsenkgntlx. ftpgmxi nba xjeg gnwr, cdh kfyvjfz qtyg oajjejpxshmtf cayl iuk hfvtazsq vtfvgswxoodnxxry qty pek lts rbcswhal zg hscsxgsx nbajxiaikk. nr dhx otvaq, gdq xwr ywsxxzkfyw paj wctgryknscf ux mybntayc, ueue ylt qktfwxam lt xwr gfliavi, swi enxlx su n ywfqaryk bldyk, lmi vyutfp rbtnjvhnzatr ds hayw. lr issrdg ywuegnzw ylt noj ylpg iztotf ljtq iuk snv jcuf blxpn onrvf hwfx. xa iznrp, tkjrecl, ljfrrr, xmxwxn, yaskpcujj, minrq frs gnw zrxgkv xxpgkk, dsj nxw yvnvty ys lnxv tju gnw amghy gk pxokjyc ql kjjgivty lypej htwif gl ylt sxgsxxrxk tj rlhwwweniw. yltfk efc zrkh tyi gnw hscggynsc suj f wbnrd ymbr, hmy xwre onpa aul bsgx of f aderv ylpg caqp hbuf gi qygfpiirj as fxg-hwfvxam ejhxn. egzv xaijjehvtyqc doygqiir ofksgzglnsc vtvzwieowx adhrv uigcklzeir zzjqhrrnjw ql vjttdfofl ppjy, as ebrxahe paj wqwtjnwwi, iugl hppvs lt sla yhjiru olxias zzwsjtngzx iuk otvaq. zzjwt ygox adhrv iirygjj msrgk ys qr gftxwrx ashjfzjnea cxgiyrg, tg rsgr tggpt gnss txt ojtr. xa umw aderv, blpgknjv iuk zzqpa sash bne uwipgk ufr qr xwuvdqaujh paj vnwieotzxtq ofkmcvzwqc pg tg hshg. zzj kabhsq gdabwdecpk gk xwbaymx cb rgskte xwvyxekk dsje lshxdeowx xd niutqeyokm. xwryw nrreksxmctrq mshgodj ecq igqscvgd ripfajjw eyguj yh vt lmi hnsw ushvzatr pf zztwt cxwamdhy dtztey gk jgrkvtq paj kjpu-qkljvbvtsymda czt lpq zg wiyril ylt nalmsgvzajw ds jaxxpaz, msmcsujris cuojvh. jk ezwi qkuqegr umw zxezmfp hrrnjw xzsmsi ib egzv hbbwwixttld, ikrt sx at pufymchk lt gdaywsx ib egzv ghrw tzte umw fdqowx. at jodq weeksi sjeywqztf guwshf zzj tantwy wd gnsy rd btw hec nxjjwi baj yldhmzyw. lr caqp reksyi p ponnpxmglnsc bl lmi bvtv nr rlhwwweniw. ren vz tj qdek zzqpak ssh unoj ylpa zzj aderv dsje mgaigaswsxh ugnj qpqk tjjdek. xqev vy ewgis balicrxw hvnczg hvppq efr, eyksxi pqj mshteyutvt ntv hygye twerry. 尝试使用在线工具进行维吉尼亚密码的解密：\na declaration of the independence of cyberspace by john perry barlow governments of the industrial world, you weary giants of flesh and steel, i come from cyberspace, the new home of mind. on behalf of the future, i ask you of the past to leave us alone. you are not welcome among us. you have no sovereignty where we gather. we have no elected government, nor are we likely to have one, so i address you with no greater authority than that with which liberty itself always speaks. i declare the global social space we are building to be naturally independent of the tyrannies you seek to impose on us. you have no moral right to rule us nor do you possess any methods of enforcement we have true reason to fear. governments derive their just powers from the consent of the governed. you have neither solicited nor received ours. we did not invite you. you do not know us, nor do you know our world. cyberspace does not lie within your borders. do not think that you can build it, as though it were a public construction project. you cannot. it is an act of nature and it grows itself through our collective actions. you have not engaged in our great and gathering conversation, nor did you create the wealth of our marketplaces. you do not know our culture, our ethics, or the unwritten codes that already provide our society more order than could be obtained by any of your impositions. you claim there are problems among us that you need to solve. you use this claim as an excuse to invade our precincts. many of these problems don\u0026#39;t exist. where there are real conflicts, where there are wrongs, we will identify them and address them by our means. we are forming our own social contract. this governance will arise according to the conditions of our world, not yours. our world is different. cyberspace consists of transactions, relationships, and thought itself, arrayed like a standing wave in the web of our communications. ours is a world that is both everywhere and nowhere, but it is not where bodies live. we are creating a world that all may enter without privilege or prejudice accorded by race, economic power, military force, or station of birth. we are creating a world where anyone, anywhere may express his or her beliefs, no matter how singular, without fear of being coerced into silence or conformity. your legal concepts of property, expression, identity, movement, and context do not apply to us. they are all based on matter, and there is no matter here. our identities have no bodies, so, unlike you, we cannot obtain order by physical coercion. we believe that from ethics, enlightened self-interest, and the commonweal, our governance will emerge. our identities may be distributed across many of your jurisdictions. the only law that all our constituent cultures would generally recognize is the golden rule. we hope we will be able to build our particular solutions on that basis. but we cannot accept the solutions you are attempting to impose. in the united states, you have today created a law, the telecommunications reform act, which repudiates your own constitution and insults the dreams of jefferson, washington, mill, madison, detoqueville, and brandeis. these dreams must now be born anew in us. you are terrified of your own children, since they are natives in a world where you will always be immigrants. because you fear them, you entrust your bureaucracies with the parental responsibilities you are too cowardly to confront yourselves. in our world, all the sentiments and expressions of humanity, from the debasing to the angelic, are parts of a seamless whole, the global conversation of bits. we cannot separate the air that chokes from the air upon which wings beat. in china, germany, france, russia, singapore, italy and the united states, you are trying to ward off the virus of liberty by erecting guard posts at the frontiers of cyberspace. these may keep out the contagion for a small time, but they will not work in a world that will soon be blanketed in bit-bearing media. your increasingly obsolete information industries would perpetuate themselves by proposing laws, in america and elsewhere, that claim to own speech itself throughout the world. these laws would declare ideas to be another industrial product, no more noble than pig iron. in our world, whatever the human mind may create can be reproduced and distributed infinitely at no cost. the global conveyance of thought no longer requires your factories to accomplish. these increasingly hostile and colonial measures place us in the same position as those previous lovers of freedom and self-determination who had to reject the authorities of distant, uninformed powers. we must declare our virtual selves immune to your sovereignty, even as we continue to consent to your rule over our bodies. we will spread ourselves across the planet so that no one can arrest our thoughts. we will create a civilization of the mind in cyberspace. may it be more humane and fair than the world your governments have made before. flag is mrctf vigenere crypto crack man, please add underscore and curly braces. vigenere解密后，flag已经出现了！\n0x6 [BJDCTF2020]rsa_output # 看题目应该是RSA题目，看看这次又是什么花样？\n{21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111,2767} {21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111,3659} message1=20152490165522401747723193966902181151098731763998057421967155300933719378216342043730801302534978403741086887969040721959533190058342762057359432663717825826365444996915469039056428416166173920958243044831404924113442512617599426876141184212121677500371236937127571802891321706587610393639446868836987170301813018218408886968263882123084155607494076330256934285171370758586535415136162861138898728910585138378884530819857478609791126971308624318454905992919405355751492789110009313138417265126117273710813843923143381276204802515910527468883224274829962479636527422350190210717694762908096944600267033351813929448599 message2=11298697323140988812057735324285908480504721454145796535014418738959035245600679947297874517818928181509081545027056523790022598233918011261011973196386395689371526774785582326121959186195586069851592467637819366624044133661016373360885158956955263645614345881350494012328275215821306955212788282617812686548883151066866149060363482958708364726982908798340182288702101023393839781427386537230459436512613047311585875068008210818996941460156589314135010438362447522428206884944952639826677247819066812706835773107059567082822312300721049827013660418610265189288840247186598145741724084351633508492707755206886202876227 看题目的样子，应该是考察共模攻击的题目，直接丢个共模攻击的脚本吧：\nimport libnum import gmpy2 def common_modulus(n,c1,c2,e1,e2): assert(libnum.gcd(e1,e2)) _, s1 ,s2 = gmpy2.gcdext(e1,e2) if s1 \u0026amp;lt; 0: s1 = -s1 c1 = gmpy2.invert(c1,n) elif s2 \u0026amp;lt; 0: s2 = -s2 c2 = gmpy2.invert(c2,n) return pow(c1,s1,n) * pow(c2,s2,n) % n n = 21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111 e1 = 2767 e2 = 3659 c1=20152490165522401747723193966902181151098731763998057421967155300933719378216342043730801302534978403741086887969040721959533190058342762057359432663717825826365444996915469039056428416166173920958243044831404924113442512617599426876141184212121677500371236937127571802891321706587610393639446868836987170301813018218408886968263882123084155607494076330256934285171370758586535415136162861138898728910585138378884530819857478609791126971308624318454905992919405355751492789110009313138417265126117273710813843923143381276204802515910527468883224274829962479636527422350190210717694762908096944600267033351813929448599 c2=11298697323140988812057735324285908480504721454145796535014418738959035245600679947297874517818928181509081545027056523790022598233918011261011973196386395689371526774785582326121959186195586069851592467637819366624044133661016373360885158956955263645614345881350494012328275215821306955212788282617812686548883151066866149060363482958708364726982908798340182288702101023393839781427386537230459436512613047311585875068008210818996941460156589314135010438362447522428206884944952639826677247819066812706835773107059567082822312300721049827013660418610265189288840247186598145741724084351633508492707755206886202876227 if __name__ == \u0026#34;__main__\u0026#34;: m = common_modulus(n,c1,c2,e1,e2) flag = libnum.n2s(m) print flag 运行脚本，得到flag：\nBJD{r3a_C0mmoN_moD@_4ttack} 0x7 [MRCTF2020]keyboard # 键盘密码吗？瞧瞧看吧！\n得到的flag用 MRCTF{xxxxxx}形式上叫 都为小写字母 6 666 22 444 555 33 7 44 666 66 3 似曾相识的熟悉内容，用丢个脚本解决吧！\nkeyborad = [None,None,\u0026#34;ABC\u0026#34;,\u0026#34;DEF\u0026#34;,\u0026#34;GHI\u0026#34;,\u0026#34;JKL\u0026#34;,\u0026#34;MNO\u0026#34;,\u0026#34;PQRS\u0026#34;,\u0026#34;TUV\u0026#34;,\u0026#34;WXYZ\u0026#34;] c = \u0026#34;6 666 22 444 555 33 7 44 666 66 3\u0026#34; c_list = c.split(\u0026#34; \u0026#34;) m = \u0026#34;\u0026#34; for i in c_list: m += keyborad[int(i[0])][len(i)-1] print m 运行脚本，得到一个错误的flag：\nMOBILEPHOND 需要进行简单拼写检查进行修改，便得到flag：\nMOBILEPHONE 0x8 [BJDCTF2020]signin # 签到题？萌新狂喜！看看是什么样的签到吧：\nwelcome to crypto world！！ 密文：424a447b57653163306d655f74345f424a444354467d 看样子应该是一个HEX编码的密文，解一下就得到flag了：\nBJD{We1c0me_t4_BJDCTF} 0x9 [ACTF新生赛2020]crypto-rsa0 # RSA题目，题目内容应该是比较有意思的：\n附件文件有两个文件，一个hint.txt应该是一个提示文件，还有一个压缩包，但是压缩包打不开，嘤嘤嘤~\n看看hint.txt里面有什么：\n怎么办呢，出题人也太坏了，竟然把压缩包给伪加密了！ 感觉有点像是杂项题目……伪加密，那是什么东西？\n菜狗查一查……\n经过查询发现，好像是zip文件结构中的09标志着是伪加密文件结构，只需要将09修改为00就可以破解伪加密，可以使用一个010edit工具进行修改：\n然后将09修改成00并将文件进行保持即可进行解压操作\n解压得到一个rsa0.py的python源码文件和一个output的文本文件\nrsa0.py\nfrom Cryptodome.Util.number import * import random FLAG=#hidden, please solve it flag=int.from_bytes(FLAG,byteorder = \u0026#39;big\u0026#39;) p=getPrime(512) q=getPrime(512) print(p) print(q) N=p*q e=65537 enc = pow(flag,e,N) print (enc) output\n9018588066434206377240277162476739271386240173088676526295315163990968347022922841299128274551482926490908399237153883494964743436193853978459947060210411 7547005673877738257835729760037765213340036696350766324229143613179932145122130685778504062410137043635958208805698698169847293520149572605026492751740223 50996206925961019415256003394743594106061473865032792073035954925875056079762626648452348856255575840166640519334862690063949316515750256545937498213476286637455803452890781264446030732369871044870359838568618176586206041055000297981733272816089806014400846392307742065559331874972274844992047849472203390350 根据源代码，可以看出源码已经将p，q，c的数据输出，而且根据源码中的e的数值，写个简单脚本就可以解决了：\nimport libnum p = 9018588066434206377240277162476739271386240173088676526295315163990968347022922841299128274551482926490908399237153883494964743436193853978459947060210411 q = 7547005673877738257835729760037765213340036696350766324229143613179932145122130685778504062410137043635958208805698698169847293520149572605026492751740223 c = 50996206925961019415256003394743594106061473865032792073035954925875056079762626648452348856255575840166640519334862690063949316515750256545937498213476286637455803452890781264446030732369871044870359838568618176586206041055000297981733272816089806014400846392307742065559331874972274844992047849472203390350 e = 65537 n = p*q phi = (p-1)*(q-1) d = libnum.invmod(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，得到flag：\nactf{n0w_y0u_see_RSA} 0xA 一张谍报 # 看样子，应该是一个古典密码学题目，或者脑洞题？\n看一下题目描述：\n国家能源总部经过派出卧底长期刺探，终于找到一个潜伏已久的国外内鬼：三楼能源楼管老王。由于抓捕仓促，老王服毒自尽了。侦查部门搜出老王每日看的报纸原来是特制的情报。聪明的你能从附件的报纸中找出情报么？flag是老王说的暗号。（由于老王的线人曾今做的土匪，所以用的行话） 注意：得到的 flag 请包上 flag{} 提交 附件文件是一个docx文件：\n国家能源时报2015年3月5日 平时要针对性的吃些防辐射菜 对于和电脑“朝夕相处”的人们来说,辐射的确是个让人忧心的“副产物”。因此,平时针对性的吃些可以防辐射的菜是很有好处的。特别是现在接近年底，加班加点是家常便饭，对着电脑更是辐射吸收得满满的，唯有趁一日三餐进食的时候吃点防辐射的食物了。 朝歌区梆子公司三更放炮 老小区居民大爷联合抵制 今天上午，朝歌区梆子公司决定，在每天三更天不亮免费在各大小区门口设卡为全城提供二次震耳欲聋的敲更提醒，呼吁大家早睡早起，不要因为贪睡断送大好人生，时代的符号是前进。为此，全区老人都蹲在该公司东边树丛合力抵制，不给公司人员放行，场面混乱。李罗鹰住进朝歌区五十年了，人称老鹰头，几年孙子李虎南刚从东北当猎户回来，每月还寄回来几块鼹鼠干。李罗鹰当年遇到的老婆是朝歌一枝花，所以李南虎是长得非常秀气的一个汉子。李罗鹰表示：无论梆子公司做的对错，反正不能打扰他孙子睡觉，子曰：‘睡觉乃人之常情’。梆子公司这是连菩萨睡觉都不放过啊。李南虎表示：梆子公司智商捉急，小心居民猴急跳墙！这三伏天都不给睡觉，这不扯淡么！ 到了中午人群仍未离散，更有人提议要烧掉这个公司，公司高层似乎恨不得找个洞钻进去。直到治安人员出现才疏散人群归家，但是李南虎仍旧表示爷爷年纪大了，睡不好对身体不好。 朝歌区梆子公司三更放炮 老小区居民大爷联合抵制 喵天上午，汪歌区哞叽公司决定，在每天八哇天不全免费在各大小区门脑设卡为全城提供双次震耳欲聋的敲哇提醒，呼吁大家早睡早起，不要因为贪睡断送大好人生，时代的编号是前进。为此，全区眠人都足在该公司流边草丛合力抵制，不给公司人员放行，场面混乱。李罗鸟住进汪歌区五十年了，人称眠鸟顶，几年孙叽李熬值刚从流北当屁户回来，每月还寄回来几块报信干。李罗鸟当年遇到的眠婆是汪歌一枝花，所以李值熬是长得非常秀气的一个汉叽。李罗鸟表示：无论哞叽公司做的对错，反正不能打扰他孙叽睡觉，叽叶：‘睡觉乃人之常情’。哞叽公司这是连衣服睡觉都不放过啊。李值熬表示：哞叽公司智商捉急，小心居民猴急跳墙！这八伏天都不给睡觉，这不扯淡么！ 到了中午人群仍未离散，哇有人提议要烧掉这个公司，公司高层似乎恨不得找个洞钻进去。直到治安人员出现才疏散人群归家，但是李值熬仍旧表示爷爷年纪大了，睡不好对身体不好。 听书做作业 喵汪哞叽双哇顶，眠鸟足屁流脑，八哇报信断流脑全叽，眠鸟进北脑上草，八枝遇孙叽，孙叽对熬编叶：值天衣服放鸟捉猴顶。鸟对：北汪罗汉伏熬乱天门。合编放行，卡编扯呼。人离烧草，报信归洞，孙叽找爷爷。 这道题目其实更像是一道MISC题目，这道题目的总体思路是和达芬奇密码那道题目有着异曲同工之妙的，\n写个处理脚本即可：\nflag = \u0026#34;\u0026#34; flag_list = [] str1 = \u0026#34;今天上午，朝歌区梆子公司决定，在每天三更天不亮免费在各大小区门口设卡为全城提供二次震耳欲聋的敲更提醒，呼吁大家早睡早起，不要因为贪睡断送大好人生，时代的符号是前进。为此，全区老人都蹲在该公司东边树丛合力抵制，不给公司人员放行，场面混乱。李罗鹰住进朝歌区五十年了，人称老鹰头，几年孙子李虎南刚从东北当猎户回来，每月还寄回来几块鼹鼠干。李罗鹰当年遇到的老婆是朝歌一枝花，所以李南虎是长得非常秀气的一个汉子。李罗鹰表示：无论梆子公司做的对错，反正不能打扰他孙子睡觉，子曰：‘睡觉 乃人之常情’。梆子公司这是连菩萨睡觉都不放过啊。李南虎表示：梆子公司智商捉急，小心居民猴急跳墙！这三伏天都不给睡觉，这不 扯淡么！到了中午人群仍未离散，更有人提议要烧掉这个公司，公司高层似乎恨不得找个洞钻进去。直到治安人员出现才疏散人群归家，但是李南虎仍旧表示爷爷年纪大了，睡不好对身体不好。\u0026#34; str2 = \u0026#34;喵天上午，汪歌区哞叽公司决定，在每天八哇天不全免费在各大小区门脑设卡为全城提供双次震耳欲聋的敲哇提醒，呼吁大家早睡早起，不要因为贪睡断送大好人生，时代的编号是前进。为此，全区眠人都足在该公司流边草丛合力抵制，不给公司人员放行，场面混乱。李罗鸟住进汪歌区五十年了，人称眠鸟顶，几年孙叽李熬值刚从流北当屁户回来，每月还寄回来几块报信干。李罗鸟当年遇到的眠婆是汪歌一枝花，所以李值熬是长得非常秀气的一个汉叽。李罗鸟表示：无论哞叽公司做的对错，反正不能打扰他孙叽睡觉，叽叶：‘睡觉 乃人之常情’。哞叽公司这是连衣服睡觉都不放过啊。李值熬表示：哞叽公司智商捉急，小心居民猴急跳墙！这八伏天都不给睡觉，这不 扯淡么！到了中午人群仍未离散，哇有人提议要烧掉这个公司，公司高层似乎恨不得找个洞钻进去。直到治安人员出现才疏散人群归家，但是李值熬仍旧表示爷爷年纪大了，睡不好对身体不好。\u0026#34; str3 = \u0026#34;喵汪哞叽双哇顶，眠鸟足屁流脑，八哇报信断流脑全叽，眠鸟进北脑上草，八枝遇孙叽，孙叽对熬编叶：值天衣服放鸟捉猴顶。鸟对：北汪罗汉伏熬乱天门。合编放行，卡编扯呼。人离烧草，报信归洞，孙叽找爷爷。\u0026#34; for i in range(len(str3)): for j in range(len(str2)): if str3[i] == str2[j]: flag += str1[j] break print(flag) 运行脚本得到一段文字：\n今朝梆子二更头，老鹰蹲猎东口，三更鼹鼠断东口亮子，老鹰进北口上树，三枝遇孙子，孙子对虎符曰：南天菩萨放鹰捉猴头。鹰对：北朝罗汉伏虎乱天门。合符放行，卡符扯呼。人离烧树，鼹鼠归洞，孙子找爷爷。 而本题的flag就在这段文字中，即flag{南天菩萨放鹰捉猴头}\n0xB SameMod # 看到题目，不由就联想到了共模攻击，应该是一道RSA题目，瞧瞧看吧！\n{6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,773} {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,839} message1=3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2=5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 这熟悉的感觉，共模攻击没错了！\n直接丢个共模攻击的脚本：\nimport libnum n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249 e1 = 773 e2 = 839 c1=3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 c2=5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 def Samemod(n,c1,c2,e1,e2): def egcd(a,b): if b == 0: return a,0 else: x,y = egcd(b, a % b) return y,x - ( a//b )*y s = egcd(e1,e2) s1 = s[0] s2 = s[1] if s1\u0026amp;lt;0: s1 = -s1 c1 = libnum.invmod(c1,n) elif s2\u0026amp;lt;0: s2 = -s2 c2 = libnum.invmod(c2,n) m = pow(c1,s1,n)*pow(c2,s2,n) %n return m m = Samemod(n, c1, c2, e1, e2) flag = \u0026#34;\u0026#34; m = str(m) i = 0 while i\u0026amp;lt;len(m): if m[i] == \u0026#39;1\u0026#39;: c = chr(int(m[i:i+3])) i += 3 else: c=chr(int(m[i:i+2])) i += 2 flag +=c print flag 运行脚本，得到flag：\nflag{whenwethinkitispossible} 0xC [GWCTF 2019]BabyRSA # 开始了，开始了！RSA的盛宴！\n两个文件，一个secret文件，一个encrypt.py文件\nsecret\nN=636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163 m1=90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239 m2=487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546 encrypt.py\nimport hashlib import sympy from Crypto.Util.number import * flag = \u0026#39;GWHT{******}\u0026#39; secret = \u0026#39;******\u0026#39; assert(len(flag) == 38) half = len(flag) / 2 flag1 = flag[:half] flag2 = flag[half:] secret_num = getPrime(1024) * bytes_to_long(secret) p = sympy.nextprime(secret_num) q = sympy.nextprime(p) N = p * q e = 0x10001 F1 = bytes_to_long(flag1) F2 = bytes_to_long(flag2) c1 = F1 + F2 c2 = pow(F1, 3) + pow(F2, 3) assert(c2 \u0026amp;lt; N) m1 = pow(c1, e, N) m2 = pow(c2, e, N) output = open(\u0026#39;secret\u0026#39;, \u0026#39;w\u0026#39;) output.write(\u0026#39;N=\u0026#39; + str(N) + \u0026#39;n\u0026#39;) output.write(\u0026#39;m1=\u0026#39; + str(m1) + \u0026#39;n\u0026#39;) output.write(\u0026#39;m2=\u0026#39; + str(m2) + \u0026#39;n\u0026#39;) output.close() 根据源码文件，可以对源码文件进行简单分析，发现p和q的数值是非常接近的，可以直接对n开平方然后求得下一个素数来得到p，然后再用n除以p来得到q。这道rsa题目使用了套娃，对密文加了一层方程组的套套：\n[ c_1 = F_1+F_2 ]\n[ c_2 = F_1^3 + F_2^3 ]\n其实这道题目也没有太大的难度，扔给脚本直接求解就好：\nimport libnum import sympy N=636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163 m1=90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239 m2=487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546 e = 0x10001 p =sympy.nextprime(libnum.nroot(N,2)) q = N // p assert(N == p*q) phi = (p-1)*(q-1) d = libnum.invmod(e,phi) c1 = pow(m1,d,N) c2 = pow(m2,d,N) x = sympy.Symbol(\u0026#39;x\u0026#39;) y = sympy.Symbol(\u0026#39;y\u0026#39;) result = sympy.solve([x + y - c1, x**3 + y**3 - c2 ],[x,y]) # print result F1 = int(result[0][0]) F2 = int(result[0][1]) flag1 = libnum.n2s(F1) flag2 = libnum.n2s(F2) flag = flag2 + flag1 print flag 运行脚本，大约等个2min，得到flag：\nGWHT{f709e0e2cfe7e530ca8972959a1033b2} 0xD [WUSTCTF2020]babyrsa # 又是一道有点意思的RSA题目，看看题吧！\nc = 28767758880940662779934612526152562406674613203406706867456395986985664083182 n = 73069886771625642807435783661014062604264768481735145873508846925735521695159 e = 65537 拿到这个题目，好像除了爆破n，没有什么别的方法了，那就分解一下n就好了\n使用sage分解一下（笑~漫长的等待）,得到分解结果：\n189239861511125143212536989589123569301*386123125371923651191219869811293586459 然后就是愉快地写脚本了：\nimport libnum c = 28767758880940662779934612526152562406674613203406706867456395986985664083182 n = 73069886771625642807435783661014062604264768481735145873508846925735521695159 e = 65537 p = 189239861511125143212536989589123569301 q = 386123125371923651191219869811293586459 phi = (p-1)*(q-1) d = libnum.invmod(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，得到flag：\nwctf2020{just_@_piece_0f_cak3} 0xE RSA4 # 看看这RSA有什么东西吧！\nN = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004 c = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243 N = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114 c = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344 N = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323 c = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242 看样子是低加密指数广播攻击了，观察数据发现数据中都是小于5的数字，五进制，这可太恶心了，看来还需要进行一下进制转换。但是题目没有给出e的数值，根据这种攻击可能的情况，e的取值是3，10，17，然后结合中国剩余定理求解，我丢！\nimport libnum import string N1 = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004 c1 = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243 N2 = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114 c2 = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344 N3 = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323 c3 = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242 N = [N1,N2,N3] c = [c1,c2,c3] for i in range(3): N[i] = int(str(N[i]),5) c[i] = int(str(c[i]),5) def CRT(data): sum_ = 0 m = 1 for n in data: m = m*n[0] for n,c in data: m1 = m/n mr = libnum.invmod(m1,n) sum_ = sum_ + mr * m1 * c return sum_ % m def isprintstr(data): index = 0 for i in data: if i not in string.printable: index = 0 break else: index = 1 if index == 1: return libnum.n2s(m) else: return False data = zip(N,c) m_e = CRT(data) e = [3,10,17] flag = \u0026#34;\u0026#34; for i in e: m = libnum.nroot(m_e,i) flag = isprintstr(libnum.n2s(m)) if flag: print flag 运行脚本，得到flag：\nnoxCTF{D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!} 0xF yxx # 这是啥？看看题目吧！\n附件里面是两个txt文件\n明文.txt：\nlovelovelovelovelovelovelovelove 密文.txt：\n\u0003\u0017\u0002V\u0001\u0015\u0011 \u0014\u000e \u001e0\u000e \u001e0\u000e \u001e0\u0014\u000c\u0019 \u001f\u0010\u000e\u0006\u0003\u0018 密文中有很多不可打印的字符，这道题目应该是考察异或操作的，写个脚本读一下转一下数字进行一下异或：\nimport libnum c = \u0026#34;\u0026#34; m = \u0026#34;\u0026#34; with open(\u0026#34;c.txt\u0026#34;,\u0026#34;rb\u0026#34;) as f: lines = f.readlines() for line in lines: c += line with open(\u0026#34;m.txt\u0026#34;) as f: lines = f.readlines() for line in lines: m += line m_n = libnum.s2n(m) c_n = libnum.s2n(c) result = m_n^c_n flag = libnum.n2s(result) print flag 运行脚本，得到flag：\nflag:nctf{xor_xor_xor_biubiubiu} 本期wp分享到此为止，有时间再来喝杯茶呀！\n","date":"June 26, 2021","permalink":"/posts/buuctf-crypto-4_writeup/","section":"Posts","summary":"沉浸在密码学的世界里面，缓缓浸入题目的海洋，16道crypto题目！\n这次的题目，难度也开始逐渐上来咯！当然不仅仅只有难度，还有脑洞！\n0x0 古典密码知多少 # 应该是考察古典密码的题目，点开题目下载附件，瞧一瞧\n打开图片就察觉到这题可能会非常草……，果然古典的恶心，应该是三种古典密码的组合，可以清晰地看出有猪圈密码和变种圣堂武士密码，至于剩下那一种密码实在是找不到……，只能无奈地去瞧一瞧大佬的wp，发现是标准银河字母。根据得到的信息进行比对，蓝色的是猪圈密码，橙色的是圣堂武士密码，黑色的是标准银河字母。根据信息，进行解密得：\nFGCPFLIRTUASYON 看样子应该还有一层加密，最常见的古典加密方法就是凯撒加密和栅栏密码，经过尝试发现是栅栏密码，使用栅栏密码进行解密得到flag：\nFLAGISCRYPTOFUN 猪圈密码对照表：\n圣堂武士密码对照表：\n标准银河字母对照表：\n0x1 [HDCTF2019]bbbbbbrsa # 看来又是熟悉的RSA题目，嘤嘤嘤~\n下载附件，打开发现有两个文件，一个enc文件，一个encode.py文件\nenc文件：\np = 177077389675257695042507998165006460849 n = 37421829509887796274897162249367329400988647145613325367337968063341372726061 c = ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM encode.py文件：\nfrom base64 import b64encode as b32encode from gmpy2 import invert,gcd,iroot from Crypto.Util.number import * from binascii import a2b_hex,b2a_hex import random flag = \u0026#34;******************************\u0026#34; nbit = 128 p = getPrime(nbit) q = getPrime(nbit) n = p*q print p print n phi = (p-1)*(q-1) e = random.","title":"BUUCTF CRYPTO (4) writeup"},{"content":"BJDCTF 2nd的密码学题目有8道题目可以尝试做一做，都挺有意思的。\n0x0 签到-y1ng # 来康康题目：\nwelcome to BJDCTF 1079822948 QkpEe1czbGMwbWVfVDBfQkpEQ1RGfQ== 直接使用base64解码就好：\nBJD{W3lc0me_T0_BJDCTF} 0x1 老文盲了 # 下载附件，康康附件有什么好玩的内容：\n罼雧締眔擴灝淛匶襫黼瀬鎶軄鶛驕鳓哵眔鞹鰝 不认识的文字内容，不认识怎么办？找找拼音吧，查了一下发现有个汉字转拼音的工具：在线汉字转换拼音工具 (aies.cn)\n用一下这个工具得到拼音：\nbì jí dì dà kuò hào zhè jiù shì fǔ lài gē zhí jiē jiāo lè bā dà kuò hào 根据拼音得到flag：\nBJD{淛匶襫黼瀬鎶軄鶛驕鳓哵} 0x2 cat_flag # 下载附件，康康有什么有趣的内容：\n附件内容\n哇哦！一个gif图片，仔细康康图片，发现猫猫挺像二进制编码的，尝试写个小脚本解决一下：\nimport libnum cat_list=[ \u0026#34;01000010\u0026#34;, \u0026#34;01001010\u0026#34;, \u0026#34;01000100\u0026#34;, \u0026#34;01111011\u0026#34;, \u0026#34;01001101\u0026#34;, \u0026#34;00100001\u0026#34;, \u0026#34;01100001\u0026#34;, \u0026#34;00110000\u0026#34;, \u0026#34;01111110\u0026#34;, \u0026#34;01111101\u0026#34; ] cat_c = \u0026#34;\u0026#34;.join(cat_list) flag = libnum.n2s(int(cat_c,2)) print flag 运行脚本，得到flag：\nBJD{M!a0~} 0x3 灵能精通-y1ng # 来康康题目描述：\n身经百战的Y1ng已经达到崇高的武术境界，以自律克己来取代狂热者的战斗狂怒与传统的战斗形式。Y1ng所受的训练也进一步将他们的灵能强化到足以瓦解周遭的物质世界。借由集中这股力量，Y1ng能释放灵能能量风暴来摧毁敌人的心智、肉体与器械。 得到的 flag 建议用 flag{} 包上提交。 感觉题目描述挺有意思，看来出题人也是玩星际的，下载附件瞧一瞧吧！\n附件内容\n如果附件打不开，附件的文件名是jpg，这是个hint，可以尝试把附件的文件名扩展名修改为.jpg打开\n附件内容是个图片，看样子好像猪圈密码，不过应该是猪圈密码的变形，圣堂武士密码。\n圣堂武士密码是什么呢？\n圣堂武士密码无非就是猪圈密码的变种，查表就可以进行求解：\n圣堂武士密码表\n根据圣堂武士密码的密码表进行求解：\nIMKNIGHTSTEMPLAR 得到flag：\nflag{IMKNIGHTSTEMPLAR} 0x4 燕言燕语-y1ng # 瞧一瞧题目描述：\n小燕子，穿花衣，年年春天来这里，我问燕子你为啥来，燕子说: 79616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20 看样子还是比较有趣的题目，燕子说的话像是hex编码，简单进行编码解码：\nyanzi ZJQ{xilzv_iqssuhoc_suzjg} 像是一个移位替换密码，而且还有密钥，自然而然就联想到多表替换的维吉尼亚密码，使用维吉尼亚密码进行解密，密钥是yanzi。解密得到flag：\nBJD{yanzi_jiushige_shabi} 0x5 Y1nglish-y1ng # 看看题目描述：\nY1ng根据English居然独自发明了一门语言，就叫Y1nglish 明文都是可读的英文单词，flag如果提交失败，自己读一下，把错误的单词修正，再提交(某个地方的u和i不需要调换顺序，错误点不在那里) 得到的 flag 建议用 flag{} 包上提交。 又是一道有意思的古典密码学题目，下载附件看一看吧！\nNkbaslk ds sef aslckdqdqst. Sef aslckdqdqst qo lzqtbw usf ufkoplkt zth oscpslsfko. Dpkfk zfk uqjk dwcko su dscqao qt dpqo aslckdqdqst, kzap su npqap qo jkfw mzoqa. Qu wse zfk qtdkfkodkh qt tkdnsfw okaefqdw, nkbaslk ds czfdqaqczdk. Bkd lk dkbb wse z odsfw. Q nzo pzjqtv hqttkf zd z fkodzefztd npkt Pzffw Odkkbk azlk qt, pk qo z Izcztkok ufsl Izczt med tsn pk qo tsd bqjqtv qt Izczt, lzwmk Pzffw qot\u0026#39;d z Izcztkok tzlk med pk qo fkzbbw z Izcztkok. Pzffw nsfwkh qt z bznwkf\u0026#39;o suuqak wkzfo zvs, med pk qo tsn nsfwqtv zd z mztw. Pk vkdo z vssh ozbzfw, med pk zbnzwo msffsno lstkw ufsl pqo ufqktho zth tkjkf czwo qd mzaw. Pzffw ozn lk zth azlk zthozdzd dpk ozlk dzmbk. Pk pzo tkjkf msffsnkh lstkw ufsl lk. Npqbk pk nzo kzdqtv, Q zowkh pql ds bkth lk \u0026amp;2. Ds lw oefcfqok, pk vzjk lk dpk lstkw qllkhqzdkbw. \u0026#39;Q pzjk tkjkf msfffsnkh ztw lstkw ufsl wse,\u0026#39; Pzffw ozqh,\u0026#39;os tsn wse azt czw usf lw hqttkf!\u0026#39; Tsn q nqbb vqjk wse npzd wse nztd. MIH{cwdp0t_Mfed3_u0fa3_sF_geqcgeqc_ZQ_Af4aw} 扔到词频分析里面看一看有什么有意思的东西吧！\nWelcome to our competition. Our competition is mainly for freshmen and sophomores. There are five types of topics in this competition, each of which is very basic. If you are interested in networy security, welcome to participate. Let me tell you a story. I was having dinner at a restaurant when Harry Steele came in, he is a Japanese from Japan but now he is not living in Japan, maybe Harry isn\u0026#39;t a Japanese name but he is really a Japanese. Harry woryed in a lawyer\u0026#39;s office years ago, but he is now worying at a bany. He gets a good salary, but he always borrows money from his friends and never pays it bacy. Harry saw me and came andsatat the same table. He has never borrowed money from me. While he was eating, I asyed him to lend me \u0026amp;2. To my surprise, he gave me the money immediately. \u0026#39;I have never borrrowed any money from you,\u0026#39; Harry said,\u0026#39;so now you can pay for my dinner!\u0026#39; Now i will give you what you want. BJD{pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4cy} 看到flag了，这个会是flag吗？提交发现失败了，需要找找这flag中的错误单词呀！\nBJD{pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4cy} 仔细看看，可能是“Cr4cy”单词出错了，应该是“Cr4ck”，将y改成k，提交flag就成功了！\nBJD{pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4ck} 0x6 rsa0 # 终于看到了满怀期待的RSA题目了，这个题目需要nc连接，打开kali使用nc连一下：\nnc连接\nnc获取了一些信息：\ne=10477063 p+q=17797691537345386808732394196803681705577569713058967120949517816644062502139647331474144263789043199741290898466578874059252164582901136367451369351827816 p-q=1305460584852976150632619140303339956209228307006605810393373145443065968179582165859467446565684139103706614652868361938441145461112269668449569764472982 c=39163440507451196385175391692403807512116238503431942217244080791066873723780085527827581471431177375753278940397090368658088104095247010524149681791425756148064544080426058546466326660811194616137132601269623860143290910244742205045745875133012498997510445277485057284790297158770357940730856250397868755440 flag=?????? 应该是一道简单的解方程题目，编写python脚本处理一下：\nimport sympy import libnum e=10477063 pq_add=17797691537345386808732394196803681705577569713058967120949517816644062502139647331474144263789043199741290898466578874059252164582901136367451369351827816 pq_reduce=1305460584852976150632619140303339956209228307006605810393373145443065968179582165859467446565684139103706614652868361938441145461112269668449569764472982 c=39163440507451196385175391692403807512116238503431942217244080791066873723780085527827581471431177375753278940397090368658088104095247010524149681791425756148064544080426058546466326660811194616137132601269623860143290910244742205045745875133012498997510445277485057284790297158770357940730856250397868755440 p = sympy.Symbol(\u0026#39;p\u0026#39;) q = sympy.Symbol(\u0026#39;q\u0026#39;) result = sympy.solve([p+q-pq_add,p-q-pq_reduce],[p,q]) p = int(result[p]) q = int(result[q]) n = p*q phi = (p-1)*(q-1) d = libnum.invmod(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，得到flag：\nflag{562f22b9-400d-4ec9-aa76-cd616aac90f1} 0x7 rsa1 # RSA题目，这道题目同样也需要nc进行一下连接才能看到信息，用kali连一下吧！\nnc连接\n通过nc连接可以得到如下信息：\ne=13978249 p^2+q^2=151633530567840355748243871671727511189658909500927250886437120180748983135296331316827920586717252371861785059822420509109728958374451816184682503257816598163005301542586939209069221866722313318463885766603690164708951344417890956348605521584906780834058177779608801835165928975303416040686406630968929531010 p-q=-2118796405660557026785910948566097381644078577714422876494681451389305041193569373390033403177726098952539178824903786390753214478292445023621601397654014 c=21916668537159292929146888499738761128788996251113020794961311339328734967861189157533491528242915717785269949067916125251437612282270561594687073731637132301015100520285933737661576838469743738400472236913537499783613239148851084298950840310231212420378731161267913668383166553730465799427960831384019988540 flag=?????? 还是比较类似的考察方法，依旧是解方程，编写一个小脚本求解吧！\nimport sympy import libnum e=13978249 f1=151633530567840355748243871671727511189658909500927250886437120180748983135296331316827920586717252371861785059822420509109728958374451816184682503257816598163005301542586939209069221866722313318463885766603690164708951344417890956348605521584906780834058177779608801835165928975303416040686406630968929531010 f2=-2118796405660557026785910948566097381644078577714422876494681451389305041193569373390033403177726098952539178824903786390753214478292445023621601397654014 c=21916668537159292929146888499738761128788996251113020794961311339328734967861189157533491528242915717785269949067916125251437612282270561594687073731637132301015100520285933737661576838469743738400472236913537499783613239148851084298950840310231212420378731161267913668383166553730465799427960831384019988540 p = sympy.Symbol(\u0026#39;p\u0026#39;) q = sympy.Symbol(\u0026#39;q\u0026#39;) result = sympy.solve([p**2+q**2-f1,p-q-f2],[p,q]) # print result p = int(result[1][0]) q = int(result[1][1]) # print p,q n = p*q phi = (p-1)*(q-1) d = libnum.invmod(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，得到flag：\nflag{db0f7d6f-da5a-413b-8dfa-1a82a004c083} BJD 2nd的Crypto题目全部求解，脑洞题目偏多，整体考察比较综合，难度相对较低。\n","date":"June 26, 2021","permalink":"/posts/bjdctf-2nd-crypto_writeup/","section":"Posts","summary":"BJDCTF 2nd的密码学题目有8道题目可以尝试做一做，都挺有意思的。\n0x0 签到-y1ng # 来康康题目：\nwelcome to BJDCTF 1079822948 QkpEe1czbGMwbWVfVDBfQkpEQ1RGfQ== 直接使用base64解码就好：\nBJD{W3lc0me_T0_BJDCTF} 0x1 老文盲了 # 下载附件，康康附件有什么好玩的内容：\n罼雧締眔擴灝淛匶襫黼瀬鎶軄鶛驕鳓哵眔鞹鰝 不认识的文字内容，不认识怎么办？找找拼音吧，查了一下发现有个汉字转拼音的工具：在线汉字转换拼音工具 (aies.cn)\n用一下这个工具得到拼音：\nbì jí dì dà kuò hào zhè jiù shì fǔ lài gē zhí jiē jiāo lè bā dà kuò hào 根据拼音得到flag：\nBJD{淛匶襫黼瀬鎶軄鶛驕鳓哵} 0x2 cat_flag # 下载附件，康康有什么有趣的内容：\n附件内容\n哇哦！一个gif图片，仔细康康图片，发现猫猫挺像二进制编码的，尝试写个小脚本解决一下：\nimport libnum cat_list=[ \u0026#34;01000010\u0026#34;, \u0026#34;01001010\u0026#34;, \u0026#34;01000100\u0026#34;, \u0026#34;01111011\u0026#34;, \u0026#34;01001101\u0026#34;, \u0026#34;00100001\u0026#34;, \u0026#34;01100001\u0026#34;, \u0026#34;00110000\u0026#34;, \u0026#34;01111110\u0026#34;, \u0026#34;01111101\u0026#34; ] cat_c = \u0026#34;\u0026#34;.join(cat_list) flag = libnum.n2s(int(cat_c,2)) print flag 运行脚本，得到flag：","title":"BJDCTF 2nd CRYPTO_writeup"},{"content":"GKCTF2020的密码学题目相对而言比较简单，古典密码学题目偏多。而且密码学题目也只有四道题目\n0x0 小学生的密码学 # 打开题目描述，查看题目描述内容：\ne(x)=11x+6(mod26) 密文：welcylk （flag为base64形式） 看样子是仿射密码，直接逆就好了，写个python脚本解决吧：\nimport gmpy2 import string import base64 m = gmpy2.invert(11,26) table = string.ascii_lowercase # print table cipher = \u0026#34;welcylk\u0026#34; plainer = \u0026#34;\u0026#34; for i in cipher: x = table.index(i) j = (x-6)*m %26 # print j plainer += table[j] flag = \u0026#34;flag{\u0026#34;+base64.b64encode(plainer) +\u0026#34;}\u0026#34; print flag 运行脚本，得到flag：\nflag{c29yY2VyeQ==} 0x1 汉字的秘密 # 题目描述：\n你能看出汉字的奥秘吗？ 答案形式：flag{小写字母} 和汉字相关的密码，又是考察古典密码，估计是当铺密码\n下载附件，发现附件是一个doc文件，查看附件内容：\n王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫 看样子是当铺密码，没错了，写个脚本处理一下吧：\ndh = \u0026#39;田口由中人工大土士王夫井羊壮\u0026#39; ds = \u0026#39;00123455567899\u0026#39; c = \u0026#39;王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫\u0026#39; s = \u0026#39;\u0026#39; for i in c: if i in dh: s += ds[dh.index(i)] else: s += \u0026#39; \u0026#39; #print(s) c_list = s.split(\u0026#34; \u0026#34;) m = \u0026#39;\u0026#39; for i in range(0,len(c_list)): m += chr(int(c_list[i])+i+1) flag = m.lower() print(flag) 运行脚本，得到flag：\nflag{you_are_good} 那什么是当铺密码呢？\n当铺密码是一种很有意思的密码，专门用来加密数字的，不需要密钥，明文信息包含在加密后的密文中。\n它通过一个汉字中隐藏的信息：笔画数，来将汉字和数字关联起来，将汉字定义为明文，将数字定义为密文，加密是将数字映射到对应笔画的汉字，解密是将汉字按照笔画映射回数字。\n有很多汉字的笔画数是相同的，所以可能会有多个明文（汉字）对应同一个密文（数字），当然这个主要是看汉字笔画映射表的选择，如果映射表只准备了9个汉字，每种笔画有一个汉字对应则是一对一的，否则是一对多的。一对一的话有个缺点就是如果要加密的明文中有重复数字，比如33，转换为“飞马”比“三三”更难总结出规律，而这种没有秘钥的加密方式重要的就是隐藏自己的规律，所以一对多会更难被破译。[1]\n当铺密码就是根据汉字的特点来设计的一种古典密码，还是挺有意思的，虽然不是很实用。\n0x2 babycrypto # 下载附件，查看附件内容：\n# n:0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L # e:65537 # enc:1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361 # p\u0026gt;\u0026gt;128\u0026lt;\u0026lt;128:0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L RSA题目，考察的应该是p的高位泄露，应该是针对p的高位泄露进行设计的攻击算法来进行求解的。经查询发现，coppersmith算法应该是就是解决p高位泄露问题的解密算法，但是这个算法需要使用的开源数学工具sagemath。这里采用sagemath程序解决：\nn = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L p_fake = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L pbits = 1024 kbits = 128 pbar = p_fake \u0026amp; (2^pbits-2^kbits) print(\u0026#34;upper %d bits (of %d bits) is given\u0026#34; % (pbits-kbits, pbits)) PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = x + pbar x0 = f.small_roots(X=2^kbits, beta=0.4)[0] print(hex(int(x0 + pbar))) 使用sagemath运行可以得到p的数值：\n0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b92826225b6d0e735440b613a8336ffa3 然后再使用一常规的RSA脚本进行求解：\nimport libnum n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L e = 65537 c = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361 p = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b92826225b6d0e735440b613a8336ffa3 q = n // p phi = (p-1)*(q-1) d = libnum.invmod(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，得到flag：\nflag{3d0914a1-1e97-4822-a745-c7e20c5179b9} 0x3 Backdoor # 查看题目描述：\np=k*M+(65537**a %M) 根据题目描述可以联想到ROCA漏洞，可以从论文中清晰地看到：\n正好符合这个题目的hint，这个题目的考察要点应该就是ROCA的CVE漏洞。这个CVE的利用再GitHub上面有现成的轮子，进行稍微修改一下就可以使用，这里给出解题的sagemath exp：[2]\nparam = { 512: { \u0026#34;n\u0026#34;: 39, \u0026#34;a_max\u0026#34;: 62, \u0026#34;k_max\u0026#34;: 37, \u0026#34;M\u0026#34;: 0x924cba6ae99dfa084537facc54948df0c23da044d8cabe0edd75bc6, \u0026#34;M_prime\u0026#34;: 0x1b3e6c9433a7735fa5fc479ffe4027e13bea, \u0026#34;m\u0026#34;: 5, \u0026#34;t\u0026#34;: 6, \u0026#34;c_a\u0026#34;: 0x80000 }, 1024: { \u0026#34;n\u0026#34;: 71, \u0026#34;a_max\u0026#34;: 134, \u0026#34;k_max\u0026#34;: 37, \u0026#34;M\u0026#34;: 0x7923ba25d1263232812ac930e9683ac0b02180c32bae1d77aa950c4a18a4e660db8cc90384a394940593408f192de1a05e1b61673ac499416088382, \u0026#34;M_prime\u0026#34;: 0x24683144f41188c2b1d6a217f81f12888e4e6513c43f3f60e72af8bd9728807483425d1e, \u0026#34;m\u0026#34;: 4, \u0026#34;t\u0026#34;: 5, \u0026#34;c_a\u0026#34;: 0x40000000 }, 2048: { \u0026#34;n\u0026#34;: 126, \u0026#34;a_max\u0026#34;: 434, \u0026#34;k_max\u0026#34;: 53, \u0026#34;M\u0026#34;: 0x7cda79f57f60a9b65478052f383ad7dadb714b4f4ac069997c7ff23d34d075fca08fdf20f95fbc5f0a981d65c3a3ee7ff74d769da52e948d6b0270dd736ef61fa99a54f80fb22091b055885dc22b9f17562778dfb2aeac87f51de339f71731d207c0af3244d35129feba028a48402247f4ba1d2b6d0755baff6, \u0026#34;M_prime\u0026#34;: 0x16928dc3e47b44daf289a60e80e1fc6bd7648d7ef60d1890f3e0a9455efe0abdb7a748131413cebd2e36a76a355c1b664be462e115ac330f9c13344f8f3d1034a02c23396e6, \u0026#34;m\u0026#34;: 7, \u0026#34;t\u0026#34;: 8, \u0026#34;c_a\u0026#34;: 0x400000000 } } # https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/coppersmith.sage def coppersmith_howgrave_univariate(pol, N, beta, mm, tt, XX): \u0026#34;\u0026#34;\u0026#34; Coppersmith revisited by Howgrave-Graham finds a solution if: * b|N, b \u0026gt;= N^beta , 0 \u0026lt; beta \u0026lt;= 1 * |x| \u0026lt; XX \u0026#34;\u0026#34;\u0026#34; # # init # dd = pol.degree() nn = dd * mm + tt # # checks # if not 0 \u0026lt; beta \u0026lt;= 1 : raise ValueError(\u0026#34;beta should belongs in (0, 1]\u0026#34;) if not pol.is_monic(): raise ArithmeticError(\u0026#34;Polynomial must be monic.\u0026#34;) # # Coppersmith revisited algo for univariate # # change ring of pol and x polZ = pol.change_ring(ZZ) x = polZ.parent().gen() # compute polynomials gg = [] for ii in range(mm): for jj in range(dd): gg.append((x * XX)**jj * N**(mm - ii) * polZ(x * XX)**ii) for ii in range(tt): gg.append((x * XX)**ii * polZ(x * XX)**mm) # construct lattice B BB = Matrix(ZZ, nn) for ii in range(nn): for jj in range(ii+1): BB[ii, jj] = gg[ii][jj] # LLL BB = BB.LLL(early_red=True, use_siegel=True) # transform shortest vector in polynomial new_pol = 0 for ii in range(nn): new_pol += x**ii * BB[0, ii] / XX**ii # factor polynomial potential_roots = new_pol.roots() return [i[0] for i in potential_roots] # Top level of the attack, feeds the queue for the workers def roca(N): # Key is not always of perfect size, infer from size keylength = int(log(N, 2)) if keylength \u0026lt; 1000 : keylength = 512 elif keylength \u0026lt; 2000 : keylength = 1024 elif keylength \u0026lt; 4000 : keylength = 2048 else: keylength = 4096 # bruteforce M_prime = param[keylength][\u0026#39;M_prime\u0026#39;] c_prime = discrete_log(N, Mod(65537, M_prime)) ord_prime = Zmod(M_prime)(65537).multiplicative_order() top = (c_prime + ord_prime)/2 beta = 0.5 mm = param[keylength][\u0026#39;m\u0026#39;] tt = param[keylength][\u0026#39;t\u0026#39;] XX = int((2*pow(N, beta)) / M_prime) # Bruteforce until p, q are found a_prime = floor(c_prime/2) while a_prime \u0026lt; top: # Construct polynomial m_inv = int(inverse_mod(M_prime, N)) k_tmp = int(pow(65537, a_prime, M_prime)) known_part_pol = int(k_tmp * m_inv) F = PolynomialRing(Zmod(N), implementation=\u0026#39;NTL\u0026#39;, names=(\u0026#39;x\u0026#39;,)) (x,) = F._first_ngens(1) pol = x + known_part_pol # Get roots of polynomial using coppersmith roots = coppersmith_howgrave_univariate(pol, N, beta, mm, tt, XX) # Check if roots are p, q for root in roots: factor1 = k_tmp + abs(root) * M_prime if mod(N, factor1) == 0: factor2 = N // factor1 return int(factor1), int(factor2) a_prime += 1 from Crypto.Util.number import * from Crypto.PublicKey import RSA import base64 with open(\u0026#39;./pub.pem\u0026#39;, \u0026#39;r\u0026#39;) as f: key = RSA.import_key(f.read()) e = key.e n = key.n print(n) with open(\u0026#39;flag.enc\u0026#39;, \u0026#39;r\u0026#39;) as f: c = base64.b64decode(f.read()) N = n print (\u0026#34;[+] Factoring %i\u0026#34; % N) factor1, factor2 = roca(N) q = factor1 p = factor2 print (\u0026#34;[+] Found factors of N:\u0026#34;) print (\u0026#34;[+] p =\u0026#34; , factor1) print (\u0026#34;[+] q =\u0026#34; , factor2) assert(p * q == n) d = inverse(e, (q - 1) * (p - 1)) c = bytes_to_long(bytes.fromhex(str(c)[2:-1])) print(long_to_bytes(pow(c, d, n))) 使用sagemath运行得到flag：\nflag{760958c9-cca9-458b-9cbe-ea07aa1668e4} 参考： # 当铺密码-博客园 GKCTF2020 Crypto Writeup- Chrisyy\u0026rsquo;s blog ","date":"June 26, 2021","permalink":"/posts/gkctf2020-crypto_writeup/","section":"Posts","summary":"GKCTF2020的密码学题目相对而言比较简单，古典密码学题目偏多。而且密码学题目也只有四道题目\n0x0 小学生的密码学 # 打开题目描述，查看题目描述内容：\ne(x)=11x+6(mod26) 密文：welcylk （flag为base64形式） 看样子是仿射密码，直接逆就好了，写个python脚本解决吧：\nimport gmpy2 import string import base64 m = gmpy2.invert(11,26) table = string.ascii_lowercase # print table cipher = \u0026#34;welcylk\u0026#34; plainer = \u0026#34;\u0026#34; for i in cipher: x = table.index(i) j = (x-6)*m %26 # print j plainer += table[j] flag = \u0026#34;flag{\u0026#34;+base64.b64encode(plainer) +\u0026#34;}\u0026#34; print flag 运行脚本，得到flag：\nflag{c29yY2VyeQ==} 0x1 汉字的秘密 # 题目描述：\n你能看出汉字的奥秘吗？ 答案形式：flag{小写字母} 和汉字相关的密码，又是考察古典密码，估计是当铺密码\n下载附件，发现附件是一个doc文件，查看附件内容：\n王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫 看样子是当铺密码，没错了，写个脚本处理一下吧：","title":"GKCTF2020 CRYPTO_writeup"},{"content":"同样的味道，同样的感觉，再看密码的世界！\nBUUCTF\n来审视一下，本次的题目：\n题目列表\nMorse Cipher Dangerous RSA basic rsa 达芬奇密码 Checkln BabyRSA rsa2 RSA5 密码学的心声 传感器 这是base？ rot Keyboard 这是什么 childRSA 也是同样满满的16道CTF题目，都是密码学题目哟！\n0x0 Morse # 打开附件，直接就是Morse密码密文：\n-..../.----/-..../-..../-..../...--/--.../....-/-..../-..../--.../-.../...--/.----/--.../...--/..---/--.../--.../....-/...../..-./--.../...--/...--/-----/...../..-./...--/...--/...--/....-/...--/...../--.../----./--.../-.. 直接解密摩斯密码得到：\n61666374667B317327745F73305F333435797D 得到的16进制密文，对密文进行解密：\n成功得到flag：\nafctf{1s\u0026#39;t_s0_345y} flag：afctf{1s\u0026rsquo;t_s0_345y}\n0x1 Cipher # 打开题目描述：\n还能提示什么呢？公平的玩吧（密钥自己找） Dncnoqqfliqrpgeklwmppu 注意：得到的 flag 请包上 flag{} 提交, flag{小写字母} 看的非常懵，考察古典密码的题目，唯一的提示就是“公平的玩吧（密钥自己找）”，实在是找不到头绪，看了大佬的WP发现是playfair加密，在网上找到了一个在线工具可以求解playfair加密，这里就使用在线工具进行解密\n得到解密结果：Itisnotaproblemhavefun\n故得flag: flag{itisnotaproblemhavefun}\n0x2 Dangerous RSA # 应该是一道典型的RSA题目，直接下载附件\n#n: 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L #e: 0x3 #c:0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365 so,how to get the message? e的值非常小，这道RSA题目应该是考察低加密指数攻击的，直接上脚本：\nimport gmpy2 import libnum c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365 n = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L e = 0x3 m = 0 i = 0 while 1: if(gmpy2.iroot(c+i*n,3)[1]==1): m = gmpy2.iroot(c+i*n,3)[0] break i += 1 flag = libnum.n2s(m) print flag 运行脚本，得到flag\nflag：flag{25df8caf006ee5db94d48144c33b2c3b}\n0x3 basic rsa # 应该是RSA加密算法的考察，直接看附件\nimport gmpy2 from Crypto.Util.number import * from binascii import a2b_hex,b2a_hex flag = \u0026#34;*****************\u0026#34; p = 262248800182277040650192055439906580479 q = 262854994239322828547925595487519915551 e = 65533 n = p*q c = pow(int(b2a_hex(flag),16),e,n) print c # 27565231154623519221597938803435789010285480123476977081867877272451638645710 一个非常简单的加密脚本，简单审计一下就能得到结果。这里使用一个脚本解决：\nimport gmpy2 import libnum c = 27565231154623519221597938803435789010285480123476977081867877272451638645710 e = 65533 p = 262248800182277040650192055439906580479 q = 262854994239322828547925595487519915551 n = p*q phi = (p-1)*(q-1) d = gmpy2.invert(e,phi) m = pow(c,d,n) flag = libnum.n2s(m) print flag 运行脚本，获得flag\nflag：flag{B4by_Rs4}\n0x4 达芬奇密码 # 查看题目描述：\n达芬奇一直是一个有争议的画家，科学家。。。小明为了研究他，从网上找到了名画蒙娜丽莎，一天深夜，小明突然从蒙娜丽莎背后的天空中看到了一串神秘的数字。顺带告诉小明达芬奇家窗台上有一串数字是关键。小明千里迢迢找到了这串数字，请将这个送分题做出来，亲，包邮哦（答案是一串32位十进制数字） 注意：得到的 flag 请包上 flag{} 提交 题目应该是和达芬奇有关系，下载附件，查看附件内容\n达芬奇隐藏在蒙娜丽莎中的数字列:1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711 记录在达芬奇窗台口的神秘数字串:36968853882116725547342176952286 数字列非常像斐波那契数列，只不过是斐波那契数列进行了乱序而得到的结果。下面的密文应该是根据乱序的结果进行反向乱序得到明文，这里使用一个反乱序的脚本解决：\nTrue_c = \u0026#39;1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309\u0026#39; False_c = \u0026#39;1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711\u0026#39; cipher = \u0026#39;36968853882116725547342176952286\u0026#39; True_c = True_c.split(\u0026#39; \u0026#39;) False_c = False_c.split(\u0026#39; \u0026#39;) result = [\u0026#39;a\u0026#39;]*32 for i in range(len(cipher)): if(i == 24): index = 1 else: index = True_c.index(False_c[i]) result[index] = cipher[i] for i in result: print(i,end=\u0026#39;\u0026#39;) 运行脚本，得到明文\n37995588256861228614165223347687\n故本题的flag：flag{37995588256861228614165223347687}\n0x5 Checkln # 直接下载附件，查看附件\ndikqTCpfRjA8fUBIMD5GNDkwMjNARkUwI0BFTg== 看样子，密文像是base64加密过的明文，首先尝试进行base64解密得到密文：\nv)L_F0\u0026lt;}@H0\u0026gt;F49023@FE0#@EN 如果对这对古典密码熟悉，看到这一段应该就可以识别出这是ROT47加密的密文，使用ROT47进行解密得到FLAG：\nGXY{Y0u_kNow_much_about_Rot} 成功得到flag：GXY{Y0u_kNow_much_about_Rot}\n0x6 BabyRSA # RSA题目，直接下载附件，查看附件内容：\np+q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea (p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740 e : 0xe6b1bee47bd63f615c7d0a43c529d219 d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5 enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a 应该是解方程的题目，使用python的sympy库或者sagemath库进行方程求解，这里使用一个脚本就行求解：\nimport sympy import libnum import gmpy2 sum_pq = 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea phi_r = 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740 e = 0xe6b1bee47bd63f615c7d0a43c529d219 d = 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5 enc_flag = 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a p = sympy.Symbol(\u0026#39;p\u0026#39;) q = sympy.Symbol(\u0026#39;q\u0026#39;) result = sympy.solve([p+q-sum_pq,(p+1)*(q+1)-phi_r]) q = int(result[0][q]) p = int(result[0][p]) n = p*q m = pow(enc_flag,d,n) flag = libnum.n2s(m) print flag 运行脚本，得到flag\nflag{cc7490e-78ab-11e9-b422-8ba97e5da1fd} flag:flag{cc7490e-78ab-11e9-b422-8ba97e5da1fd}\n0x7 rsa2 # RSA题目，看看这次又有什么花样吧！直接下载附件，查看附件\nN = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471 e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085 import hashlib flag = \u0026#34;flag{\u0026#34; + hashlib.md5(hex(d)).hexdigest() + \u0026#34;}\u0026#34; 附件是一个python程序，简单审计一下，发现e的数值有不太正常，有些过大。应该是RSA低解密指数，采用rsa-wiener-attack算法可以攻击得到d，拉一些github上的rsa-wiener-attack仓库，使用一个脚本解决：\nimport RSAwienerHacker import hashlib n = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471 e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085 test_d = RSAwienerHacker.hack_RSA(e, n) if test_d: d = test_d flag = \u0026#34;flag{\u0026#34; + hashlib.md5(hex(d)).hexdigest()+\u0026#34;}\u0026#34; print flag 运行脚本，得到flag：\nflag{47bf28da384590448e0b0d23909a25a4} flag:flag{47bf28da384590448e0b0d23909a25a4}\n0x8 RSA5 # RSA题目，看看这次又有什么有意思的变化，下载附件，查看附件：\nm = xxxxxxxx e = 65537 ========== n c ========== n = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207 c = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320 n = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759 c = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855 n = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491 c = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862 n = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751 c = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613 n = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067 c = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357 n = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369 c = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932 n = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137 c = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179 n = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191 c = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006 n = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941 c = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934 n = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491 c = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869 n = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019 c = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467 n = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299 c = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971 n = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551 c = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175 n = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987 c = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457 n = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837 c = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842 n = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451 c = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724 n = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499 c = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024 n = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973 c = 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887 n = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603 c = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889 n = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659 c = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346 观察附件中的数据信息，发现有很多组n，c数据，应该是广播攻击。低加密指数广播攻击，是采用欧几里得算法对多组数据进行求解。这里使用一个脚本求解：\nimport gmpy2 import libnum m = 0 e = 65537 n1 = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207 c1 = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320 n2 = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759 c2 = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855 n3 = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491 c3 = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862 n4 = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751 c4 = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613 n5 = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067 c5 = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357 n6 = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369 c6 = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932 n7 = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137 c7 = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179 n8 = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191 c8 = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006 n9 = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941 c9 = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934 n10 = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491 c10 = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869 n11 = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019 c11 = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467 n12 = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299 c12 = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971 n13 = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551 c13 = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175 n14 = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987 c14 = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457 n15 = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837 c15 = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842 n16 = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451 c16 = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724 n17 = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499 c17 = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024 n18 = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973 c18 = 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887 n19 = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603 c19 = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889 n20 = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659 c20 = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346 n = [n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20] c = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20] for i in range(len(n)): for j in range(len(n)): if(i!=j): if(gmpy2.gcd(n[i],n[j])!=1): p = gmpy2.gcd(n[i],n[j]) q = n[i] // p d = gmpy2.invert(e , (p-1)*(q-1)) m = pow(c[i],d,n[i]) flag = libnum.n2s(int(m)) print flag 运行脚本，得到flag:\nflag{abdcbe5fd94e23b3de429223ab9c2fdf} flag:flag{abdcbe5fd94e23b3de429223ab9c2fdf}\n0x9 密码学的心声 # 看题目应该是挺有意思的题目，看看题目描述：\n二战时期，某国军官与一个音乐家情妇相好，然而自从那时起，他屡战屡败，敌人似乎料事如神。他也有怀疑过他的情妇，但是他经过24小时观察他的情妇，发现她每天都只是作曲，然后弹奏给战地电台，为士兵们鼓气，并未有任何逾越。那么，间谍到底是谁？这张曲谱是否有猫腻？ (答案为一个明文字符串，提交获得的有意义语句通顺字符串即可) 注意：得到的 flag 请包上 flag{} 提交 下载附件，查看附件内容：\n附件内容\n发现，附件是一个图片，解密的提示和思维应该就藏在图片里面\n大致分析一下，图片提供的照片，可以知道是ASCII编码，进制是八进制，八进制一般而言是三个一组，数字以八进制为一组。这样思路就非常明确了，编写Python脚本直接求解：\nc = \u0026#34;111 114 157 166 145 123 145 143 165 162 151 164 171 126 145 162 171 115 165 143 150\u0026#34; c_list = c.split(\u0026#34; \u0026#34;) m = \u0026#34;\u0026#34; for i in c_list: m += chr(int(i,8)) flag = \u0026#34;flag{\u0026#34;+m+\u0026#34;}\u0026#34; print flag 运行脚本，得到flag：\nflag{ILoveSecurityVeryMuch} flag:flag{ILoveSecurityVeryMuch}\n0xA 传感器 # 直接下载附件，查看附件：\n5555555595555A65556AA696AA6666666955 这是某压力传感器无线数据包解调后但未解码的报文(hex) 已知其ID为0xFED31F，请继续将报文完整解码，提交hex。 提示1：曼联 提示是曼联，又是考察古典密码的题目，真是头疼。经过查询发现是曼彻斯特编码，在wiki百科上面找到曼彻斯特编码的相关信息：\n在电信与数据存储中, 曼彻斯特编码（Manchester coding），又称自同步码、相位编码（phase encoding，PE），能够用信号的变化来保持发送设备和接收设备之间的同步。它用电压的变化来分辨0和1，从高电平到低电平的跳变代表1，而从低电平到高电平的跳变代表0(as per G.E.Tomas编码方式)。从高电平到低电平的跳变代表0，而从低电平到高电平的跳变代表1(as per IEEE 802.3编码方式)，下方有所展示。信号的保持不会超过一个比特位的时间间隔。即使是0或1的序列，信号也将在每个时间间隔的中间发生跳变。这种跳变将允许接收设备的时钟与发送设备的时钟保持一致。[1]\n根据曼彻斯特编码的原理进行归纳，得到一个异或数据表\n这个异或数据表应该就是曼彻斯特编码的具体原理，根据这个原理编写python脚本进行解密：\ncipher=\u0026#39;5555555595555A65556AA696AA6666666955\u0026#39; def decrypto(cipher): tmp=\u0026#39;\u0026#39; for i in range(len(cipher)): a=bin(eval(\u0026#39;0x\u0026#39;+cipher[i]))[2:].zfill(4) tmp=tmp+a[1]+a[3] # print(tmp) plain = [ hex(int(tmp[i:i+8][::-1],2))[2:] for i in range(0,len(tmp),8)] m = \u0026#39;\u0026#39;.join(plain).upper() return m if __name__ == \u0026#34;__main__\u0026#34;: flag = \u0026#34;flag{\u0026#34;+decrypto(cipher)+\u0026#34;}\u0026#34; print flag 运行脚本，得到flag\nflag{FFFFFED31F645055F9} flag:flag{FFFFFED31F645055F9}\n0xB 这是base？ # 应该是考察base的，直接下载附件查看附件：\ndict:{0: \u0026#39;J\u0026#39;, 1: \u0026#39;K\u0026#39;, 2: \u0026#39;L\u0026#39;, 3: \u0026#39;M\u0026#39;, 4: \u0026#39;N\u0026#39;, 5: \u0026#39;O\u0026#39;, 6: \u0026#39;x\u0026#39;, 7: \u0026#39;y\u0026#39;, 8: \u0026#39;U\u0026#39;, 9: \u0026#39;V\u0026#39;, 10: \u0026#39;z\u0026#39;, 11: \u0026#39;A\u0026#39;, 12: \u0026#39;B\u0026#39;, 13: \u0026#39;C\u0026#39;, 14: \u0026#39;D\u0026#39;, 15: \u0026#39;E\u0026#39;, 16: \u0026#39;F\u0026#39;, 17: \u0026#39;G\u0026#39;, 18: \u0026#39;H\u0026#39;, 19: \u0026#39;7\u0026#39;, 20: \u0026#39;8\u0026#39;, 21: \u0026#39;9\u0026#39;, 22: \u0026#39;P\u0026#39;, 23: \u0026#39;Q\u0026#39;, 24: \u0026#39;I\u0026#39;, 25: \u0026#39;a\u0026#39;, 26: \u0026#39;b\u0026#39;, 27: \u0026#39;c\u0026#39;, 28: \u0026#39;d\u0026#39;, 29: \u0026#39;e\u0026#39;, 30: \u0026#39;f\u0026#39;, 31: \u0026#39;g\u0026#39;, 32: \u0026#39;h\u0026#39;, 33: \u0026#39;i\u0026#39;, 34: \u0026#39;j\u0026#39;, 35: \u0026#39;k\u0026#39;, 36: \u0026#39;l\u0026#39;, 37: \u0026#39;m\u0026#39;, 38: \u0026#39;W\u0026#39;, 39: \u0026#39;X\u0026#39;, 40: \u0026#39;Y\u0026#39;, 41: \u0026#39;Z\u0026#39;, 42: \u0026#39;0\u0026#39;, 43: \u0026#39;1\u0026#39;, 44: \u0026#39;2\u0026#39;, 45: \u0026#39;3\u0026#39;, 46: \u0026#39;4\u0026#39;, 47: \u0026#39;5\u0026#39;, 48: \u0026#39;6\u0026#39;, 49: \u0026#39;R\u0026#39;, 50: \u0026#39;S\u0026#39;, 51: \u0026#39;T\u0026#39;, 52: \u0026#39;n\u0026#39;, 53: \u0026#39;o\u0026#39;, 54: \u0026#39;p\u0026#39;, 55: \u0026#39;q\u0026#39;, 56: \u0026#39;r\u0026#39;, 57: \u0026#39;s\u0026#39;, 58: \u0026#39;t\u0026#39;, 59: \u0026#39;u\u0026#39;, 60: \u0026#39;v\u0026#39;, 61: \u0026#39;w\u0026#39;, 62: \u0026#39;+\u0026#39;, 63: \u0026#39;/\u0026#39;, 64: \u0026#39;=\u0026#39;} chipertext: FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw 给出了base64的编码表，但不是标准的base64编码表，首先需要了解base标准的编码表：\n标准的base64表\n给出的字典数据和标准的base64表有很大的出出入，需要python脚本简单处理一下转换为标准的base64编码格式，然后再使用base64进行解密。python脚本：\nimport base64 file_dict = {0: \u0026#39;J\u0026#39;, 1: \u0026#39;K\u0026#39;, 2: \u0026#39;L\u0026#39;, 3: \u0026#39;M\u0026#39;, 4: \u0026#39;N\u0026#39;, 5: \u0026#39;O\u0026#39;, 6: \u0026#39;x\u0026#39;, 7: \u0026#39;y\u0026#39;, 8: \u0026#39;U\u0026#39;, 9: \u0026#39;V\u0026#39;, 10: \u0026#39;z\u0026#39;, 11: \u0026#39;A\u0026#39;, 12: \u0026#39;B\u0026#39;, 13: \u0026#39;C\u0026#39;, 14: \u0026#39;D\u0026#39;, 15: \u0026#39;E\u0026#39;, 16: \u0026#39;F\u0026#39;, 17: \u0026#39;G\u0026#39;, 18: \u0026#39;H\u0026#39;, 19: \u0026#39;7\u0026#39;, 20: \u0026#39;8\u0026#39;, 21: \u0026#39;9\u0026#39;, 22: \u0026#39;P\u0026#39;, 23: \u0026#39;Q\u0026#39;, 24: \u0026#39;I\u0026#39;, 25: \u0026#39;a\u0026#39;, 26: \u0026#39;b\u0026#39;, 27: \u0026#39;c\u0026#39;, 28: \u0026#39;d\u0026#39;, 29: \u0026#39;e\u0026#39;, 30: \u0026#39;f\u0026#39;, 31: \u0026#39;g\u0026#39;, 32: \u0026#39;h\u0026#39;, 33: \u0026#39;i\u0026#39;, 34: \u0026#39;j\u0026#39;, 35: \u0026#39;k\u0026#39;, 36: \u0026#39;l\u0026#39;, 37: \u0026#39;m\u0026#39;, 38: \u0026#39;W\u0026#39;, 39: \u0026#39;X\u0026#39;, 40: \u0026#39;Y\u0026#39;, 41: \u0026#39;Z\u0026#39;, 42: \u0026#39;0\u0026#39;, 43: \u0026#39;1\u0026#39;, 44: \u0026#39;2\u0026#39;, 45: \u0026#39;3\u0026#39;, 46: \u0026#39;4\u0026#39;, 47: \u0026#39;5\u0026#39;, 48: \u0026#39;6\u0026#39;, 49: \u0026#39;R\u0026#39;, 50: \u0026#39;S\u0026#39;, 51: \u0026#39;T\u0026#39;, 52: \u0026#39;n\u0026#39;, 53: \u0026#39;o\u0026#39;, 54: \u0026#39;p\u0026#39;, 55: \u0026#39;q\u0026#39;, 56: \u0026#39;r\u0026#39;, 57: \u0026#39;s\u0026#39;, 58: \u0026#39;t\u0026#39;, 59: \u0026#39;u\u0026#39;, 60: \u0026#39;v\u0026#39;, 61: \u0026#39;w\u0026#39;, 62: \u0026#39;+\u0026#39;, 63: \u0026#39;/\u0026#39;, 64: \u0026#39;=\u0026#39;} base64_dict ={} index = 0 for i in (range(65,91) + range(97,123)+range(48,58)+range(43,44)+range(47,48)): base64_dict[index] = chr(i) index += 1 chipertext = \u0026#34;FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw\u0026#34; m = \u0026#34;\u0026#34; for i in range(len(chipertext)): for j in range(64): if(file_dict[j] == chipertext[i]): m += base64_dict[j] flag = base64.b64decode(m) print flag 运行脚本，得到flag：\nBJD{D0_Y0u_kNoW_Th1s_b4se_map} flag:flag{D0_Y0u_kNoW_Th1s_b4se_map}\n0xC rot # 直接下载附件，查看附件：\n破解下面的密文： 83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112 flag格式flag{} 看密文应该是ASCII码，结合题目应该是rot加密，应该是比较常规的rot13加密需要对数据进行-13操作，因为观察一下就可以非常清楚地发现有些ASCII数字超过123，可显示字符，因此可以推断是rot13加密。这里先用一个脚本处理一下：\nc = \u0026#34;83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112\u0026#34; c_list = c.split(\u0026#34; \u0026#34;) c_str = \u0026#34;\u0026#34; for i in c_list: c_str += chr(int(i)-13) print c_str 运行脚本，得到一个残缺的flag和MD5信息：\nFLAG IS flag{www_shiyanbar_com_is_very_good_????} MD5:38e4c352809e150186920aac37190cbc MD5值应该是校验flag信息的，需要对MD5进行爆破来得到真实的flag，这里使用一个总的python脚本来求解：\nimport hashlib c = \u0026#34;83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112\u0026#34; c_list = c.split(\u0026#34; \u0026#34;) c_str = \u0026#34;\u0026#34; for i in c_list: c_str += chr(int(i)-13) # print c_str # print c_str.find(\u0026#34;{\u0026#34;) # print c_str.find(\u0026#34;}\u0026#34;) # print c_str.find(\u0026#34;3\u0026#34;) little_flag = c_str[8:49] flag_md5 = c_str[54:] flag_str = little_flag[:-5] flag = \u0026#34;\u0026#34; # print flag_str for i in range(49,123): for j in range(49,123): for k in range(49,123): for l in range(49,123): result = flag_str + chr(i) + chr(j) + chr(k) + chr(l) + \u0026#34;}\u0026#34; if hashlib.md5(result).hexdigest() == flag_md5: flag = result break print flag 运行脚本，得到flag：\nflag{www_shiyanbar_com_is_very_good_@8Mu} flag:flag{www_shiyanbar_com_is_very_good_@8Mu}\n0xD Keyboard # 会是键盘密码吗？下载附件，瞧一瞧吧！\nooo yyy ii w uuu ee uuuu yyy uuuu y w uuu i i rr w i i rr rrr uuuu rrr uuuu t ii uuuu i w u rrr ee www ee yyy eee www w tt ee 果真是键盘密码，出现的字符都是26键键盘上面那一排对应的字符，而字符对应0-9的数字正好又对应着九键键盘的数字，而出现的次数代表九键键盘一个键的第几个字符，这样解密思路就非常流畅了。\n根据图示内容编写一个python脚本：\nstr_26 = \u0026#34;pqwertyuio\u0026#34; str_9 = \u0026#34;abc def ghi jkl mno pqrs tuv wxyz\u0026#34; list_9 = str_9.split(\u0026#34; \u0026#34;) dict_26 = {} dict_9 = {} index_26 = 0 index_9 = 0 for i in str_26: dict_26[index_26] = i index_26 += 1 for i in range(10): if i \u0026lt; 2: dict_9[i] = None; else: dict_9[i] = list_9[index_9] index_9 += 1 # print dict_26 # print dict_9 c = \u0026#34;ooo yyy ii w uuu ee uuuu yyy uuuu y w uuu i i rr w i i rr rrr uuuu rrr uuuu t ii uuuu i w u rrr ee www ee yyy eee www w tt ee\u0026#34; c_list = c.split(\u0026#34; \u0026#34;) result = \u0026#34;\u0026#34; for i in c_list: for j in range(10): if i[0] == dict_26[j]: result += dict_9[j][len(i)-1] flag = \u0026#34;flag{\u0026#34;+ result +\u0026#34;}\u0026#34; print flag 运行脚本，得到flag：\nflag{youaresosmartthatthisisjustapieceofcake} flag:flag{youaresosmartthatthisisjustapieceofcake}\n0xE 这是什么 # 查看题目描述：\n小明是一个软件专业的高材生，但是老师布置的这次的作业似乎不怎么靠谱，因为他们老师以前是学物理的！喜欢乱七八糟命名文件，还喜欢奇奇怪怪的编码。你快帮小明看一下这题，小明准备好了一箱子辣条。 注意：得到的 flag 请包上 flag{} 提交 题目描述可以看到明显的提示：喜欢乱七八糟命名文件，还喜欢奇奇怪怪的编码。\n这道题目应该考察的是奇奇怪怪的编码，下载附件，发现附件是一个apk文件，使用file命令简单查看一下apk文件的类型：\n94f5b952-3710-4609-ab6f-bc11609fdc67.apk: Composite Document File V2 Document, Little Endian, Os: Windows, Version 6.1, Code page: 936, Author: Administrator, Template: Normal.dotm, Last Saved By: Administrator, Revision Number: 5, Name of Creating Application: Microsoft Office Word, Total Editing Time: 07:00, Create Time/Date: Tue Dec 30 03:15:00 2014, Last Saved Time/Date: Tue Dec 30 03:42:00 2014, Number of Pages: 3, Number of Words: 1921, Number of Characters: 10950, Security: 0 发现文件应该是一个document文件，可以修改成txt文件查看文件内容\n邢\u0011唷?? \u0026gt; \u0003 ?\t\u0006 \u0001 H \u0010 J \u0001 ? G 欹? \u0003€\t\u0004 餜? \u0010 \u0008 U: \u000e bjbj肴肴 \u0004\u0008\u0016 8@ 墷 墷 G2 \u000f \u000f \u000f ? P\u0006 P\u0006 ? ? ? ? ? \u0014  ? ? ? 8 ? ? ? N\u0016 l\u0001 ? ? ? ? ? 1\u0015 1\u0015 1\u0015 ? \u0002 ? ? ? ? ? ? $ ? ? \u001a ^ ? \u0015 ? 1\u0015 1\u0015 1\u0015 1\u0015 1\u0015 ? ? ? ? ? 4\u0001 \u0008\u0016 \u0016 ? ? ? 1\u0015 X ? ? ? ? ? ? 1\u0015 ? ? ? ? ?  癴櫄?? ? ? ? ? \u0014 \u001e\u0016 0 N\u0016 ? ? ? ? ? ? ? ? 0 1\u0015 1\u0015 ? 1\u0015 1\u0015 1\u0015 1\u0015 1\u0015 ? ? ? 1\u0015 1\u0015 1\u0015 N\u0016 1\u0015 1\u0015 1\u0015 1\u0015                  ? 1\u0015 1\u0015 1\u0015 1\u0015 1\u0015 1\u0015 1\u0015 1\u0015 1\u0015 P\u0006 \u000f\u000c_\u0012 :\u0001 \u0005 \u0012\u0001 \u0004\u0004\u0008 [][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+!+[]]]+(![]+[])[+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+[]]+([][[]]+[])[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+[+[]]+(+(+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+[+[]])+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+[+!+[]]+[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+[!+[]+!+[]]+[+[]]+[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(![]+[])[+!+[]]+[!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+[]])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]])+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() \u0003 \u0004 \u0003 \u0004 \u0008 F: G: H: J: K: M: N: P: Q: T: U: 赕赕赕赕? \u0006\u0016h韖? \u000f\u0003j \u0016h韖? U\u0008\u0001\u000c\u0015ho`? \u0016h?? \u0015ho`? \u0016ho`? \u0008 G: I: J: L: M: O: P: R: S: T: U: ? ? ? ? ? ? ? ? ? ? ? \u0001 \u0004 gd\u000f\to \u0004 gdo`? 6 1?\u00012P\u0002 :p?? \u001f皞. 捌A!?\u0007\u0026#34;?\u0007#悹\u0005$悹\u0005%? \u0017癝\u0003\u0018班\u0003\u000c惄\u0001 j\u0004\u0013 \u0012 \u0001 \u0001\u000f \u0007 \u0003 \u0004 \u0003 \u0004 \u0008 ? ? ? ? ? ? ? ? ? 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 v\u0002 v\u0002 v\u0002 v\u0002 v\u0002 v\u0002 v\u0002 v\u0002 v\u0002 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 \u0026gt;\u0002 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 ? 6\u0006 6\u0006 \u0016 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 ? 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 h\u0001 H\u0001 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 6\u0006 ? 6\u0006 2\u0006 \u0018 ? ? ? ? \u0004 \u0010\u0004 \u0004 0\u0004 @\u0004 P\u0004 `\u0004 p\u0004 €\u0004 ? ? ? ? ? \u0004 \u0010\u0004 2\u0006 (\u0002 ? ? \u0004 0\u0004 @\u0004 P\u0004 `\u0004 p\u0004 €\u0004 ? ? ? ? ? \u0004 \u0010\u0004 \u0004 0\u0004 @\u0004 P\u0004 `\u0004 p\u0004 €\u0004 ? ? ? ? ? \u0004 \u0010\u0004 \u0004 0\u0004 @\u0004 P\u0004 `\u0004 p\u0004 €\u0004 ? ? ? ? ? \u0004 \u0010\u0004 \u0004 0\u0004 @\u0004 P\u0004 `\u0004 p\u0004 €\u0004 ? ? ? ? ? \u0004 \u0010\u0004 \u0004 0\u0004 @\u0004 P\u0004 `\u0004 p\u0004 €\u0004 ? ? ? ? ? \u0004 \u0010\u0004 \u0004 0\u0004 @\u0004 P\u0004 `\u0004 p\u0004 €\u0004 ? 8\u0001 X\u0001 ? \u0008\u0002 \u0018\u0002 V\u0002 ~\u0002 OJ\u0003 PJ\u0004 QJ\u0003 _H\u0001\u0004mH\t\u0004nH\u0004\u0008sH\t\u0004tH\u0004\u0008 J `?\u0002 J \u0010 ?? \u0002 ck噀 \u0003$\u00031$ a$\u0003 CJ\u0015 KH\u0002 _H\u0001\u0004aJ\u0016 mH\t\u0004nH\u0004\u0008sH\t\u0004tH\u0004\u0008 $ A ?? $ \u0010 \u0006 貫祂=刉[SO B i ?? B \u001d 0\u0006\u0004 nf\u001a恏?h \u001c \u0017? 4? \u0001 \u0003l 4? \u0001\u0005\u0003 a? \u0002 k ?? 0\u0006\u0003 鄀\u0017Rh? \u0002 N \u001f \u0001 ? N \u0010 \u000f\to 0\u0006\u0002 u?w \u0026#39; \u000f \u0003$\u0001 ? \u00029\u0010r \u0001\u0002\u0026amp;d\u0006\u0001 \u0001G$ P? \u0006\u0001\u0001 a$\u0001 \u0008 CJ\u0012 aJ\u0012 2 ?? \u0001\u00012 \u0001\u000f \u000f\to 0\u0006\u0007 u?w C h a r CJ\u0012 KH\u0002 aJ\u0012 \u0026lt; \u0001 \u0012\u0001\u0026lt; \u0012 \u000f\to 0\u0006\u0002 u?? \u0016 \u0011 \u0003$ ? \u00029\u0010r \u0001\u0002G$ a$ \u0008 CJ\u0012 aJ\u0012 2 ?? !\u00012 \u0001\u0011 \u000f\to 0\u0006\u0007 u?? C h a r CJ\u0012 KH\u0002 aJ\u0012 PK\u0003\u0004\u0014 \u0006 \u0008 ! 倞?? \u001c\u0002 \u0013 [Content_Types].xml瑧薺?\u0010E鲄卸豶?ヘ微Iw},?\u0018浔-j弰4\t蛇w旄P?-t#\u0010b螜{U畯銧\u000e\u0018擉T閁^h卍}悒)蛔*1P\u0003?\t揯鬃W孱\u00140)櫐T闉9\u0026lt;\u0018搇?ぼ\u0007$yi}\u001c佸\u001a;\u0013纞@囨?顚跄H滖男u?\u000bD谞z內/0娗盃瘥?$€?X3aZ⒁\u0010锣,癉0\u0007j~?叨蝏沩~\u0014i\u0026gt;?赝\u00043縗`???[?G殁??跼k.搒粣.\u0018.椃碼婵?\u0001 \u0003 PK\u0003\u0004\u0014 \u0006 \u0008 ! ブх? 6\u0001 _rels/.rels剰蟡?\u000c囷吔冄}Q颐\u0018%v/C/ ?h\u0026#34;\u001b?脎O? ?劋秣?孂釘?\u0016毆\u0006免C?薶醰=?偵叅?\u0008[xp啠{鄣_糚眩\u0026lt;?\u001b??\u000f堎O糝瓸d焉\u0010襃E?b$q_?槥\u0019?L吁\u0016R?`畯ㄉ趁0虨O??錏\u0004n7擫i鋌〃/鉙綈╡\u001e械根铸\u0001 \u0003 PK\u0003\u0004\u0014 \u0006 \u0008 ! ky?? ? \u001c theme/theme/themeManager.xml\u000c蘉 ?\u0010@醹愘7c?Eb菜? C?A菭覠圩邈?芜\u0014諞K Y,? 奺?埛饇,?ㄚH\u001c?l崆\u0015骈x\u0018纱?逫萻Q}#諓叚递 值+??較?j=婫W栌?釫?\u0026amp; \u00028? \u0003 PK\u0003\u0004\u0014 \u0006 \u0008 ! ?m\u0014? Q\u001b \u0016 theme/theme/theme1.xml靁Mo\u001bE\u0018??F{oc\u0026#39;v\u001aGu?h覨盵糟x=逎zvg53N?j廐H垈z?饴\u0001\u0001昛\t$石I)*E阓酀欇鮊?I\u001bA\u0005?裎\u0026gt;秣羌3緓镹男\u0026gt;\u0011掤搁U蟇\u0026lt;Db?i\u001c4??\u000fI呫!f\u0026lt;\u0026amp;MoJi泯?鈛\u0015拡 爮?nz生覓鬭\u0019梭\u0026lt;!1?q\u0011a\u0005?X\u001a | |#洞┈.E樒\u001e妐\u0004l瘡F?栀峡鉴鎭窇q?\u0010\u0011+?|\u0026amp;z?qH\u000cv8甹劀?\u0013h\u001f肠\u0007倖鼱O?\u000f1,\u0015糷z\u0015篑?..狨攬??寒t)羛糽d奰?璿k?[9\u0003`j\u001e组t跐j蜗 帮儱V?蟌w蕏\u0016@鲭\u0026lt;飗┕???璙Hu盠 葉嶙*蚭\u0007o@\u0016_熋譠涰霆? 媉澝w/4Vk.迉BF泷\u001cZ\u0007篡M圭?g邾?€疷R?\u0005賽g?1獗Z攌\u0011就E\u0017 \u001a劝?R觿尠\u000fi芷袬P?鄒?o鞉/鐤?$}A\u0013蒸\u0026gt;L0斈屵呖z?\u001d迃rx鳔脅?稔h\u00199T?\u000e奣/魁煜??\u001e?鍃Y?雒\u0026#39;蟸\u001c\u0008?S琦棌~蜩鶅O_|w??馉\u0008镉圚t??\u001e乤?d NG?1-Rl苼?諶J鴚T锠疢1Kｃ柩\u0026#34;?o h\u001fe浪撣幝絇L\u0014-憒%??绗臙?甴Y\u00057?qP.L姼=岟薲穛炷?I爋fi??墸?帽?墘B?\u001f\u0013Rb?J\u001d款P_p蒅 茛▍i㎏鷗郿訉h汧\u0010梚櫷\u0010o?;7Q嫵2染媱珼?a?/銐翾\u0019?嶺厌W?藬霱卂膗H\u0007剄?\u0012)薶?胺\u0010?\u0018:Vi豾?r態裶\u0019汐橌\u0026#34;r嫃?帓2l徠a\u0011麃\u001cC奲此U\u0019|嚮\u0015!\u000e8^\u0018顩???軤仯?A魶壭眲V韙鄨?讕\u0019厏ls囔?4犁_=,涩返\u0011o聻TV\t跥陲\u0026#34;苎鎎H唼灮???熯x薜躻-戏蹺鮸褾;氕衯踯`嘼3\u0026#34;G\u000b\u0026#39;?e昮H柊O\u000c话ㄩ恬愪\u0026#39;?劘i_wp伬?\t??靺8?魂i\u0026amp;丩Y\u0007\u0012%铝?楎謝\u0018視=\u0016瞩伭?壵\u000e\u001f阱\u0015綔?r6f?提3\u0013储\u0019淭厥厰)橗:陋Z?K?誏玸ゅ\u0026amp;C\u000c鏜兣軟0€ \u0018[浪玴@注醏?\u0019j扣?\u000b媺耏咹唜H?i荤cT5A蕆跑\u0004@顢腍\u001f驇馴AZC硙\u0003i\u0026#39;\tRQm伕,zo\u0012?僩Q襲{?Y,N\u0016ψ??溷ら嵿L\u000b_??跆嘫 7C?6韽-fS宄h62密\u0026#34;5咍麥罭\u001fH凾[X?5太4\u0005X?Y龡豚殖2纅鷎h辈\u0006绅痠\u0001~tCKF#猥b?+趙?m鑵?4`\u0013眹!?U翞!昿5a:倊€{4韒笫m蝘?o?萎c杽8m泛D矹秔S枪\u000e姗?豓1铘?#S奿?3E?pS??疳\u001eW`る甸q\u000e](\t┻\u001508樲\u0001?w别\u001a?n撏A鲺[s枃)k8皓=\u001a Aa?R?d\u0017趻删c楿咏瞬d)#換\u0005ueb?恾满?捷C!ず?i\u001b0福\u0026gt;?4\u0008魫S?鋥?z虮?F箎?4?s\u0015KvUKo瘸椒h垀1\u001b砵YU€奥V蠬塔5U8錠k;譁潘鮈9堚寂皹\u000fD\t荀 ??*|FL\u001a?迪鳡?A3兇伂\u0026gt;g\u0007\u000f?\u001c类d\u0017m2iV值殍そ杕謌\u0026lt;殒r?[kv抶熞蠃p鎶sj?潩z伛礭[鑚堨?叆Qv??縤\u0015u鈨??高?%M2羙J\u0002描?u 舘%\u001a覎? \u0003 PK\u0003\u0004\u0014 \u0006 \u0008 ! 褠煻 \u001b\u0001 \u0026#39; theme/theme/_rels/themeManager.xml.rels剰M ?\u0014匃倃\u0008oo雍\u0010?輬协?勪5 6?$Q祉 ?\u0008.嘺緳i粭澤\u0013c2?h?\u0008:闀q毩m胳嶡R\u0016N壻;d癭値o7?g慘(M\u0026amp;$R(.1榬\u000e\u0026#39;J摐袏T鶂?V?＆A然蠬鱱}狇?|?絙\u0010{? \u0019朠?除8\u001a塯/\u001f\u0016]As賲\u0005(⑵锑#洩L\u0004蔥汉倪 \u0003 PK\u0001\u0002- \u0014 \u0006 \u0008 ! 倞?? \u001c\u0002 \u0013 [Content_Types].xmlPK\u0001\u0002- \u0014 \u0006 \u0008 ! ブх? 6\u0001 +\u0001 _rels/.relsPK\u0001\u0002- \u0014 \u0006 \u0008 ! ky?? ? \u001c \u0014\u0002 theme/theme/themeManager.xmlPK\u0001\u0002- \u0014 \u0006 \u0008 ! ?m\u0014? Q\u001b \u0016 ? theme/theme/theme1.xmlPK\u0001\u0002- \u0014 \u0006 \u0008 ! 褠煻 \u001b\u0001 \u0026#39; ? theme/theme/_rels/themeManager.xml.relsPK\u0005\u0006 \u0005 \u0005 ]\u0001 ? \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;a:clrMap xmlns:a=\u0026#34;http://schemas.openxmlformats.org/drawingml/2006/main\u0026#34; bg1=\u0026#34;lt1\u0026#34; tx1=\u0026#34;dk1\u0026#34; bg2=\u0026#34;lt2\u0026#34; tx2=\u0026#34;dk2\u0026#34; accent1=\u0026#34;accent1\u0026#34; accent2=\u0026#34;accent2\u0026#34; accent3=\u0026#34;accent3\u0026#34; accent4=\u0026#34;accent4\u0026#34; accent5=\u0026#34;accent5\u0026#34; accent6=\u0026#34;accent6\u0026#34; hlink=\u0026#34;hlink\u0026#34; folHlink=\u0026#34;folHlink\u0026#34;/\u0026gt; U2 @  \u0003 \u0006 \u0006 \u000f \u0008 U: \u001e \u0008 U: \u001f \u000f 餈 \u0006? \u0002\u000c\u0003 \u0002 \u0002 \u0002 \u0002 \u0001 \u0001 @ \u001e?   €€€ ? \u0010 \u000f \u0002饞 \u0008? \u0001 \u0001\u0004 \u000f \u0003? \u000f \u0004? \u0001 ? \u0002 ? \u0004 \u0005 \u000f \u0004養 \u0012 ? \u0001\u0004 \u000e S ? ? \u0010 ? \u0001 \u0008 \u0004\u0003\t?\u0003\u0001 \u0001 \u0011? \u0001 \u0001\u000f \u0002餒 \u0010 \u0008? \u0001 \u0008 \u000f \u0003? \u000f \u0004? \u0001 ? \u0002 ? \u0008 \u0005 ? G2 G2 I2 I2 J2 J2 L2 M2 O2 P2 R2 S2 V2 \u0005 \u0007 \u0004 \u0007 \u0004 \u0002 \u0004 \u0007 \u0004 \u0007 \u0004 \u0007 \u0004 \u0002 \u0006 \u0004 \u0008 ? \u0005 両F \u000f\to ?? o`? 漼? 韖? G2 I2 \u0001 @\u0001€\u0001 F2 F2 (?\u0001 \u0001 F2 F2 \u0002\u0010 U2 ` \u0010 @ \u0001 \u0007 U n k n o w n \u0001 \u0008 \u0001  \u0002   \u0002  \u0006 G\u001e? \u0002\u0002\u0006\u0003\u0005\u0004\u0005\u0002\u0003\u0004* 郃x ? \u0001 T i m e s N e w R o m a n 5\u001e?\u0002 \u0005\u0005\u0001\u0002\u0001\u0007\u0006\u0002\u0005\u0007 \u0010 € S y m b o l 3.? \u0002\u000b\u0006\u0004\u0002\u0002\u0002\u0002\u0002\u0004* 郈x ? \u0001 A r i a l 7.? \u0002\u000f\u0005\u0002\u0002\u0002\u0004\u0003\u0002\u0004\u0002 ?? @\u0001 ? C a l i b r i ;\u000e??\u0002\u0001\u0006 \u0003\u0001\u0001\u0001\u0001\u0001\u0003 ?\u0016 \u0001 \u0004 媅SO S i m S u n A\u001e? \u0002\u0004\u0005\u0003\u0005\u0004\u0006\u0003\u0002\u0004\u0002 ?$ B ? C a m b r i a M a t h \u0004 1\u0008? ? h\u0001 向,G牝,G \u0005 \u0007 ? ? \u0003 \u0019 \u0004 \u0003怺 ? ? \u0003 \u0019 [ q\u0003 \u0003 ? \u001b ! % ) , . : ; \u0026gt; ? ] } ? ? ? ? ??\u0015 \u0016 \u0019 \u001d \u0026amp; 0 2 3 : \u0003!6\u0026#34;\u00010\u00020\u00030\t0\u000b0 0\u000f0\u00110\u00150\u00170\u001e06??兀﨑?\u0002\u0005\u0007\t\u000c\u000e\u001a\u001b\u001f=@]^? $ ( [ { ? ? ? \u0018 \u001c \u00080 0\u000c0\u000e0\u00100\u00140\u00160\u001d0Y?\u0008\u000e;[?? \u0008\u0007?? ? 個\u0012 \u0010 \u0019 d \u0019 .2 .2 \u0002 2? \u0001 \u0008HX ?\u000f\u0001\u0008$P ? 両F \u0004 2 !\u0004 \u0010\u001c \u0005 x x ? \u0012 A d m i n i s t r a t o r A d m i n i s t r a t o r ? \u0006\u0001\u0002 \u0001 鄥燆鵒h\u0010珣\u0008 +\u0026#39;迟0 h\u0001 \u0010 \u0001 ? \u0002 ? \u0003 ? \u0004 ? \u0005 ? \u0007 ? \u0008 ? ? \u0012 \u0004\u0001 $\u0001 0\u0001 \u0026lt;\u0001 \u000e H\u0001 \u000f P\u0001 \u0010 X\u0001 \u0013 `\u0001 \u0002 ? \u001e \u0004 \u001e \u0004 \u001e \u0010 Administrator \u001e \u0004 \u001e Normal.dotm \u001e \u0010 Administrator \u001e \u0004 5 \u001e \u0018 Microsoft Office Word @ 闢? @ Rに??@ ?戔#?\u0003 \u0003 \u0003 ? \u0003 ? \u0003 ? \u0006\u0001\u0002 \u0001 \u0002胀諟.\u001b\u0010摋\u0008 +,0 ? \u0001 X \u000f ` \u0005 l \u0006 t \u0011 | \u0017 ? ? \u0010 ? \u0013 ? \u0016 ? \u0002 ? \u001e \u0004 \u0003 [ \u0003 \u0019 \u0003 .2 \u0003 \u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \u0008 \u000e \u000f \u0010 \u0011 \u0012 \u0013 \u0014 \u0015 \u0016 \u0017 \u0018 \u0019 \u001a \u001b \u001c \u001d \u001e \u001f ?\u0026#34; # $ % \u0026amp; \u0026#39; ( ?* + , - . / 0 1 2 3 4 5 6 ?8 9 : ; \u0026lt; = \u0026gt; ?@ A B C D E F ??I ???R o o t E n t r y \u0016 \u0005\u0001\u0003 \u0006\t\u0002 ? F P氣#?K € D a t a \u0002\u0001 ! \u0010 1 T a b l e \u000e \u0002\u0001\u0001 \u0006  ) ? W o r d D o c u m e n t \u001a \u0002\u0001\u0002 \u0005  8@ \u0005 S u m m a r y I n f o r m a t i o n ( \u0002\u0001 7 \u0010 \u0005 D o c u m e n t S u m m a r y I n f o r m a t i o n 8 \u0002\u0001\u0004  ? \u0010 \u0001 C o m p O b j \u0012 \u0002  e  \u0001 ?\u0001 ?\u0003 \u0006\t\u0002 ? F# Microsoft Office Word 97-2003 文档 MSWordDoc ?瞦 发现文件中间有一堆奇奇怪怪的编码：\n[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+!+[]]]+(![]+[])[+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+[]]+([][[]]+[])[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+[+[]]+(+(+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+[+[]])+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+[+!+[]]+[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+[!+[]+!+[]]+[+[]]+[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(![]+[])[+!+[]]+[!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+[]])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]])+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() 应该可以非常容易地看出这种编码格式是JSFuck编码，可以去JSFuck官方网站进行解密：\n成功拿到flag，flag：flag{a0448fd730b62c13ca80200c4529daa2}\n0xF childRSA # RSA题目，有趣，直接下载附件，查看附件内容：\nfrom random import choice from Crypto.Util.number import isPrime, sieve_base as primes from flag import flag def getPrime(bits): while True: n = 2 while n.bit_length() \u0026lt; bits: n *= choice(primes) if isPrime(n + 1): return n + 1 e = 0x10001 m = int.from_bytes(flag.encode(), \u0026#39;big\u0026#39;) p, q = [getPrime(2048) for _ in range(2)] n = p * q c = pow(m, e, n) # n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 # c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 发现附件文件是一个python程序，可以看到rsa加密算法的具体细节，可以看到一个关键函数：\ndef getPrime(bits): while True: n = 2 while n.bit_length() \u0026lt; bits: n *= choice(primes) if isPrime(n + 1): return n + 1 对函数进行审计发现大素数生成的细节并不是很清晰，需要对Crypto.Util.number库的sieve_base模块进行检索，来获取更多的信息。经过查询发现，sieve_base模块是一个前10000个素数的素数表，可以节约素数生成的时间。使用数学工具查询第10000个素数是104729，但是知道这个好像也没什么用的样子。仅仅知道p和q是生成算法是由小于104729的数随机生成的。这里需要引入一个smooth number的概念：[3]\n光滑数（smooth number），或译脆数，是一个可以约数分解为小素数乘积的正整数。光滑数一词是是伦纳德·阿德曼所提出。光滑数在以约数分解为基础的密码学中扮演重要角色。[2]\n现在有了两个材料，没有工具，要想解决这道题目，还需要有个工具来处理，费马小定理。这道题目主要是在考察大数分解的方法——Pollard\u0026rsquo;s p-1 method，这个大数分解方法非常巧妙，其数学证明也非常优美。回到题目来，现在我们有这些信息，该如何处理这道题目呢？这里先利用已有的信息进行简单的数学演绎：\n首先来康康费马小定理：\n$$ a^{p-1} \\equiv 1 \\quad (\\text{mod} p) $$\n也就是说，指数那边每增加( p-1 ) ，其结果仍然不变。指数以( p-1 ) 为一个循环。\n我们将其变形一下：\n$$ a^{p-1} – 1 \\equiv 0 \\quad (\\text{mod} p) $$\n模p同余0，也就是说( a^{p-1} – 1 ) 是 ( p ) 的倍数。将同余式改写为等式：\n$$ a^{t \\times (p-1)} – 1 = k\\times p $$\n其中 $t, k$ 是两个整数。\n如果指数( exp )是 ( p-1 ) 的倍数，那么( a^{exp} – 1 )就会是 ( p ) 的倍数。\n上面的( p )均指某一个质数，而非( N=pq )中的( p )\n这里很关键。\n如果我们能够找到一个指数( L )，使得对于某一个底数( a )，( a^{L} – 1 ) 是( p )的倍数，但不是( q )的倍数。\n这时，我们只要去计算 $$ gcd(a^{L}-1, N) $$ 得到的结果，必定是( p )。也就是说，我们成功地分解了( N )。\n那么该怎么去寻找这个( L )呢，这个时候就需要用到光滑数的概念了，需要使用一下光滑数这个不错的材料来进行求解：\n对于每一个$n = 2, 3, 4, …$，我们任意选择一个底数$a$（事实上，我们可以简单地选择为2），并计算 $$ gcd(a^{n!-1}, N) $$\n如果结果落在1和( N ）中间，便可成功进行求解。\n现在根据上述算法原理编写python脚本进行求解：\nfrom Crypto.Util.number import sieve_base as primes import gmpy2 n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 t=pow(2,2048) e = 0x10001 k=2 for i in range(10000): k=pow(k,primes[i],n) if(k\u0026gt;t): if(i%15==0): if(gmpy2.gcd(k-1,n)!=1): print(gmpy2.gcd(k-1,n)) break p=gmpy2.gcd(k-1,n) q=n//p phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) m=pow(c,d,n) flag=hex(m)[2:].decode(\u0026#39;hex\u0026#39;) print(flag) 运行脚本，可能需要等一段时间，大致7s就能跑出来flag：\nNCTF{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3} flag:flag{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3}\n参考 # 曼彻斯特编码-维基百科 光滑数-维基百科 NCTF2019-官方writeup 本期wp分享到此为止，有时间再来喝杯茶呀！\n","date":"June 26, 2021","permalink":"/posts/buuctf-crypto-3_writeup/","section":"Posts","summary":"同样的味道，同样的感觉，再看密码的世界！\nBUUCTF\n来审视一下，本次的题目：\n题目列表\nMorse Cipher Dangerous RSA basic rsa 达芬奇密码 Checkln BabyRSA rsa2 RSA5 密码学的心声 传感器 这是base？ rot Keyboard 这是什么 childRSA 也是同样满满的16道CTF题目，都是密码学题目哟！\n0x0 Morse # 打开附件，直接就是Morse密码密文：\n-..../.----/-..../-..../-..../...--/--.../....-/-..../-..../--.../-.../...--/.----/--.../...--/..---/--.../--.../....-/...../..-./--.../...--/...--/-----/...../..-./...--/...--/...--/....-/...--/...../--.../----./--.../-.. 直接解密摩斯密码得到：\n61666374667B317327745F73305F333435797D 得到的16进制密文，对密文进行解密：\n成功得到flag：\nafctf{1s\u0026#39;t_s0_345y} flag：afctf{1s\u0026rsquo;t_s0_345y}\n0x1 Cipher # 打开题目描述：\n还能提示什么呢？公平的玩吧（密钥自己找） Dncnoqqfliqrpgeklwmppu 注意：得到的 flag 请包上 flag{} 提交, flag{小写字母} 看的非常懵，考察古典密码的题目，唯一的提示就是“公平的玩吧（密钥自己找）”，实在是找不到头绪，看了大佬的WP发现是playfair加密，在网上找到了一个在线工具可以求解playfair加密，这里就使用在线工具进行解密\n得到解密结果：Itisnotaproblemhavefun\n故得flag: flag{itisnotaproblemhavefun}\n0x2 Dangerous RSA # 应该是一道典型的RSA题目，直接下载附件\n#n: 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L #e: 0x3 #c:0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365 so,how to get the message? e的值非常小，这道RSA题目应该是考察低加密指数攻击的，直接上脚本：\nimport gmpy2 import libnum c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365 n = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L e = 0x3 m = 0 i = 0 while 1: if(gmpy2.","title":"BUUCTF CRYPTO (3) writeup"},{"content":"还是BUUCTF的题目，熟悉的感觉，再来一次！\nBUUCTF首页\n本次的题目大致如下：\nCTF题目\n题目是16道密码学题目：\n传统知识+古典密码 信息化时代的步伐 RSA1 凯撒？转换？呵呵！ old-fashion 萌萌哒的八戒 权限获得第一步 世上无难事 RSA3 RSA2 异性相吸 RSA 还原大师 Unencode robomunication RSAROLL 题目求解： # 题目都还比较简单，正常来做就好。\n0x0 传统知识+古典密码 # 下载附件，得到题目\n题目信息\n应该是考察古典密码的题目，是考察六十甲子顺序纳音表的题目\n这里列出六十顺序纳音表：\n六十甲子顺序表\n根据六十甲子顺序表编写python脚本：\nC_sky = \u0026#34;甲乙丙丁戊己庚辛壬癸\u0026#34; C_earth = \u0026#34;子丑寅卯辰巳午未申酉戌亥\u0026#34; C_dict={} for i in range(60): C_dict[C_sky[i%len(C_sky)]+C_earth[i%len(C_earth)]] = str(i+1) cipher = \u0026#34;辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳\u0026#34; cipher_list = cipher.split(\u0026#34;，\u0026#34;) plainer = \u0026#34;\u0026#34; for i in cipher_list: plainer += chr(int(C_dict[i])+60) def decrype(cipher,key): cipher_len = len(cipher) if cipher_len%key == 0: key = cipher_len // key else: key = cipher_len // key + 1 result = {x:\u0026#39;\u0026#39; for x in range(key)} for i in range(cipher_len): a = i%key; result.update({a:result[a]+cipher[i]}) plainer=\u0026#34;\u0026#34; for i in range(key): plainer = plainer + result[i] return plainer plainer_list=[] for n in range(2,20): plainer_list.append(decrype(plainer,n)) plainer_set = set(plainer_list) def Caesar(cipher): dict_list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;] for j in range(26): plainer = \u0026#34;\u0026#34; for i in cipher: if i in dict_list: plainer += dict_list[(dict_list.index(i)-j)%26] else: plainer += i print(plainer.upper()) for i in plainer_set: Caesar(i.lower()) print(\u0026#34;\u0026#34;) 说明：\n脚本使用了三种加密算法，分别是传统文化加密，栅栏密码，凯撒密码\n最终的输出结果是凯撒密码爆破的结果，需要进行筛选\n通过简单的筛选可以得到flag为：flag{SHUANGYU}\n0x1 信息化时代的步伐 # 审题目\n应该是和中文相关的密码\n看附件：\n附件是一串数字，应该需要数字和中文进行联系\n搜索一下：中文电码\n得到了不错的搜索结果\n这里涉及了一个中文电码的知识，这是一个比较偏的知识，这里可以积累一下：\n中文电码，又称：中文商用电码（Chinese commercial code, CCC）、中文电报码（Chinese telegraph code, CTC）或中文电报明码（Chinese ordinary telegraph code, COTC），原本是用于电报之中传送中文信息的方法。它是第一个将汉字化作电子信号的编码表。[1]\n简单来说，就是针对中文设计的一种数字编码方式。\n这里直接使用在线脚本进行解码：\n解码得出结果，即flag是flag{计算机要从娃娃抓起}\n0x2 RSA1 # 题目考察RSA加密算法\n下载附件，得到数据：\np = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 有p和q，以及dp和dq，但是没有e，n等参数\n这道题目是一道典型的dp，dq泄露的RSA题目\n由于涉及dp，dq参数，需要推导一下公式：\n首先，最基本的RSA求值公式：\n$m \\equiv c^d\\ mod\\ n$ 和 $c \\equiv m^e\\ mod\\ n$\n然后，这里有不同于常规RSA的新参数dp和dq：\n$ d_p \\equiv d\\ mod\\ (p-1) $和 $ d_q \\equiv d\\ mod\\ (q-1) $\n下面就需要根据已知的条件进行推导：\n$$ m \\equiv c^d \\ mod\\ n \\Rightarrow m = c^d + k \\cdot n \\Rightarrow m = c^d + k \\cdot p \\cdot q $$\n由上面的推导可以得出：\n$$ m_p \\equiv c^d\\ mod \\ p \\ m_q \\equiv c^d\\ mod\\ q $$\n进一步推导可以得出：\n$$ m_p + k \\cdot p = c^d$$\n将上式带入到$ m_q \\equiv c^d \\ mod \\ q $ 可得：\n$$ m_q \\equiv m_q + kp\\ mod\\ q $$\n然后简单整理可得：\n$$ k \\equiv p^{-1} \\cdot (m_q - m_p)\\ mod\\ q $$\n故可得：\n$$ m \\equiv (p^{-1} \\cdot (m_q-m_p)\\ mod\\ q ) \\cdot p+ m_p \\ mod \\ (p \\cdot q) $$\n同理可得：\n$$ m \\equiv (p^{-1} \\cdot (m_q-m_p)\\ mod\\ q ) \\cdot q+ m_q \\ mod \\ (p \\cdot q) $$\n$$ m \\equiv (q^{-1} \\cdot (m_p-m_q)\\ mod\\ p ) \\cdot p+ m_p \\ mod \\ (p \\cdot q) $$\n$$ m \\equiv (q^{-1} \\cdot (m_p-m_q)\\ mod\\ p ) \\cdot q+ m_q \\ mod \\ (p \\cdot q) $$\n根据推导的公式，这里使用一个python脚本解决问题：\nimport gmpy2 from Crypto.Util.number import * p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 mp = pow(c,dp,p) mq = pow(c,dq,q) Ip = gmpy2.invert(p,q) Iq = gmpy2.invert(q,p) m1 = ((((mq-mp)*Ip)%q)*p+mp)%(p*q) m2 = ((((mq-mp)*Ip)%q)*q+mq)%(p*q) m3 = ((((mp-mq)*Iq)%p)*p+mp)%(p*q) m4 = ((((mp-mq)*Iq)%p)*q+mq)%(p*q) flag1 = long_to_bytes(m1) flag2 = long_to_bytes(m2) flag3 = long_to_bytes(m3) flag4 = long_to_bytes(m4) print \u0026#34;flag:{}\u0026#34;.format(flag1) print \u0026#34;flag:{}\u0026#34;.format(flag2) print \u0026#34;flag:{}\u0026#34;.format(flag3) print \u0026#34;flag:{}\u0026#34;.format(flag4) 脚本运行即得到flag，即noxCTF{W31c0m3_70_Ch1n470wn}\n根据题目要求，故flag： flag{W31c0m3_70_Ch1n470wn}\n0x3 凯撒？转换？呵呵！ # 题目应该是考察变种凯撒加密的\nMTHJ{CUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZOHIXOEOWMEHZO} 注意：得到的 flag 请包上 flag{} 提交, flag{小写字母} 这里使用一个在线工具进行求解\n通过在线工具就得到flag，即flag{substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake}\n“忘了是否要进行大小写转换，题目的思路大致就是这样了”\n0x4 old-fashion # 题目描述没什么好说的，直接下载附件，查看附件\nOs drnuzearyuwn, y jtkjzoztzoes douwlr oj y ilzwex eq lsdexosa kn pwodw tsozj eq ufyoszlbz yrl rlufydlx pozw douwlrzlbz, ydderxosa ze y rlatfyr jnjzli; mjy gfbmw vla xy wbfnsy symmyew (mjy vrwm qrvvrf), hlbew rd symmyew, mebhsymw rd symmyew, vbomgeyw rd mjy lxrzy, lfk wr dremj. Mjy eyqybzye kyqbhjyew mjy myom xa hyedrevbfn lf bfzyewy wgxwmbmgmbrf. Wr mjy dsln bw f1_2jyf-k3_jg1-vb-vl_l 一段文字，直接丢在线工具里面进行词频分析吧：\n得到词频分析结果：\nXl fogkvryoeksg, e hjdhvxvjvxrl fxksao xh e zavsrb rc alfrbxly dg wsxfs jlxvh rc knexlvaiv eoa oaknefab wxvs fxksaovaiv, effrobxly vr e oayjneo hghvaz; the units may be single letters (the most common), pairs of letters, triplets of letters, mixtures of the above, and so forth. The receiver deciphers the text by performing an inverse substitution. So the flag is n1_2hen-d3_hu1-mi-ma_a 故得flag：flag{n1_2hen-d3_hu1-mi-ma_a}\n0x5 萌萌哒的八戒 # 萌萌哒的八戒，应该是猪圈密码\n什么是猪圈密码？\n猪圈密码（英语：pigpen cipher)，亦称共济会密码（masonic cipher）或 共济会员密码（Freemason\u0026rsquo;s cipher），是一种以格子为基础的简单替代式密码。即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。右边的例子，是把字母填进格子的模样。\n早在1700年代，共济会常常使用这种密码保护一些私密纪录或用来通讯，所以又称共济会密码。[2]\n萌萌哒的八戒原来曾经是猪村的村长，从远古时期，猪村就有一种神秘的代码。请从附件中找出代码，看看萌萌哒的猪八戒到底想说啥 注意：得到的 flag 请包上 flag{} 提交 题目描述正好和猜想对应，下载附件，查看附件\n得到一张图片:\n下面那一串应该就是猪圈密码，进行解密：\n这里使用在线工具进行解密：\n得到flag，即flag{whenthepigwanttoeat}\n0x6 权限获得第一步 # 这题应该是使用哈希密码破解的方法进行解密\n下载附件，查看附件内容：\nAdministrator:500:806EDC27AA52E314AAD3B435B51404EE:F4AD50F57683D4260DFD48AA351A17A8::: 密文明显是windows系统的hash加密，第一段的哈希加密应该是Administrator的用户名，第二段的哈希加密应该是windows系统的密码\n直接对第二段哈希值进行哈希破解：\n这里使用在线工具进行破解：\n故flag即为flag{3617656}\n0x7 世上无难事 # 打开题目：\n以下是某国现任总统外发的一段指令，经过一种奇异的加密方式，毫无规律，看来只能分析了。请将这段语句还原成通顺语句，并从中找到key作为答案提交，答案是32位，包含小写字母。 注意：得到的 flag 请包上 flag{} 提交 下载附件，查看附件：\nVIZZB IFIUOJBWO NVXAP OBC XZZ UKHVN IFIUOJBWO HB XVIXW XAW VXFI X QIXN VBD KQ IFIUOJBWO WBKAH NBWXO VBD XJBCN NKG QLKEIU DI XUI VIUI DKNV QNCWIANQ XN DXPIMKIZW VKHV QEVBBZ KA XUZKAHNBA FKUHKAKX XAW DI VXFI HBN QNCWIANQ NCAKAH KA MUBG XZZ XEUBQQ XGIUKEX MUBG PKAWIUHXUNIA NVUBCHV 12NV HUXWI XAW DI XUI SCQN QB HZXW NVXN XZZ EBCZW SBKA CQ NBWXO XAW DI DXAN NB NVXAP DXPIMKIZW MBU JIKAH QCEV XA BCNQNXAWKAH VBQN HKFI OBCUQIZFIQ X JKH UBCAW BM XLLZXCQI XAW NVI PIO KQ 640I11012805M211J0XJ24MM02X1IW09 得到一段文字，直接丢到在线工具得：\nHELLO EVERYBODY THANK YOU ALL RIGHT EVERYBODY GO AHEAD AND HAVE A SEAT HOW IS EVERYBODY DOING TODAY HOW ABOUT TIM SPICER WE ARE HERE WITH STUDENTS AT WAKEFIELD HIGH SCHOOL IN ARLINGTON VIRGINIA AND WE HAVE GOT STUDENTS TUNING IN FROM ALL ACROSS AMERICA FROM KINDERGARTEN THROUGH 12TH GRADE AND WE ARE JUST SO GLAD THAT ALL COULD JOIN US TODAY AND WE WANT TO THANK WAKEFIELD FOR BEING SUCH AN OUTSTANDING HOST GIVE YOURSELVES A BIG ROUND OF APPLAUSE AND THE KEY IS 640E11012805F211B0AB24FF02A1ED09 得到flag，即flag为flag{640e11012805f211b0ab24ff02a1ed09}\n0x8 RSA3 # RSA题目，直接下载附件，查看附件：\nc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361 n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801 e1=11187289 c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397 e2=9647291 看到c1，c2，e1，e2应该是RSA共模攻击\nRSA共模攻击需要使用到扩展欧几里得定理：\n扩展欧几里得算法是欧几里得算法（又叫辗转相除法）的扩展。除了计算a、b两个整数的最大公约数，此算法还能找到整数x、y（其中一个很可能是负数）。通常谈到最大公因子时, 我们都会提到一个非常基本的事实: 给予二整数 a 与 b, 必存在有整数 x 与 y 使得$ ax + by = gcd(a,b) $。有两个数a,b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到$ ax+by=gcd(a,b) $的整数解。[3]\n根据维基百科，可以找到扩展欧几里得定理的python算法 [4] :\ndef ext_euclid(a, b): old_s,s=1,0 old_t,t=0,1 old_r,r=a,b if b == 0: return 1, 0, a else: while(r!=0): q=old_r//r old_r,r=r,old_r-q*r old_s,s=s,old_s-q*s old_t,t=t,old_t-q*t return old_s, old_t, old_r 这里根据题目要求，使用一个python脚本解决题目：\nfrom gmpy2 import invert from Crypto.Util.number import * def gongmo(n, c1, c2, e1, e2): def egcd(a, b): if b == 0: return a, 0 else: x, y = egcd(b, a % b) return y, x - (a // b) * y s = egcd(e1, e2) s1 = s[0] s2 = s[1] if s1 \u0026lt; 0: s1 = - s1 c1 = invert(c1, n) elif s2 \u0026lt; 0: s2 = - s2 c2 = invert(c2, n) m = pow(c1, s1, n) * pow(c2, s2, n) % n return m c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361 n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801 e1=11187289 c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397 e2=9647291 result = gongmo(n, c1, c2, e1, e2) print long_to_bytes(result) 根据脚本可以直接求出flag：flag{49d91077a1abcb14f1a9d546c80be9ef}\n0x9 RSA2 # 直接下载附件，打开附件：\ne = 65537 n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113 dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657 c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 题目考察的应该就是典型的dp泄露问题，这里就进行简单的公式推导： $$ n = p \\cdot q $$\n$$ \\varphi(n) = (p-1) \\cdot (q-1) $$\n$$ d_p \\equiv d\\ mod\\ (p-1) $$\n$$ d \\equiv e^{-1}\\ mod\\ \\varphi(n) $$\n根据已知信息进行推导：\n$$ d = e^{-1} + k(p-1)(q-1) \\Rightarrow dp \\equiv e^{-1} mod\\ (p-1)\\ $$\n同理，也可以推导出：\n$$ d = e^{-1} + k(p-1)(q-1) \\Rightarrow dp \\equiv e^{-1} mod\\ (q-1)\\ $$\n易得：\n$$ dp \\cdot e -1 = k \\cdot (q-1) $$\n爆破出k即可求得的q值，进一步即可求得结果，这里使用一个python脚本求解：\nfrom Crypto.Util.number import * import gmpy2 e = 65537 n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113 dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657 c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 temp = dp *e for i in range(1,e): if (temp-1)%i == 0: x = (temp-1)//i + 1 y = n%x if y == 0: p=x break q = n // p # print p # print q phi = (q-1)*(p-1) d = gmpy2.invert(e,phi) m = pow(c,d,n) flag = long_to_bytes(m) print flag 运行脚本即可求出flag：flag{wow_leaking_dp_breaks_rsa?_98924743502}\n0xA 异性相吸 # 看题目，应该是考察异或操作的题目\n下载附件，查看附件\n附件内容\n两个文件，应该是使用异或处理最终得到结果，这里使用一个python脚本进行文件的二进制数据读取，然后进行异或操作求解出flag：\n# env = python3 from Crypto.Util.number import * import struct # 读取key.txt文件 key = open(\u0026#34;key.txt\u0026#34;,mode=\u0026#34;rb\u0026#34;) k = key.read() key.close() # 读取密文.txt文件 cipher = open(\u0026#34;密文.txt\u0026#34;,mode=\u0026#34;rb\u0026#34;) c = cipher.read() cipher.close() # 文件二进制数据进行异或处理 m=int.from_bytes(c,byteorder=\u0026#34;big\u0026#34;,signed=True)^int.from_bytes(k,byteorder=\u0026#34;big\u0026#34;,signed=True) # 求解flag flag = long_to_bytes(m).decode() print(flag) 运行脚本得到flag：flag{ea1bc0988992276b7f95b54a7435e89e}\n0xB RSA # RSA题目，直接下载附件，查看附件\n附件内容\n常规的RSA题目，使用openssl工具进行公钥文件的读取和私钥文件的解密\n首先使用openssl对公钥文件进行解析：\n\u0026gt; openssl rsa -pubin -in pub.key -modulus -text RSA Public-Key: (256 bit) Modulus: 00:c0:33:2c:5c:64:ae:47:18:2f:6c:1c:87:6d:42: 33:69:10:54:5a:58:f7:ee:fe:fc:0b:ca:af:5a:f3: 41:cc:dd Exponent: 65537 (0x10001) Modulus=C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+ /AvKr1rzQczdAgMBAAE= -----END PUBLIC KEY----- 获得到了n和e\nn = 0xC0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD e = 65537 使用factordb进行大数分解\n得到p和q：\np=285960468890451637935629440372639283459 q=304008741604601924494328155975272418463 根据已知的信息，编写python脚本，来获取flag：\n# import rsa import libnum e = 65537 n = 86934482296048119190666062003494800588905656017203025617216654058378322103517 p = 285960468890451637935629440372639283459 q = 304008741604601924494328155975272418463 d = libnum.invmod(e,(p-1)*(q-1)) key = rsa.PrivateKey(n,e,d,p,q) with open(\u0026#34;flag.enc\u0026#34;,\u0026#34;rb\u0026#34;) as f: f = f.read() flag = rsa.decrypt(f,key).decode() print(flag) 执行脚本，获取到flag：flag{decrypt_256}\n0xC 还原大师 # 打开题目描述：\n我们得到了一串神秘字符串：TASC?O3RJMV?WDJKX?ZM,问号部分是未知大写字母，为了确定这个神秘字符串，我们通过了其他途径获得了这个字串的32位MD5码。但是我们获得它的32位MD5码也是残缺不全，E903???4DAB????08?????51?80??8A?,请猜出神秘字符串的原本模样，并且提交这个字串的32位MD5码作为答案。 注意：得到的 flag 请包上 flag{} 提交 题目应该是考察md5加密的暴力破解来还原md5的数值：\n根据题目要求编写python脚本进行还原：\nimport hashlib cipher_dict=[] for i in range(65,91): cipher_dict.append(chr(i)) def md5_encrypt(m): return hashlib.md5(m).hexdigest() cipher=\u0026#34;TASC?O3RJMV?WDJKX?ZM\u0026#34; cipher_list=[] while \u0026#34;?\u0026#34; in cipher: index = 0 cipher_list.append(cipher[:cipher.index(\u0026#34;?\u0026#34;)]) cipher = cipher[cipher.index(\u0026#34;?\u0026#34;)+1:] cipher_list.append(cipher) for i in cipher_dict: for j in cipher_dict: for k in cipher_dict: md5_str =md5_encrypt(cipher_list[0]+i+cipher_list[1]+j+cipher_list[2]+k+cipher_list[3]).upper() if md5_str[:4] == \u0026#34;E903\u0026#34;: print \u0026#34;flag{\u0026#34;+md5_str+\u0026#34;}\u0026#34; print \u0026#34;flag{\u0026#34;+md5_str.lower()+\u0026#34;}\u0026#34; break 运行脚本就可以获得flag，结果有大写和小写，忘记了具体是要求提交小写flag和大写flag。\n运行结果：\nflag{E9032994DABAC08080091151380478A2} flag{e9032994dabac08080091151380478a2} 0xD Unencode # 看题目应该是考察UUencode编码的题目\n下载附件，查看附件：\n89FQA9WMD\u0026lt;V1A\u0026lt;V1S83DY.#\u0026lt;W3$Q,2TM] 丢在线工具里面进行解码：\n解码即可获得flag：flag{dsdasdsa99877LLLKK}\n0xE robomunication # 直接下载附件，查看附件：\n附件内容\n发现是一个音频文件，听出来是如下内容：\nbbbb b bpbb bpbb ppp bpp bbbb bp p bb bbb p bbbb b pbp b pbpp bb p bb bbb pbbb ppp ppp bppb pbbb b b bppb 发现是一个摩尔斯电码加密，破译得：\nHELLOWHATISTHEKEYITISBOOPBEEP 对单词进行分割可得：\nHELLO WHAT IS THE KEY IT IS BOOPBEEP 故flag是flag:flag{BOOPBEEP}\n0xF RSAROLL # RSA题目，直接下载附件，查看附件\n题目.txt\nRSA roll！roll！roll！ Only number and a-z （don\u0026#39;t use editor which MS provide） data.txt\n{920139713,19} 704796792 752211152 274704164 18414022 368270835 483295235 263072905 459788476 483295235 459788476 663551792 475206804 459788476 428313374 475206804 459788476 425392137 704796792 458265677 341524652 483295235 534149509 425392137 428313374 425392137 341524652 458265677 263072905 483295235 828509797 341524652 425392137 475206804 428313374 483295235 475206804 459788476 306220148 题目考查RSA低加密指数攻击，但是这道题目，可以试试分解一下n然后进行一下拼接\n首先可以先去在线网站进行大数分解：\n得到p和q的数值\np = 18443 q = 49891 然后使用一个python脚本解决问题：\nimport libnum from Crypto.Util.number import * pub_str = \u0026#34;\u0026#34; cipher_list=[] with open(\u0026#34;data.txt\u0026#34;) as f: lines = f.readlines() for line in lines: line = line.strip(\u0026#34;\\n\u0026#34;) if \u0026#34;{\u0026#34; in line: pub_str = line[1:-1] elif line != \u0026#34;\u0026#34;: cipher_list.append(line) pub_list= pub_str.split(\u0026#34;,\u0026#34;) n = int(pub_list[0]) e = int(pub_list[1]) p = 18443 q = 49891 phi = (p-1)*(q-1) d = libnum.invmod(e,phi) flag = \u0026#34;\u0026#34; for i in cipher_list: m = pow(int(i),d,n) plainer = long_to_bytes(m) flag += plainer print flag 运行脚本获得flag，即flag{13212je2ue28fy71w8u87y31r78eu1e2}\n参考： # [标准中文电码(Chinese Commercial Code)简介、用途及查询](https://www.chasedream.com/show.aspx?id=4487\u0026amp;cid=30#:~:text=中文电码，又称：中文商用电码（Chinese commercial code%2C CCC）、中文电报码（Chinese telegraph,code%2C CTC）或中文电报明码（Chinese ordinary telegraph code%2C COTC），原本是用于电报之中传送中文信息的方法。) 猪圈密码-维基百科 [扩展欧几里得算法-百度百科](https://baike.baidu.com/item/扩展欧几里得算法/2029414?fromtitle=扩展欧几里德算法\u0026amp;fromid=1053275#:~:text=扩展欧几里得算法 （英语：Extended Euclidean algorithm）是 欧几里得算法 （又叫辗转相除法）的扩展。 已知整数a、b，扩展欧几里得算法可以在求得a、b的 最大公约数,by %3D gcd (a%2Cb) 。 有两个数a%2Cb，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。 然后，收集辗转相除法中产生的式子，倒回去，可以得到ax%2Bby%3Dgcd (a%2Cb)的整数解。) [扩展欧几里得算法-维基百科](https://baike.baidu.com/item/扩展欧几里得算法/2029414?fromtitle=扩展欧几里德算法\u0026amp;fromid=1053275#:~:text=扩展欧几里得算法 （英语：Extended Euclidean algorithm）是 欧几里得算法 （又叫辗转相除法）的扩展。 已知整数a、b，扩展欧几里得算法可以在求得a、b的 最大公约数,by %3D gcd (a%2Cb) 。 有两个数a%2Cb，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。 然后，收集辗转相除法中产生的式子，倒回去，可以得到ax%2Bby%3Dgcd (a%2Cb)的整数解。) 本期wp分享到此为止，有时间再来喝杯茶呀！\n","date":"June 26, 2021","permalink":"/posts/buuctf-crypto-2_writeup/","section":"Posts","summary":"还是BUUCTF的题目，熟悉的感觉，再来一次！\nBUUCTF首页\n本次的题目大致如下：\nCTF题目\n题目是16道密码学题目：\n传统知识+古典密码 信息化时代的步伐 RSA1 凯撒？转换？呵呵！ old-fashion 萌萌哒的八戒 权限获得第一步 世上无难事 RSA3 RSA2 异性相吸 RSA 还原大师 Unencode robomunication RSAROLL 题目求解： # 题目都还比较简单，正常来做就好。\n0x0 传统知识+古典密码 # 下载附件，得到题目\n题目信息\n应该是考察古典密码的题目，是考察六十甲子顺序纳音表的题目\n这里列出六十顺序纳音表：\n六十甲子顺序表\n根据六十甲子顺序表编写python脚本：\nC_sky = \u0026#34;甲乙丙丁戊己庚辛壬癸\u0026#34; C_earth = \u0026#34;子丑寅卯辰巳午未申酉戌亥\u0026#34; C_dict={} for i in range(60): C_dict[C_sky[i%len(C_sky)]+C_earth[i%len(C_earth)]] = str(i+1) cipher = \u0026#34;辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳\u0026#34; cipher_list = cipher.split(\u0026#34;，\u0026#34;) plainer = \u0026#34;\u0026#34; for i in cipher_list: plainer += chr(int(C_dict[i])+60) def decrype(cipher,key): cipher_len = len(cipher) if cipher_len%key == 0: key = cipher_len // key else: key = cipher_len // key + 1 result = {x:\u0026#39;\u0026#39; for x in range(key)} for i in range(cipher_len): a = i%key; result.","title":"BUUCTF CRYPTO (2) writeup"},{"content":"“再论RSA加密算法” # 优美的数，自然的码\n侦破数的逻辑\n看透码的奥秘\nRSA加密算法的算法结构是非常严谨的，具有良好的保密性和完整性。正确使用RSA加密算法，可以确保信息传输的安全性。但是根据现代密码学的研究和发现，RSA加密算法已经被攻破了。中国的王小云通过密码分析学的方法，破解了RSA加密算法。\n而RSA加密算法在CTF比赛中的地位仍然是不容小视的，在CTF比赛中的密码学部分是经常出没。CTF的密码学题目往往是在考察参赛者对于密码学算法的理解，往往采用的是密码分析学的知识进行密码学破解。密码学经常使用的三个角色是Alice、Bob和Eva，这三个人往往是Alice和Bob在不安全的信道上进行传输信息，而Eva是在窃听不安全信道上面信息的窃听者。而CTF比赛中，参赛者往往就需要扮演Eva的角色，根据题目给到的信息进行密码破译，来获取到Flag。\n说来说去，RSA加密算法，RSA加密算法其实就挺简单的，至少算法逻辑是比较简单的。但是在计算机的实际应用中，往往会有编码和其他各种加密的使用，进行综合性的安全性应用。RSA加密算法虽然是比较简单的算法过程，但是随着现代密码学的不断发展和进步，越来越多针对RSA加密算法的攻击方式，因而CTF也根据密码学研究是文献进行革新，演变出来了各种各样针对RSA攻击方法的破译算法。\nCTF中RSA题目类型 # CTF中常见的RSA题目类型有如下几类：^1^\n公钥加密文\n这是CTF中最常见最基础的题型，出题人会给你一个公钥文件（通常是以.pem或.pub结尾的文件）和密文（通常叫做flag.enc之类的），你需要分析公钥，提取出（N，e），通过各种攻击手段恢复私钥，然后去解密密文得到flag。\n文本文档\n对于第一种题型，耿直点的出题人直接给你一个txt文本文档，里面直接写出了（N，e，c）所对应的十进制数值，然后你直接拿去用就行了。当然也不都是给出（N，e，c）的值，有时还会给出其他一些参数，这时就需要思考，这题具体考察的什么攻击方法\npcap文件\n有时出题人会给你一个流量包，你需要用wireshark等工具分析，然后根据流量包的通信信息，分析题目考察的攻击方法，你可以提取出所有你解题需要用到的参数，然后进行解密\n本地脚本分析\n题目会给你一个脚本和一段密文，一般为python编写，你需要逆向文件流程，分析脚本的加密过程，写出对应的解密脚本进行解密\n远程脚本利用\n这种题型一般难度较大。题目会给你一个运行在远程服务器上的python脚本和服务器地址，你需要分析脚本存在的漏洞，确定攻击算法，然后编写脚本与服务器交互，得到flag\n密码学的题目类型也大致就是这些类型了，这些题目类型也展现出了密码学并不是孤立的存在，密码学与网络安全的各个方面都有着较大的联系，并彼此互联。\n数据处理 # CTF比赛中的CRYPTO题目类型往往会给到一些需要进行数据处理的文件格式：\n基本上来说，RSA的题目都是围绕着c，m，e，d，n，p，q这几个参数展开的，但是题目一般不会直接给这种样子的参数，而是通过别的方式给出，这里就需要我们使用一些工具或者自己手工将这些参数提取出来。^2^\npem文件**：**针对此类文件可以直接使用openssl提取，大概使用过的方式有：\nopenssl rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.enc openssl rsa -pubin -text -modulus -in warmup -in public.pem pcap文件：针对此类文件可以使用wireshark follow一下。这种问题一般都是写了一个交互的crypto系统，所以可能产生多轮交互。\nPPC模式：这种模式是上述pcap文件的交互版，会给一个端口进行一些crypto的交互，参数会在交互中给出。\n第二个需要处理的就是明密文，这个方法多多，不多赘述。\nRSA加密算法的攻击类型 # RSA加密算法题目的攻击类型是各种各样的，常见的攻击方法：\n模数分解 # 解决RSA题目最简单，最暴力，最好使的方法就是分解模数n。如果能够将n分解成功，成功得到p，q的取值，那么可求n的欧拉函数的值。\n模数分解往往可以使用多种方式进行分解，素数分解向来就是数学研究领域比较难以攻克的内容。而RSA算法的保密性也是由于素数分解的困难。但是有些简单的RSA题目可以使用素数分解的方法来解决，常用的工具有：foctordb，sagemath\n低加密指数攻击 # 在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。\ne=3时的小明文攻击 # 当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。\n即： $$ c\\equiv; m^e ;mod; n $$\n如果e=3，且 $ m^e\u0026lt;{n} $，那么：\n$$ c= m^e,;e=3 $$\n$$ m=sqrt[3]{c} $$\n如果明文的三次方比n大，但是不是足够大，那么设k，有：\n$$ c= m^e+kn $$\n爆破k，如果$ c-kn $能开三次根式，那么可以直接得到明文。\n低加密指数广播攻击 # 如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。\n即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有：\n$$ c_1\\equiv m^e;mod ; n_1 $ $$ $$ c_2\\equiv m^e;mod ; n_2 $ $$ $$ c_3\\equiv m^e;mod;n_3 $$\n对上述等式运用中国剩余定理，在e=3时，可以得到：\n$$ c_x\\equiv m^3;mod;n_1n_2n_3 $$\n通过对 $ c_x $ 进行三次开方可以求得明文。\n低解密指数攻击 # 与低加密指数相同，低解密指数可以加快解密的过程，但是者也带来了安全问题。Wiener表示如果满足：\n$$ d\u0026lt;\\frac{1}{3}g n^\\frac{1}{4} $$\n那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害RSA的安全。此时需要满足：\n$$ q;\u0026lt;;p;\u0026lt;;2q $$\n如果满足上述条件，通过Wiener Attack可以在多项式时间中分解n。\nrsa-wiener-attack的攻击源码开源在了github中，采取python编写，可以很容易使用。\n共模攻击 # 如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。\n即：\n$$ c_1\\equiv m^{e_1};mod;n $$ $$ c_2\\equiv m^{e_2};mod;n $$\n此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。\n过程如下，首先两个加密指数互质，则：\n$$ (e_1,e_2)=1 $$\n即存在$ s_2 $，$ s_2 $使得：\n$$ s_1e_1+s_2e_2=1 $$\n又因为： $$ c_1 \\equiv m^{e_1};mod;n $$ $$ c_2\\equiv m^{e_2};mod;n $$\n通过代入化简可以得出： $$ c_1^{s_1}c_2^{s_2}\\equiv;m;mod;n $$\n明文解出。\nRSA的攻击方法肯定不止这五种，随着时代的发展和科技的进步，RSA加密算法被各种各样的破译算法进行攻破。而掌握这几种攻击算法，可以解决RSA题目中的大部分中等题目类型。比较难的题目，也就只能去多看看paper了。\n参考 # CTF中RSA题型解题思路及技巧，附小白福利-FREEBUF 【技术分享】CTF中RSA的常见攻击方法-安全客 闲聊到此为止，来喝杯茶可好？\n","date":"June 26, 2021","permalink":"/posts/%E5%B0%BD%E6%B2%BE%E6%89%8B%E8%A5%9F-%E6%B7%8B%E6%BB%A1%E7%9C%BC%E7%9C%B6/","section":"Posts","summary":"“再论RSA加密算法” # 优美的数，自然的码\n侦破数的逻辑\n看透码的奥秘\nRSA加密算法的算法结构是非常严谨的，具有良好的保密性和完整性。正确使用RSA加密算法，可以确保信息传输的安全性。但是根据现代密码学的研究和发现，RSA加密算法已经被攻破了。中国的王小云通过密码分析学的方法，破解了RSA加密算法。\n而RSA加密算法在CTF比赛中的地位仍然是不容小视的，在CTF比赛中的密码学部分是经常出没。CTF的密码学题目往往是在考察参赛者对于密码学算法的理解，往往采用的是密码分析学的知识进行密码学破解。密码学经常使用的三个角色是Alice、Bob和Eva，这三个人往往是Alice和Bob在不安全的信道上进行传输信息，而Eva是在窃听不安全信道上面信息的窃听者。而CTF比赛中，参赛者往往就需要扮演Eva的角色，根据题目给到的信息进行密码破译，来获取到Flag。\n说来说去，RSA加密算法，RSA加密算法其实就挺简单的，至少算法逻辑是比较简单的。但是在计算机的实际应用中，往往会有编码和其他各种加密的使用，进行综合性的安全性应用。RSA加密算法虽然是比较简单的算法过程，但是随着现代密码学的不断发展和进步，越来越多针对RSA加密算法的攻击方式，因而CTF也根据密码学研究是文献进行革新，演变出来了各种各样针对RSA攻击方法的破译算法。\nCTF中RSA题目类型 # CTF中常见的RSA题目类型有如下几类：^1^\n公钥加密文\n这是CTF中最常见最基础的题型，出题人会给你一个公钥文件（通常是以.pem或.pub结尾的文件）和密文（通常叫做flag.enc之类的），你需要分析公钥，提取出（N，e），通过各种攻击手段恢复私钥，然后去解密密文得到flag。\n文本文档\n对于第一种题型，耿直点的出题人直接给你一个txt文本文档，里面直接写出了（N，e，c）所对应的十进制数值，然后你直接拿去用就行了。当然也不都是给出（N，e，c）的值，有时还会给出其他一些参数，这时就需要思考，这题具体考察的什么攻击方法\npcap文件\n有时出题人会给你一个流量包，你需要用wireshark等工具分析，然后根据流量包的通信信息，分析题目考察的攻击方法，你可以提取出所有你解题需要用到的参数，然后进行解密\n本地脚本分析\n题目会给你一个脚本和一段密文，一般为python编写，你需要逆向文件流程，分析脚本的加密过程，写出对应的解密脚本进行解密\n远程脚本利用\n这种题型一般难度较大。题目会给你一个运行在远程服务器上的python脚本和服务器地址，你需要分析脚本存在的漏洞，确定攻击算法，然后编写脚本与服务器交互，得到flag\n密码学的题目类型也大致就是这些类型了，这些题目类型也展现出了密码学并不是孤立的存在，密码学与网络安全的各个方面都有着较大的联系，并彼此互联。\n数据处理 # CTF比赛中的CRYPTO题目类型往往会给到一些需要进行数据处理的文件格式：\n基本上来说，RSA的题目都是围绕着c，m，e，d，n，p，q这几个参数展开的，但是题目一般不会直接给这种样子的参数，而是通过别的方式给出，这里就需要我们使用一些工具或者自己手工将这些参数提取出来。^2^\npem文件**：**针对此类文件可以直接使用openssl提取，大概使用过的方式有：\nopenssl rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.enc openssl rsa -pubin -text -modulus -in warmup -in public.pem pcap文件：针对此类文件可以使用wireshark follow一下。这种问题一般都是写了一个交互的crypto系统，所以可能产生多轮交互。\nPPC模式：这种模式是上述pcap文件的交互版，会给一个端口进行一些crypto的交互，参数会在交互中给出。\n第二个需要处理的就是明密文，这个方法多多，不多赘述。\nRSA加密算法的攻击类型 # RSA加密算法题目的攻击类型是各种各样的，常见的攻击方法：\n模数分解 # 解决RSA题目最简单，最暴力，最好使的方法就是分解模数n。如果能够将n分解成功，成功得到p，q的取值，那么可求n的欧拉函数的值。\n模数分解往往可以使用多种方式进行分解，素数分解向来就是数学研究领域比较难以攻克的内容。而RSA算法的保密性也是由于素数分解的困难。但是有些简单的RSA题目可以使用素数分解的方法来解决，常用的工具有：foctordb，sagemath\n低加密指数攻击 # 在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。\ne=3时的小明文攻击 # 当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。\n即： $$ c\\equiv; m^e ;mod; n $$","title":"尽沾手襟 淋满眼眶"},{"content":"清茶一盏 公杯斟茗 # 上下运杯，左右轻斟\n公杯，私茗，香满阑\n清茶，浓茶，甘润田\n然君闻几何？\n要谈谈RSA加密算法，不妨先聊聊密码学的发展历史和密码学的历程。\n密码学早在公元前400多年就已经产生，人类使用密码的历史几乎与使用文字的时间一样长，密码学的发展大致可以分为 3 个阶段: 1949 年之前的古典密码学阶段; 1949 年至 1975 年密码学成为科学的分支; 1976 年以后对称密钥密码算法得到进一步发展，产生了密码学的新方向—公钥密码学。1976 年，W.Diffie 和 M.Hellman 在发表的文章“密码学的新方向”中首次公开提出了公钥密码( Public-key Cryptography) 的概念。公钥密码的提出实现了加密密钥和解密密钥之间的独立，解决了对称密码体制中通信双方必须共享密钥的问题，在密码学界具有划时代的意义。^1^\n密码学的历史非常悠久，但是密码学的发展速度并不是非常迅速，直到信息时代的到来以及网络空间安全面临着巨大的威胁，密码学得到了前所未有的飞速发展，RSA公钥密码就是其中的代表。密码学中研究的对象有大致三类：\n对称密码 非对称密码 协议 而RSA密码属于非对称密码，公钥密码。RSA也是现代密码学的代表性的内容部分，那么非常经典的RSA密码就是一个什么样的密码呢？\n首先，要搞清楚什么是RSA密码：\nRSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。\n1973年，在英国政府通讯总部工作的数学家克利福德·柯克斯（Clifford Cocks）在一个内部文件中提出了一个与之等效的算法，但该算法被列入机密，直到1997年才得到公开。\n对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式破解。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被破解的。^2^\nRSA加密算法就是三个人提出的一个非对称加密的算法，是一种公钥算法。RSA加密算法进行加密的信息具有良好的安全性和可靠性，正确地使用RSA加密算法可以应对互联网上的大多数针对密码进行的攻击。\nRSA加密算法的具体内容是什么呢？\n（这里借鉴一下阮一峰的个人博客进行说明）^3^\n（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。\n（2）甲方获取乙方的公钥，然后用它对信息加密。\n（3）乙方得到加密后的信息，用私钥解密。\n这是非对称加密的总体流程，简单来说就是公钥加密，私钥解密的算法模式。而RSA加密算法就是公钥算法中的代表性的算法，这经典算法的基本原理还是比较简单易懂的。\nRSA加密算法需要一点点的数学基础，也可以说是数论基础。\n数学基础 # 模运算：模运算也可以说是用取余的运算方式\n$$ a \\equiv b(mod; m)$$\n这是最简单的模运算公式，也可以使用简单的Python语法实现：\nb = a % m # python语言中%可以进行取余运算 整数环：模运算的延申，无论模运算中的数怎么加减乘除都在模的一个整数环中。\n在数论的概念中，模运算主要是针对自然数进行的研究，模运算也是如此。可以把整数环想象成一个钟表，钟表有12个数字，无论怎么加减乘除钟表的数字，指针始终都指在钟表的环中。\n这里用简单的数学语言进行表示：\n$$ a + c\\equiv e(mod;12)$$\n$$ a \\cdot c\\equiv f(mod;12)$$\n当然也可以使用Python语法进行表示：\ne = (a+c) % 12 f = (a*c) % 12 欧拉函数：求小于该数的素数个数多少的问题的最佳解决方案。\n欧拉函数也是数论里面比较重要的概念，欧拉函数的特点使得RSA加密算法有良好的加密性和安全性。\n在讲欧拉函数之前，先阐述一下素数的概念：\n素数也叫质数，素数就是只能被1和自身整除的数\n互素也叫互质，如果两个数的最大公因数是1，那么则称这两个数是互素的\n什么是欧拉函数呢？\n欧拉函数一般使用 φ(n) 表示，一般来说是分为两种情况的：\n（1） n是一个素数：\n$$ \\varphi (n)= n-1$$\n（2）n不是一个素数，但是n是两个素数的乘积：\n$$ \\varphi (n) = (p-1) \\cdot (q-1) $$\n这就是欧拉函数，和欧拉函数一起使用的还有一个欧拉定理：\n在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则:\n$$ a ^{\\varphi(n)} \\equiv 1(mod; n) $$\n这些大致就是欧拉函数和欧拉定理的大致内容，都是规律性的总结，在RSA算法中加以使用就可以了。\n模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。^3^\n这里可以使用数学语言进行解释一下：\n$$ a \\cdot b \\equiv 1(mod;m) $$\n就是两个数进行模乘法运算得到的结果是1的两个数互为模反元素，也叫逆元。\n在这个等式中，可以说a是b的逆元，也可以说是b是a的逆元。\n最后一个数学概念：单向函数，公钥加密算法的核心原理\n单向函数就是由x求y简单，而由y求x比较困难的函数叫做单向函数：\n$$ y = f(x) $$\n$$ x = f^{-1}(y) $$\n由于单向函数概念的出现，使得公钥加密私钥解密成为现实。\n可是单向函数只是使加密变得容易，而并没有使解密变得容易。于是一个陷门的概念提出使公钥加密私钥解密的加密算法模式真正的变成现实。\n什么是陷门呢？\n陷门的概念就好比网络安全的后门，单向函数解密不是非常困难嘛，而陷门就是一个特殊的数值可以使单向函数进行解密变得简单。于是陷门就可以作为私钥进行解密。\nRSA公钥加密算法的数学知识大致就是这些了。\n下面，来聊一聊RSA公钥加密算法的具体过程。\nRSA加密算法 # 首先随机选择两个不相等的素数p和q 计算p和q的乘积n 计算n的欧拉函数发φ(n) 随机选择一个整数e，e满足的条件是：1\u0026lt;e\u0026lt;φ(n) 计算e对于φ(n)的模反元素d 将n和e封装成公钥，将n和d封装成私钥 具体流程用数学的语言描述：\n$$ 1. \\quad p , q$$\n$$ 2. \\quad p\\cdot q = n $$\n$$ 3. \\quad \\varphi (n) $$\n$$ 4. \\quad 1\u0026lt;e\u0026lt;\\varphi (n) $$\n$$ 5. \\quad e \\cdot d \\equiv 1 (mod; \\varphi (n)) $$\n$$ 6. \\quad (n , e) , (n , d) $$\n当然也可使用python语句进行设计：4\nimport gmpy2 import gmpy2 from gmpy2 import mpz import binascii rs = gmpy2.random_state() #生成大素数（0-2^1024位） def create_prime(): p = gmpy2.mpz_urandomb(rs,1024) #随机生成一个0~2^1024位的数 while not gmpy2.is_prime(p): #判断生成的数是否是素数 p = gmpy2.mpz_urandomb(rs,1024) return p #生成密钥e,d def get_e_d(phi): e = gmpy2.mpz_random(rs,phi) while gmpy2.gcd(e,phi) != 1: e = gmpy2.mpz_random(rs,phi) #随机生成一个0~phi的,与phi互素的数 d = gmpy2.invert(e,phi) #生成d return e,d #rsa加密 def encrypt(plain_text,e,n): m = mpz(binascii.hexlify(plain_text.encode(\u0026#39;utf-8\u0026#39;)), 16) cipher_text = gmpy2.powmod(m,e,n) return cipher_text #rsa解密 def decrypt(cipher_text,d,n): m = gmpy2.powmod(cipher_text,d,n) plain_text = binascii.unhexlify(format(m, \u0026#39;x\u0026#39;)).decode(\u0026#39;utf-8\u0026#39;) return plain_text if __name__ == \u0026#39;__main__\u0026#39;: p = create_prime() q = create_prime() n = p * q phi = (p-1)*(q-1) e,d = get_e_d(phi) plain_text = input(\u0026#34;请输入明文：\u0026#34;) cipher_text = encrypt(plain_text,e,n) print(\u0026#34;RSA加密后的密文是：%x\u0026#34;%cipher_text) plain_text1 = decrypt(cipher_text,d,n) print(\u0026#34;RSA解密后的明文是：{}\u0026#34;.format(plain_text1)) RSA的加密流程非常简单，只需要大致记忆就可以对RSA算法流程非常清晰，而且明了于心。同时，也会出现一些疑问，这么安全的加密算法会有什么样的漏洞会在CTF比赛中让CTF选手进行攻击呢？\n无论再安全的算法，都有可以破解的漏洞存在，“没有绝对安全的系统”。时代在进步，密码学算法也在一步一步的提升，下一篇将揭示RSA公钥密码的常见攻击手段。\n参考 # 密码学发展简史-CSDN RSA加密算法-维基百科 RSA算法原理-阮一峰 python实现RSA算法 闲聊到此为止，来喝杯茶可好？\n","date":"June 26, 2021","permalink":"/posts/%E6%B8%85%E8%8C%B6%E4%B8%80%E7%9B%8F-%E5%85%AC%E6%9D%AF%E6%96%9F%E8%8C%97/","section":"Posts","summary":"清茶一盏 公杯斟茗 # 上下运杯，左右轻斟\n公杯，私茗，香满阑\n清茶，浓茶，甘润田\n然君闻几何？\n要谈谈RSA加密算法，不妨先聊聊密码学的发展历史和密码学的历程。\n密码学早在公元前400多年就已经产生，人类使用密码的历史几乎与使用文字的时间一样长，密码学的发展大致可以分为 3 个阶段: 1949 年之前的古典密码学阶段; 1949 年至 1975 年密码学成为科学的分支; 1976 年以后对称密钥密码算法得到进一步发展，产生了密码学的新方向—公钥密码学。1976 年，W.Diffie 和 M.Hellman 在发表的文章“密码学的新方向”中首次公开提出了公钥密码( Public-key Cryptography) 的概念。公钥密码的提出实现了加密密钥和解密密钥之间的独立，解决了对称密码体制中通信双方必须共享密钥的问题，在密码学界具有划时代的意义。^1^\n密码学的历史非常悠久，但是密码学的发展速度并不是非常迅速，直到信息时代的到来以及网络空间安全面临着巨大的威胁，密码学得到了前所未有的飞速发展，RSA公钥密码就是其中的代表。密码学中研究的对象有大致三类：\n对称密码 非对称密码 协议 而RSA密码属于非对称密码，公钥密码。RSA也是现代密码学的代表性的内容部分，那么非常经典的RSA密码就是一个什么样的密码呢？\n首先，要搞清楚什么是RSA密码：\nRSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。\n1973年，在英国政府通讯总部工作的数学家克利福德·柯克斯（Clifford Cocks）在一个内部文件中提出了一个与之等效的算法，但该算法被列入机密，直到1997年才得到公开。\n对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式破解。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被破解的。^2^\nRSA加密算法就是三个人提出的一个非对称加密的算法，是一种公钥算法。RSA加密算法进行加密的信息具有良好的安全性和可靠性，正确地使用RSA加密算法可以应对互联网上的大多数针对密码进行的攻击。\nRSA加密算法的具体内容是什么呢？\n（这里借鉴一下阮一峰的个人博客进行说明）^3^\n（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。\n（2）甲方获取乙方的公钥，然后用它对信息加密。\n（3）乙方得到加密后的信息，用私钥解密。\n这是非对称加密的总体流程，简单来说就是公钥加密，私钥解密的算法模式。而RSA加密算法就是公钥算法中的代表性的算法，这经典算法的基本原理还是比较简单易懂的。\nRSA加密算法需要一点点的数学基础，也可以说是数论基础。\n数学基础 # 模运算：模运算也可以说是用取余的运算方式\n$$ a \\equiv b(mod; m)$$\n这是最简单的模运算公式，也可以使用简单的Python语法实现：\nb = a % m # python语言中%可以进行取余运算 整数环：模运算的延申，无论模运算中的数怎么加减乘除都在模的一个整数环中。","title":"清茶一盏 公杯斟茗"},{"content":"日常刷题喝茶的平时生活，整理一下题目的思路，捋一捋密码学。\nBUUCTF是国内另一个比较不错的CTF的刷题平台，是由北京联合大学创建并维护的CTF大型同性交流沟通的平台，页面制作还是蛮美观滴！\nBUUCTF页面\nBUUCTF的整体难度是由简单变难的一个过程，前面的题目通常都是比较简单的题目，来看看这次日常的题目：\n题目\n这次是16道题目：\nMD5 Url编码 一眼就解密 看我回旋踢 摩丝 password 变异凯撒 Quoted-printable Rabbit 篱笆墙的影子 RSA 丢失的MD5 Alice与Bob rsarsa 大帝的密码武器 Windows系统密码 MD5 # 看题目应该是考察MD5加密的暴力破解\n什么是MD5加密？\nMD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 中被加以规范。\n将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。\n1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的资料，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞攻击（英语：Collision_attack），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。[1]\n看看题目描述：\n题目描述\n下载附件，查看附件内容：\n附件内容\n附件中给出一段加密数据：e00cf25ad42683b3df678c61f42c6bda\n根据题目，应该是MD5加密，去解密网站\n进行解密。\ncmd5\n题目描述中，要求以flag{}形式进行提交，故flag就是flag{admin1}\n这道题目考察md5加密的相关知识，签到题。\nUrl编码 # 看题目应该是考察Url编码的解码\n什么是Url编码？\n百分号编码（英语：Percent-encoding），又称：URL编码（URL encoding）是特定上下文的统一资源定位符 （URL）的编码机制，实际上也适用于统一资源标志符（URI）的编码。也用于为 application/x-www-form-urlencoded MIME准备数据，因为它用于通过HTTP的请求操作（request）提交HTML表单数据。[2]\n看看题目描述：\n题目描述\n下载附件，查看附件内容：\n附件内容\n一段编码的字段：%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d\n使用url解码工具解码，也可以使用python进行解码。我个人习惯使用python脚本进行url编码解码：\nimport urllib.parse cipher = \u0026#39;%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d\u0026#39; print(urllib.parse.unquote(cipher)) 运行脚本就可以出结果：\n解码后也就是flag数据：flag{and 1=1}\n故本题的flag是flag{and 1=1}\n题目主要考察URL编码，签到题。\n一眼就解密 # 题目给不了太多提示\n直接点开题目描述看内容：\n题目描述\n看题目描述中的字符串，字符串的样子像是base64编码：ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=\n这里一个脚本进行求解：\nimport base64 cipher = \u0026#34;ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=\u0026#34; plainer = \u0026#34;\u0026#34; plainer = base64.b64decode(cipher) print plainer 运行程序求解得到：flag{THE_FLAG_OF_THIS_STRING}\n故本题的flag是flag{THE_FLAG_OF_THIS_STRING}\n题目考察base64编码，签到题。\n看我回旋踢 # 看题目，暂时想不出什么密码相关联的内容。\n点开题目描述：\n题目描述\n只提示了题目提交的flag数据的格式信息\n下载附件，查看附件内容：\n附件内容\n看附件给出的字符形式像是替换密码加密的数据，最容易联想到的替换密码就是凯撒密码，尝试使用凯撒密码进行解密：（这里一个脚本求解凯撒密码）\ndict_list = [] for i in range(26): dict_list.append(chr(ord(\u0026#39;a\u0026#39;)+i)) cipher = \u0026#34;synt{5pq1004q-86n5-46q8-o720-oro5on0417r1}\u0026#34; for n in range(26): plainer = \u0026#34;\u0026#34; for i in cipher: if i in dict_list: plainer += dict_list[(dict_list.index(i)-n)%26] else: plainer += i print plainer 凯撒密码的算法思路，在上一篇XCTF CRYPTO的WP中有提到，具体内容可以访问上一篇：\nXCTF-CRYPTO-新手区 writeup\n运行脚本程序，得到一堆凯撒解密的结果：\nsynt{5pq1004q-86n5-46q8-o720-oro5on0417r1} rxms{5op1004p-86m5-46p8-n720-nqn5nm0417q1} qwlr{5no1004o-86l5-46o8-m720-mpm5ml0417p1} pvkq{5mn1004n-86k5-46n8-l720-lol5lk0417o1} oujp{5lm1004m-86j5-46m8-k720-knk5kj0417n1} ntio{5kl1004l-86i5-46l8-j720-jmj5ji0417m1} mshn{5jk1004k-86h5-46k8-i720-ili5ih0417l1} lrgm{5ij1004j-86g5-46j8-h720-hkh5hg0417k1} kqfl{5hi1004i-86f5-46i8-g720-gjg5gf0417j1} jpek{5gh1004h-86e5-46h8-f720-fif5fe0417i1} iodj{5fg1004g-86d5-46g8-e720-ehe5ed0417h1} hnci{5ef1004f-86c5-46f8-d720-dgd5dc0417g1} gmbh{5de1004e-86b5-46e8-c720-cfc5cb0417f1} flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1} ekzf{5bc1004c-86z5-46c8-a720-ada5az0417d1} djye{5ab1004b-86y5-46b8-z720-zcz5zy0417c1} cixd{5za1004a-86x5-46a8-y720-yby5yx0417b1} bhwc{5yz1004z-86w5-46z8-x720-xax5xw0417a1} agvb{5xy1004y-86v5-46y8-w720-wzw5wv0417z1} zfua{5wx1004x-86u5-46x8-v720-vyv5vu0417y1} yetz{5vw1004w-86t5-46w8-u720-uxu5ut0417x1} xdsy{5uv1004v-86s5-46v8-t720-twt5ts0417w1} wcrx{5tu1004u-86r5-46u8-s720-svs5sr0417v1} vbqw{5st1004t-86q5-46t8-r720-rur5rq0417u1} uapv{5rs1004s-86p5-46s8-q720-qtq5qp0417t1} tzou{5qr1004r-86o5-46r8-p720-psp5po0417s1} 在解密的字符列表中，找到符合flag格式的字符段：\nflag{5cd1004d-86a5-46d8-b720-beb5ba0417e1}\n故本题的flag是：flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1}\n题目主要考察凯撒密码，签到题。\n摩丝 # 看题目，可以联想到Morse电码，这题目应该是摩尔斯密码的解密题目\n点开题目描述：\n题目描述\n题目描述只说了flag{}的格式，下载附件并查看：\n附件内容\n果然是摩尔斯密码，这里一个脚本解决：\ndict_list = { \u0026#39;.-\u0026#39;:\u0026#39;a\u0026#39;, \u0026#39;-...\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;-.-.\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;-..\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;.\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;..-.\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;--.\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;....\u0026#39;:\u0026#39;h\u0026#39;, \u0026#39;..\u0026#39;:\u0026#39;i\u0026#39;, \u0026#39;.---\u0026#39;:\u0026#39;j\u0026#39;, \u0026#39;-.-\u0026#39;:\u0026#39;k\u0026#39;, \u0026#39;.-..\u0026#39;:\u0026#39;l\u0026#39;, \u0026#39;--\u0026#39;:\u0026#39;m\u0026#39;, \u0026#39;-.\u0026#39;:\u0026#39;n\u0026#39;, \u0026#39;---\u0026#39;:\u0026#39;o\u0026#39;, \u0026#39;.--.\u0026#39;:\u0026#39;p\u0026#39;, \u0026#39;--.-\u0026#39;:\u0026#39;q\u0026#39;, \u0026#39;.-.\u0026#39;:\u0026#39;r\u0026#39;, \u0026#39;...\u0026#39;:\u0026#39;s\u0026#39;, \u0026#39;-\u0026#39;:\u0026#39;t\u0026#39;, \u0026#39;..-\u0026#39;:\u0026#39;u\u0026#39;, \u0026#39;...-\u0026#39;:\u0026#39;v\u0026#39;, \u0026#39;.--\u0026#39;:\u0026#39;w\u0026#39;, \u0026#39;-..-\u0026#39;:\u0026#39;x\u0026#39;, \u0026#39;-.--\u0026#39;:\u0026#39;y\u0026#39;, \u0026#39;--..\u0026#39;:\u0026#39;z\u0026#39;, \u0026#39;-----\u0026#39;:\u0026#39;0\u0026#39;, \u0026#39;.----\u0026#39;:\u0026#39;1\u0026#39;, \u0026#39;..---\u0026#39;:\u0026#39;2\u0026#39;, \u0026#39;...--\u0026#39;:\u0026#39;3\u0026#39;, \u0026#39;....-\u0026#39;:\u0026#39;4\u0026#39;, \u0026#39;.....\u0026#39;:\u0026#39;5\u0026#39;, \u0026#39;-....\u0026#39;:\u0026#39;6\u0026#39;, \u0026#39;--...\u0026#39;:\u0026#39;7\u0026#39;, \u0026#39;---..\u0026#39;:\u0026#39;8\u0026#39;, \u0026#39;----.\u0026#39;:\u0026#39;9\u0026#39;, \u0026#39;..--.-\u0026#39;:\u0026#39;_\u0026#39; } cipher = \u0026#34;.. .-.. --- ...- . -.-- --- ..-\u0026#34; plainer = \u0026#34;\u0026#34; cipher_arr = cipher.split(\u0026#34; \u0026#34;) for i in cipher_arr: plainer += dict_list[i] print plainer.upper() print plainer.lower() 摩尔斯电码的详细介绍，在上一篇XCTF CRYPTO的WP中有提到，具体内容可以访问上一篇：\nXCTF-CRYPTO-新手区 writeup\n执行一下代码，得到两个数据：\nILOVEYOU iloveyou 两个数据都可能是flag数据，我记得这道题目的flag数据好像是用大写的，即：flag{ILOVEYOU}，也有可能错。\n题目主要考察摩尔斯电码相关知识，签到题。\npassword # 看题目应该是与密码有关系的题目\n点开题目描述：\n题目描述\n只有flag数据提交格式的相关信息，下载附件并打开：\n附件内容\n看到附件内容里面的信息，可以大致判断这道题目应该是社会工程学题目。\n什么是社会工程学：\n在计算机科学，社会工程学指的是通过与他人的合法交流，来使其心理受到影响，做出某些动作或者是透露一些机密信息的方式。这通常被认为是欺诈他人以收集信息、行骗和入侵计算机系统的行为。在英美普通法系，这一行为一般是被认作侵犯隐私权的。\n历史上，社会工程学是隶属于社会学，不过其影响他人心理的效果引起了计算机安全专家的注意。3\n简单来说，社会工程学就是利用人性的弱点来进行分析，得到关键性的信息的方式。社会工程学也就是互联网安全体系中存在的威胁性漏洞。\n根据题目的信息，可以猜测flag数据可能是flag{zs19900315}或flag{19900315zs}\n经过测试发现，flag数据是flag{zs19900315}\n题目主要考察社会工程学的知识，签到题。\n变异凯撒 # 看题目应该是凯撒密码考察\n点开题目描述：\n题目描述\n题目描述一如既往的朴素，只告诉了提交的格式\n下载附件，并查看附件内容：\n附件内容\n密文中有很多编码的字符，字典集可能不是26字母表，可能是ascii编码表\n分析一下附件的加密逻辑：（这里我写了一个小脚本）\n分析\n分析发现移位是ascii码的移位方式，而且移位的数据是一个递增的数列，5作为初始数列，以1为差值的等差数列形式。明文的数值比密文的数值大一些。分析完毕。\n这里还是一个脚本解决问题：\ncipher = \u0026#34;afZ_r9VYfScOeO_UL^RWUc\u0026#34; plainer = \u0026#34;\u0026#34; num = 5 for i in cipher: plainer +=chr(ord(i)+num) num += 1 print plainer 执行脚本，得到flag数据：flag{Caesar_variation}\n故flag数据是flag{Caesar_variation}\n题目主要考察凯撒密码的原理，简单题。\nQuoted-printable # 题目暂时看不出什么样的信息，题目翻译下来就是字符集\n点开题目描述：\n题目描述\n题目描述还是一如既往的buu的风格，没有什么提示性的描述\n直接下载附件，并查看附件内容：\n附件内容\n看到内容，感觉是熟悉的味道：E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6\n这里写个小脚本试试16进制解码：\ncipher = \u0026#34;E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6\u0026#34; cipher_arr = cipher.split(\u0026#39;=\u0026#39;) plainer = \u0026#39;\u0026#39;.join(cipher_arr).decode(\u0026#39;hex\u0026#39;) print plainer 执行编写的脚本，得到数据：那你也很棒哦\n这个数据应该就是flag数据了，对数据进行一些修饰得到flag：flag{那你也很棒哦}\n故flag是flag{那你也很棒哦}\n本题主要考察hex编码，签到题。\nRabbit # 看到题目名字还是有些懵懵的，搜索一些发现题目应该是在说Rabbit流密码。\n什么是流密码？什么是Rabbit密码？\n在密码学中，流密码（英语：Stream cipher），又译为流加密、资料流加密，是一种对称加密算法，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中数据通常是一个位（bit）并用异或（xor）操作加密。\n该算法解决了对称加密完善保密性（perfect secrecy）的实际操作困难。“完善保密性”由克劳德·香农于1949年提出。由于完善保密性要求密钥长度不短于明文长度，故而实际操作存在困难，改由较短数据流通过特定算法得到密钥流。[4]\n流密码就是基于随机数的对称加密算法，Rabbit密码是流密码的一种：\nRabbit流密码（Rabbit Stream Cipher）简介\nRabbit流密码是由Cryptico公司（http://www.cryptico.com）设计的，密钥长度128位，\n最大加密消息长度为2 Bytes，即16 TB，若消息超过该长度，则需要更换密钥对剩下的消息进行处理。它是目前安全性较高，加/解密速度比较高效的流密码之一，在各种处理器平台上都有不凡的表现。[5]\nCryptico公司好像是已经搜索不到了，而且那个网站的域名也在进行拍卖，以目前的情况，我还找不到有关Rabbit密码的相关算法信息。但是，通过论文的查阅找到了，rabbit算法的内容：[6]\nRabbit密码的加密算法还是比较复杂的，不过通过搜索引擎找到了破解Rabbit密码的现成脚本\n点开题目描述：\n题目描述\n一如既往没有什么卵用的题目描述\n下载附件，查看附件内容：\n附件内容\n附件内容里面是一组密文：\nU2FsdGVkX1/+ydnDPowGbjjJXhZxm2MP2AgI 这里使用在线解密工具进行解密：https://www.sojson.com/encrypt_rabbit.html\n（本菜鸡不会写，嘤嘤嘤）\n解密页面\n得到了一个明文：Cute_Rabbit\n对得到的明文进行简单的修饰：flag{Cute_Rabbit}\n故flag是flag{Cute_Rabbit}\n本题主要考察Rabbit流密码加密，简单题\n篱笆墙的影子 # 看到题目，这题应该是考察栅栏密码。（篱笆墙也只能联想到栅栏密码了）\n栅栏密码的详细介绍，在上一篇XCTF CRYPTO的WP中有提到，具体内容可以访问上一篇：\nXCTF-CRYPTO-新手区 writeup\n点开题目描述\n题目描述\n题目描述就是在说，还是熟悉的味道，唔~。然而也没什么卵用\n下载附件，并查看附件内容：\n附件内容\n附件里面的文件中是一段熟悉密文：felhaagv{ewtehtehfilnakgw}\n由于不确定是W型还是传统型，直接使用之前写的两个脚本都跑一下：\n传统型栅栏密码\nfhetlehhafaiglvn{aekwgtwe} feiewlltnheaahkatggewvh}{f fvtae{eklehghwfwati}aelghn fgeiwevhl}l{tnheeaawhkatfg fawen}egthalvefkh{higaetlw fa{ehnweaehfa}lgwtikhvtelg fa{ehnweaehfa}lgwtikhvtelg fhgeeeiaweavwhhlk}la{ttfng fhgeeeiaweavwhhlk}la{ttfng fhgeeeiaweavwhhlk}la{ttfng fhgeeeiaweavwhhlk}la{ttfng flag{wethinkwehavetheflag} flag{wethinkwehavetheflag} flag{wethinkwehavetheflag} flag{wethinkwehavetheflag} flag{wethinkwehavetheflag} flag{wethinkwehavetheflag} flag{wethinkwehavetheflag} W型栅栏密码\nfhetlehhafaiglvn{aekwgtwe} fvn{eeawltkehhgtaewhaf}igl fatkegevhgf{leiwlwhtn}aeah fatfgieaeghlwntvl{ea}khehw fh{higlteaeawenwahtglvefk} fh{ehnwafheaeawtik}gletglv fla{ehnwafhegheavwtik}glet fla{ttfnwaieeegheavwhhlk}g fla{ttfng}waieeegheavwhhlk fla{ttflag}wknieeegheavwhh fla{theflag}wknihteegheavw flavetheflag}wknihtew{ghea fehavetheflag}wknihtew{gal felhavetheflag}wknihtew{ga felhaavetheflag}wknihtew{g felhaagvetheflag}wknihtew{ felhaagv{etheflag}wknihtew felhaagv{ewtheflag}wknihte 在跑出来的数据中寻找有关flag的相关信息，经查找发现flag数据是：flag{wethinkwehavetheflag}\n故本题的flag就是flag{wethinkwehavetheflag}\n题目主要考察栅栏密码，签到题。\n本题的解题脚本代码还是扔出来一下吧：\ndef decrype(cipher,key): cipher_len = len(cipher) if cipher_len%key == 0: key = cipher_len / key else: key = cipher_len / key + 1 result = {x:\u0026#39;\u0026#39; for x in range(key)} for i in range(cipher_len): a = i%key; result.update({a:result[a]+cipher[i]}) plainer=\u0026#34;\u0026#34; for i in range(key): plainer = plainer + result[i] print plainer cipher=\u0026#34;felhaagv{ewtehtehfilnakgw}\u0026#34; for n in range(2,20): decrype(cipher,n) RSA # 看题目应该是主要考察RSA非对称加密算法的问题，密码学核心考察的问题。\nRSA加密算法的详细介绍，在上一篇XCTF CRYPTO的WP中有提到，具体内容可以访问上一篇：\nXCTF-CRYPTO-新手区 writeup\n点开题目描述：\n题目描述\n没有太多有用的信息，一如既往\n下载附件，并查看附件：\n题目描述\n应该是比较简单的RSA题目，这里就是求解一下逆元。\n这里写一个脚本进行求解：（使用到了gmpy2库）\nimport gmpy2 p = 473398607161 q = 4511491 n = p*q e = 17 ni = 0 if(gmpy2.is_prime(n)): ni = n-1 else: ni = (p-1)*(q-1) d = gmpy2.invert(e,ni) print(d) 执行脚本，得到运算出的d：125631357777427553\n故flag是flag{125631357777427553}\n本题主要考察RSA加密算法的简单应用，简单题。\n丢失的MD5 # 这道题目，应该是和MD5相关\n点开题目描述：\n题目描述\n一如既往，没有什么东西\n下载附件，查看附件内容：\n附件内容\n发现是一个python文件，尝试执行一下这个python代码\n获得一段数据：e9032994dabac08080091151380478a2\n这段数据是不是flag呢？\n康一康源代码吧：\nimport hashlib for i in range(32,127): for j in range(32,127): for k in range(32,127): m=hashlib.md5() m.update(\u0026#39;TASC\u0026#39;+chr(i)+\u0026#39;O3RJMV\u0026#39;+chr(j)+\u0026#39;WDJKX\u0026#39;+chr(k)+\u0026#39;ZM\u0026#39;) des=m.hexdigest() if \u0026#39;e9032\u0026#39; in des and \u0026#39;da\u0026#39; in des and \u0026#39;911513\u0026#39; in des: print des 源代码中找不到有关flag的相关信息，（这题好难呀），那flag很可能就是python的运行结果\n尝试加工一下运行数据：flag{e9032994dabac08080091151380478a2}\n尝试提交一下flag，发现成功了（这题真简单）\n本题考察python2代码的相关知识，签到题。（谁能想到运行结果就是flag呢？）\nAlice与Bob # Alice和Bob是密码学中经常使用来进行密码描述的人物名称，所以这道题目可能是加密相关。不过，也推断不出更多的信息。\n点开题目描述：\n题目描述\n题目描述终于是有用了，看样子，这道题目也是一道签到题目。\n将题目描述进行提炼即可解密：\n98554799767,请分解为两个素数 分解后，小的放前面，大的放后面，合成一个新的数字 进行md5的32位小写哈希，提交答案 得到的 flag 请包上 flag{} 提交 根据步骤一步一步的来就好\n首先需要进行大数分解，这里使用sagemath进行大数分解：\n得到两个素数101999和966233\n然后进行数字组合，小的放前面，大的放后面，即101999966233\n然后进行md5加密，这里写一个简单的脚本进行MD5加密（对脚本的热爱）：\nimport hashlib plainer = \u0026#34;101999966233\u0026#34; m = hashlib.md5() m.update(plainer) cipher = m.hexdigest() print cipher 执行脚本，得到md5加密的结果：d450209323a847c8d01c6be47c81811a\n对MD5的加密结果进行修饰：flag{d450209323a847c8d01c6be47c81811a}\n故flag就是flag{d450209323a847c8d01c6be47c81811a}\n题目主要考察md5加密和大数分解，签到题\nrsarsa # 看题目应该也是考察RSA加密算法的题目\n点开题目描述：\n题目描述\n没有什么有用的信息，也只是告诉了提交flag的数据格式\n下载附件，查看附件内容：\n附件内容\n应该是RSA数学计算的题目类型\n提炼出附件内容中给到的重要数据：\np = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 这里使用一个脚本来解决问题：\nimport gmpy2 p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 n = p*q if(gmpy2.is_prime(n)): ni = n -1 else: ni = (p-1)*(q-1) d = gmpy2.invert(e,ni) m = pow(c,d,n) print(m) 运行一下脚本，得到数据：5577446633554466577768879988\n对得到的数据进行修饰：flag{5577446633554466577768879988}\n故flag就是flag{5577446633554466577768879988}\n本题主要考察RSA加密算法相关知识，简单题\n大帝的密码武器 # 看到题目，感觉有点意思，但是暂时联想不到有用的信息\n点开题目描述：\n一如既往，题目描述不能给到太多的信息，仅仅只给到了提交flag的数据格式\n下载附件：\n附件\n附件是个zip文件，无法打开，尝试修改文件扩展名为zip：\n打开zip文件：\n发现有两个文件，依次打开两个文件：\n附件内容\n一个题目tip信息，一个需要进行解密的密文\n题目tip如下：\n公元前一百年，在罗马出生了一位对世界影响巨大的人物，他生前是罗马三巨头之一。他率先使用了一种简单的加密函，因此这种加密方法以他的名字命名。 以下密文被解开后可以获得一个有意义的单词：FRPHEVGL 你可以用这个相同的加密向量加密附件中的密文，作为答案进行提交。 根据描述，罗马三巨头应该自然而然就联想到了凯撒加密。\n这里先使用一个脚本解决位移向量问题：\ndict_list = [] for i in range(26): dict_list.append(chr(ord(\u0026#39;a\u0026#39;)+i)) cipher = \u0026#34;FRPHEVGL\u0026#34;.lower() for n in range(26): plainer = \u0026#34;\u0026#34; for i in cipher: if i in dict_list: plainer += dict_list[(dict_list.index(i)-n)%26] else: plainer += i print(plainer+\u0026#34; index:\u0026#34;+str(n)) 执行脚本，得到数据：\nfrphevgl index:0 eqogdufk index:1 dpnfctej index:2 comebsdi index:3 bnldarch index:4 amkczqbg index:5 zljbypaf index:6 ykiaxoze index:7 xjhzwnyd index:8 wigyvmxc index:9 vhfxulwb index:10 ugewtkva index:11 tfdvsjuz index:12 security index:13 rdbtqhsx index:14 qcaspgrw index:15 pbzrofqv index:16 oayqnepu index:17 nzxpmdot index:18 mywolcns index:19 lxvnkbmr index:20 kwumjalq index:21 jvtlizkp index:22 iuskhyjo index:23 htrjgxin index:24 gsqifwhm index:25 发现位移13是一个有意义的单词：security index:13\n再写一个小脚本求解密文：\ncipher = \u0026#34;ComeChina\u0026#34;.lower() def caesar(n,cipher): dict_list = [] for i in range(26): dict_list.append(chr(ord(\u0026#39;a\u0026#39;)+i)) plainer = \u0026#34;\u0026#34; for i in cipher: if i in dict_list: plainer += dict_list[(dict_list.index(i)-n)%26] else: plainer += i return plainer print caesar(13,cipher) 执行脚本，获得数据：pbzrpuvan\n对得到的数据进行修饰：flag{pbzrpuvan}\n故flag就是flag{pbzrpuvan}\n本题主要考察Caesar加密的相关知识，简单题\nWindows系统密码 # Windows系统密码，根据本菜鸡的知识Windows密码也是使用hash的方式进行加密的，所以本题应该也是在考察hash密码的破解。\n点开题目描述：\n题目描述\n一如既往，没有什么有用的信息\n下载附件，查看附件内容：\n附件内容\n附件给出了4对哈希值：\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: ctf:1002:06af9108f2e1fecf144e2e8adef09efd:a7fcb22a88038f35a8f39d503e7f0062::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:bef14eee40dffbc345eeb3f58e290d56::: 这里解密去cmd5网站进行解密，经过反复尝试发现只有\na7fcb22a88038f35a8f39d503e7f0062可以解密出hash数值：\nhash解密结果就是：good-luck\n对hash解密结果进行修饰：flag{good-luck}\n故flag就是flag{good-luck}\n本题主要考察Windows系统的数据加密方式，简单题\n参考 # MD5-维基百科 百分号编码-维基百科 社会工程学-维基百科 流密码-维基百科 Rabbit流密码 [张振广,胡予濮,王璐.流密码Rabbit的安全性分析J].计算机科学,2011,38(02):100-102. BUUCTF前面的题目偏向简单题目和签到题目，大多数都在考察古典密码，对称密码的相关知识。\n本期wp分享到此为止，有时间再来喝杯茶呀！\n","date":"June 26, 2021","permalink":"/posts/buuctf-crypto-1_writeup/","section":"Posts","summary":"日常刷题喝茶的平时生活，整理一下题目的思路，捋一捋密码学。\nBUUCTF是国内另一个比较不错的CTF的刷题平台，是由北京联合大学创建并维护的CTF大型同性交流沟通的平台，页面制作还是蛮美观滴！\nBUUCTF页面\nBUUCTF的整体难度是由简单变难的一个过程，前面的题目通常都是比较简单的题目，来看看这次日常的题目：\n题目\n这次是16道题目：\nMD5 Url编码 一眼就解密 看我回旋踢 摩丝 password 变异凯撒 Quoted-printable Rabbit 篱笆墙的影子 RSA 丢失的MD5 Alice与Bob rsarsa 大帝的密码武器 Windows系统密码 MD5 # 看题目应该是考察MD5加密的暴力破解\n什么是MD5加密？\nMD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 中被加以规范。\n将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。\n1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的资料，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞攻击（英语：Collision_attack），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。[1]\n看看题目描述：\n题目描述\n下载附件，查看附件内容：\n附件内容\n附件中给出一段加密数据：e00cf25ad42683b3df678c61f42c6bda\n根据题目，应该是MD5加密，去解密网站\n进行解密。\ncmd5\n题目描述中，要求以flag{}形式进行提交，故flag就是flag{admin1}\n这道题目考察md5加密的相关知识，签到题。\nUrl编码 # 看题目应该是考察Url编码的解码\n什么是Url编码？\n百分号编码（英语：Percent-encoding），又称：URL编码（URL encoding）是特定上下文的统一资源定位符 （URL）的编码机制，实际上也适用于统一资源标志符（URI）的编码。也用于为 application/x-www-form-urlencoded MIME准备数据，因为它用于通过HTTP的请求操作（request）提交HTML表单数据。[2]\n看看题目描述：\n题目描述\n下载附件，查看附件内容：\n附件内容\n一段编码的字段：%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d\n使用url解码工具解码，也可以使用python进行解码。我个人习惯使用python脚本进行url编码解码：\nimport urllib.parse cipher = \u0026#39;%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d\u0026#39; print(urllib.parse.unquote(cipher)) 运行脚本就可以出结果：\n解码后也就是flag数据：flag{and 1=1}","title":"BUUCTF CRYPTO (1) writeup"},{"content":"这次又是XCTF平台，没错，我又来无聊谈谈解题了\n首先先来一张XCTF的首页图片，来开启本次的writeup文章：\nxctf首页\n这次我们要搞哪些题目的思路呢？这次还是新手区，不过是不一样的新手局，这回盘一盘密码学。\ncrypto新手区题目\n题目数量不变，依然是12道题目：\nbase64 Caesar Morse 幂数加密 Railfence 不仅仅是Morse 混合编码 easy_RSA easychallenge 转轮机加密 Normal_RSA esay_ECC 在开始进行密码学的题目问题思路分析的开始之前，首先进行一部分知识的了解。\n密码学的CTF题目通常都是以附件形式来进行考察的。不像网页需要进入到平台设定的docker靶机中\nCTF中密码学题目目前的趋势是越来越难，而且分值越来越高。密码学的题目往往分为编码题目和密码学题目，而密码学题目又会分为古典密码学题目和现代密码学题目。\n密码学早在公元前400多年就已经产生，人类使用密码的历史几乎与使用文字的时间一样长，密码学的发展大致可以分为 3 个阶段: 1949 年之前的古典密码学阶段; 1949 年至 1975 年密码学成为科学的分支; 1976 年以后对称密钥密码算法得到进一步发展，产生了密码学的新方向—公钥密码学。1976 年，W.Diffie 和 M.Hellman 在发表的文章“密码学的新方向”中首次公开提出了公钥密码( Public-key Cryptography) 的概念。公钥密码的提出实现了加密密钥和解密密钥之间的独立，解决了对称密码体制中通信双方必须共享密钥的问题，在密码学界具有划时代的意义。[1]\nCTF中的编码题目往往会考察一些常用的编码类型，当然也会出现一些比较偏的编码方式进行编码。\n常用的编码方式有：ASCii编码，Base64编码，Bin编码，Hex编码，URL编码以及HTML编码。\nCTF中的古典密码学题目可以通过查找相关的密码学算法来了解与密码学相关内容的更多信息，通过网络方式进行解决，或者获取一些灵感。古典密码学经常会考察最基础的凯撒密码，栅栏密码，或者替换密码。这些古典密码学的处理思路和方式都比较相似，而且网络已经有很多处理这些密码的算法工具来进行加密和解密。\nCTF中的现代密码学题目主要会考察RSA加密算法，ECC加密算法等经典的现代密码学算法。也会有一些新的加密算法题目，这种题目往往需要进行算法分析，通过加密算法的语法逻辑来设计解密算法通过逆元的思维求出明文。\n关于密码学的更多内容，可以访问：http://eol.sicau.edu.cn:8080/ 来了解更多密码学相关的内容。\n下面就开始本回的题目！\nbase64 # 看到这道题目，猜想这道题目可能是考察base64编码方式的密码学题目\n进入道题目页面，看看是否可以得到一点tip：\nbase64题目\n没有什么特别的tip，只是给题目一个情景化的描述，没有太多有用信息的描述。\n直接下载附件内容，并打开附件文件进行查看：\n附件文件\n文件内容有一段字符型文字：Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9\n根据题目的内容，尝试使用一下base64进行解码，可以使用在线的解码工具，也可以使用python脚本进行解码。这里编写简单的python脚本进行解码：\n# python3 脚本 import base64 cipher=\u0026#39;Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9\u0026#39; plainer= base64.b64decode(cipher) print(str(plainer,\u0026#39;utf-8\u0026#39;)) # python2 脚本 import base64 cipher=\u0026#39;Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9\u0026#39; plainer= base64.b64decode(cipher) print(plainer) 然后运行python脚本进行解码：\npython base64_decode.py # 这里创建的python2脚本文件名是base64_decode.py python3 base64_decode3.py # 这里创建的python3脚本文件名是base64_decode3.py 执行命令后查看执行结果\n成功拿到flag数据，这道题目是道签到题。\n这道题目主要考察base64编码知识，没有什么难度，就是一道签到题目。\nCaesar # 看到题目，自然就联系到Caesar cipher，翻译成中文就是凯撒密码。\n所有解决这道题目的关键就是凯撒密码的密码逻辑了\n凯撒密码（英语：Caesar cipher），或称凯撒加密、凯撒变换、变换加密，是一种最简单且最广为人知的加密技术。凯撒密码是一种替换加密技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期凯撒的名字命名的，据称当年凯撒曾用此方法与其将军们进行联系。[2]\n点开题目的页面，看看是否有些有用的信息\nCaesar题目\n从题目描述中依旧获取不到更多的信息，没有太多有用的信息可以帮助解题\n直接下载附件并进行查看：\n附件内容\n附件内容中，只有一段加密文字：oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}\n根据题目这应该是凯撒加密算法，可以使用在线的工具进行解密，也可以使用python脚本进行解决，这里使用python脚本进行解密：\n# python2脚本 dict_list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;] cipher = \u0026#34;oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}\u0026#34; for j in range(26): plainer = \u0026#34;\u0026#34; for i in cipher: if i in dict_list: plainer += dict_list[(dict_list.index(i)-j)%26] else: plainer += i print plainer # pyhton3脚本 dict_list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;] cipher = \u0026#34;oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}\u0026#34; for j in range(26): plainer = \u0026#34;\u0026#34; for i in cipher: if i in dict_list: plainer += dict_list[(dict_list.index(i)-j)%26] else: plainer += i print(plainer) 这道题目的python2和python3脚本差别不大，虽然密码学的大多数题目还是推荐使用python2进行编写，但是对于使用sagemath的密码学题目，python3还是比较适合。下面运行python脚本：\n# python2 python Caesar_decode.py # python3 python3 Caesar_decode3.py 查看终端显示的运行结果：\n运行结果\n从运行结果发现：cyberpeace{you_have_learned_caesar_encryption} 应该是有明显含义的解密的文段，很可能是这道题目的flag。尝试进行提交，发现这段数据就是flag数据。\n这道题目解决，题目没有什么难度，算是签到题。\n题目主要考察凯撒密码的相关知识，非常直接的解密方法，没有什么难度。\nMorse # 看到题目Morse，自然而然便联想到了摩尔斯电码。这道题目有可能是在考察摩尔斯电码。\n点开题目页面，看看题目描述中会有什么有用的信息：\nMorse题目\n题目描述依然是大片无用的信息，但是最后提示了提交flag的格式和内容要求。\n直接打开附件并进行查看需要进行解密的内容：\n附件内容\n文件内容非常像bin方式的加密，但是考虑到题目Morse，应该是Morse电码方式的加密\n首先，需要了解什么摩尔斯电码：\n摩尔斯电码（英语：Morse code）是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。是由美国人艾尔菲德·维尔与萨缪尔·摩尔斯在1836年发明。[3]\n摩尔斯电码是一种早期的数字化通信形式，但是它不同于现代只使用0和1两种状态的二进制代码，它的代码包括五种：\n点（·）：1 划（-）：111 字符内部的停顿（在点和划之间）：0 字符之间的停顿：000 单词之间的停顿：0000000 根据摩尔斯电码的知识点，这道题目可以使用在线工具进行解密，也可以使用python脚本进行解密。这里使用python脚本进行解密：\n这里的密文文段和摩尔斯代码的文段不太一致，需要进行一下代换。这里使用 1 代表 - ，0 代表 ·\n来进行摩尔斯电码的解密算法的设计和编写。\n# python2脚本 dict_list = { \u0026#39;01\u0026#39;:\u0026#39;a\u0026#39;, \u0026#39;1000\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;1010\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;100\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;0\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;0010\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;110\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;0000\u0026#39;:\u0026#39;h\u0026#39;, \u0026#39;00\u0026#39;:\u0026#39;i\u0026#39;, \u0026#39;0111\u0026#39;:\u0026#39;j\u0026#39;, \u0026#39;101\u0026#39;:\u0026#39;k\u0026#39;, \u0026#39;0100\u0026#39;:\u0026#39;l\u0026#39;, \u0026#39;11\u0026#39;:\u0026#39;m\u0026#39;, \u0026#39;10\u0026#39;:\u0026#39;n\u0026#39;, \u0026#39;111\u0026#39;:\u0026#39;o\u0026#39;, \u0026#39;0110\u0026#39;:\u0026#39;p\u0026#39;, \u0026#39;1101\u0026#39;:\u0026#39;q\u0026#39;, \u0026#39;010\u0026#39;:\u0026#39;r\u0026#39;, \u0026#39;000\u0026#39;:\u0026#39;s\u0026#39;, \u0026#39;1\u0026#39;:\u0026#39;t\u0026#39;, \u0026#39;001\u0026#39;:\u0026#39;u\u0026#39;, \u0026#39;0001\u0026#39;:\u0026#39;v\u0026#39;, \u0026#39;011\u0026#39;:\u0026#39;w\u0026#39;, \u0026#39;1001\u0026#39;:\u0026#39;x\u0026#39;, \u0026#39;1011\u0026#39;:\u0026#39;y\u0026#39;, \u0026#39;1100\u0026#39;:\u0026#39;z\u0026#39; } cipher=\u0026#34;11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110\u0026#34; plainer=\u0026#34;\u0026#34; cipher_arr = cipher.split(\u0026#34; \u0026#34;) for i in cipher_arr: plainer += dict_list[i] print plainer # python3脚本 dict_list = { \u0026#39;01\u0026#39;:\u0026#39;a\u0026#39;, \u0026#39;1000\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;1010\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;100\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;0\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;0010\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;110\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;0000\u0026#39;:\u0026#39;h\u0026#39;, \u0026#39;00\u0026#39;:\u0026#39;i\u0026#39;, \u0026#39;0111\u0026#39;:\u0026#39;j\u0026#39;, \u0026#39;101\u0026#39;:\u0026#39;k\u0026#39;, \u0026#39;0100\u0026#39;:\u0026#39;l\u0026#39;, \u0026#39;11\u0026#39;:\u0026#39;m\u0026#39;, \u0026#39;10\u0026#39;:\u0026#39;n\u0026#39;, \u0026#39;111\u0026#39;:\u0026#39;o\u0026#39;, \u0026#39;0110\u0026#39;:\u0026#39;p\u0026#39;, \u0026#39;1101\u0026#39;:\u0026#39;q\u0026#39;, \u0026#39;010\u0026#39;:\u0026#39;r\u0026#39;, \u0026#39;000\u0026#39;:\u0026#39;s\u0026#39;, \u0026#39;1\u0026#39;:\u0026#39;t\u0026#39;, \u0026#39;001\u0026#39;:\u0026#39;u\u0026#39;, \u0026#39;0001\u0026#39;:\u0026#39;v\u0026#39;, \u0026#39;011\u0026#39;:\u0026#39;w\u0026#39;, \u0026#39;1001\u0026#39;:\u0026#39;x\u0026#39;, \u0026#39;1011\u0026#39;:\u0026#39;y\u0026#39;, \u0026#39;1100\u0026#39;:\u0026#39;z\u0026#39; } cipher=\u0026#34;11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110\u0026#34; plainer=\u0026#34;\u0026#34; cipher_arr = cipher.split(\u0026#34; \u0026#34;) for i in cipher_arr: plainer += dict_list[i] print(plainer) 这道题目的python2和python3的求解脚本差别也不是非常大，执行脚本后直接查看执行结果：\n执行结果\n发现执行结果是一句有意义的句子，应该就是flag数据了。然后再利用题目描述所说的信息对执行出来的flag数据进行个加帽处理：cyberpeace{morsecodeissointeresting}\n题目解决，题目也是签到题，没有什么难度。\n题目主要考察了摩尔斯电码的解密方法，以及摩尔斯电码相关知识，签到题。\n幂数加密 # 看到题目的时候有些懵逼，本菜鸡不太了解什么的是幂数加密，于是只能求助一下搜索引擎。\n二进制幂数加密-百度百科\n好像是一个加密方法，这种加密方法大致逻辑是：\n将明文对应字母序列 对字母序列进行处理加密 使用间隔符进行间隔 获得密文 现在知道这种加密方法，点开题目的描述看看是否可以获取到更多的信息\n幂数加密题目\n题目描述中仅仅告诉了需要提交的flag格式，和flag数据类型。题目描述的其他信息都是无用的信息。\n将附件下载下来并查看附件中的密文信息内容：\n附件资料\n发现密文数据不太对劲呀，二进制幂数加密的数据都是01234的形式，这个密文的形式是01248的形式\n于是作为菜鸡的我只能去再次求助于搜索引擎了，查到了云影密码：\n01248云影密码 # 原理：有1，2，4，8这四个数字，可以通过加法来用这四个数字表示0-9中的任何一个数字，列如0=28， 也就是0=2+8，同理7=124， 9=18。这样之后再用1-26来表示26个英文字母，就有了密文与明文之间的对应关系。引入0来作为间隔，以免出现混乱。所以云影密码又叫“01248密码”。[4]\n看来密文是云影密码没错了，由于云影密码是比较少见的密码，而是加密逻辑比较简单，网络上几乎没有什么可用的在线工具。这道题目可以使用手工解密，也可以使用python脚本进行解密。这里使用python脚本进行解密：\n# python2 dict_list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;] cipher=\u0026#34;8842101220480224404014224202480122\u0026#34; cipher_array = cipher.split(\u0026#34;0\u0026#34;) cipher_arr = [] flag = \u0026#34;\u0026#34; for i in cipher_array: k = 0 for j in range(len(i)): k += int(i[j]) cipher_arr.append(k) for m in cipher_arr: flag += dict_list[m-1] print flag # python3 dict_list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;] cipher=\u0026#34;8842101220480224404014224202480122\u0026#34; cipher_array = cipher.split(\u0026#34;0\u0026#34;) cipher_arr = [] flag = \u0026#34;\u0026#34; for i in cipher_array: k = 0 for j in range(len(i)): k += int(i[j]) cipher_arr.append(k) for m in cipher_arr: flag += dict_list[m-1] print(flag) 执行python脚本并查看终端输出的结果：\n获取到明文，然后对明文加个flag数据形式的帽子并进行字母大写：cyberpeace{WELLDONE}\n这道题目解决，题目属于签到题，没有什么难度\n这道题目主要考察幂数加密的知识，（云影密码的设计逻辑其实和幂数加密相似，只是在设计过程进行了修改。）题目难度比较低·，签到题。\nRailfence # 看到题目大致知道考察的是什么密码的加密算法了，题目是栅栏，应该就是栅栏密码的密码知识考察\n什么是栅栏密码呢？\n所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话）。加密原理：\n把将要传递的信息中的字母交替排成上下两行。 再将下面一行字母排在上面一行的后边，从而形成一段密码。[5] 栅栏密码大致就是一种分组密码的一种密码算法，便于更好理解栅栏密码，这里有一个例子：\n明文：THE LONGEST DAY MUST HAVE AN END5\n加密：\n把将要传递的信息中的字母交替排成上下两行。 T E O G S D Y U T A E N N H L N E T A M S H V A E D 密文：将下面一行字母排在上面一行的后边。 TEOGSDYUTAENN HLNETAMSHVAED 解密：\n先将密文分为两行\nT E O G S D Y U T A E N N\nH L N E T A M S H V A E D\n再按上下上下的顺序组合成一句话明文：\nTHE LONGEST DAY MUST HAVE AN EN\n现在知识也大致了解了，点开题目揭开这道题目的真实面目吧！\nRailfence题目\n题目描述中也暗示了是栅栏密码的信息\n于是直接下载附件，看看附件中的描述内容密文究竟是啥样：\n附件内容\n密文形式看样子像是解密出来直接就是flag数据。\n这道题目可以使用在线工具进行解密，也可以使用python脚本进行解密。这里还是一如既往，使用python脚本进行解密：（这道题目比较狗，是W型的栅栏密码解密）\n栅栏密码有两种类型：一种是传统型栅栏密码，一种是W型栅栏密码，W型栅栏密码比较复杂。\n传统型栅栏密码脚本：\ndef decrype(cipher,key): cipher_len = len(cipher) if cipher_len%key == 0: key = cipher_len / key else: key = cipher_len / key + 1 result = {x:\u0026#39;\u0026#39; for x in range(key)} for i in range(cipher_len): a = i%key; result.update({a:result[a]+cipher[i]}) plainer=\u0026#34;\u0026#34; for i in range(key): plainer = plainer + result[i] print plainer cipher=\u0026#34;TEOGSDYUTAENNHLNETAMSHVAED\u0026#34; for n in range(2,10): decrype(cipher,n) W型栅栏密码脚本：\ndef fence(lst, numrails): fence = [[None] * len(lst) for n in range(numrails)] rails =list(range(numrails - 1))+ list(range(numrails - 1, 0, -1)) for n, x in enumerate(lst): fence[rails[n % len(rails)]][n] = x return [c for rail in fence for c in rail if c is not None] def encode(text, n): return \u0026#39;\u0026#39;.join(fence(text, n)) def decode(text, n): rng = range(len(text)) pos = fence(rng, n) return \u0026#39;\u0026#39;.join(text[pos.index(n)] for n in rng) z = \u0026#34;ccehgyaefnpeoobe{lcirg}epriec_ora_g\u0026#34; for i in range(2,10): y = decode(z,i) print(y) 这道题目是W型的栅栏密码，这里使用W型栅栏密码的脚本进行破解：\n成功跑出flag数据：cyberpeace{railfence_cipher_gogogo}\n题目解决，这道题目属于简单题目\n题目主要考察对栅栏密码的知识全面性考察，如果知识不全面可能会有一点绕，不容易解出。难度算是简单题目。\n不仅仅是Morse # 看题目应该知道这道题目不是非常简单的样子，应该是一个复合加密的题目，就是涉及多种加密算法的加密。\n点开题目页面，希望可以获取到更多关于题目的tip：\n题目页面\n题目描述中有两个重要的tip信息：flag的数据格式和flag是一种食物的单词。对于解题有主要作用的是flag数据是一种食物的单词。\n下面打开附件，进行解密：\n附件内容\n看来是一个摩尔斯电码的加密：\n--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.- 首先先编写一个摩尔斯电码的解密脚本：（当然也可以使用在线的摩尔斯电码解密工具进行解密）\n# python2 dict_list = { \u0026#39;.-\u0026#39;:\u0026#39;a\u0026#39;, \u0026#39;-...\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;-.-.\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;-..\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;.\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;..-.\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;--.\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;....\u0026#39;:\u0026#39;h\u0026#39;, \u0026#39;..\u0026#39;:\u0026#39;i\u0026#39;, \u0026#39;.---\u0026#39;:\u0026#39;j\u0026#39;, \u0026#39;-.-\u0026#39;:\u0026#39;k\u0026#39;, \u0026#39;.-..\u0026#39;:\u0026#39;l\u0026#39;, \u0026#39;--\u0026#39;:\u0026#39;m\u0026#39;, \u0026#39;-.\u0026#39;:\u0026#39;n\u0026#39;, \u0026#39;---\u0026#39;:\u0026#39;o\u0026#39;, \u0026#39;.--.\u0026#39;:\u0026#39;p\u0026#39;, \u0026#39;--.-\u0026#39;:\u0026#39;q\u0026#39;, \u0026#39;.-.\u0026#39;:\u0026#39;r\u0026#39;, \u0026#39;...\u0026#39;:\u0026#39;s\u0026#39;, \u0026#39;-\u0026#39;:\u0026#39;t\u0026#39;, \u0026#39;..-\u0026#39;:\u0026#39;u\u0026#39;, \u0026#39;...-\u0026#39;:\u0026#39;v\u0026#39;, \u0026#39;.--\u0026#39;:\u0026#39;w\u0026#39;, \u0026#39;-..-\u0026#39;:\u0026#39;x\u0026#39;, \u0026#39;-.--\u0026#39;:\u0026#39;y\u0026#39;, \u0026#39;--..\u0026#39;:\u0026#39;z\u0026#39;, \u0026#39;..--.-\u0026#39;:\u0026#39;_\u0026#39; } cipher = \u0026#34;--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.-\u0026#34; plainer = \u0026#34;\u0026#34; cipher_arr = cipher.split(\u0026#39;/\u0026#39;) for i in cipher_arr: plainer += dict_list[i] print plainer 执行编写好的python脚本，并查看终端的返回结果：\n获得一段解密后的文段：\nmay_be_have_another_decodehhhhaaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba 仔细看看文段，好像出题人想要我们去解密后面那段ab组成的密文\n那段密文形式没有见过，于是本菜鸡又去求助搜索引擎了。搜索发现是培根密码，正好于tip相对应了。那什么是培根密码呢？\n培根密码，又名倍康尼密码（英语：Bacon\u0026rsquo;s cipher）是由法兰西斯·培根发明的一种隐写术。\n加密时，明文中的每个字母都会转换成一组五个英文字母。其转换依靠下表：\na AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 这只是一款最常用的加密表，有另外一款将每种字母配以不同的字母组予以转换，即I与J、U与V皆有不同编号。\n加密者需使用两种不同字体，分别代表A和B。准备好一篇包含相同AB字数的假信息后，按照密文格式化假信息，即依密文中每个字母是A还是B分别套用两种字体。\n解密时，将上述方法倒转。所有字体一转回A，字体二转回B，以后再按上表拼回字母。\n法兰西斯·培根另外准备了一种方法，其将大小写分别看作A与B，可用于无法使用不同字体的场合（例如只能处理纯文本时）。但这样比起字体不同更容易被看出来，而且和语言对大小写的要求也不太兼容。\n培根密码本质上是将二进制信息通过样式的区别，加在了正常书写之上。培根密码所包含的信息可以和用于承载其的文章完全无关。[6]\n将摩尔斯电码解密出来的文段的后半部分取出作为密文，即：\naaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba 可以使用网上的培根密码工具进行解密也可以使用python脚本进行解密，这里使用python脚本进行解密：\n# python2 dict_list={ \u0026#39;aaaaa\u0026#39;:\u0026#39;a\u0026#39;, \u0026#39;aaaab\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;aaaba\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;aaabb\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;aabaa\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;aabab\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;aabba\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;aabbb\u0026#39;:\u0026#39;h\u0026#39;, \u0026#39;abaaa\u0026#39;:\u0026#39;i\u0026#39;, \u0026#39;abaab\u0026#39;:\u0026#39;j\u0026#39;, \u0026#39;ababa\u0026#39;:\u0026#39;k\u0026#39;, \u0026#39;ababb\u0026#39;:\u0026#39;l\u0026#39;, \u0026#39;abbaa\u0026#39;:\u0026#39;m\u0026#39;, \u0026#39;abbab\u0026#39;:\u0026#39;n\u0026#39;, \u0026#39;abbba\u0026#39;:\u0026#39;o\u0026#39;, \u0026#39;abbbb\u0026#39;:\u0026#39;p\u0026#39;, \u0026#39;baaaa\u0026#39;:\u0026#39;q\u0026#39;, \u0026#39;baaab\u0026#39;:\u0026#39;r\u0026#39;, \u0026#39;baaba\u0026#39;:\u0026#39;s\u0026#39;, \u0026#39;baabb\u0026#39;:\u0026#39;t\u0026#39;, \u0026#39;babaa\u0026#39;:\u0026#39;u\u0026#39;, \u0026#39;babab\u0026#39;:\u0026#39;v\u0026#39;, \u0026#39;babba\u0026#39;:\u0026#39;w\u0026#39;, \u0026#39;babbb\u0026#39;:\u0026#39;x\u0026#39;, \u0026#39;bbaaa\u0026#39;:\u0026#39;y\u0026#39;, \u0026#39;bbaab\u0026#39;:\u0026#39;z\u0026#39; } cipher = \u0026#34;aaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba\u0026#34; plainer = \u0026#34;\u0026#34; cipher_arr = [] [cipher_arr.append(cipher[i:i+5]) for i in range(0,len(cipher),5)] for i in cipher_arr: plainer =plainer+dict_list[i] print plainer 执行python脚本，并查看终端返回的结果：\n看来输出的结果应该就是未成熟的flag数据：attackanddefenceworldisinteresting\n对这个数据进行加帽处理：cyberpeace{attackanddefenceworldisinteresting}\nflag数据成功拿到\n这道题目主要考察古典密码学的替换加密算法知识，难度上应该算是简单题，思路也是比较流畅的。\n混合编码 # 看到题目，这道题应该是考察编码相关的知识的内容\n点开题目页面，看看能得到什么关键信息：\n混合编码题目\n题目描述中就有一个关键信息，就是题目的要求提交的flag数据格式信息，没有其他关键性的信息了\n下载附件并打开查看密文：\n附件内容\n附件中的密文内容看样子像是base64编码格式的：\nJiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow== 使用在base64关卡中的python脚本进行base64解密（当然也可以使用在线工具进行base64解密）\n接出来的数据好像又是一种编码格式：\n\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#79;\u0026amp;#83;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#69;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#65;\u0026amp;#52;\u0026amp;#76;\u0026amp;#122;\u0026amp;#107;\u0026amp;#53;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#77;\u0026amp;#83;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#107;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#65;\u0026amp;#120;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#78;\u0026amp;#105;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#118;\u0026amp;#79;\u0026amp;#84;\u0026amp;#99;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#50;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#78;\u0026amp;#105;\u0026amp;#56;\u0026amp;#53;\u0026amp;#78;\u0026amp;#121;\u0026amp;#56;\u0026amp;#53;\u0026amp;#79;\u0026amp;#83;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#99;\u0026amp;#118;\u0026amp;#79;\u0026amp;#84;\u0026amp;#99;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#119;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#119;\u0026amp;#77;\u0026amp;#67;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#65;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#65;\u0026amp;#120;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#119;\u0026amp;#77;\u0026amp;#105;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#69;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#119;\u0026amp;#76;\u0026amp;#122;\u0026amp;#107;\u0026amp;#53;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#119;\u0026amp;#77;\u0026amp;#83;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#84;\u0026amp;#107;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#120;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#78;\u0026amp;#67;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#103;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#65;\u0026amp;#119; 看样子应该是ascii编码格式，可以使用在线的ascii编码工具进行解密，也可使用python脚本进行解密，一如既往，这里使用python脚本进行解密：\n# python2 cipher=\u0026#34;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#79;\u0026amp;#83;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#69;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#65;\u0026amp;#52;\u0026amp;#76;\u0026amp;#122;\u0026amp;#107;\u0026amp;#53;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#77;\u0026amp;#83;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#107;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#65;\u0026amp;#120;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#78;\u0026amp;#105;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#118;\u0026amp;#79;\u0026amp;#84;\u0026amp;#99;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#50;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#78;\u0026amp;#105;\u0026amp;#56;\u0026amp;#53;\u0026amp;#78;\u0026amp;#121;\u0026amp;#56;\u0026amp;#53;\u0026amp;#79;\u0026amp;#83;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#99;\u0026amp;#118;\u0026amp;#79;\u0026amp;#84;\u0026amp;#99;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#119;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#119;\u0026amp;#77;\u0026amp;#67;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#65;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#65;\u0026amp;#120;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#119;\u0026amp;#77;\u0026amp;#105;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#69;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#119;\u0026amp;#76;\u0026amp;#122;\u0026amp;#107;\u0026amp;#53;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#119;\u0026amp;#77;\u0026amp;#83;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#84;\u0026amp;#107;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#69;\u0026amp;#120;\u0026amp;#76;\u0026amp;#122;\u0026amp;#69;\u0026amp;#120;\u0026amp;#78;\u0026amp;#67;\u0026amp;#56;\u0026amp;#120;\u0026amp;#77;\u0026amp;#68;\u0026amp;#103;\u0026amp;#118;\u0026amp;#77;\u0026amp;#84;\u0026amp;#65;\u0026amp;#119;\u0026#34; plainer=\u0026#34;\u0026#34; cipher_arr = cipher[2:-1].split(\u0026#39;;\u0026amp;#\u0026#39;) for i in cipher_arr: plainer += chr(int(i)) print plainer 执行编写好的python代码并查看终端输出情况：\n输出的解密信息像是base64格式的编码：\nLzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw 可以再使用一次base64解码的python脚本进行base64解码（也可以使用在线base64工具进行解码）：\n解码后又是一段ascii的编码格式，这里还是编写一个ascii解码的python脚本：\n# python2 cipher = \u0026#34;/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100\u0026#34; plainer = \u0026#34;\u0026#34; cipher_arr = cipher[1:].split(\u0026#39;/\u0026#39;) for i in cipher_arr: plainer += chr(int(i)) print plainer 执行编写好的python代码并查看终端输出的结果：\n解码出来的数据应该就是flag数据：welcometoattackanddefenceworld\n根据题目要求，需要对这个flag数据进行加帽处理：cyberpeace{welcometoattackanddefenceworld}\n题目解决，题目属于简单题目，思路就是反复套娃操作：base64-\u0026gt;ASCII-\u0026gt;base64-\u0026gt;ASCII\n题目主要考察对编码数据的识别和基本编码方式的解决，简单题。\neasy_RSA # 看题目，这应该是考察到ctf中密码学的核心模块，也就是现代密码学的部分，RSA加密算法。\n什么是RSA加密算法？\nRSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。\n对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式破解。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被破解的。[7]\nRSA是现在密码学的一个典型代表，加密过程不像古典密码学中的密码那么简单，加密过程是非常复杂的。RSA加密算法的安全性也是相当高的。\nRSA算法 # 密钥生成的步骤 [8]\n我们通过一个例子，来理解RSA算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？\n第一步，随机选择两个不相等的质数p和q。\n爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）\n第二步，计算p和q的乘积n。\n爱丽丝就把61和53相乘。\n$$ n = 61×53 = 3233 $$\nn的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。\n第三步，计算n的欧拉函数φ(n)。\nn是质数，则 φ(n)=n-1 $$ n = p_1 × p_2 $$\n$$ φ(n) = φ(p_1 \\cdot p_2) = φ(p_1)\\cdot φ(p_1) $$\n$$ =\u0026gt; φ(n) = (p-1)(q-1) $$\n爱丽丝算出φ(3233)等于60×52，即3120。\n第四步，随机选择一个整数e，条件是1\u0026lt; e \u0026lt; φ(n)，且e与φ(n) 互质。\n爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）\n第五步，计算e对于φ(n)的模反元素d。\n所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。\n$$ ed ≡ 1 (mod φ(n)) $$\n这个式子等价于\n$$ ed - 1 = kφ(n) $$\n于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。(-k = y)\n$$ ex + φ(n)y = 1 $$\n已知 e=17, φ(n)=3120，\n$$ 17x + 3120y = 1 $$\n这个方程可以用“扩展欧几里得算法”(又叫辗转相除法)求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。\n至此所有计算完成。\n第六步，将n和e封装成公钥，n和d封装成私钥。\n在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。\n实际应用中，公钥和私钥的数据都采用ASN.1格式表达。\n这些RSA加密算法的流程和重要的几个参数是解决RSA算法密码学题目的核心，只有清晰地了解RSA加密算法的每个细节，面对RSA题目才能胸有成竹、游刃有余。\n点开题目，看看题目描述能给出哪些提示吧：\neasy_RSA\n题目中只有提交格式的提示，除此之外，都是描述性的信息，但是对解题没有太多作用。\n下载附件，直接查看附件中的信息：\n附件内容\n这道题目应该是简单的计算，即根据RSA设计的算法过程进行逆向计算。这道题目可以使用rsatool工具进行直接求解，本菜鸡还是编写一个python脚本进行求解吧：（此脚本只能针对简单问题）\n# python2 p=473398607161 q=4511491e=17 pn=(p-1)*(q-1) flag=(pn+1)/e print flag 执行编写的脚本，查看终端输出的结果：\n这段输出的数据应该就是flag数据：125631357777427553\n给这段flag数据加个帽子：cyberpeace{125631357777427553}\n这道题目是RSA题目中的签到题，难度非常低，思路也非常简单\n题目主要考察RSA加密算法的过程，签到题。\neasychallenge # 这道题的题目似乎看不出什么门路来，于是只能点开题目描述的页面：\neasychallenge题目\n这道题目应该是在说程序方面的问题，题目描述也得到不了太多有用的信息，于是下载附件来获取到这道题目的真实面目：\n发现附件是一个python的一个可以执行的文件，查看文件的属性：\n发现是一个pyc文件，本菜鸡不知道什么是pyc文件，于是通过互联网的搜索引擎求助一波：\npyc是一种二进制文件，是由Python文件经过编译后所生成的文件，它是一种byte code，Python文件变成pyc文件后，加载的速度有所提高，而且pyc还是一种跨平台的字节码，由python的虚拟机来执行的，就类似于JAVA或者.NET的虚拟机的概念。pyc的内容与python的版本是相关的，不同版本编译后的pyc文件是不同的，例如2.5版本编译的是pyc文件，而2.4版本编译的python是无法执行的。[9]\npyc文件是py文件经过编译的文件格式，文件内容是一种可执行字节码，尝试执行一下这个文件：\n发现需要执行一下这个文件，需要输入flag数据，看来flag数据很可能就在这个文件内部。这里就需要进行反编译，即把pyc文件打回原形。通过互联网的搜索引擎查询到python内置了一个uncompyle模块可以进行pyc反编译。\n于是可以使用pip install uncompyle 命令安装一下uncompyle。\n在命令行中执行：uncompyle6 -o test.py '.\\42aa1a89e3ae48c38e8b713051557020 (1).pyc'\n文件应该成功输出成了一个test.py文件。\n通过代码编辑器，查看到这个文件的源代码：\n# uncompyle6 version 3.7.4 # Python bytecode 2.7 (62211) # Decompiled from: Python 3.8.6 (tags/v3.8.6:db45529, Sep 23 2020, 15:52:53) [MSC v.1927 64 bit (AMD64)] # Embedded file name: ans.py # Compiled at: 2018-08-09 11:29:44 import base64 def encode1(ans): s = \u0026#39;\u0026#39; for i in ans: x = ord(i) ^ 36 x = x + 25 s += chr(x) return s def encode2(ans): s = \u0026#39;\u0026#39; for i in ans: x = ord(i) + 36 x = x ^ 36 s += chr(x) return s def encode3(ans): return base64.b32encode(ans) flag = \u0026#39; \u0026#39; print \u0026#39;Please Input your flag:\u0026#39; flag = raw_input() final = \u0026#39;UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===\u0026#39; if encode3(encode2(encode1(flag))) == final: print \u0026#39;correct\u0026#39; else: print \u0026#39;wrong\u0026#39; 看到文件源代码，发现flag数据是进行三次加密的：\n异或处理-\u0026gt;加数值chuli-\u0026gt;ASCII编码 加数值处理-\u0026gt;异或处理-\u0026gt;ASCII编码 base32编码处理 我们可以根据这个代码逻辑逆向设计一个加密算法脚本来解决：\n# python2 import base64 def decode1(ans): return base64.b32decode(ans) def decode2(ans): s=\u0026#39;\u0026#39; for i in ans: x = ord(i) ^ 36 x = x -36 s += chr(x) return s def decode3(ans): s=\u0026#39;\u0026#39; for i in ans: x = ord(i)-25 x = x ^ 36 s += chr(x) return s cipher = \u0026#34;UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===\u0026#34; plainer = decode3(decode2(decode1(cipher))) print plainer 执行一下编写好的代码，查看终端输出的结果：\n看输出结果，应该是flag数据没错了。\n再次执行以下pyc程序验证一下：\n看来是没错了，成功获取这道题目的flag数据：cyberpeace{interestinghhhhh}\n这道题目的难度上也是简单题，思路也是比较流畅的。\n题目主要考察pyc文件的反编译，以及编码和密码学的一些简单理论。简单题。\n转轮机加密 # 看到题目有些懵懵的，本菜鸡不知道啥是转轮机加密，于是只能求助一下搜索引擎来获取与转轮机加密相关的更多信息：\n转轮机是古典加密方法的集大成者，二战时轴心国普遍应用了该技术，可惜惨遭盟军攻破，德日还蒙在鼓里，一定程度上改变了最终的战局。\n转轮机的原理概括起来就是循环置换的多表代换技术，尤其是多筒转轮机，可重复使用数以万计的字母替换表。\n以三筒转轮机为例：\n有三个可以独立旋转的圆筒，每个圆筒内部有26个输入引脚和26个输出引脚，内部连线使得输入与输出唯一连接。\n每按一下输入键（旋转键），快速转子旋转一个引脚，当快速转子转满一轮（循环归位）时，带动中速转子旋转一个引脚，以此类推，类似钟表的秒分时。\n今天，转轮机的意义在于它曾经给目前最广泛使用的密码\u0026ndash;数据加密标准DES指明了方向。[10]\n转轮机加密是一种古典密码学的一种加密方法，应该是古典密码学的分组密码\n加密过程大致是：\n明文-\u0026gt;分组处理（类似于栅栏密码处理方式）-\u0026gt;文段内容位移+密文-\u0026gt;多文段顺序重排+密钥-\u0026gt;密文组\n下面点开题目描述，看看可以得到什么信息：\n转轮机加密题目\n根据题目描述的信息，可以获得以下几点提示：\n二战 托马斯·杰斐逊 flag格式 下面下载附件，并进行查看：\n附件内容\n要想获取到flag数据，应该就需要对附件内容的数据进行机密，这里编写一个python脚本来解密：\n# python2 dict_list = { \u0026#39;1\u0026#39;:\u0026#39;ZWAXJGDLUBVIQHKYPNTCRMOSFE\u0026#39;, \u0026#39;2\u0026#39;:\u0026#39;KPBELNACZDTRXMJQOYHGVSFUWI\u0026#39;, \u0026#39;3\u0026#39;:\u0026#39;BDMAIZVRNSJUWFHTEQGYXPLOCK\u0026#39;, \u0026#39;4\u0026#39;:\u0026#39;RPLNDVHGFCUKTEBSXQYIZMJWAO\u0026#39;, \u0026#39;5\u0026#39;:\u0026#39;IHFRLABEUOTSGJVDKCPMNZQWXY\u0026#39;, \u0026#39;6\u0026#39;:\u0026#39;AMKGHIWPNYCJBFZDRUSLOQXVET\u0026#39;, \u0026#39;7\u0026#39;:\u0026#39;GWTHSPYBXIZULVKMRAFDCEONJQ\u0026#39;, \u0026#39;8\u0026#39;:\u0026#39;NOZUTWDCVRJLXKISEFAPMYGHBQ\u0026#39;, \u0026#39;9\u0026#39;:\u0026#39;XPLTDSRFHENYVUBMCQWAOIKZGJ\u0026#39;, \u0026#39;10\u0026#39;:\u0026#39;UDNAJFBOWTGVRSCZQKELMXYIHP\u0026#39;, \u0026#39;11\u0026#39;:\u0026#39;MNBVCXZQWERTPOIUYALSKDJFHG\u0026#39;, \u0026#39;12\u0026#39;:\u0026#39;LVNCMXZPQOWEIURYTASBKJDFHG\u0026#39;, \u0026#39;13\u0026#39;:\u0026#39;JZQAWSXCDERFVBGTYHNUMKILOP\u0026#39; } key=[2,3,7,5,13,12,9,1,8,10,4,11,6] cipher=\u0026#34;NFQKSEVOQOFNP\u0026#34; cipher_arr=[] plainer_arr=[] plainer_list=[] index = 0 for i in key: cipher_arr.append(dict_list[str(i)]) for j in cipher_arr: location = j.index(cipher[index]) str_get = j[location:] + j[:location] plainer_arr.append(str_get) index += 1 for i in range(len(plainer_arr[0])): str_get=\u0026#34;\u0026#34; for j in plainer_arr: str_get += j[i] print str_get.lower() 执行刚刚编写好的python脚本，并在终端命令行中查看执行结果：\n得到了一个明文的列表：\nnfqksevoqofnpahgcxiusnwcbnctwpcubfotuvyzetmdrmezgkccdqhneyczuvtxjtgszrtqwtrezbrypqfawawsbqfxxywvsaxdcswzmpbxbbojczxedjlxygkigvqqrrqoiitjkdrkytuoczhydzljeipsykufhfgullzolhblrnhjbxmmiogdvlugxvkxjuqvmkamlpiiywyxsambkvlqsiaavfireintheholeuzaulcdkfprstwvfoomsyaupkairdtpxrppdldmkncsjzfnmnnjkpsegzphtyadfgbjojqqecgjvhheunvaonrhfhgilwjdwwymbbgmw 列表中存在明文，这时候需要看看题目描述的3个tip：\n二战 托马斯·杰斐逊 flag格式 由于转轮机加密是托马斯·杰斐逊发明的，因而tip2已经使用，tip3是要在提交的时候使用，这时候还有一个tip1，二战。找一下明文列表中是否有与二战相关的文段。\n发现文段：fireinthehole 与二战相关，这个明文段应该就是flag数据了。\n根据题目描述的flag数据要求，fireinthehole就是正确的flag数据了。\n题目解决，题目的思路也是比较流畅简单的，难度上算是简单题。\n题目主要考察的是古典密码学中的转轮机加密，简单题。\nNormal_RSA # 看到题目，感觉这道题目应该不简单，明显的一道RSA加密算法题目，估计也是考察RSA加密算法相关知识的题目。\n直接点开题目描述，看看可以获取到什么有用的tip\nNormal_RSA题目\n根据题目描述，这道题目应该是需要使用到工具的。RSA加密算法题目通常会使用到openssl，rsatool，factordb，sagemath工具进行rsa的公钥私钥的运算。\n下载附件，查看附件有什么东西吧：\n附件\n附件个压缩文件，我们对压缩文件进行解压获得一个文件夹：\n打开这个文件夹：\n文件夹内容\n发现有两个文件，一个是公钥，一个是密文。pem格式的文件应该是openssl的一种文件格式\n这里使用openssl来获取到公钥文件的e和n，使用openssl的rsa功能之前可以先看看rsa功能的帮助：\nopenssl rsa帮助\n了解了大致参数，执行命令rsa -pubin -text -modulus -in pubkey.pem 来获取e和n的数据：\nexponent就是e，modulus就是n。\n这里的e是十进制的，n是十六进制的：\nExponent: 65537 (0x10001) Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD 需要进行转换，使用ipython交互求出十进制数值：\n现在得到：\nn=87924348264132406875276140514499937145050893665602592992418171647042491658461 e=65537 下面需要求出p和q，这里需要进行大数分解，这里使用focterdb进行大数分解：\n现在得到的数据有：\np=275127860351348928173285174381581152299 q=319576316814478949870590164193048041239 n=87924348264132406875276140514499937145050893665602592992418171647042491658461 e=65537 现在这些数据可以求出参数d了，这里使用rsatool求解参数d、生成私钥文件：\npython ~/rsatool/rsatool.py -f PEM -o private.pem -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239 -e 65537 现在得到了私钥文件和公钥文件了，可以使用openssl进行解密了\nopensssl解密RSA加密算法的模块是rsautl，解密之前，先看看rsautl的帮助：\n了解大致参数后，执行命令开始进行求解：\nrsautl -in flag.enc -inkey private.pem -out flag.txt -decrypt 然后查看生成的txt文件内容：\n成功获取到flag数据：PCTF{256b_i5_m3dium}\n题目解决，题目是比较常规的RSA题目，题目主要考察RSA知识的掌握以及RSA工具的使用。\n题目难度上，题目算是简单题目。\nesay_ECC # 看到题目，这道题目应该是一个比较难的题目，题目考察到的是ecc加密算法，是密码学中比较难也是比较核心的考察点。ecc加密算法也是ctf密码学的难点。什么是ecc加密算法？\n椭圆曲线密码学（英语：Elliptic Curve Cryptography，缩写：ECC）是一种基于椭圆曲线数学的公开密钥加密算法。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz（英语：Neal Koblitz）和Victor Miller（英语：Victor Miller）分别独立提出的。\nECC的主要优势是它相比RSA加密算法使用较小的密钥长度并提供相当等级的安全性。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。[11]\n点开题目，看看题目能给我们什么有用的信息：\neasy_ECC题目\n题目的描述提示了ecc基本原理和提交的flag格式。这道题目解决的关键应该就是ecc基本原理。\n点开附件进行下载，查看附件内容：\n附件内容\n本菜鸡现在实在是看不懂ecc加密算法的基本原理，这道题目直接搬大佬的脚本求解：[12]\nGx = 6478678675 Gy = 5636379357093 a = 16546484 b = 4548674875 p = 15424654874903 k = 546768 x = Gx y = Gy for i in range(k-1): if (x==Gx and y==Gy): inv = pow(2*Gy, p-2,p) temp = (3*Gx*Gx+a)*inv%p else: inv = pow((x-Gx), p-2,p) temp = (y-Gy)*inv%p xr = (temp*temp-Gx-x)%p yr = (temp*(x-xr)-y)%p #print(i,xr,yr) x = xr y = yr print(x+y) 执行脚本进行求解：\n解出来的数值：19477226185390。对解出来的数值加个帽子：cyberpeace{19477226185390}\nflag数据就是：cyberpeace{19477226185390}\n题目解决，难度适中，主要考察ecc基本原理（本菜鸡现在看不懂，嘤嘤嘤）\n参考： # 密码学发展简史 凯撒密码-维基百科 摩尔斯电码-维基百科 01248云影密码-简书 栅栏密码-百度百科 培根密码-维基百科 RSA加密算法-维基百科 RSA加密算法-阮一峰 什么是.pyc文件-Python教程-PHP中文网 古典加密方法（三）转轮机 - block2016 - 博客园 椭圆曲线密码学-维基百科 XCTF easy_ECC WP XCTF的新手区密码学题目可能难度不是很高，但是XCTF新手区的密码学题目涉及的范围还是比较广的。从编码到密码，从古典到现代，从rsa到ecc都有涉及，密码学考察的基本知识都涉及到了。\n本期wp分享到此为止，有时间再来喝杯茶呀！\n","date":"June 25, 2021","permalink":"/posts/xctf-crypto-novice_writeup/","section":"Posts","summary":"这次又是XCTF平台，没错，我又来无聊谈谈解题了\n首先先来一张XCTF的首页图片，来开启本次的writeup文章：\nxctf首页\n这次我们要搞哪些题目的思路呢？这次还是新手区，不过是不一样的新手局，这回盘一盘密码学。\ncrypto新手区题目\n题目数量不变，依然是12道题目：\nbase64 Caesar Morse 幂数加密 Railfence 不仅仅是Morse 混合编码 easy_RSA easychallenge 转轮机加密 Normal_RSA esay_ECC 在开始进行密码学的题目问题思路分析的开始之前，首先进行一部分知识的了解。\n密码学的CTF题目通常都是以附件形式来进行考察的。不像网页需要进入到平台设定的docker靶机中\nCTF中密码学题目目前的趋势是越来越难，而且分值越来越高。密码学的题目往往分为编码题目和密码学题目，而密码学题目又会分为古典密码学题目和现代密码学题目。\n密码学早在公元前400多年就已经产生，人类使用密码的历史几乎与使用文字的时间一样长，密码学的发展大致可以分为 3 个阶段: 1949 年之前的古典密码学阶段; 1949 年至 1975 年密码学成为科学的分支; 1976 年以后对称密钥密码算法得到进一步发展，产生了密码学的新方向—公钥密码学。1976 年，W.Diffie 和 M.Hellman 在发表的文章“密码学的新方向”中首次公开提出了公钥密码( Public-key Cryptography) 的概念。公钥密码的提出实现了加密密钥和解密密钥之间的独立，解决了对称密码体制中通信双方必须共享密钥的问题，在密码学界具有划时代的意义。[1]\nCTF中的编码题目往往会考察一些常用的编码类型，当然也会出现一些比较偏的编码方式进行编码。\n常用的编码方式有：ASCii编码，Base64编码，Bin编码，Hex编码，URL编码以及HTML编码。\nCTF中的古典密码学题目可以通过查找相关的密码学算法来了解与密码学相关内容的更多信息，通过网络方式进行解决，或者获取一些灵感。古典密码学经常会考察最基础的凯撒密码，栅栏密码，或者替换密码。这些古典密码学的处理思路和方式都比较相似，而且网络已经有很多处理这些密码的算法工具来进行加密和解密。\nCTF中的现代密码学题目主要会考察RSA加密算法，ECC加密算法等经典的现代密码学算法。也会有一些新的加密算法题目，这种题目往往需要进行算法分析，通过加密算法的语法逻辑来设计解密算法通过逆元的思维求出明文。\n关于密码学的更多内容，可以访问：http://eol.sicau.edu.cn:8080/ 来了解更多密码学相关的内容。\n下面就开始本回的题目！\nbase64 # 看到这道题目，猜想这道题目可能是考察base64编码方式的密码学题目\n进入道题目页面，看看是否可以得到一点tip：\nbase64题目\n没有什么特别的tip，只是给题目一个情景化的描述，没有太多有用信息的描述。\n直接下载附件内容，并打开附件文件进行查看：\n附件文件\n文件内容有一段字符型文字：Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9\n根据题目的内容，尝试使用一下base64进行解码，可以使用在线的解码工具，也可以使用python脚本进行解码。这里编写简单的python脚本进行解码：\n# python3 脚本 import base64 cipher=\u0026#39;Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9\u0026#39; plainer= base64.b64decode(cipher) print(str(plainer,\u0026#39;utf-8\u0026#39;)) # python2 脚本 import base64 cipher=\u0026#39;Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9\u0026#39; plainer= base64.","title":"XCTF CRYPTO novice_writeup"},{"content":"","date":"June 25, 2021","permalink":"/tags/web/","section":"Tags","summary":"","title":"web"},{"content":"来点时效性的文章，不能总闲聊吧？\nXCTF是一个国内比较常用的CTF的刷题网站，网站页面如下：\nXCTF攻防世界页面\n初次写writeup，解题思路可能不是很明确。\n本次要解决的题目如下：\nXCTF WEB新手区题目\nview source robots backup cookie disabled button weak auth simple php get post xff referer webshell command execution simple js view_source # 进入到题目页面中，获取与解题相关的信息\nview_source题目\n根据题目要求可知，鼠标右键不可用了。\n我们进入环境来一探究竟\n靶机环境\n靶机展示的页面非常简单，说flag不在这儿，我不大相信，尝试使用右键查看源代码\n发现右键不能使用。看来靶机的代码把浏览器的右键给禁用了，解决方法有两个：\n使用F12进行检查源代码 开启浏览器禁用js模式 这里使用F12进行查看源代码（开启禁用js模式比较麻烦）\n页面源代码\nF12成功打开页面源代码调试，可以看到flag就在源代码的注释中，简单题\n本题主要考察对浏览器调试器的使用技巧，没有什么难度。\nrobots # 进入到题目页面环境中，查看题目信息和相关描述。\nrobots题目\n题目描述中提到了robots协议，本菜鸡不知道什么是robots协议，但是可以肯定robots协议就是本题的突破点，我去搜索查找一下有关robots协议的相关信息。\nrobots协议相关信息\n根据百度百科的说明，其实robots协议就是网站目录下的robots.txt文件\n预备的知识信息获取到了，下面进入到靶机环境，去拿flag\n靶机页面\n靶机页面是个空白页面，在靶机地址后面输入/robots.txt尝试找到flag\n进入到robots.txt页面寻找有关flag的相关信息\nrobots.txt页面信息\n根据robots.txt展示的页面信息，可知flag就在flag_1s_h3re.php文件中\n那就进入到这个文件中\nflag_1s_h3re.php文件页面\n成功拿到flag数据信息，题目也是简单题\n这道题目主要考察robots协议的相关知识以及网站目录的部分知识，也是简单题，思路非常明确\nbackup # 进入到题目页面中，寻找有用的题目突破信息\nbackup题目\n根据题目描述，这道题目是在考察备份文件，备份文件是解题的关键\n根据备份文件的相关信息可知，备份文件通常都是后缀名.bak的文件\n已有知识准备好了，现在进入到靶机环境中拿flag\n靶机页面\n靶机直接就把提示摆到页面上面了，直接访问index.php.bak文件就可以了\n一般来说index.php的备份文件就是index.php.bak文件\n访问url/index.php.bak，备份文件成功被下载下来\n备份文件\n打开备份文件寻找信息\n备份文件信息\n发现flag数据就在备份文件中，题目解决，也是一道简单题目\n题目主要考察的就是备份文件的相关知识，简单题，思路非常明确\ncookie # 进入到题目页面，寻找与解题相关的信息\ncookie题目\n题目描述和题目明显提示是cookie相关的知识，cookie的知识一般做web安全都是必须知道且需要了解的一个重要的知识点。这里搬出MDN上面对于cookie的说明，cookie知识不清楚的可以去MDN页面中了解\nMDN cookie\n简单来说，cookie就是存储在用户服务器上的一段信息内容\n可以使用浏览器的调试器查看该页面的cookie数据，准备知识现在已经完备。\n进入到靶机环境，拿flag！\n靶机页面\n靶机页面信息展示的很明确，就是cookie\n打开F12调试器查看cookie信息\ncookie数据\n发现有很多条cookie数据，不知道该选择哪一条cookie数据，我发现这些cookie的domain信息不太一样。有四条的domain信息是baidu.com，只有一条的domain信息是靶机的ip地址，看来需要的cookie信息就是domain信息是靶机ip地址的那条cookie\n靶机cookie数据\ncookie的键值对是look-here:cookie.php，cookie.php显然不是flag数据，估计是想让我们访问这个文件，我们来访问一下这个文件\ncookie.php页面信息\n这个页面展示的内容也是非常简单的，让我们去看看response信息。\n可能有人会问response是什么？response就是http头部信息的响应信息，在调试器的网络那一栏可以查看到页面的http头部信息。关于http头部信息的更多内容，可以访问MDN的HTTP头部列表\n打开浏览器的调试器\n网络响应数据\n如果响应数据中没有任何信息，可以刷新一下页面来找到响应数据\n然后我们选择响应数据中的cookie.php的数据信息\ncookie.php的响应信息\n发现响应标头的信息中有flag数据，本题也就成功解出，也是简单题目，跟着引导走，很快就能拿到flag\n题目主要考察cookie相关知识和htpp头的相关知识内容，这里也可以使用burp suite来抓包获取http信息，简单题，思路也相对比较流畅。\ndisabled button # 看到这个题目就大致知道这道题目的考察目标了，应该是一道非常简单的题目\n来看看题目内容有什么具体的描述信息\ndisabled_button题目\n根据题目描述可以知道，这道题目是考察前端知识的。根据题目disabled_button，这道题目很可能是在考察html标签属性的，下面我们进入到题目中一探究竟\n靶机页面\n页面展示的信息非常清晰不能按的按钮，而且flag信息就藏在这个按钮后面\n直接点开F12查看源代码\n源代码检查\n发现input标签有关disabled属性，我们将disabled属性删除，按钮就可以按了\n源代码修改\n然后返回到页面上去，发现按钮可以被按下\n按钮页面\n按下按钮，查看可以获取到的信息\nflag信息\n成功获取到flag信息，题目解决，这道题目非常简单，应该是道签到题\n题目主要考察前端的html知识，签到题\nweak auth # 进入到题目页面，查看可以利用的信息及提示\nweak_auth\n根据题目和题目描述信息可以知道，这道题目是一个登录页面，而且采用的是弱口令进行认证的页面。\n考察的信息应该是暴力破解的知识以及暴力破解的工具使用。\n这里说一下暴力破解的内容知识：\n暴力破解也叫蛮力攻击，是一种非常无脑的攻击手段，经常会和社会工程学一起采用来达到成功破解用户密码的效果。\n蛮力攻击（英语：Brute-force attack），又称为穷举攻击（英语：Exhaustive attack）或暴力破解，是一种密码分析的方法，即将密码进行逐个推算直到找出真正的密码为止。例如：一个已知是四位数并且全部由阿拉伯数字组成的密码，其可能共有10000种组合，因此最多尝试9999次就能找到正确的密码。理论上除了具有完善保密性的密码以外，利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。有些人运用计算机来增加效率，有些人透过字典攻击（英语：Dictionary attack）来缩小密码组合的范围。[1]\n如果要解决这道题目，就必不可少一些暴力破解会使用的工具来进行暴力破解。暴力破解工具有很多，一般来说，web安全会有一些比较常用的暴力破解工具，这道题目可能需要使用到kali操作系统来辅助解题。常用的暴力破解工具一般有：Hydra，Medusa，Burp suite。\n这里可能使用到Hydra进行暴力破解，这里说明一些Hydra的暴力破解的方法和相关参数\nhydra 是一个支持众多协议的爆破工具，已经集成到KaliLinux中，直接在终端打开即可。[2]\n常用的hydra的暴力破解命令：\n1、破解ssh： hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip ssh hydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh 2、破解ftp： hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vV hydra ip ftp -l 用户名 -P 密码字典 -e ns -vV 3、get方式提交，破解web登录： hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/ hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php 4、post方式提交，破解web登录： hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form \u0026#34;/admin/login.php:username=^USER^\u0026amp;password=^PASS^\u0026amp;submit=login:sorry password\u0026#34; hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form \u0026#34;login.php:id=^USER^\u0026amp;passwd=^PASS^:\u0026lt;title\u0026gt;wrong username or password\u0026lt;/title\u0026gt;\u0026#34; （参数说明：-t同时线程数3，-l用户名是admin，字典pass.txt，保存为out.txt，-f 当破解了一个密码就停止， 10.36.16.18目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破解,\u0026lt;title\u0026gt;中 的内容是表示错误猜解的返回信息提示。） 5、破解https： hydra -m /index.php -l muts -P pass.txt 10.36.16.18 https 6、破解teamspeak： hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak 7、破解cisco： hydra -P pass.txt 10.36.16.18 cisco hydra -m cloud -P pass.txt 10.36.16.18 cisco-enable 8、破解smb： hydra -l administrator -P pass.txt 10.36.16.18 smb 9、破解pop3： hydra -l muts -P pass.txt my.pop3.mail pop3 10、破解rdp： hydra ip rdp -l administrator -P pass.txt -V 11、破解http-proxy： hydra -l admin -P pass.txt http-proxy://10.36.16.18 12、破解imap： hydra -L user.txt -p secret 10.36.16.18 imap PLAIN hydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN 这些常用的命令解决这道题目应该是足够的。\n现在工具和知识都已经准备完毕了，进入靶机来一探究竟\nweak_auth页面\n非常简单的一个登录认证页面，先进行简单的密码猜测\n使用root:root进行登录尝试\n弹出提示，please login as admin，说明登录的用户名必须要素admin\n下面试试admin:admin进行登录尝试\n弹出提示，password error，登录错误的提示，然后点击确定查看一下页面的源代码\n靶机error页面源代码\n发现登录错误关键字error，然后查看页面的响应标头确定传输方式\n发现页面数据的传输方式是post方式进行传输的。而且页面存在着跳转，hydra的易用性相对较差，这里需要选用burpsuite进行暴力破解\n进入到kali系统中，抓取页面信息进行暴力破解攻击\nbp抓到的数据包\n右键将页面发送到intruder页面中\n然后点击intruder页面进行暴力破解的设置\n调整好参数，然后进入到option的配置页面中进行攻击，（最好找一个弱口令字典）\n简单设置进行暴力破解的字典，然后设置匹配项。由于我们知道页面登录失败的时候会出现password error的选项，因此进入到option页面中设置匹配。\n点击clear将所有的匹配规则清除\n点击add将error的匹配规则添加进去\n然后点击start attack开始攻击\n稍微等一下，等攻击结果出现\n发现123456这个密码没有匹配到error的规则，然后进入到页面中将123456密码输入进去\n进入到跳转页面中，成功找到flag数据。\n本题也成功解决，题目的思路也是比较简单的。考察的要点就是暴力破解，通过暴力破解解决问题。\n题目属于简单题。\nsimple php # 这道题的题目是simple_php，应该是一道考察php代码的简单题目\n进入到题目页面，来获取到更多信息\nsimple_php题目\n页面中的题目描述信息也是在说php代码的问题，这道题目应该是在考察php代码的简单使用情况\n进入到靶机环境来一探究竟\n直接展示出源代码，这应该是一道简单的php代码审计题目，本菜鸡的php基础还可以，这道题目主要是考察php代码的特性和缺陷。\n这道题目中有三个特性进行了考察：\nphp中的字符串在进行比较的时候都会被当作0来处理 php中的变量如果被赋值了数字加字符，在进行数值判断的时候，字符会被忽略 php中的is_numeric()函数会判断变量是否是纯数字，如果是纯数字就返回true，如果不是纯数字就返回false 有时候php代码审计的题目遇到不认识的代码或者函数，可以进行搜索引擎的使用和查找\n代码可控的地方是get传输的数据，a和b参数作为数据接收并进行传递的\n由于这道题目比较简单，直接在url上面进行构造\n构造payload：url?a=Flag\u0026amp;b=1235s\n成功获取到flag数据，题目解决。\n题目主要考察get传输方式和php代码的特性，思路也比较简单，分析代码的逻辑进行简单的注入就可以解决问题。属于简单题目。\nget post # 看题目，这道题目应该是考察http的传输数据的方式，get传输方式和post传输数据的方式\n点开题目，希望可以从题目页面中获取到更多的信息\nget_post题目\n题目描述也是说用get和post方式，看来这道题目的关键点就是get和post传输数据的方式。\n由于这里涉及的post方式的传输，这里需要使用一个Hackbar的插件攻击来辅助进行注入进攻来获取到flag数据。这里给出hackbar的GitHub地址：https://github.com/Hack-Free/HackBar，如果没有这个工具可以进行下载使用。\n现在工具齐全了，可以进行尝试去拿flag了，打开靶机进入到环境中\n页面中展示的信息非常明确，而且比较明了。为了方便操作，进入到kali系统中的已装好hackbar的firefox浏览器中进行操作。\n首先使用get方法进行提交，点击execut进行传输\n页面内容发生了变化，这次使用post数据进行传输\n点击execute进行传输数据\n数据传输过去后，页面发生变化，然后flag数据就展示在眼前，题目解决。\n这道题目的思路非常清晰，就是引导性的题目，没有什么难度，应该是道签到题目。\n题目考察的知识点是http传输数据的方式，属于签到题。\nxff referer # 刚开始看到这个题目标题的时候还是有点懵逼的，因为本菜鸡并不知道什么是xff和referer\n于是使用搜索引擎解决一下问题\nX-Forwarded-For (XFF) 在客户端访问服务器的过程中如果需要经过HTTP代理或者负载均衡服务器，可以被用来获取最初发起请求的客户端的IP地址，这个消息首部成为事实上的标准。在消息流从客户端流向服务器的过程中被拦截的情况下，服务器端的访问日志只能记录代理服务器或者负载均衡服务器的IP地址。如果想要获得最初发起请求的客户端的IP地址的话，那么 X-Forwarded-For 就派上了用场。[3]\n**Referer** 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。[4]\n发现Xff和Referer就是一个可以进行IP代理的东西和一个可以进行来源记录的东西\n再去查一下Xff和Referer的语法格式，确保对于Xff和Referer的知识掌握的比较完善。\n于是再去MDN上查看一波：\nX-Forwarded-For: \u0026lt;client\u0026gt;, \u0026lt;proxy1\u0026gt;, \u0026lt;proxy2\u0026gt; # 示例 X-Forwarded-For: 2001:db8:85a3:8d3:1319:8a2e:370:7348 X-Forwarded-For: 203.0.113.195 X-Forwarded-For: 203.0.113.195, 70.41.3.18, 150.172.238.178 Referer: \u0026lt;url\u0026gt; # 示例 Referer: https://developer.mozilla.org/en-US/docs/Web/JavaScript 点开题目查看，题目中又有些什么信息\nxff_referer题目\n根据题目描述，xff和referer是可以伪造的，可以知道这道题目应该是伪造xff和referer的题目，由于xff和referer都是http头部的信息，所以需要使用burp suite进行抓包来伪造xff和referer信息，需要先启动一下kali操作系统。\n目前，知识基础和工具基础都准备好了，进入到靶机环境\n靶机环境\n要求ip必须为123.123.123.123，用burp suite抓到数据包，修改xff数据来进行伪造\n然后进行放行来查看页面情况\n页面返回了一个必须来自https://www.google.com\n再次抓包，设置一下referer和xff的信息\n将数据包放行，然后查看页面信息\n最后，页面成功出现flag信息，题目成功解决，题目比较简单，具有引导性\n题目属于简单的题目，应该算是签到题，题目主要考察对于xff和referer的http头部信息的了解和掌握，思路比较流程，具有引导性。\nwebshell # 看到这个·题目，首先第一反应是上传php一句话木马拿webshell。可能有人不解，什么是webshell？什么是一句话木马？这里搬出百度百科的解释，对webshell简单说明：\nwebshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。[5]\nwebshell简单来说就是命令执行的环境，而一句话木马就是在创建一个可以连接到网站的命令执行环境的一个后门程序，这个后门程序通常都是比较简单，比较小的文件。可以通过网站的文件上传漏洞进行文件上传，创建后门木马。\n进入到题目页面，看看可以获取到什么额外的信息：\nwebshell题目\n根据题目描述，这道题目应是考察一句话木马的题目，而且是php一句话木马的题目。\n根据目前的推出和知识分析，进入环境来看看怎么拿flag\n靶机环境\n靶机环境中的页面直接把页面中写入的php一句话木马展示出来了，是通过post方式进行参数传递的。\n这道题目可以使用hackbar插件进行post数据的传输，首先进行hello world输出来测试webshell的稳定性，根据页面回显情况来进行下一步操作。\n查看一下，页面的回显情况\n页面将hello world成功输出到页面上面，说明页面会直接将代码执行结果回显到页面上面，回显效果良好。\n接下来，讲一个的php的小技巧：\nphp代码中的反引号```可以直接执行终端shell命令.并返回输出\n\u0026lt;?php echo `ls`; #会将ls命令的输出结果输出到php页面上面 ?\u0026gt; 下面我们就可以根据这个小技巧来构造payload：shell=echo ls;\n查看页面返回的结果\n发现网站的站点目录下有两个文件，一个是index.php文件，一个是flag.txt文件\n显然flag文件肯定就是目标文件，需要查看到flag.txt文件中究竟写了些什么样的内容，flag.txt文件很可能藏着flag文件\n构造payload：shell=echo cat flag.txt;\n查看页面显示的结果\n发现flag.txt文件中写的就是flag数据，题目解决\n题目主要考察php一句话木马，php特性和linux命令的简单使用，整体思路还是比较流畅的，题目难度比较简单，顺着思路就可以解决了。当然此题有多种解法。\ncommand execution # 看到题目，可能是考察命令执行漏洞的题目，从题目也获取不到太多信息\n直接点开题目页面，来看看有没有更多的信息\ncommand_execution题目\n题目描述说是ping功能，题目可能于ping功能有些出入，进入靶场环境看看情况\n靶机环境\n页面非常简单，好像就是一个ping功能的页面，首先试试使用127.0.0.1地址进行测试\n发现这是一个命令执行环境，可控的地方就是输入框\n来分析一下输入框的输入模式：\n输入框可以输入ip地址和url地址\n输入的内容前方会被增加ping -c 3 的代码\n输入内容的后面不会增加任何额外代码\n页面输出内容会把终端输出内容返回\n因此，这里可以使用一点shell的语法技巧来构造payload\n\u0026amp;\u0026amp;在shell语法中是前面的命令执行成功后继续执行后面的代码\nping -c 3 127.0.0.1 \u0026amp;\u0026amp; ls # 会先执行ping命令，ping命令执行成功会再执行ls命令 于是构造payload：127.0.0.1 \u0026amp;\u0026amp; ls ，并输入到输入框中来执行\n发现网站页面下没有藏有flag文件，下一个可能的目录是home目录或是root目录\n访问root目录需要权限，于是先查看一下ping功能的用户权限\n构造payload：127.0.0.1 \u0026amp;\u0026amp; id ，并输入到输入框中来执行\n发现ping的权限仅仅知识apache的权限，使用的服务器很可能是Ubuntu服务\n构造payload：127.0.0.1 \u0026amp;\u0026amp; uname -a ，并输入到输入框中执行\n发现服务器确实是Ubuntu服务器\n根据目前收集到的信息，可能只能访问到home目录下，那就先尝试查看到home目录，如果home目录下没有再尝试提权进入到root目录下\n构造查看home目录的payload：127.0.0.1 \u0026amp;\u0026amp; ls /home ，输入到输入框中执行\n发现home目录下存在有flag文件，让本菜鸡来瞧瞧这个flag.txt里面写的啥\n构造payload：127.0.0.1 \u0026amp;\u0026amp; cat /home/flag.txt ，输入到输入框中执行\n发现flag.txt里面写的就是flag数据，题目解决\n题目主要考察linux命令行的使用以及对于命令执行漏洞的觉察，题目的解题思路还是比较流畅的，题目应该也属于简单题。难度并不是很高。\nsimple js # 看到题目，应该是一个简单JavaScript代码审计的题目\n进入到题目页面中，希望可以获取到更多相关的数据\nsimple_js题目\n看到题目的难度系数，可知这道题目应该不简单，网页一直输入不对密码，这应该是一个提示\n下面就直接进入到靶机环境来看看情况\n页面直接就是一个提示框，先随便输入点内容\n就报出了另一个提示框，然后页面内容是空白的\n这种情况下，只能尝试从F12检查源代码中找到一些有用的信息\n在源代码检查的过程中找到了js的代码，这道题目应该是对js源代码的审计\nfunction dechiffre(pass_enc) { var pass = \u0026#34;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\u0026#34;; var tab = pass_enc.split(\u0026#39;,\u0026#39;); var tab2 = pass.split(\u0026#39;,\u0026#39;); var i, j, k, l = 0, m, n, o, p = \u0026#34;\u0026#34;; i = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; for (i = (o = 0); i \u0026lt; (k = j = n); i++) { o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; } for (i = (o = 0); i \u0026lt; (k = j = n); i++) { o = tab[i - l]; if (i \u0026gt; 5 \u0026amp;\u0026amp; i \u0026lt; k - 1) p += String.fromCharCode((o = tab2[i])); } p += String.fromCharCode(tab2[17]); pass = p; return pass; } String[\u0026#34;fromCharCode\u0026#34;](dechiffre(\u0026#34;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\u0026#34;)); h = window.prompt(\u0026#39;Enter password\u0026#39;); alert(dechiffre(h)); 然后对这段js代码进行简单分析：\n从js代码整体来看，代码先定义了一个dechiffre的函数，然后定义了一个字符串数组，然后使用了两个功能性函数进行弹窗。\n整段js代码的核心应该是应该是定义的dechiffre的函数，对于dechiffre函数的分析应该就是解决这道题目的关键性问题\n下面对JS源代码中的dechiffre函数进行分析：\n首先将dechiffre函数内部进行划分\nfunction dechiffre(pass_enc) { // 变量定义区 var pass = \u0026#34;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\u0026#34;; var tab = pass_enc.split(\u0026#39;,\u0026#39;); var tab2 = pass.split(\u0026#39;,\u0026#39;); var i, j, k, l = 0, m, n, o, p = \u0026#34;\u0026#34;; // 变量处理区 i = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; // 逻辑处理区 for (i = (o = 0); i \u0026lt; (k = j = n); i++) { o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; } for (i = (o = 0); i \u0026lt; (k = j = n); i++) { o = tab[i - l]; if (i \u0026gt; 5 \u0026amp;\u0026amp; i \u0026lt; k - 1) p += String.fromCharCode((o = tab2[i])); } // 最终输出区 p += String.fromCharCode(tab2[17]); pass = p; return pass; } js函数被划分成四个区域：\n变量定义区 变量处理区 逻辑处理区 最终输出区 下面对这四个分区进行逐一分析\n变量定义区：\nvar pass = \u0026#34;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\u0026#34;; var tab = pass_enc.split(\u0026#39;,\u0026#39;); var tab2 = pass.split(\u0026#39;,\u0026#39;); var i, j, k, l = 0, m, n, o, p = \u0026#34;\u0026#34;; 定义了一个pass变量并赋值\u0026quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\u0026quot;\n定义了一个tab变量并赋值pass_enc参数进行分隔成数组\n定义了一个tab2变量并赋值pass变量进行分隔成数组[70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65]\n定义了变量i，j，k，l并赋值为0，定义了变量m，n，o，p并赋值为“”\n变量处理区\ni = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; 将变量i再次赋值为0\n将变量j赋值为tab的长度\n将变量k赋值为j的值加上l和n=0的数值\n将变量n赋值为tab2的长度，即n=18\n逻辑处理区\nfor (i = (o = 0); i \u0026lt; (k = j = n); i++) { o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; } for (i = (o = 0); i \u0026lt; (k = j = n); i++) { o = tab[i - l]; if (i \u0026gt; 5 \u0026amp;\u0026amp; i \u0026lt; k - 1) p += String.fromCharCode((o = tab2[i])); } 对于第一个循环，初始值i被赋值为0，限制条件是i\u0026lt;18，循环条件是i++\n循环内部是对于o变量的处理，第一个赋值语句是无用的赋值语句，由于下面的语句会对o进行 重新赋值处理。下面p += String.fromCharCode((o = tab2[i]));语句涉及了string对象和fromCharCode（）函数。经过搜索和查询，发现fromcharcode函数是将unicode值转换为字符的函数，属于String对象的api。这条语句的作用是对p变量进行累计赋值处理。如果i==5循环就结束。\n对于第二个循环，初始值i被赋值为0，限制条件是i\u0026lt;18，循环条件是i++\n循环内部依旧是对于o变量的处理，还是和第一个循环非常类似的处理，都是最终对于p变量进行累计赋值。\n两个循环都是对于p变量进行累加赋值。\n最终输出区\np += String.fromCharCode(tab2[17]); pass = p; return pass; 仍然是对p变量进行赋值处理\n将p的值赋值给pass\n将pass变量返回\n总体对这个函数进行分析，这个函数根本没有涉及任何传入参数的处理情况，简单来说就是没有tab数组任何事情。无论传入什么变量都只返回tab2数组的数据。\n再看看代码最后的调用情况\nString[\u0026#34;fromCharCode\u0026#34;](dechiffre(\u0026#34;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\u0026#34;)); h = window.prompt(\u0026#39;Enter password\u0026#39;); alert(dechiffre(h)); 这个函数被调用两次。\n第一次是调用了dechiffre并传入参数\n“\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30” 作为函数的实参进行传入数据\n第二次是调用了用户输入的数据（无论传入什么数据结果都一样） 所以这个JavaScript的代码中肯定藏有flag，flag可能藏在第一次传入的参数中\n\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30 编写js文件对第一次传入的参数进行处理\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var input=\u0026#34;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\u0026#34;; var result; var o=0; var tab=input.split(\u0026#39;,\u0026#39;); document.write(tab); for (var i = 0; i\u0026lt;tab.length; i++){ result += String.fromCharCode((o=tab[i])) } document.write(result); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在浏览器上运行一下这段代码\nundefined后面那段字符就是flag数据：786OsErtk12\n这道题目也解决了，分析过程比较复杂，需要一定的JavaScript基础。难度其实也应该是一道简单题目，但是思路比较绕，如果比较灵敏可以直接找到关键数据，对关键数据进行unicode解码在进行ascii解码就能得出flag数据。\n这里提供几个网址，便于js基础不是非常牢固的人补习一下：\nhttps://javascript.ruanyifeng.com/\nhttps://www.liaoxuefeng.com/wiki/1022910821149312\nhttps://developer.mozilla.org/zh-CN/docs/learn/JavaScript\n参考 # WIKI百科-蛮力攻击 爆破工具 Hydra 简单使用 X-Forwarded-For MDN Referer MDN webshell 百度百科 本期wp分享到此为止，有时间再来喝杯茶呀！\n","date":"June 25, 2021","permalink":"/posts/xctf-web-novice_writeup/","section":"Posts","summary":"来点时效性的文章，不能总闲聊吧？\nXCTF是一个国内比较常用的CTF的刷题网站，网站页面如下：\nXCTF攻防世界页面\n初次写writeup，解题思路可能不是很明确。\n本次要解决的题目如下：\nXCTF WEB新手区题目\nview source robots backup cookie disabled button weak auth simple php get post xff referer webshell command execution simple js view_source # 进入到题目页面中，获取与解题相关的信息\nview_source题目\n根据题目要求可知，鼠标右键不可用了。\n我们进入环境来一探究竟\n靶机环境\n靶机展示的页面非常简单，说flag不在这儿，我不大相信，尝试使用右键查看源代码\n发现右键不能使用。看来靶机的代码把浏览器的右键给禁用了，解决方法有两个：\n使用F12进行检查源代码 开启浏览器禁用js模式 这里使用F12进行查看源代码（开启禁用js模式比较麻烦）\n页面源代码\nF12成功打开页面源代码调试，可以看到flag就在源代码的注释中，简单题\n本题主要考察对浏览器调试器的使用技巧，没有什么难度。\nrobots # 进入到题目页面环境中，查看题目信息和相关描述。\nrobots题目\n题目描述中提到了robots协议，本菜鸡不知道什么是robots协议，但是可以肯定robots协议就是本题的突破点，我去搜索查找一下有关robots协议的相关信息。\nrobots协议相关信息\n根据百度百科的说明，其实robots协议就是网站目录下的robots.txt文件\n预备的知识信息获取到了，下面进入到靶机环境，去拿flag\n靶机页面\n靶机页面是个空白页面，在靶机地址后面输入/robots.txt尝试找到flag\n进入到robots.txt页面寻找有关flag的相关信息\nrobots.txt页面信息\n根据robots.txt展示的页面信息，可知flag就在flag_1s_h3re.php文件中\n那就进入到这个文件中\nflag_1s_h3re.php文件页面\n成功拿到flag数据信息，题目也是简单题\n这道题目主要考察robots协议的相关知识以及网站目录的部分知识，也是简单题，思路非常明确\nbackup # 进入到题目页面中，寻找有用的题目突破信息\nbackup题目\n根据题目描述，这道题目是在考察备份文件，备份文件是解题的关键\n根据备份文件的相关信息可知，备份文件通常都是后缀名.bak的文件\n已有知识准备好了，现在进入到靶机环境中拿flag\n靶机页面\n靶机直接就把提示摆到页面上面了，直接访问index.php.bak文件就可以了\n一般来说index.php的备份文件就是index.php.bak文件\n访问url/index.php.bak，备份文件成功被下载下来","title":"XCTF WEB novice Writeup"}]