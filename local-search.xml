<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>XCTF-WEB-新手区 writeup</title>
    <link href="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/"/>
    <url>/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/</url>
    
    <content type="html"><![CDATA[<p>来点时效性的文章，不能总闲聊吧？</p><p><a href="https://adworld.xctf.org.cn/">XCTF</a>是一个国内比较常用的CTF的刷题网站，网站页面如下：</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-1.png" class="">XCTF攻防世界页面<p>初次写writeup，解题思路可能不是很明确。</p><p>本次要解决的题目如下：</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-2.png" class="">XCTF WEB新手区题目<ul><li>view source</li><li>robots</li><li>backup</li><li>cookie</li><li>disabled button</li><li>weak auth</li><li>simple php</li><li>get post</li><li>xff referer</li><li>webshell</li><li>command execution</li><li>simple js</li></ul><h2 id="view-source"><a href="#view-source" class="headerlink" title="view_source"></a>view_source</h2><p>进入到题目页面中，获取与解题相关的信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-3.png" class="">view_source题目<p>根据题目要求可知，鼠标右键不可用了。</p><p>我们进入环境来一探究竟</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-4.png" class="">靶机环境<p>靶机展示的页面非常简单，说flag不在这儿，我不大相信，尝试使用右键查看源代码</p><p>发现右键不能使用。看来靶机的代码把浏览器的右键给禁用了，解决方法有两个：</p><ol><li>使用F12进行检查源代码</li><li>开启浏览器禁用js模式</li></ol><p>这里使用F12进行查看源代码（开启禁用js模式比较麻烦）</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-5.png" class=""><p>页面源代码</p><p>F12成功打开页面源代码调试，可以看到flag就在源代码的注释中，简单题</p><p>本题主要考察对浏览器调试器的使用技巧，没有什么难度。</p><h2 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h2><p>进入到题目页面环境中，查看题目信息和相关描述。</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-6.png" class="">robots题目<p>题目描述中提到了robots协议，本菜鸡不知道什么是robots协议，但是可以肯定robots协议就是本题的突破点，我去搜索查找一下有关robots协议的相关信息。</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-7.png" class="">robots协议相关信息<p>根据百度百科的说明，其实robots协议就是网站目录下的robots.txt文件</p><p>预备的知识信息获取到了，下面进入到靶机环境，去拿flag</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-8.png" class="">靶机页面<p>靶机页面是个空白页面，在靶机地址后面输入/robots.txt尝试找到flag</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-9.png" class=""><p>进入到robots.txt页面寻找有关flag的相关信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-10.png" class="">robots.txt页面信息<p>根据robots.txt展示的页面信息，可知flag就在flag_1s_h3re.php文件中</p><p>那就进入到这个文件中</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-11.png" class="">flag_1s_h3re.php文件页面<p>成功拿到flag数据信息，题目也是简单题</p><p>这道题目主要考察robots协议的相关知识以及网站目录的部分知识，也是简单题，思路非常明确</p><h2 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h2><p>进入到题目页面中，寻找有用的题目突破信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-12-1024x292.png" class="">backup题目<p>根据题目描述，这道题目是在考察备份文件，备份文件是解题的关键</p><p>根据备份文件的相关信息可知，备份文件通常都是后缀名.bak的文件</p><p>已有知识准备好了，现在进入到靶机环境中拿flag</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-13.png" class="">靶机页面<p>靶机直接就把提示摆到页面上面了，直接访问index.php.bak文件就可以了</p><p>一般来说index.php的备份文件就是index.php.bak文件</p><p>访问url/index.php.bak，备份文件成功被下载下来</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-14.png" class="">备份文件<p>打开备份文件寻找信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-15.png" class="">备份文件信息<p>发现flag数据就在备份文件中，题目解决，也是一道简单题目</p><p>题目主要考察的就是备份文件的相关知识，简单题，思路非常明确</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>进入到题目页面，寻找与解题相关的信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-16-1024x282.png" class="">cookie题目<p>题目描述和题目明显提示是cookie相关的知识，cookie的知识一般做web安全都是必须知道且需要了解的一个重要的知识点。这里搬出MDN上面对于<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">cookie</a>的说明，cookie知识不清楚的可以去MDN页面中了解</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-17.png" class="">MDN cookie<p>简单来说，cookie就是存储在用户服务器上的一段信息内容</p><p>可以使用浏览器的调试器查看该页面的cookie数据，准备知识现在已经完备。</p><p>进入到靶机环境，拿flag！</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-18.png" class="">靶机页面<p>靶机页面信息展示的很明确，就是cookie</p><p>打开F12调试器查看cookie信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-19-1024x234.png" class="">cookie数据<p>发现有很多条cookie数据，不知道该选择哪一条cookie数据，我发现这些cookie的domain信息不太一样。有四条的domain信息是baidu.com，只有一条的domain信息是靶机的ip地址，看来需要的cookie信息就是domain信息是靶机ip地址的那条cookie</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-20.png" class="">靶机cookie数据<p>cookie的键值对是look-here:cookie.php，cookie.php显然不是flag数据，估计是想让我们访问这个文件，我们来访问一下这个文件</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-21.png" class=""><p>cookie.php页面信息</p><p>这个页面展示的内容也是非常简单的，让我们去看看response信息。</p><p>可能有人会问response是什么？response就是http头部信息的响应信息，在调试器的网络那一栏可以查看到页面的http头部信息。关于http头部信息的更多内容，可以访问<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN的HTTP头部列表</a></p><p>打开浏览器的调试器</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-22-1024x140.png" class="">网络响应数据<p>如果响应数据中没有任何信息，可以刷新一下页面来找到响应数据</p><p>然后我们选择响应数据中的cookie.php的数据信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-23.png" class="">cookie.php的响应信息<p>发现响应标头的信息中有flag数据，本题也就成功解出，也是简单题目，跟着引导走，很快就能拿到flag</p><p>题目主要考察cookie相关知识和htpp头的相关知识内容，这里也可以使用burp suite来抓包获取http信息，简单题，思路也相对比较流畅。</p><h2 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled button"></a>disabled button</h2><p>看到这个题目就大致知道这道题目的考察目标了，应该是一道非常简单的题目</p><p>来看看题目内容有什么具体的描述信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-24-1024x287.png" class="">disabled_button题目<p>根据题目描述可以知道，这道题目是考察前端知识的。根据题目disabled_button，这道题目很可能是在考察html标签属性的，下面我们进入到题目中一探究竟</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-25.png" class="">靶机页面<p>页面展示的信息非常清晰不能按的按钮，而且flag信息就藏在这个按钮后面</p><p>直接点开F12查看源代码</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-26.png" class="">源代码检查<p>发现input标签有关disabled属性，我们将disabled属性删除，按钮就可以按了</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-27.png" class="">源代码修改<p>然后返回到页面上去，发现按钮可以被按下</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-28.png" class="">按钮页面<p>按下按钮，查看可以获取到的信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-29.png" class="">flag信息<p>成功获取到flag信息，题目解决，这道题目非常简单，应该是道签到题</p><p>题目主要考察前端的html知识，签到题</p><h2 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak auth"></a>weak auth</h2><p>进入到题目页面，查看可以利用的信息及提示</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-30-1024x277.png" class="">weak_auth<p>根据题目和题目描述信息可以知道，这道题目是一个登录页面，而且采用的是弱口令进行认证的页面。</p><p>考察的信息应该是暴力破解的知识以及暴力破解的工具使用。</p><p>这里说一下暴力破解的内容知识：</p><p>暴力破解也叫蛮力攻击，是一种非常无脑的攻击手段，经常会和社会工程学一起采用来达到成功破解用户密码的效果。</p><p>蛮力攻击（英语：Brute-force attack），又称为穷举攻击（英语：Exhaustive attack）或暴力破解，是一种密码分析的方法，即将密码进行逐个推算直到找出真正的密码为止。例如：一个已知是四位数并且全部由阿拉伯数字组成的密码，其可能共有10000种组合，因此最多尝试9999次就能找到正确的密码。理论上除了具有完善保密性的密码以外，利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。有些人运用计算机来增加效率，有些人透过字典攻击（英语：Dictionary attack）来缩小密码组合的范围。1</p><p>如果要解决这道题目，就必不可少一些暴力破解会使用的工具来进行暴力破解。暴力破解工具有很多，一般来说，web安全会有一些比较常用的暴力破解工具，这道题目可能需要使用到kali操作系统来辅助解题。常用的暴力破解工具一般有：Hydra，Medusa，Burp suite。</p><p>这里可能使用到Hydra进行暴力破解，这里说明一些Hydra的暴力破解的方法和相关参数</p><p><strong>hydra</strong> 是一个支持众多协议的爆破工具，已经集成到KaliLinux中，直接在终端打开即可。2</p><p>常用的hydra的暴力破解命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>、破解ssh： <br>hydra -l 用户名 -<span class="hljs-selector-tag">p</span> 密码字典 -t 线程 -vV -e ns ip ssh <br>hydra -l 用户名 -<span class="hljs-selector-tag">p</span> 密码字典 -t 线程 -o save<span class="hljs-selector-class">.log</span> -vV ip ssh <br><br><br><span class="hljs-number">2</span>、破解ftp： <br>hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认<span class="hljs-number">16</span>) -vV <br>hydra ip ftp -l 用户名 -P 密码字典 -e ns -vV <br><br><br><span class="hljs-number">3</span>、get方式提交，破解web登录： <br>hydra -l 用户名 -<span class="hljs-selector-tag">p</span> 密码字典 -t 线程 -vV -e ns ip http-get /admin/ <br>hydra -l 用户名 -<span class="hljs-selector-tag">p</span> 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index<span class="hljs-selector-class">.php</span><br><br><br><span class="hljs-number">4</span>、post方式提交，破解web登录： <br>hydra -l 用户名 -P 密码字典 -s <span class="hljs-number">80</span> ip http-post-<span class="hljs-selector-tag">form</span> <span class="hljs-string">&quot;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry password&quot;</span> <br>hydra -t <span class="hljs-number">3</span> -l admin -P pass<span class="hljs-selector-class">.txt</span> -o out<span class="hljs-selector-class">.txt</span> -f <span class="hljs-number">10.36</span>.<span class="hljs-number">16.18</span> http-post-<span class="hljs-selector-tag">form</span> <span class="hljs-string">&quot;login.php:id=^USER^&amp;passwd=^PASS^:&lt;title&gt;wrong username or password&lt;/title&gt;&quot;</span> <br>（参数说明：-t同时线程数<span class="hljs-number">3</span>，-l用户名是admin，字典pass.txt，保存为out.txt，-f 当破解了一个密码就停止， <span class="hljs-number">10.36</span>.<span class="hljs-number">16.18</span>目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破解,&lt;title&gt;中 的内容是表示错误猜解的返回信息提示。） <br><br><br><span class="hljs-number">5</span>、破解https： <br>hydra -m /index<span class="hljs-selector-class">.php</span> -l muts -P pass<span class="hljs-selector-class">.txt</span> <span class="hljs-number">10.36</span>.<span class="hljs-number">16.18</span> https <br><br><span class="hljs-number">6</span>、破解teamspeak： <br>hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak <br><br><span class="hljs-number">7</span>、破解cisco： <br>hydra -P pass<span class="hljs-selector-class">.txt</span> <span class="hljs-number">10.36</span>.<span class="hljs-number">16.18</span> cisco <br>hydra -m cloud -P pass<span class="hljs-selector-class">.txt</span> <span class="hljs-number">10.36</span>.<span class="hljs-number">16.18</span> cisco-enable <br><br><span class="hljs-number">8</span>、破解smb： <br>hydra -l administrator -P pass<span class="hljs-selector-class">.txt</span> <span class="hljs-number">10.36</span>.<span class="hljs-number">16.18</span> smb <br><br><span class="hljs-number">9</span>、破解pop3： <br>hydra -l muts -P pass<span class="hljs-selector-class">.txt</span> my<span class="hljs-selector-class">.pop3</span><span class="hljs-selector-class">.mail</span> pop3 <br><br><span class="hljs-number">10</span>、破解rdp： <br>hydra ip rdp -l administrator -P pass<span class="hljs-selector-class">.txt</span> -V <br><br><span class="hljs-number">11</span>、破解http-proxy： <br>hydra -l admin -P pass<span class="hljs-selector-class">.txt</span> http-proxy:<span class="hljs-comment">//10.36.16.18 </span><br><br><span class="hljs-number">12</span>、破解imap： <br>hydra -L user<span class="hljs-selector-class">.txt</span> -<span class="hljs-selector-tag">p</span> secret <span class="hljs-number">10.36</span>.<span class="hljs-number">16.18</span> imap PLAIN <br>hydra -C defaults<span class="hljs-selector-class">.txt</span> -<span class="hljs-number">6</span> imap:<span class="hljs-comment">//[fe80::2c:31ff:fe12:ac11]:143/PLAIN</span><br></code></pre></td></tr></table></figure><p>这些常用的命令解决这道题目应该是足够的。</p><p>现在工具和知识都已经准备完毕了，进入靶机来一探究竟</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-31.png" class=""><p>weak_auth页面</p><p>非常简单的一个登录认证页面，先进行简单的密码猜测</p><p>使用root:root进行登录尝试</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-32.png" class=""><p>弹出提示，please login as admin，说明登录的用户名必须要素admin</p><p>下面试试admin:admin进行登录尝试</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-33.png" class=""><p>弹出提示，password error，登录错误的提示，然后点击确定查看一下页面的源代码</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-34.png" class="">靶机error页面源代码<p>发现登录错误关键字error，然后查看页面的响应标头确定传输方式</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-35.png" class=""><p>发现页面数据的传输方式是post方式进行传输的。而且页面存在着跳转，hydra的易用性相对较差，这里需要选用burpsuite进行暴力破解</p><p>进入到kali系统中，抓取页面信息进行暴力破解攻击</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-36.png" class="">bp抓到的数据包<p>右键将页面发送到intruder页面中</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-37.png" class=""><p>然后点击intruder页面进行暴力破解的设置</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-38-1024x287.png" class=""><p>调整好参数，然后进入到option的配置页面中进行攻击，（最好找一个弱口令字典）</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-41-1024x490.png" class=""><p>简单设置进行暴力破解的字典，然后设置匹配项。由于我们知道页面登录失败的时候会出现password error的选项，因此进入到option页面中设置匹配。</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-42.png" class=""><p>点击clear将所有的匹配规则清除</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-43.png" class=""><p>点击add将error的匹配规则添加进去</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-44.png" class=""><p>然后点击start attack开始攻击</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-45.png" class=""><p>稍微等一下，等攻击结果出现</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-46.png" class=""><p>发现123456这个密码没有匹配到error的规则，然后进入到页面中将123456密码输入进去</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-47.png" class=""><p>进入到跳转页面中，成功找到flag数据。</p><p>本题也成功解决，题目的思路也是比较简单的。考察的要点就是暴力破解，通过暴力破解解决问题。</p><p>题目属于简单题。</p><h2 id="simple-php"><a href="#simple-php" class="headerlink" title="simple php"></a>simple php</h2><p>这道题的题目是simple_php，应该是一道考察php代码的简单题目</p><p>进入到题目页面，来获取到更多信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-48-1024x287.png" class="">simple_php题目<p>页面中的题目描述信息也是在说php代码的问题，这道题目应该是在考察php代码的简单使用情况</p><p>进入到靶机环境来一探究竟</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-49.png" class=""><p>直接展示出源代码，这应该是一道简单的php代码审计题目，本菜鸡的php基础还可以，这道题目主要是考察php代码的特性和缺陷。</p><p>这道题目中有三个特性进行了考察：</p><ol><li>php中的字符串在进行比较的时候都会被当作0来处理</li><li>php中的变量如果被赋值了数字加字符，在进行数值判断的时候，字符会被忽略</li><li>php中的<code>is_numeric()</code>函数会判断变量是否是纯数字，如果是纯数字就返回true，如果不是纯数字就返回false</li></ol><p>有时候php代码审计的题目遇到不认识的代码或者函数，可以进行搜索引擎的使用和查找</p><p>代码可控的地方是get传输的数据，a和b参数作为数据接收并进行传递的</p><p>由于这道题目比较简单，直接在url上面进行构造</p><p>构造payload：<code>url?a=Flag&amp;b=1235s</code></p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-50.png" class=""><p>成功获取到flag数据，题目解决。</p><p>题目主要考察get传输方式和php代码的特性，思路也比较简单，分析代码的逻辑进行简单的注入就可以解决问题。属于简单题目。</p><h2 id="get-post"><a href="#get-post" class="headerlink" title="get post"></a>get post</h2><p>看题目，这道题目应该是考察http的传输数据的方式，get传输方式和post传输数据的方式</p><p>点开题目，希望可以从题目页面中获取到更多的信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-51-1024x307.png" class="">get_post题目<p>题目描述也是说用get和post方式，看来这道题目的关键点就是get和post传输数据的方式。</p><p>由于这里涉及的post方式的传输，这里需要使用一个Hackbar的插件攻击来辅助进行注入进攻来获取到flag数据。这里给出hackbar的GitHub地址：<a href="https://github.com/Hack-Free/HackBar%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E4%BD%BF%E7%94%A8%E3%80%82">https://github.com/Hack-Free/HackBar，如果没有这个工具可以进行下载使用。</a></p><p>现在工具齐全了，可以进行尝试去拿flag了，打开靶机进入到环境中</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-52.png" class=""><p>页面中展示的信息非常明确，而且比较明了。为了方便操作，进入到kali系统中的已装好hackbar的firefox浏览器中进行操作。</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-53-1024x222.png" class=""><p>首先使用get方法进行提交，点击execut进行传输</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-54.png" class=""><p>页面内容发生了变化，这次使用post数据进行传输</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-55-1024x333.png" class=""><p>点击execute进行传输数据</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-56.png" class=""><p>数据传输过去后，页面发生变化，然后flag数据就展示在眼前，题目解决。</p><p>这道题目的思路非常清晰，就是引导性的题目，没有什么难度，应该是道签到题目。</p><p>题目考察的知识点是http传输数据的方式，属于签到题。</p><h2 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff referer"></a>xff referer</h2><p>刚开始看到这个题目标题的时候还是有点懵逼的，因为本菜鸡并不知道什么是xff和referer</p><p>于是使用搜索引擎解决一下问题</p><p><strong><code>X-Forwarded-For</code></strong> (XFF) 在客户端访问服务器的过程中如果需要经过HTTP代理或者负载均衡服务器，可以被用来获取最初发起请求的客户端的IP地址，这个消息首部成为事实上的标准。在消息流从客户端流向服务器的过程中被拦截的情况下，服务器端的访问日志只能记录代理服务器或者负载均衡服务器的IP地址。如果想要获得最初发起请求的客户端的IP地址的话，那么 X-Forwarded-For 就派上了用场。3</p><p><code>**Referer**</code> 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 <code>Referer</code> 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。4</p><p>发现Xff和Referer就是一个可以进行IP代理的东西和一个可以进行来源记录的东西</p><p>再去查一下Xff和Referer的语法格式，确保对于Xff和Referer的知识掌握的比较完善。</p><p>于是再去MDN上查看一波：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Forwarded-For: &lt;client&gt;, &lt;proxy<span class="hljs-number">1</span>&gt;, &lt;proxy<span class="hljs-number">2</span>&gt;<br><br><span class="hljs-comment"># 示例</span><br><span class="hljs-attribute">X</span>-Forwarded-For: <span class="hljs-number">2001</span>:db<span class="hljs-number">8</span>:<span class="hljs-number">85</span>a<span class="hljs-number">3</span>:<span class="hljs-number">8</span>d<span class="hljs-number">3</span>:<span class="hljs-number">1319</span>:<span class="hljs-number">8</span>a<span class="hljs-number">2</span>e:<span class="hljs-number">370</span>:<span class="hljs-number">7348</span><br><br><span class="hljs-attribute">X</span>-Forwarded-For: <span class="hljs-number">203.0.113.195</span><br><br><span class="hljs-attribute">X</span>-Forwarded-For: <span class="hljs-number">203.0.113.195</span>, <span class="hljs-number">70.41.3.18</span>, <span class="hljs-number">150.172.238.178</span><br><span class="hljs-attribute">Referer</span>: &lt;url&gt;<br><br><span class="hljs-comment"># 示例</span><br><span class="hljs-attribute">Referer</span>: https://developer.mozilla.org/en-US/docs/Web/JavaScript<br></code></pre></td></tr></table></figure><p>点开题目查看，题目中又有些什么信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-57-1024x287.png" class="">xff_referer题目<p>根据题目描述，xff和referer是可以伪造的，可以知道这道题目应该是伪造xff和referer的题目，由于xff和referer都是http头部的信息，所以需要使用burp suite进行抓包来伪造xff和referer信息，需要先启动一下kali操作系统。</p><p>目前，知识基础和工具基础都准备好了，进入到靶机环境</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-58.png" class="">靶机环境<p>要求ip必须为123.123.123.123，用burp suite抓到数据包，修改xff数据来进行伪造</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-59.png" class=""><p>然后进行放行来查看页面情况</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-60.png" class=""><p>页面返回了一个必须来自<a href="https://www.google.com/">https://www.google.com</a></p><p>再次抓包，设置一下referer和xff的信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-61.png" class=""><p>将数据包放行，然后查看页面信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-62.png" class=""><p>最后，页面成功出现flag信息，题目成功解决，题目比较简单，具有引导性</p><p>题目属于简单的题目，应该算是签到题，题目主要考察对于xff和referer的http头部信息的了解和掌握，思路比较流程，具有引导性。</p><h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><p>看到这个·题目，首先第一反应是上传php一句话木马拿webshell。可能有人不解，什么是webshell？什么是一句话木马？这里搬出百度百科的解释，对webshell简单说明：</p><p>webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。5</p><p>webshell简单来说就是命令执行的环境，而一句话木马就是在创建一个可以连接到网站的命令执行环境的一个后门程序，这个后门程序通常都是比较简单，比较小的文件。可以通过网站的文件上传漏洞进行文件上传，创建后门木马。</p><p>进入到题目页面，看看可以获取到什么额外的信息：</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-63-1024x274.png" class="">webshell题目<p>根据题目描述，这道题目应是考察一句话木马的题目，而且是php一句话木马的题目。</p><p>根据目前的推出和知识分析，进入环境来看看怎么拿flag</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-64.png" class="">靶机环境<p>靶机环境中的页面直接把页面中写入的php一句话木马展示出来了，是通过post方式进行参数传递的。</p><p>这道题目可以使用hackbar插件进行post数据的传输，首先进行hello world输出来测试webshell的稳定性，根据页面回显情况来进行下一步操作。</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-66-1024x352.png" class=""><p>查看一下，页面的回显情况</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-71.png" class=""><p>页面将hello world成功输出到页面上面，说明页面会直接将代码执行结果回显到页面上面，回显效果良好。</p><p>接下来，讲一个的php的小技巧：</p><blockquote><p>php代码中的反引号```可以直接执行终端shell命令.并返回输出</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>    <span class="hljs-keyword">echo</span> `ls`; <span class="hljs-comment">#会将ls命令的输出结果输出到php页面上面</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>下面我们就可以根据这个小技巧来构造payload：<code>shell=echo </code>ls<code>;</code></p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-67-1024x340.png" class=""><p>查看页面返回的结果</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-68.png" class=""><p>发现网站的站点目录下有两个文件，一个是index.php文件，一个是flag.txt文件</p><p>显然flag文件肯定就是目标文件，需要查看到flag.txt文件中究竟写了些什么样的内容，flag.txt文件很可能藏着flag文件</p><p>构造payload：<code>shell=echo </code>cat flag.txt<code>;</code></p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-69-1024x363.png" class=""><p>查看页面显示的结果</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-70.png" class=""><p>发现flag.txt文件中写的就是flag数据，题目解决</p><p>题目主要考察php一句话木马，php特性和linux命令的简单使用，整体思路还是比较流畅的，题目难度比较简单，顺着思路就可以解决了。当然此题有多种解法。</p><h2 id="command-execution"><a href="#command-execution" class="headerlink" title="command execution"></a>command execution</h2><p>看到题目，可能是考察命令执行漏洞的题目，从题目也获取不到太多信息</p><p>直接点开题目页面，来看看有没有更多的信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-72-1024x290.png" class="">command_execution题目<p>题目描述说是ping功能，题目可能于ping功能有些出入，进入靶场环境看看情况</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-73.png" class=""><p>靶机环境</p><p>页面非常简单，好像就是一个ping功能的页面，首先试试使用127.0.0.1地址进行测试</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-74.png" class=""><p>发现这是一个命令执行环境，可控的地方就是输入框</p><p>来分析一下输入框的输入模式：</p><blockquote><p>输入框可以输入ip地址和url地址</p><p>输入的内容前方会被增加<code>ping -c 3 </code>的代码</p><p>输入内容的后面不会增加任何额外代码</p><p>页面输出内容会把终端输出内容返回</p></blockquote><p>因此，这里可以使用一点shell的语法技巧来构造payload</p><p><code>&amp;&amp;</code>在shell语法中是前面的命令执行成功后继续执行后面的代码</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ping</span> -c <span class="hljs-number">3</span> <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> &amp;&amp; ls # 会先执行<span class="hljs-built_in">ping</span>命令，<span class="hljs-built_in">ping</span>命令执行成功会再执行ls命令<br></code></pre></td></tr></table></figure><p>于是构造payload：<code>127.0.0.1 &amp;&amp; ls</code> ，并输入到输入框中来执行</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-75.png" class=""><p>发现网站页面下没有藏有flag文件，下一个可能的目录是home目录或是root目录</p><p>访问root目录需要权限，于是先查看一下ping功能的用户权限</p><p>构造payload：<code>127.0.0.1 &amp;&amp; id</code> ，并输入到输入框中来执行</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-76.png" class=""><p>发现ping的权限仅仅知识apache的权限，使用的服务器很可能是Ubuntu服务</p><p>构造payload：<code>127.0.0.1 &amp;&amp; uname -a</code> ，并输入到输入框中执行</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-77.png" class=""><p>发现服务器确实是Ubuntu服务器</p><p>根据目前收集到的信息，可能只能访问到home目录下，那就先尝试查看到home目录，如果home目录下没有再尝试提权进入到root目录下</p><p>构造查看home目录的payload：<code>127.0.0.1 &amp;&amp; ls /home </code>，输入到输入框中执行</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-78.png" class=""><p>发现home目录下存在有flag文件，让本菜鸡来瞧瞧这个flag.txt里面写的啥</p><p>构造payload：<code>127.0.0.1 &amp;&amp; cat /home/flag.txt </code>，输入到输入框中执行</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-79.png" class=""><p>发现flag.txt里面写的就是flag数据，题目解决</p><p>题目主要考察linux命令行的使用以及对于命令执行漏洞的觉察，题目的解题思路还是比较流畅的，题目应该也属于简单题。难度并不是很高。</p><h2 id="simple-js"><a href="#simple-js" class="headerlink" title="simple js"></a>simple js</h2><p>看到题目，应该是一个简单JavaScript代码审计的题目</p><p>进入到题目页面中，希望可以获取到更多相关的数据</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-80-1024x304.png" class="">simple_js题目<p>看到题目的难度系数，可知这道题目应该不简单，网页一直输入不对密码，这应该是一个提示</p><p>下面就直接进入到靶机环境来看看情况</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-81.png" class=""><p>页面直接就是一个提示框，先随便输入点内容</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-82.png" class=""><p>就报出了另一个提示框，然后页面内容是空白的</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-83.png" class=""><p>这种情况下，只能尝试从F12检查源代码中找到一些有用的信息</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-84.png" class=""><p>在源代码检查的过程中找到了js的代码，这道题目应该是对js源代码的审计</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">function dechiffre(pass_enc) &#123;<br>    var pass = &quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;;<br>    var tab = pass_enc.split(&#x27;,&#x27;);<br>    var tab2 = pass.split(&#x27;,&#x27;);<br>    var i, j, k, l = 0,<br>        m, n, o, p = &quot;&quot;;<br>    i = 0;<br>    j = tab.length;<br>    k = j + (l) + (n = 0);<br>    n = tab2.length;<br>    for (i = (o = 0); i &lt; (k = j = n); i++) &#123;<br>        o = tab[i - l];<br>        p += String.fromCharCode((o = tab2[i]));<br>        if (i == 5) break;<br>    &#125;<br>    for (i = (o = 0); i &lt; (k = j = n); i++) &#123;<br>        o = tab[i - l];<br>        if (i &gt; 5 &amp;&amp; i &lt; k - 1)<br>            p += String.fromCharCode((o = tab2[i]));<br>    &#125;<br>    p += String.fromCharCode(tab2[17]);<br>    pass = p;<br>    return pass;<br>&#125;<br>String[&quot;fromCharCode&quot;](dechiffre(&quot;<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>36<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>34<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>37<span class="hljs-symbol">\x</span>39<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>36<span class="hljs-symbol">\x</span>39<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>34<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>36<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>30<span class="hljs-symbol">\x</span>37<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>34<span class="hljs-symbol">\x</span>39<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>30&quot;));<br><br>h = window.prompt(&#x27;Enter password&#x27;);<br>alert(dechiffre(h));<br></code></pre></td></tr></table></figure><p>然后对这段js代码进行简单分析：</p><blockquote><p>\1. 从js代码整体来看，代码先定义了一个dechiffre的函数，然后定义了一个字符串数组，然后使用了两个功能性函数进行弹窗。</p><p>\2. 整段js代码的核心应该是应该是定义的dechiffre的函数，对于dechiffre函数的分析应该就是解决这道题目的关键性问题</p></blockquote><p>下面对JS源代码中的dechiffre函数进行分析：</p><p>首先将dechiffre函数内部进行划分</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs nix">function dechiffre(pass_enc) &#123;<br><br>    // 变量定义区<br>    var <span class="hljs-attr">pass</span> = <span class="hljs-string">&quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;</span>;<br>    var <span class="hljs-attr">tab</span> = pass_enc.split(&#x27;,&#x27;);<br>    var <span class="hljs-attr">tab2</span> = pass.split(&#x27;,&#x27;);<br>    var i, j, k, <span class="hljs-attr">l</span> = <span class="hljs-number">0</span>,<br>        m, n, o, <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;&quot;</span>;<br><br>    // 变量处理区<br>    <span class="hljs-attr">i</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-attr">j</span> = tab.length;<br>    <span class="hljs-attr">k</span> = j + (l) + (<span class="hljs-attr">n</span> = <span class="hljs-number">0</span>);<br>    <span class="hljs-attr">n</span> = tab2.length;<br><br>    // 逻辑处理区<br>    for (<span class="hljs-attr">i</span> = (<span class="hljs-attr">o</span> = <span class="hljs-number">0</span>); i &lt; (<span class="hljs-attr">k</span> = <span class="hljs-attr">j</span> = n); i++) &#123;<br>        <span class="hljs-attr">o</span> = tab[i - l];<br>        p += String.fromCharCode((<span class="hljs-attr">o</span> = tab2[i]));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-attr">i</span> == <span class="hljs-number">5</span>) break;<br>    &#125;<br>    for (<span class="hljs-attr">i</span> = (<span class="hljs-attr">o</span> = <span class="hljs-number">0</span>); i &lt; (<span class="hljs-attr">k</span> = <span class="hljs-attr">j</span> = n); i++) &#123;<br>        <span class="hljs-attr">o</span> = tab[i - l];<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span> &amp;&amp; i &lt; k - <span class="hljs-number">1</span>)<br>            p += String.fromCharCode((<span class="hljs-attr">o</span> = tab2[i]));<br>    &#125;<br><br>    // 最终输出区<br>    p += String.fromCharCode(tab2[<span class="hljs-number">17</span>]);<br>    <span class="hljs-attr">pass</span> = p;<br>    return pass;<br>&#125;<br></code></pre></td></tr></table></figure><p>js函数被划分成四个区域：</p><ol><li>变量定义区</li><li>变量处理区</li><li>逻辑处理区</li><li>最终输出区</li></ol><p>下面对这四个分区进行逐一分析</p><p>变量定义区：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> pass = <span class="hljs-string">&quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">tab</span> = pass_enc.<span class="hljs-keyword">split</span>(&#x27;,&#x27;);<br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">tab2</span> = pass.<span class="hljs-keyword">split</span>(&#x27;,&#x27;);<br>    <span class="hljs-keyword">var</span> i, j, k, <span class="hljs-keyword">l</span> = 0,<br>        <span class="hljs-keyword">m</span>, <span class="hljs-keyword">n</span>, o, p = <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>\1. 定义了一个pass变量并赋值”70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65”</p><p>\2. 定义了一个tab变量并赋值pass_enc参数进行分隔成数组</p><p>\3. 定义了一个tab2变量并赋值pass变量进行分隔成数组[70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65]</p><p>\4. 定义了变量i，j，k，l并赋值为0，定义了变量m，n，o，p并赋值为“”</p></blockquote><p>变量处理区</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><span class="hljs-attr">j</span> = tab.length<span class="hljs-comment">;</span><br><span class="hljs-attr">k</span> = j + (l) + (n = <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br><span class="hljs-attr">n</span> = tab2.length<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>\1. 将变量i再次赋值为0</p><p>\2. 将变量j赋值为tab的长度</p><p>\3. 将变量k赋值为j的值加上l和n=0的数值</p><p>\4. 将变量n赋值为tab2的长度，即n=18</p></blockquote><p>逻辑处理区</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">for (<span class="hljs-attr">i</span> = (<span class="hljs-attr">o</span> = <span class="hljs-number">0</span>); i &lt; (<span class="hljs-attr">k</span> = <span class="hljs-attr">j</span> = n); i++) &#123;        <span class="hljs-attr">o</span> = tab[i - l];        p += String.fromCharCode((<span class="hljs-attr">o</span> = tab2[i]));        <span class="hljs-keyword">if</span> (<span class="hljs-attr">i</span> == <span class="hljs-number">5</span>) break;    &#125;    for (<span class="hljs-attr">i</span> = (<span class="hljs-attr">o</span> = <span class="hljs-number">0</span>); i &lt; (<span class="hljs-attr">k</span> = <span class="hljs-attr">j</span> = n); i++) &#123;        <span class="hljs-attr">o</span> = tab[i - l];        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span> &amp;&amp; i &lt; k - <span class="hljs-number">1</span>)            p += String.fromCharCode((<span class="hljs-attr">o</span> = tab2[i]));    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>\1. 对于第一个循环，初始值i被赋值为0，限制条件是i&lt;18，循环条件是i++</p><p>循环内部是对于o变量的处理，第一个赋值语句是无用的赋值语句，由于下面的语句会对o进行   重新赋值处理。下面<code>p += String.fromCharCode((o = tab2[i]));</code>语句涉及了string对象和fromCharCode（）函数。经过搜索和查询，发现fromcharcode函数是将unicode值转换为字符的函数，属于String对象的api。这条语句的作用是对p变量进行累计赋值处理。如果i==5循环就结束。</p><p>\2. 对于第二个循环，初始值i被赋值为0，限制条件是i&lt;18，循环条件是i++</p><p>循环内部依旧是对于o变量的处理，还是和第一个循环非常类似的处理，都是最终对于p变量进行累计赋值。</p><p>\3. 两个循环都是对于p变量进行累加赋值。</p></blockquote><p>最终输出区</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">p += String.fromCharCode(tab2[<span class="hljs-number">17</span>]);    <span class="hljs-keyword">pass</span> = p;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">pass</span>;<br></code></pre></td></tr></table></figure><blockquote><p>\1. 仍然是对p变量进行赋值处理</p><p>\2. 将p的值赋值给pass</p><p>\3. 将pass变量返回</p></blockquote><p>总体对这个函数进行分析，这个函数根本没有涉及任何传入参数的处理情况，简单来说就是没有tab数组任何事情。无论传入什么变量都只返回tab2数组的数据。</p><p>再看看代码最后的调用情况</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">String[&quot;fromCharCode&quot;](dechiffre(&quot;<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>36<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>34<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>37<span class="hljs-symbol">\x</span>39<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>36<span class="hljs-symbol">\x</span>39<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>34<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>36<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>30<span class="hljs-symbol">\x</span>37<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>34<span class="hljs-symbol">\x</span>39<span class="hljs-symbol">\x</span>2c<span class="hljs-symbol">\x</span>35<span class="hljs-symbol">\x</span>30&quot;));h = window.prompt(&#x27;Enter password&#x27;);alert(dechiffre(h));<br></code></pre></td></tr></table></figure><blockquote><p>\1. 这个函数被调用两次。</p><p>\2. 第一次是调用了dechiffre并传入参数“\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30”作为函数的实参进行传入数据</p><p>\3. 第二次是调用了用户输入的数据（无论传入什么数据结果都一样）</p></blockquote><p>所以这个JavaScript的代码中肯定藏有flag，flag可能藏在第一次传入的参数中</p><p>\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30</p><p>编写js文件对第一次传入的参数进行处理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"><span class="hljs-keyword">var</span> input=<span class="hljs-string">&quot;\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30&quot;</span>;<span class="hljs-keyword">var</span> result;<span class="hljs-keyword">var</span> o=<span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> tab=input.split(<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-built_in">document</span>.write(tab);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;tab.length; i++)&#123;result += <span class="hljs-built_in">String</span>.fromCharCode((o=tab[i]))&#125;    <span class="hljs-built_in">document</span>.write(result);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在浏览器上运行一下这段代码</p><img src="/2021/06/21/XCTF-WEB-%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/image-85.png" class=""><p>undefined后面那段字符就是flag数据：786OsErtk12</p><p>这道题目也解决了，分析过程比较复杂，需要一定的JavaScript基础。难度其实也应该是一道简单题目，但是思路比较绕，如果比较灵敏可以直接找到关键数据，对关键数据进行unicode解码在进行ascii解码就能得出flag数据。</p><p>这里提供几个网址，便于js基础不是非常牢固的人补习一下：</p><p><a href="https://javascript.ruanyifeng.com/">https://javascript.ruanyifeng.com/</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312">https://www.liaoxuefeng.com/wiki/1022910821149312</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/learn/JavaScript">https://developer.mozilla.org/zh-CN/docs/learn/JavaScript</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://wiwiki.kfd.me/wiki/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3">WIKI百科-蛮力攻击</a></li><li><a href="https://www.jianshu.com/p/4da49f179cee">爆破工具 Hydra 简单使用</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Forwarded-For">X-Forwarded-For MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer">Referer MDN</a></li><li><a href="https://baike.baidu.com/item/WEBSHELL">webshell 百度百科</a></li></ol><p>本期wp分享到此为止，有时间再来喝杯茶呀！</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_START</title>
    <link href="/2021/06/21/CTF-START/"/>
    <url>/2021/06/21/CTF-START/</url>
    
    <content type="html"><![CDATA[<h1 id="茗叶溢香，旗扬四方"><a href="#茗叶溢香，旗扬四方" class="headerlink" title="茗叶溢香，旗扬四方"></a>茗叶溢香，旗扬四方</h1><h2 id="“浅谈CTF比赛”"><a href="#“浅谈CTF比赛”" class="headerlink" title="“浅谈CTF比赛”"></a>“浅谈CTF比赛”</h2><blockquote><p>茶，叶</p><p>一旗，一茗</p><p>杯茗间，旗影下</p><p>可否扬旗，仗剑苍穹</p></blockquote><p>CTF是网络安全行业经常会接触到的一类比赛，那么CTF究竟是什么样子的比赛呢？来，喝杯茶，我们细细聊聊CTF比赛。</p><p>CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 。1</p><p>夺旗赛，听起来好像不是很难的样子，CTF的基本目标其实就找到一个数据，即flag{xxxxx}类型的数据。通常是一种解题的方式进行的，一般来说，flag{xxxxx}类型的数据不会那么轻易的展示出来或者那么容易找到。比赛中一般会设置一道签到题目来进行参赛队员的签到，签到的题目的难度一般来说不会非常高，可以通过非常简单的方式解出来或者需要一些小技巧解出。</p><img src="/2021/06/21/CTF-START/image.png" class=""><p>来自BUUCTF题库</p><p>这就是一道非常简单的签到题目，flag{xxxx}的数据直接告诉你，但是这种题目。CTF比赛是不是都像ACM、蓝桥杯那样的，是一种解题的比赛？解题，是CTF比赛的一部分。CTF比赛的初衷是网络安全技术的提高和提升。只是进行解题的CTF比赛显然是不足的，不能满足CTF比赛进行的初衷，我们在CTF解题赛中仅仅只扮演了进攻方的角色，而没有担任防守方，而在真正的网络安全工作中很多时候是进行防守方的建设，进行网络安全防御机制的规划。</p><p>因此，CTF比赛也有很多类型。</p><p>CTF竞赛模式分为以下三类：<br>一、解题模式（Jeopardy）在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。<br>二、攻防模式（Attack-Defense）在攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。<br>三、混合模式（Mix）结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。1</p><p>在高校中的CTF比赛经常是以解题类型为主的CTF比赛类型，就是寻找flag{xxxxx}类型的数据，寻找数据在什么位置，然后将flag进行提交，完成题目的解题工作。这种类型的CTF往往与网络安全工作的贴合程度不是很高，而且近几年的题目往往比较具有偏离性。现在一些比较大型的CTF解题的比赛会采用比较真实的实验环境进行比赛，夺旗。</p><p>CTF解题类比赛一般会分为几个类型来针对不同参赛队员的专攻进行相应的分类。CTF 题目类型一般分为 Web 渗透、RE 逆向、Misc 杂项、PWN 二进制漏洞利用、Crypto 密码破译。2 但是，现在智能手机也得到了较大的发展，CTF比赛也要与时俱进对吧，于是CTF比赛也就多了一个题目类型——Mobile移动端渗透。CTF的新题型，移动端渗透的题目难度往往比较大，对萌新非常不友好。移动端往往都是基于xml文件进行渗透，以及一部分逆向和无线之类的渗透方式。</p><p>CTF比赛总体来说还是非常有意思的比赛，但是有时候也会比较痛苦吧，因为题目解不出来的感觉总是挺难受的。解出题目会有一种满满的成就感。做CTF是苦乐交织的过程，在这个过程中，可以体验到能力和技术水平飞速提升，以及学习能力方面的发展和提高。</p><p>斟茶，品茗，夺旗，键动，影现。此情此景，君忆几何？</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://tieba.baidu.com/p/3933947157?red_tag=1830578322">CTF学习与交流</a></li><li><a href="https://www.jianshu.com/p/ade6c1824d97">啥是CTF？新手如何入门CTF？</a></li></ol><p>闲聊到此为止，来喝杯茶可好？</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Crypto</title>
    <link href="/2021/06/21/Crypto/"/>
    <url>/2021/06/21/Crypto/</url>
    
    <content type="html"><![CDATA[<h1 id="杯茗藏香，君闻几何"><a href="#杯茗藏香，君闻几何" class="headerlink" title="杯茗藏香，君闻几何"></a>杯茗藏香，君闻几何</h1><h2 id="“浅谈密码学”"><a href="#“浅谈密码学”" class="headerlink" title="“浅谈密码学”"></a>“浅谈密码学”</h2><blockquote><p>密文寥寥，清茶袅袅。</p><p>杯杯入境，字字明心。</p></blockquote><p>密码学是主要研究密码编码和解码的一种学科，主要目标是提供在不安全的信道上的安全通信机制1</p><p>根据OWASP上面的定义来开启我们的闲聊。“密码学是主要研究密码编码和解码的一种学科”，这里有两个比较关键的词汇。密码编码和解码，密码比较好理解。平时我们注册一个账户的时候通常就需要一个密码来进行登入，密码和账户构成了网络账户的基本符号。那么，编码和解码又该怎么理解呢？</p><p>编码是信息从一种形式或格式转换为另一种形式的过程，也称为计算机编程语言的代码简称编码。2</p><p>编码，简单来说就是对内容进行编制，来确保内容不会影响到互联网整体的传输过程。在互联网中，数据传输通常是采用http，ftp，https等协议进行传输的。这些协议中也会有些特殊的字符有特殊的功能性作用，如果不进行编码，可能会出现预期之外的事故。当然编码也有一些安全性的作用，可以确保数据传输过程中数据不是特别明显的暴露，有较大的截获风险。</p><p>编码是互联网中不可或缺的一种数据处理方式。</p><p>解码是一种用特定方法，把数码还原成它所代表的内容或将电脉冲信号、光信号、无线电波等转换成它所代表的信息、数据等的过程。解码是受传者将接受到的符号或代码还原为信息的过程，与编码过程相对应。3</p><p>解码，就是将编码的内容进行还原的过程。意思很明了，在互联网中一般会将解码后的信息展示给用户，在数据传输的过程中，将数据进行编码传输。为什么这样做？一方面是为了用户的使用体验，另一方面是为了数据传输的正常进行和安全性保障。</p><p>OWASP的密码学定义相对来说是比较狭义的，只对互联网中的简单过程进行了定义，将密码学研究的范围缩小了。</p><p>那么，密码学是什么呢？</p><p>密码学，就是将OWASP对于密码学的定义进行推广和扩充。编码不仅仅限制于互联网、计算机领域中，解码也不仅仅仅限于互联网、计算机领域方面。编码就变成了加密的一个子集，解码就变成了解密的一个子集。加密前的数据就有了一个比较完整的概念，即明文。加密后的数据也有了一个名字叫密文。进行加密的工具叫做密钥。这些是密码学的基础性的概念。这些概念和体系形成了密码学的大集体。</p><p>下面是百度百科给出的对于密码学的具体定义和描述。</p><p>密码学（在西欧语文中，源于希腊语kryptós“隐藏的”，和gráphein“书写”）是研究如何隐密地传递信息的学科。在现代特别指对信息以及其传输的数学性研究，常被认为是数学和计算机科学的分支，和信息论也密切相关。著名的密码学者Ron Rivest解释道：“密码学是关于如何在敌人存在的环境中通讯”，自工程学的角度，这相当于密码学与纯数学的异同。密码学是信息安全等相关议题，如认证、访问控制的核心。密码学的首要目的是隐藏信息的涵义，并不是隐藏信息的存在。密码学也促进了计算机科学，特别是在于电脑与网络安全所使用的技术，如访问控制与信息的机密性。密码学已被应用在日常生活：包括自动柜员机的芯片卡、电脑使用者存取密码、电子商务等等。4</p><p>密码学不仅仅只是计算机领域的内容，也是一种比较多元化的体系，但是主要应用于计算机领域。密码学会涉及到很多与数学相关联的知识体系，从微积分到线性代数、概率论以及离散数学，再从线性代数到抽象代数，再从抽象代数到数论。几乎数学方面比较难的模块都涉及到了密码学中，仿佛富有丰富的能量和特别的活力。</p><p>这回只是对密码学的初步探索和学习，有时候知识都是相通的，都是彼此有联系的存在。密码学何尝不是呢？喝杯茶其实也是种生活种的密码学。</p><p>密码学有密文和明文，茶叶中有遗传密码和表现型，有香气分子和味觉感受。密码学应该是和生物学一样，是非常beautiful的学科，一定非常好玩！</p><p>请君先闻龙井香，道出多少古时芳。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li>[<a href="http://www.owasp.org.cn/]">http://www.owasp.org.cn/]</a>(<a href="http://www.owasp.org.cn/">http://www.owasp.org.cn/</a> <a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092">https://baike.baidu.com/item/编码/80092</a> <a href="https://baike.baidu.com/item/%E8%A7%A3%E7%A0%81">https://baike.baidu.com/item/解码</a>)</li><li>[<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092]">https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092]</a>(<a href="http://www.owasp.org.cn/">http://www.owasp.org.cn/</a> <a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092">https://baike.baidu.com/item/编码/80092</a> <a href="https://baike.baidu.com/item/%E8%A7%A3%E7%A0%81">https://baike.baidu.com/item/解码</a>)</li><li>[<a href="https://baike.baidu.com/item/%E8%A7%A3%E7%A0%81]">https://baike.baidu.com/item/%E8%A7%A3%E7%A0%81]</a>(<a href="http://www.owasp.org.cn/">http://www.owasp.org.cn/</a> <a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092">https://baike.baidu.com/item/编码/80092</a> <a href="https://baike.baidu.com/item/%E8%A7%A3%E7%A0%81">https://baike.baidu.com/item/解码</a>)</li><li><a href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E5%AD%A6">https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E5%AD%A6</a></li></ol><p>闲聊到此为止，来喝杯茶可好？</p>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PTE</title>
    <link href="/2021/06/21/PTE/"/>
    <url>/2021/06/21/PTE/</url>
    
    <content type="html"><![CDATA[<h1 id="运壶飘香，甘霖四方"><a href="#运壶飘香，甘霖四方" class="headerlink" title="运壶飘香，甘霖四方"></a>运壶飘香，甘霖四方</h1><h2 id="“浅谈渗透测试”"><a href="#“浅谈渗透测试”" class="headerlink" title="“浅谈渗透测试”"></a>“浅谈渗透测试”</h2><blockquote><p>谈到网络安全就不得不谈到渗透测试，如果把饮茶的平台作为目标，渗透测试就如盈满茶汤的紫砂壶，运壶飘香，甘霖四方。整个饮茶的平台被茶汤浸润，渗透到内部。</p></blockquote><p>渗透测试(penetration test)，模拟恶意黑客的攻击方法，来评估信息系统安全的一种评估方法。技术方面，在网络安全的红蓝对抗方面更偏向于红队的方式。</p><blockquote><p>红队蓝队对抗练习，源自其军事上的先例。概念很简单：一队安全人员——红队，攻击什么东西；另一队人员——蓝队，守护之。最初，这种操练是军队用来测试部队战备度的，也用于测试敏感地区的物理安全，比如核设施及能源部下属国家实验室和技术中心。90年代，专家开始采用红蓝对抗来测试信息安全系统。</p></blockquote><p>渗透测试本身就是一种运用攻击手段进行渗透测试的方法。</p><p>渗透测试一般而言，按照7个步骤进行渗透测试：</p><ol><li>明确需求(pre-engagement)</li><li>信息收集(information-gathering)</li><li>威胁建模(threat-modeling)</li><li>漏洞分析(vulnerability analysis)</li><li>漏洞验证(exploitation)</li><li>深度攻击(post-exploitation)</li><li>文书报告(reporting)</li></ol><p>这7个步骤可能乍一看，会感觉有些懵B，我会对这些步骤进行简单地解释说明，尽量不涉及太多代码。</p><h3 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h3><p>渗透测试本身就是一种测试性的工作，市场有需求，然后才会出现这样一个服务型的产品。渗透测试的核心产品就是进行渗透测试，而渗透测试是可以根据客户的需求进行个性化处理的。</p><p>明确客户的需求才可以正确并合理地进行渗透测试。</p><p>可能有些人有疑问，为什么要根据客户需求来进行渗透测试？</p><p>从产品角度来说，如果产品不能满足客户的需求，客户是不会进行资金的交付的。从国家法律角度来说，没有授权的渗透测试是违法的行为，大家都不喜欢蹲在铁窗里和监狱长喝茶聊人生。</p><p>明确需求简单来说，就是明确渗透测试工作的相关信息。具体都有些什么信息呢？</p><p>一般来说渗透测试工作者需要明确以下信息：</p><ul><li>项目范围</li><li>测试窗口</li><li>联系信息</li><li>”免罪“金牌</li><li>支付条款</li></ul><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>信息收集是渗透测试非常关键的一步。信息收集一般来说就是字面意思，收集渗透测试项目的各种信息。信息收集一般来说分为主动信息收集和被动信息收集。</p><p>主动信息收集，就是通过接触项目目标进行主动扫描来获取到各种各样的信息。通常会采用nmap工具进行主动信息的收集。</p><p>被动信息收集，即公开信息收集，又称开源情报分析。从搜索引擎获取有关项目目标开源的信息内容，一般来说，可以通过被动信息收集获取备案信息，服务信息等各种各样的信息。通常会采用shadow搜索引擎进行被动信息收集。</p><p>信息收集，就是收集各种有利于渗透测试的各种信息。</p><h3 id="威胁建模"><a href="#威胁建模" class="headerlink" title="威胁建模"></a>威胁建模</h3><p>威胁建模就是利用以收集的信息进行资产分析。这一步是紧紧衔接着信息收集的，简单来说，就是对信息收集所收集到的信息进行整合分析。</p><p>项目目标一般而言都是企业资产的一部分，现在步入大数据时代，很多企业的重要数据都建立在服务器等项目目标上，项目目标就相当于企业的资产。</p><p>因而威胁建模就是利用收集到的信息对项目目标进行问题分析和可能存在的威胁进行评估。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞分析就是发现目标系统和应用中存在的漏洞。找出项目目标的缺陷，并且通过测试手段对漏洞进行分析和发现。漏洞分析是基于信息收集的一个步骤。可以分析并探测存在的漏洞。</p><p>漏洞分析，关键在于找到漏洞。什么是漏洞？可以理解成缺陷，如果把系统或应用比作茶壶，茶壶有壶首，壶口，壶把等。而漏洞就好比，在壶身出现的空隙，而知道这个漏洞的黑客就如同空气中的微生物，可以通过这个空隙自由进出。</p><p>漏洞分析，简单来说，就是寻找项目目标存在的缺陷。</p><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>漏洞验证，即对已发现的漏洞使用攻击向量进行攻击。这一步的工作和上一步工作环环相扣。根据上一步所发现的漏洞，通过黑客渗透工具进行验证，或者也可以说是漏洞利用。</p><p>用上一步的比喻，漏洞验证就相当于空气中微生物进入到茶壶内部的方式或者说是通道，这个通道可以确保成功进入到内部。如果可以进入到内部，就可以验证漏洞确实存在。如果不能，则反之。</p><p>漏洞分析和漏洞验证其实就挺像对一个问题的证明，首先提出一个假设，然后对这个假设进行验证。可以类比孟德尔的演绎推理，假说-实验-结论。</p><p>漏洞验证，简单来说就是对发现的漏洞进行二次检查，确保问题真实存在。</p><h3 id="深度攻击"><a href="#深度攻击" class="headerlink" title="深度攻击"></a>深度攻击</h3><p>深度攻击是基于漏洞验证步骤的进一步渗透探测，应该是深度信息收集，利用漏洞验证步骤进入到内部，来收集更多的信息和更多的资产数据，以及内部可能存在的漏洞。</p><p>打个比方，如果把系统想象成很多盒子的包裹结构，每个盒子内部都存储着一部分信息。漏洞验证步骤可以建立通往内部盒子的通道，深度攻击就可以对内部的很多盒子中的信息进行收集和查找，并且可以发现其中的漏洞，进入到更内部的盒子里面进行收集和漏洞寻找。</p><p>深度攻击，简单来说，就是更深入的漏洞分析和信息收集。</p><h3 id="文书报告"><a href="#文书报告" class="headerlink" title="文书报告"></a>文书报告</h3><p>文书报告是对渗透测试的结果进行汇报并给出简单的安全性建议，提交给客户。</p><p>文书报告一般来说分成两个部分，执行摘要和技术报告。</p><p>执行摘得就是对整个渗透测试项目的高度总结和汇报。</p><p>技术报告技术对渗透测试过程中的操作细节进行汇报。</p><p><em>渗透测试就是一种安全性测试，是一种流程化的服务型产品，更是网络安全推进过程中不可或缺的一部分，希望大家从此文都能简单了解到什么是渗透测试。</em></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">闲聊到此为止，来喝杯茶可好？<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PTE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/21/hello-world/"/>
    <url>/2021/06/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
